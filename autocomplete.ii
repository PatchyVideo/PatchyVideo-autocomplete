# 1 "autocomplete.cpp"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "autocomplete.cpp"

# 1 "fast_io/fast_io.h" 1
       

# 1 "fast_io/fast_io_hosted.h" 1
       
# 10 "fast_io/fast_io_hosted.h"
# 1 "fast_io/fast_io_freestanding.h" 1
       



# 1 "fast_io/fast_io_core.h" 1
       



# 1 "/usr/local/include/c++/10.0.0/version" 1 3
# 33 "/usr/local/include/c++/10.0.0/version" 3
       
# 34 "/usr/local/include/c++/10.0.0/version" 3

# 1 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/c++config.h" 1 3
# 251 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/c++config.h" 3

# 251 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
# 273 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 511 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/c++config.h" 3
# 1 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/os_defines.h" 1 3
# 39 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/os_defines.h" 3
# 1 "/usr/include/features.h" 1 3 4
# 424 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 427 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 428 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 429 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 425 "/usr/include/features.h" 2 3 4
# 448 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 449 "/usr/include/features.h" 2 3 4
# 40 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/os_defines.h" 2 3
# 512 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/c++config.h" 2 3


# 1 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/cpu_defines.h" 1 3
# 515 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/c++config.h" 2 3
# 679 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/c++config.h" 3
# 1 "/usr/local/include/c++/10.0.0/pstl/pstl_config.h" 1 3
# 680 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/c++config.h" 2 3
# 36 "/usr/local/include/c++/10.0.0/version" 2 3
# 6 "fast_io/fast_io_core.h" 2
# 1 "/usr/local/include/c++/10.0.0/cstddef" 1 3
# 42 "/usr/local/include/c++/10.0.0/cstddef" 3
       
# 43 "/usr/local/include/c++/10.0.0/cstddef" 3







# 1 "/usr/local/lib/gcc/x86_64-pc-linux-gnu/10.0.0/include/stddef.h" 1 3 4
# 143 "/usr/local/lib/gcc/x86_64-pc-linux-gnu/10.0.0/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 209 "/usr/local/lib/gcc/x86_64-pc-linux-gnu/10.0.0/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 415 "/usr/local/lib/gcc/x86_64-pc-linux-gnu/10.0.0/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 426 "/usr/local/lib/gcc/x86_64-pc-linux-gnu/10.0.0/include/stddef.h" 3 4
} max_align_t;






  typedef decltype(nullptr) nullptr_t;
# 51 "/usr/local/include/c++/10.0.0/cstddef" 2 3

extern "C++"
{

namespace std
{

  using ::max_align_t;
}



namespace std
{




  enum class byte : unsigned char {};

  template<typename _IntegerType> struct __byte_operand { };
  template<> struct __byte_operand<bool> { using __type = byte; };
  template<> struct __byte_operand<char> { using __type = byte; };
  template<> struct __byte_operand<signed char> { using __type = byte; };
  template<> struct __byte_operand<unsigned char> { using __type = byte; };

  template<> struct __byte_operand<wchar_t> { using __type = byte; };


  template<> struct __byte_operand<char8_t> { using __type = byte; };

  template<> struct __byte_operand<char16_t> { using __type = byte; };
  template<> struct __byte_operand<char32_t> { using __type = byte; };
  template<> struct __byte_operand<short> { using __type = byte; };
  template<> struct __byte_operand<unsigned short> { using __type = byte; };
  template<> struct __byte_operand<int> { using __type = byte; };
  template<> struct __byte_operand<unsigned int> { using __type = byte; };
  template<> struct __byte_operand<long> { using __type = byte; };
  template<> struct __byte_operand<unsigned long> { using __type = byte; };
  template<> struct __byte_operand<long long> { using __type = byte; };
  template<> struct __byte_operand<unsigned long long> { using __type = byte; };
# 110 "/usr/local/include/c++/10.0.0/cstddef" 3
  template<typename _IntegerType>
    struct __byte_operand<const _IntegerType>
    : __byte_operand<_IntegerType> { };
  template<typename _IntegerType>
    struct __byte_operand<volatile _IntegerType>
    : __byte_operand<_IntegerType> { };
  template<typename _IntegerType>
    struct __byte_operand<const volatile _IntegerType>
    : __byte_operand<_IntegerType> { };

  template<typename _IntegerType>
    using __byte_op_t = typename __byte_operand<_IntegerType>::__type;

  template<typename _IntegerType>
    constexpr __byte_op_t<_IntegerType>
    operator<<(byte __b, _IntegerType __shift) noexcept
    { return (byte)(unsigned char)((unsigned)__b << __shift); }

  template<typename _IntegerType>
    constexpr __byte_op_t<_IntegerType>
    operator>>(byte __b, _IntegerType __shift) noexcept
    { return (byte)(unsigned char)((unsigned)__b >> __shift); }

  constexpr byte
  operator|(byte __l, byte __r) noexcept
  { return (byte)(unsigned char)((unsigned)__l | (unsigned)__r); }

  constexpr byte
  operator&(byte __l, byte __r) noexcept
  { return (byte)(unsigned char)((unsigned)__l & (unsigned)__r); }

  constexpr byte
  operator^(byte __l, byte __r) noexcept
  { return (byte)(unsigned char)((unsigned)__l ^ (unsigned)__r); }

  constexpr byte
  operator~(byte __b) noexcept
  { return (byte)(unsigned char)~(unsigned)__b; }

  template<typename _IntegerType>
    constexpr __byte_op_t<_IntegerType>&
    operator<<=(byte& __b, _IntegerType __shift) noexcept
    { return __b = __b << __shift; }

  template<typename _IntegerType>
    constexpr __byte_op_t<_IntegerType>&
    operator>>=(byte& __b, _IntegerType __shift) noexcept
    { return __b = __b >> __shift; }

  constexpr byte&
  operator|=(byte& __l, byte __r) noexcept
  { return __l = __l | __r; }

  constexpr byte&
  operator&=(byte& __l, byte __r) noexcept
  { return __l = __l & __r; }

  constexpr byte&
  operator^=(byte& __l, byte __r) noexcept
  { return __l = __l ^ __r; }

  template<typename _IntegerType>
    constexpr _IntegerType
    to_integer(__byte_op_t<_IntegerType> __b) noexcept
    { return _IntegerType(__b); }


}

}
# 7 "fast_io/fast_io_core.h" 2
# 1 "/usr/local/include/c++/10.0.0/limits" 1 3
# 40 "/usr/local/include/c++/10.0.0/limits" 3
       
# 41 "/usr/local/include/c++/10.0.0/limits" 3
# 158 "/usr/local/include/c++/10.0.0/limits" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 202 "/usr/local/include/c++/10.0.0/limits" 3
  struct __numeric_limits_base
  {


    static constexpr bool is_specialized = false;




    static constexpr int digits = 0;


    static constexpr int digits10 = 0;




    static constexpr int max_digits10 = 0;



    static constexpr bool is_signed = false;


    static constexpr bool is_integer = false;




    static constexpr bool is_exact = false;



    static constexpr int radix = 0;



    static constexpr int min_exponent = 0;



    static constexpr int min_exponent10 = 0;




    static constexpr int max_exponent = 0;



    static constexpr int max_exponent10 = 0;


    static constexpr bool has_infinity = false;



    static constexpr bool has_quiet_NaN = false;



    static constexpr bool has_signaling_NaN = false;


    static constexpr float_denorm_style has_denorm = denorm_absent;



    static constexpr bool has_denorm_loss = false;



    static constexpr bool is_iec559 = false;




    static constexpr bool is_bounded = false;
# 288 "/usr/local/include/c++/10.0.0/limits" 3
    static constexpr bool is_modulo = false;


    static constexpr bool traps = false;


    static constexpr bool tinyness_before = false;




    static constexpr float_round_style round_style =
          round_toward_zero;
  };
# 311 "/usr/local/include/c++/10.0.0/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static constexpr _Tp
      min() noexcept { return _Tp(); }


      static constexpr _Tp
      max() noexcept { return _Tp(); }




      static constexpr _Tp
      lowest() noexcept { return _Tp(); }




      static constexpr _Tp
      epsilon() noexcept { return _Tp(); }


      static constexpr _Tp
      round_error() noexcept { return _Tp(); }


      static constexpr _Tp
      infinity() noexcept { return _Tp(); }



      static constexpr _Tp
      quiet_NaN() noexcept { return _Tp(); }



      static constexpr _Tp
      signaling_NaN() noexcept { return _Tp(); }




      static constexpr _Tp
      denorm_min() noexcept { return _Tp(); }
    };




  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };
# 383 "/usr/local/include/c++/10.0.0/limits" 3
  template<>
    struct numeric_limits<bool>
    {
      static constexpr bool is_specialized = true;

      static constexpr bool
      min() noexcept { return false; }

      static constexpr bool
      max() noexcept { return true; }


      static constexpr bool
      lowest() noexcept { return min(); }

      static constexpr int digits = 1;
      static constexpr int digits10 = 0;

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr bool
      epsilon() noexcept { return false; }

      static constexpr bool
      round_error() noexcept { return false; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr bool
      infinity() noexcept { return false; }

      static constexpr bool
      quiet_NaN() noexcept { return false; }

      static constexpr bool
      signaling_NaN() noexcept { return false; }

      static constexpr bool
      denorm_min() noexcept { return false; }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;




      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static constexpr bool is_specialized = true;

      static constexpr char
      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static constexpr char
      max() noexcept { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }


      static constexpr char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((char)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char
      epsilon() noexcept { return 0; }

      static constexpr char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr
      char infinity() noexcept { return char(); }

      static constexpr char
      quiet_NaN() noexcept { return char(); }

      static constexpr char
      signaling_NaN() noexcept { return char(); }

      static constexpr char
      denorm_min() noexcept { return static_cast<char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static constexpr bool is_specialized = true;

      static constexpr signed char
      min() noexcept { return -0x7f - 1; }

      static constexpr signed char
      max() noexcept { return 0x7f; }


      static constexpr signed char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr signed char
      epsilon() noexcept { return 0; }

      static constexpr signed char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr signed char
      infinity() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      quiet_NaN() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      signaling_NaN() noexcept
      { return static_cast<signed char>(0); }

      static constexpr signed char
      denorm_min() noexcept
      { return static_cast<signed char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned char
      min() noexcept { return 0; }

      static constexpr unsigned char
      max() noexcept { return 0x7f * 2U + 1; }


      static constexpr unsigned char
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned char
      epsilon() noexcept { return 0; }

      static constexpr unsigned char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned char
      infinity() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      quiet_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      signaling_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      denorm_min() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr wchar_t
      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static constexpr wchar_t
      max() noexcept { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }


      static constexpr wchar_t
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((wchar_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr wchar_t
      epsilon() noexcept { return 0; }

      static constexpr wchar_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr wchar_t
      infinity() noexcept { return wchar_t(); }

      static constexpr wchar_t
      quiet_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      signaling_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      denorm_min() noexcept { return wchar_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<char8_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char8_t
      min() noexcept { return (((char8_t)(-1) < 0) ? -(((char8_t)(-1) < 0) ? (((((char8_t)1 << ((sizeof(char8_t) * 8 - ((char8_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char8_t)0) - 1 : (char8_t)0); }

      static constexpr char8_t
      max() noexcept { return (((char8_t)(-1) < 0) ? (((((char8_t)1 << ((sizeof(char8_t) * 8 - ((char8_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char8_t)0); }

      static constexpr char8_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char8_t) * 8 - ((char8_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char8_t) * 8 - ((char8_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char8_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char8_t
      epsilon() noexcept { return 0; }

      static constexpr char8_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
 = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char8_t
      infinity() noexcept { return char8_t(); }

      static constexpr char8_t
      quiet_NaN() noexcept { return char8_t(); }

      static constexpr char8_t
      signaling_NaN() noexcept { return char8_t(); }

      static constexpr char8_t
      denorm_min() noexcept { return char8_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
 = round_toward_zero;
    };




  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t
      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0); }

      static constexpr char16_t
      max() noexcept { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }

      static constexpr char16_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char16_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t
      epsilon() noexcept { return 0; }

      static constexpr char16_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t
      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0); }

      static constexpr char32_t
      max() noexcept { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }

      static constexpr char32_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char32_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t
      epsilon() noexcept { return 0; }

      static constexpr char32_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static constexpr bool is_specialized = true;

      static constexpr short
      min() noexcept { return -0x7fff - 1; }

      static constexpr short
      max() noexcept { return 0x7fff; }


      static constexpr short
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr short
      epsilon() noexcept { return 0; }

      static constexpr short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr short
      infinity() noexcept { return short(); }

      static constexpr short
      quiet_NaN() noexcept { return short(); }

      static constexpr short
      signaling_NaN() noexcept { return short(); }

      static constexpr short
      denorm_min() noexcept { return short(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned short
      min() noexcept { return 0; }

      static constexpr unsigned short
      max() noexcept { return 0x7fff * 2U + 1; }


      static constexpr unsigned short
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned short
      epsilon() noexcept { return 0; }

      static constexpr unsigned short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned short
      infinity() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      quiet_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      signaling_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      denorm_min() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static constexpr bool is_specialized = true;

      static constexpr int
      min() noexcept { return -0x7fffffff - 1; }

      static constexpr int
      max() noexcept { return 0x7fffffff; }


      static constexpr int
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr int
      epsilon() noexcept { return 0; }

      static constexpr int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr int
      infinity() noexcept { return static_cast<int>(0); }

      static constexpr int
      quiet_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      signaling_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      denorm_min() noexcept { return static_cast<int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned int
      min() noexcept { return 0; }

      static constexpr unsigned int
      max() noexcept { return 0x7fffffff * 2U + 1; }


      static constexpr unsigned int
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned int
      epsilon() noexcept { return 0; }

      static constexpr unsigned int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned int
      infinity() noexcept { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      quiet_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      signaling_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      denorm_min() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long
      min() noexcept { return -0x7fffffffffffffffL - 1; }

      static constexpr long
      max() noexcept { return 0x7fffffffffffffffL; }


      static constexpr long
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long
      epsilon() noexcept { return 0; }

      static constexpr long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long
      infinity() noexcept { return static_cast<long>(0); }

      static constexpr long
      quiet_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      signaling_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      denorm_min() noexcept { return static_cast<long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long
      min() noexcept { return 0; }

      static constexpr unsigned long
      max() noexcept { return 0x7fffffffffffffffL * 2UL + 1; }


      static constexpr unsigned long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long
      infinity() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      quiet_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      signaling_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      denorm_min() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long long
      min() noexcept { return -0x7fffffffffffffffLL - 1; }

      static constexpr long long
      max() noexcept { return 0x7fffffffffffffffLL; }


      static constexpr long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long long
      epsilon() noexcept { return 0; }

      static constexpr long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long long
      infinity() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      quiet_NaN() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      signaling_NaN() noexcept
      { return static_cast<long long>(0); }

      static constexpr long long
      denorm_min() noexcept { return static_cast<long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long long
      min() noexcept { return 0; }

      static constexpr unsigned long long
      max() noexcept { return 0x7fffffffffffffffLL * 2ULL + 1; }


      static constexpr unsigned long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long long
      infinity() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      quiet_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      signaling_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      denorm_min() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 1659 "/usr/local/include/c++/10.0.0/limits" 3
  template<>
    struct numeric_limits<float>
    {
      static constexpr bool is_specialized = true;

      static constexpr float
      min() noexcept { return 1.17549435082228750796873653722224568e-38F; }

      static constexpr float
      max() noexcept { return 3.40282346638528859811704183484516925e+38F; }


      static constexpr float
      lowest() noexcept { return -3.40282346638528859811704183484516925e+38F; }


      static constexpr int digits = 24;
      static constexpr int digits10 = 6;

      static constexpr int max_digits10
  = (2 + (24) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr float
      epsilon() noexcept { return 1.19209289550781250000000000000000000e-7F; }

      static constexpr float
      round_error() noexcept { return 0.5F; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
       = false;

      static constexpr float
      infinity() noexcept { return __builtin_huge_valf(); }

      static constexpr float
      quiet_NaN() noexcept { return __builtin_nanf(""); }

      static constexpr float
      signaling_NaN() noexcept { return __builtin_nansf(""); }

      static constexpr float
      denorm_min() noexcept { return 1.40129846432481707092372958328991613e-45F; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static constexpr bool is_specialized = true;

      static constexpr double
      min() noexcept { return double(2.22507385850720138309023271733240406e-308L); }

      static constexpr double
      max() noexcept { return double(1.79769313486231570814527423731704357e+308L); }


      static constexpr double
      lowest() noexcept { return -double(1.79769313486231570814527423731704357e+308L); }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr double
      epsilon() noexcept { return double(2.22044604925031308084726333618164062e-16L); }

      static constexpr double
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
        = false;

      static constexpr double
      infinity() noexcept { return __builtin_huge_val(); }

      static constexpr double
      quiet_NaN() noexcept { return __builtin_nan(""); }

      static constexpr double
      signaling_NaN() noexcept { return __builtin_nans(""); }

      static constexpr double
      denorm_min() noexcept { return double(4.94065645841246544176568792868221372e-324L); }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static constexpr bool is_specialized = true;

      static constexpr long double
      min() noexcept { return 3.36210314311209350626267781732175260e-4932L; }

      static constexpr long double
      max() noexcept { return 1.18973149535723176502126385303097021e+4932L; }


      static constexpr long double
      lowest() noexcept { return -1.18973149535723176502126385303097021e+4932L; }


      static constexpr int digits = 64;
      static constexpr int digits10 = 18;

      static constexpr int max_digits10
  = (2 + (64) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr long double
      epsilon() noexcept { return 1.08420217248550443400745280086994171e-19L; }

      static constexpr long double
      round_error() noexcept { return 0.5L; }

      static constexpr int min_exponent = (-16381);
      static constexpr int min_exponent10 = (-4931);
      static constexpr int max_exponent = 16384;
      static constexpr int max_exponent10 = 4932;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
 = false;

      static constexpr long double
      infinity() noexcept { return __builtin_huge_vall(); }

      static constexpr long double
      quiet_NaN() noexcept { return __builtin_nanl(""); }

      static constexpr long double
      signaling_NaN() noexcept { return __builtin_nansl(""); }

      static constexpr long double
      denorm_min() noexcept { return 3.64519953188247460252840593361941982e-4951L; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before =
      false;
      static constexpr float_round_style round_style =
            round_to_nearest;
    };






}
# 8 "fast_io/fast_io_core.h" 2
# 1 "/usr/local/include/c++/10.0.0/type_traits" 1 3
# 32 "/usr/local/include/c++/10.0.0/type_traits" 3
       
# 33 "/usr/local/include/c++/10.0.0/type_traits" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

# 56 "/usr/local/include/c++/10.0.0/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() const noexcept { return value; }




      constexpr value_type operator()() const noexcept { return value; }

    };

  template<typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;

  template<bool __v>
    using __bool_constant = integral_constant<bool, __v>;



  template<bool __v>
    using bool_constant = integral_constant<bool, __v>;




  template<bool, typename, typename>
    struct conditional;

  template <typename _Type>
    struct __type_identity
    { using type = _Type; };

  template<typename _Tp>
    using __type_identity_t = typename __type_identity<_Tp>::type;

  template<typename...>
    struct __or_;

  template<>
    struct __or_<>
    : public false_type
    { };

  template<typename _B1>
    struct __or_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __or_<_B1, _B2>
    : public conditional<_B1::value, _B1, _B2>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __or_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
    { };

  template<typename...>
    struct __and_;

  template<>
    struct __and_<>
    : public true_type
    { };

  template<typename _B1>
    struct __and_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __and_<_B1, _B2>
    : public conditional<_B1::value, _B2, _B1>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __and_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
    { };

  template<typename _Pp>
    struct __not_
    : public __bool_constant<!bool(_Pp::value)>
    { };



  template<typename... _Bn>
    inline constexpr bool __or_v = __or_<_Bn...>::value;
  template<typename... _Bn>
    inline constexpr bool __and_v = __and_<_Bn...>::value;



  template<typename... _Bn>
    struct conjunction
    : __and_<_Bn...>
    { };

  template<typename... _Bn>
    struct disjunction
    : __or_<_Bn...>
    { };

  template<typename _Pp>
    struct negation
    : __not_<_Pp>
    { };

  template<typename... _Bn>
    inline constexpr bool conjunction_v = conjunction<_Bn...>::value;

  template<typename... _Bn>
    inline constexpr bool disjunction_v = disjunction<_Bn...>::value;

  template<typename _Pp>
    inline constexpr bool negation_v = negation<_Pp>::value;




  template<typename>
    struct is_reference;
  template<typename>
    struct is_function;
  template<typename>
    struct is_void;
  template<typename>
    struct __is_array_unknown_bounds;




  template <typename _T, size_t = sizeof(_T)>
    constexpr true_type __is_complete_or_unbounded(__type_identity<_T>)
    { return {}; }

  template <typename _TypeIdentity,
      typename _NestedType = typename _TypeIdentity::type>
    constexpr typename __or_<
      is_reference<_NestedType>,
      is_function<_NestedType>,
      is_void<_NestedType>,
      __is_array_unknown_bounds<_NestedType>
    >::type __is_complete_or_unbounded(_TypeIdentity)
    { return {}; }






  template<typename _Tp>
    struct __success_type
    { typedef _Tp type; };

  struct __failure_type
  { };

  template<typename>
    struct remove_cv;


  template<typename _Tp>
    using __remove_cv_t = typename remove_cv<_Tp>::type;

  template<typename>
    struct is_const;



  template<typename>
    struct __is_void_helper
    : public false_type { };

  template<>
    struct __is_void_helper<void>
    : public true_type { };


  template<typename _Tp>
    struct is_void
    : public __is_void_helper<__remove_cv_t<_Tp>>::type
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };


  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };



  template<>
    struct __is_integral_helper<char8_t>
    : public true_type { };


  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };
# 364 "/usr/local/include/c++/10.0.0/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<__remove_cv_t<_Tp>>::type
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };
# 392 "/usr/local/include/c++/10.0.0/type_traits" 3
  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
    : public __not_<is_function<_Tp>>::type { };


  template<typename _Tp>
    struct is_member_object_pointer
    : public __is_member_object_pointer_helper<__remove_cv_t<_Tp>>::type
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
    : public is_function<_Tp>::type { };


  template<typename _Tp>
    struct is_member_function_pointer
    : public __is_member_function_pointer_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename _Tp>
    struct is_function
    : public __bool_constant<!is_const<const _Tp>::value> { };

  template<typename _Tp>
    struct is_function<_Tp&>
    : public false_type { };

  template<typename _Tp>
    struct is_function<_Tp&&>
    : public false_type { };



  template<typename>
    struct __is_null_pointer_helper
    : public false_type { };

  template<>
    struct __is_null_pointer_helper<std::nullptr_t>
    : public true_type { };


  template<typename _Tp>
    struct is_null_pointer
    : public __is_null_pointer_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { } __attribute__ ((__deprecated__));




  template<typename _Tp>
    struct is_reference
    : public __or_<is_lvalue_reference<_Tp>,
                   is_rvalue_reference<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_object
    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                          is_void<_Tp>>>::type
    { };

  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public __not_<is_fundamental<_Tp>>::type { };

  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
    : public true_type { };


  template<typename _Tp>
    struct is_member_pointer
    : public __is_member_pointer_helper<__remove_cv_t<_Tp>>::type
    { };

  template<typename, typename>
    struct is_same;

  template<typename _Tp, typename... _Types>
    using __is_one_of = __or_<is_same<_Tp, _Types>...>;


  template<typename _Tp>
    using __is_signed_integer = __is_one_of<__remove_cv_t<_Tp>,
   signed char, signed short, signed int, signed long,
   signed long long
# 604 "/usr/local/include/c++/10.0.0/type_traits" 3
   >;


  template<typename _Tp>
    using __is_unsigned_integer = __is_one_of<__remove_cv_t<_Tp>,
   unsigned char, unsigned short, unsigned int, unsigned long,
   unsigned long long
# 623 "/usr/local/include/c++/10.0.0/type_traits" 3
   >;



  template<typename...> using __void_t = void;



  template<typename _Tp, typename = void>
    struct __is_referenceable
    : public false_type
    { };

  template<typename _Tp>
    struct __is_referenceable<_Tp, __void_t<_Tp&>>
    : public true_type
    { };




  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_copyable
    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    struct is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };




  template<typename _Tp>
    struct is_final
    : public integral_constant<bool, __is_final(_Tp)>
    { };



  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };

  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public integral_constant<bool, _Tp(-1) < _Tp(0)>
    { };


  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>
    { };
# 764 "/usr/local/include/c++/10.0.0/type_traits" 3
  template<typename _Tp, typename _Up = _Tp&&>
    _Up
    __declval(int);

  template<typename _Tp>
    _Tp
    __declval(long);

  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0));

  template<typename, unsigned = 0>
    struct extent;

  template<typename>
    struct remove_all_extents;

  template<typename _Tp>
    struct __is_array_known_bounds
    : public integral_constant<bool, (extent<_Tp>::value > 0)>
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>
    { };






  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };





  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static __bool_constant<noexcept(declval<_Tp&>().~_Tp())>
      __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, typename... _Args>
    struct __is_constructible_impl
    : public __bool_constant<__is_constructible(_Tp, _Args...)>
    { };


  template<typename _Tp, typename... _Args>
    struct is_constructible
      : public __is_constructible_impl<_Tp, _Args...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_default_constructible
    : public __is_constructible_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_constructible_impl;

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, true>
    : public __is_constructible_impl<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_constructible
    : public __is_copy_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_constructible_impl;

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, true>
    : public __is_constructible_impl<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_constructible
    : public __is_move_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp>
    struct __is_nt_default_constructible_atom
    : public integral_constant<bool, noexcept(_Tp())>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_nt_default_constructible_impl;

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_nt_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, false>
    : public __is_nt_default_constructible_atom<_Tp>
    { };

  template<typename _Tp>
    using __is_nothrow_default_constructible_impl
      = __and_<__is_constructible_impl<_Tp>,
        __is_nt_default_constructible_impl<_Tp>>;


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __is_nothrow_default_constructible_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl
    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_nt_constructible_impl<_Tp, _Arg>
    : public integral_constant<bool,
                               noexcept(static_cast<_Tp>(declval<_Arg>()))>
    { };

  template<typename _Tp>
    struct __is_nt_constructible_impl<_Tp>
    : public __is_nothrow_default_constructible_impl<_Tp>
    { };

  template<typename _Tp, typename... _Args>
    struct __is_nothrow_constructible_impl
    : public __and_<__is_constructible_impl<_Tp, _Args...>,
      __is_nt_constructible_impl<_Tp, _Args...>>
    { };


  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __is_nothrow_constructible_impl<_Tp, _Args...>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_copy_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, true>
    : public __is_nothrow_constructible_impl<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_copy_constructible_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_move_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, true>
    : public __is_nothrow_constructible_impl<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_move_constructible_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    struct is_assignable
    : public __bool_constant<__is_assignable(_Tp, _Up)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_assignable_impl;

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, true>
    : public __bool_constant<__is_assignable(_Tp&, const _Tp&)>
    { };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_copy_assignable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_assignable_impl;

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, true>
    : public __bool_constant<__is_assignable(_Tp&, _Tp&&)>
    { };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_move_assignable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, typename _Up>
    struct __is_nt_assignable_impl
    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
    { };

  template<typename _Tp, typename _Up>
    struct __is_nothrow_assignable_impl
    : public __and_<__bool_constant<__is_assignable(_Tp, _Up)>,
      __is_nt_assignable_impl<_Tp, _Up>>
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __is_nothrow_assignable_impl<_Tp, _Up>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_copy_assignable_impl;

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, true>
    : public __is_nothrow_assignable_impl<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nt_copy_assignable_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_move_assignable_impl;

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, true>
    : public __is_nothrow_assignable_impl<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nt_move_assignable_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename... _Args>
    struct is_trivially_constructible
    : public __bool_constant<__is_trivially_constructible(_Tp, _Args...)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_default_constructible
    : public __bool_constant<__is_trivially_constructible(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  struct __do_is_implicitly_default_constructible_impl
  {
    template <typename _Tp>
    static void __helper(const _Tp&);

    template <typename _Tp>
    static true_type __test(const _Tp&,
                            decltype(__helper<const _Tp&>({}))* = 0);

    static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_impl
    : public __do_is_implicitly_default_constructible_impl
    {
      typedef decltype(__test(declval<_Tp>())) type;
    };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_safe
    : public __is_implicitly_default_constructible_impl<_Tp>::type
    { };

  template <typename _Tp>
    struct __is_implicitly_default_constructible
    : public __and_<__is_constructible_impl<_Tp>,
      __is_implicitly_default_constructible_safe<_Tp>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_copy_constructible_impl;

  template<typename _Tp>
    struct __is_trivially_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_copy_constructible_impl<_Tp, true>
    : public __and_<__is_copy_constructible_impl<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, const _Tp&)>>
    { };


  template<typename _Tp>
    struct is_trivially_copy_constructible
    : public __is_trivially_copy_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_move_constructible_impl;

  template<typename _Tp>
    struct __is_trivially_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_move_constructible_impl<_Tp, true>
    : public __and_<__is_move_constructible_impl<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, _Tp&&)>>
    { };


  template<typename _Tp>
    struct is_trivially_move_constructible
    : public __is_trivially_move_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    struct is_trivially_assignable
    : public __bool_constant<__is_trivially_assignable(_Tp, _Up)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_copy_assignable_impl;

  template<typename _Tp>
    struct __is_trivially_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_copy_assignable_impl<_Tp, true>
    : public __bool_constant<__is_trivially_assignable(_Tp&, const _Tp&)>
    { };


  template<typename _Tp>
    struct is_trivially_copy_assignable
    : public __is_trivially_copy_assignable_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_move_assignable_impl;

  template<typename _Tp>
    struct __is_trivially_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_move_assignable_impl<_Tp, true>
    : public __bool_constant<__is_trivially_assignable(_Tp&, _Tp&&)>
    { };


  template<typename _Tp>
    struct is_trivially_move_assignable
    : public __is_trivially_move_assignable_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<__is_destructible_safe<_Tp>,
      __bool_constant<__has_trivial_destructor(_Tp)>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, alignof(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };





  template<typename _Tp, typename _Up>
    struct is_same

    : public integral_constant<bool, __is_same_as(_Tp, _Up)>



    { };
# 1408 "/usr/local/include/c++/10.0.0/type_traits" 3
  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_convertible_helper
    {
      typedef typename is_void<_To>::type type;
    };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    {
      template<typename _To1>
 static void __test_aux(_To1) noexcept;

      template<typename _From1, typename _To1,
        typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_From, _To>(0)) type;
    };
#pragma GCC diagnostic pop


  template<typename _From, typename _To>
    struct is_convertible
    : public __is_convertible_helper<_From, _To>::type
    { };

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_nt_convertible_helper
    : is_void<_To>
    { };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
  template<typename _From, typename _To>
    class __is_nt_convertible_helper<_From, _To, false>
    {
      template<typename _To1>
 static void __test_aux(_To1) noexcept;

      template<typename _From1, typename _To1>
 static
 __bool_constant<noexcept(__test_aux<_To1>(std::declval<_From1>()))>
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      using type = decltype(__test<_From, _To>(0));
    };
#pragma GCC diagnostic pop


  template<typename _ToElementType, typename _FromElementType>
    using __is_array_convertible
      = is_convertible<_FromElementType(*)[], _ToElementType(*)[]>;


  template<typename _From, typename _To>
    struct __is_nothrow_convertible
    : public __is_nt_convertible_helper<_From, _To>::type
    { };



  template<typename _From, typename _To>
    struct is_nothrow_convertible
    : public __is_nt_convertible_helper<_From, _To>::type
    { };


  template<typename _From, typename _To>
    inline constexpr bool is_nothrow_convertible_v
      = is_nothrow_convertible<_From, _To>::value;





  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_cv<const _Tp>
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_cv<volatile _Tp>
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_cv<const volatile _Tp>
    { using type = _Tp; };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };






  template<typename _Tp>
    using remove_const_t = typename remove_const<_Tp>::type;


  template<typename _Tp>
    using remove_volatile_t = typename remove_volatile<_Tp>::type;


  template<typename _Tp>
    using remove_cv_t = typename remove_cv<_Tp>::type;


  template<typename _Tp>
    using add_const_t = typename add_const<_Tp>::type;


  template<typename _Tp>
    using add_volatile_t = typename add_volatile<_Tp>::type;


  template<typename _Tp>
    using add_cv_t = typename add_cv<_Tp>::type;





  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_reference_t = typename remove_reference<_Tp>::type;


  template<typename _Tp>
    using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;


  template<typename _Tp>
    using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;





  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };
# 1727 "/usr/local/include/c++/10.0.0/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      using __unsigned_type
 = typename __make_unsigned<__remove_cv_t<_Tp>>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };

  class __make_unsigned_selector_base
  {
  protected:
    template<typename...> struct _List { };

    template<typename _Tp, typename... _Up>
      struct _List<_Tp, _Up...> : _List<_Up...>
      { static constexpr size_t __size = sizeof(_Tp); };

    template<size_t _Sz, typename _Tp, bool = (_Sz <= _Tp::__size)>
      struct __select;

    template<size_t _Sz, typename _Uint, typename... _UInts>
      struct __select<_Sz, _List<_Uint, _UInts...>, true>
      { using __type = _Uint; };

    template<size_t _Sz, typename _Uint, typename... _UInts>
      struct __select<_Sz, _List<_Uint, _UInts...>, false>
      : __select<_Sz, _List<_UInts...>>
      { };
  };


  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    : __make_unsigned_selector_base
    {

      using _UInts = _List<unsigned char, unsigned short, unsigned int,
      unsigned long, unsigned long long>;

      using __unsigned_type = typename __select<sizeof(_Tp), _UInts>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };






  template<>
    struct __make_unsigned<wchar_t>
    {
      using __type
 = typename __make_unsigned_selector<wchar_t, false, true>::__type;
    };



  template<>
    struct __make_unsigned<char8_t>
    {
      using __type
 = typename __make_unsigned_selector<char8_t, false, true>::__type;
    };


  template<>
    struct __make_unsigned<char16_t>
    {
      using __type
 = typename __make_unsigned_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_unsigned<char32_t>
    {
      using __type
 = typename __make_unsigned_selector<char32_t, false, true>::__type;
    };





  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;



  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };
# 1881 "/usr/local/include/c++/10.0.0/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      using __signed_type
 = typename __make_signed<__remove_cv_t<_Tp>>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __signed_type>::__type;
    };


  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {
      typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;

    public:
      typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };






  template<>
    struct __make_signed<wchar_t>
    {
      using __type
 = typename __make_signed_selector<wchar_t, false, true>::__type;
    };



  template<>
    struct __make_signed<char8_t>
    {
      using __type
 = typename __make_signed_selector<char8_t, false, true>::__type;
    };


  template<>
    struct __make_signed<char16_t>
    {
      using __type
 = typename __make_signed_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_signed<char32_t>
    {
      using __type
 = typename __make_signed_selector<char32_t, false, true>::__type;
    };





  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;



  template<typename _Tp>
    using make_signed_t = typename make_signed<_Tp>::type;


  template<typename _Tp>
    using make_unsigned_t = typename make_unsigned<_Tp>::type;





  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };



  template<typename _Tp>
    using remove_extent_t = typename remove_extent<_Tp>::type;


  template<typename _Tp>
    using remove_all_extents_t = typename remove_all_extents<_Tp>::type;




  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, __remove_cv_t<_Tp>>
    { };


  template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,
          is_void<_Tp>>::value>
    struct __add_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, true>
    { typedef typename remove_reference<_Tp>::type* type; };

  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_pointer_t = typename remove_pointer<_Tp>::type;


  template<typename _Tp>
    using add_pointer_t = typename add_pointer<_Tp>::type;


  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 2064 "/usr/local/include/c++/10.0.0/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };

  template <typename... _Types>
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };

  template <typename _Tp, typename... _Types>
    struct __strictest_alignment<_Tp, _Types...>
    {
      static const size_t _S_alignment =
        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
 ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
      static const size_t _S_size =
        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
 ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };
# 2103 "/usr/local/include/c++/10.0.0/type_traits" 3
  template <size_t _Len, typename... _Types>
    struct aligned_union
    {
    private:
      static_assert(sizeof...(_Types) != 0, "At least one type is required");

      using __strictest = __strictest_alignment<_Types...>;
      static const size_t _S_len = _Len > __strictest::_S_size
 ? _Len : __strictest::_S_size;
    public:

      static const size_t alignment_value = __strictest::_S_alignment;

      typedef typename aligned_storage<_S_len, alignment_value>::type type;
    };

  template <size_t _Len, typename... _Types>
    const size_t aligned_union<_Len, _Types...>::alignment_value;



  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef __remove_cv_t<_Up> __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };


  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };


  template<typename _Tp>
    using __decay_t = typename decay<_Tp>::type;

  template<typename _Tp>
    class reference_wrapper;


  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    using __decay_and_strip = __strip_reference_wrapper<__decay_t<_Tp>>;




  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };


  template<bool _Cond, typename _Tp = void>
    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;

  template<typename... _Cond>
    using _Require = __enable_if_t<__and_<_Cond...>::value>;



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };


  template<typename _Tp>
    using __remove_cvref_t
     = typename remove_cv<typename remove_reference<_Tp>::type>::type;


  template<typename... _Tp>
    struct common_type;



  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      using __cond_t
 = decltype(true ? std::declval<_Tp>() : std::declval<_Up>());



    template<typename _Tp, typename _Up>
      static __success_type<__decay_t<__cond_t<_Tp, _Up>>>
      _S_test(int);




    template<typename _Tp, typename _Up>
      static __success_type<__remove_cvref_t<__cond_t<const _Tp&, const _Up&>>>
      _S_test_2(int);


    template<typename, typename>
      static __failure_type
      _S_test_2(...);

    template<typename _Tp, typename _Up>
      static decltype(_S_test_2<_Tp, _Up>(0))
      _S_test(...);
  };


  template<>
    struct common_type<>
    { };


  template<typename _Tp0>
    struct common_type<_Tp0>
    : public common_type<_Tp0, _Tp0>
    { };


  template<typename _Tp1, typename _Tp2,
    typename _Dp1 = __decay_t<_Tp1>, typename _Dp2 = __decay_t<_Tp2>>
    struct __common_type_impl
    {


      using type = common_type<_Dp1, _Dp2>;
    };

  template<typename _Tp1, typename _Tp2>
    struct __common_type_impl<_Tp1, _Tp2, _Tp1, _Tp2>
    : private __do_common_type_impl
    {


      using type = decltype(_S_test<_Tp1, _Tp2>(0));
    };


  template<typename _Tp1, typename _Tp2>
    struct common_type<_Tp1, _Tp2>
    : public __common_type_impl<_Tp1, _Tp2>::type
    { };

  template<typename...>
    struct __common_type_pack
    { };

  template<typename, typename, typename = void>
    struct __common_type_fold;


  template<typename _Tp1, typename _Tp2, typename... _Rp>
    struct common_type<_Tp1, _Tp2, _Rp...>
    : public __common_type_fold<common_type<_Tp1, _Tp2>,
    __common_type_pack<_Rp...>>
    { };




  template<typename _CTp, typename... _Rp>
    struct __common_type_fold<_CTp, __common_type_pack<_Rp...>,
         __void_t<typename _CTp::type>>
    : public common_type<typename _CTp::type, _Rp...>
    { };


  template<typename _CTp, typename _Rp>
    struct __common_type_fold<_CTp, _Rp, void>
    { };

  template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __underlying_type_impl
    {
      using type = __underlying_type(_Tp);
    };

  template<typename _Tp>
    struct __underlying_type_impl<_Tp, false>
    { };


  template<typename _Tp>
    struct underlying_type
    : public __underlying_type_impl<_Tp>
    { };

  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
    };

  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0))
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval<_Tp>(0);
    }


  template<typename _Signature>
    class result_of;





  struct __invoke_memfun_ref { };
  struct __invoke_memfun_deref { };
  struct __invoke_memobj_ref { };
  struct __invoke_memobj_deref { };
  struct __invoke_other { };


  template<typename _Tp, typename _Tag>
    struct __result_of_success : __success_type<_Tp>
    { using __invoke_type = _Tag; };


  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_ref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_deref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      ), __invoke_memobj_ref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      ), __invoke_memobj_deref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      typedef __remove_cvref_t<_Arg> _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type::type type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      typedef typename remove_reference<_Arg>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<is_base_of<_Class, _Argval>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type::type type;
    };






  template<typename _Tp, typename _Up = __remove_cvref_t<_Tp>>
    struct __inv_unwrap
    {
      using type = _Tp;
    };

  template<typename _Tp, typename _Up>
    struct __inv_unwrap<_Tp, reference_wrapper<_Up>>
    {
      using type = _Up&;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      typedef __failure_type type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<__decay_t<_MemPtr>,
    typename __inv_unwrap<_Arg>::type>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<__decay_t<_MemPtr>,
    typename __inv_unwrap<_Arg>::type, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __result_of_success<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      ), __invoke_other> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };


  template<typename _Functor, typename... _ArgTypes>
    struct __invoke_result
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
 _Functor, _ArgTypes...
      >::type
    { };

  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __invoke_result<_Functor, _ArgTypes...>
    { };



  template<size_t _Len, size_t _Align =
     __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

  template <size_t _Len, typename... _Types>
    using aligned_union_t = typename aligned_union<_Len, _Types...>::type;


  template<typename _Tp>
    using decay_t = typename decay<_Tp>::type;


  template<bool _Cond, typename _Tp = void>
    using enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;


  template<typename... _Tp>
    using common_type_t = typename common_type<_Tp...>::type;


  template<typename _Tp>
    using underlying_type_t = typename underlying_type<_Tp>::type;


  template<typename _Tp>
    using result_of_t = typename result_of<_Tp>::type;





  template<typename...> using void_t = void;



  template<typename _Default, typename _AlwaysVoid,
    template<typename...> class _Op, typename... _Args>
    struct __detector
    {
      using value_t = false_type;
      using type = _Default;
    };


  template<typename _Default, template<typename...> class _Op,
     typename... _Args>
    struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...>
    {
      using value_t = true_type;
      using type = _Op<_Args...>;
    };


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or = __detector<_Default, void, _Op, _Args...>;


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or_t
      = typename __detected_or<_Default, _Op, _Args...>::type;
# 2621 "/usr/local/include/c++/10.0.0/type_traits" 3
  template <typename _Tp>
    struct __is_swappable;

  template <typename _Tp>
    struct __is_nothrow_swappable;

  template<typename... _Elements>
    class tuple;

  template<typename>
    struct __is_tuple_like_impl : false_type
    { };

  template<typename... _Tps>
    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<__remove_cvref_t<_Tp>>::type
    { };

  template<typename _Tp>
    constexpr
    inline
    _Require<__not_<__is_tuple_like<_Tp>>,
      is_move_constructible<_Tp>,
      is_move_assignable<_Tp>>
    swap(_Tp&, _Tp&)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value);

  template<typename _Tp, size_t _Nm>
    constexpr
    inline
    __enable_if_t<__is_swappable<_Tp>::value>
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value);

  namespace __swappable_details {
    using std::swap;

    struct __do_is_swappable_impl
    {
      template<typename _Tp, typename
               = decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))>
        static true_type __test(int);

      template<typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_impl
    {
      template<typename _Tp>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))
        > __test(int);

      template<typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp>
    struct __is_swappable_impl
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_nothrow_swappable_impl
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };

  template<typename _Tp>
    struct __is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };






  template<typename _Tp>
    struct is_swappable
    : public __is_swappable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    inline constexpr bool is_swappable_v =
      is_swappable<_Tp>::value;


  template<typename _Tp>
    inline constexpr bool is_nothrow_swappable_v =
      is_nothrow_swappable<_Tp>::value;


  namespace __swappable_with_details {
    using std::swap;

    struct __do_is_swappable_with_impl
    {
      template<typename _Tp, typename _Up, typename
               = decltype(swap(std::declval<_Tp>(), std::declval<_Up>())),
               typename
               = decltype(swap(std::declval<_Up>(), std::declval<_Tp>()))>
        static true_type __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_with_impl
    {
      template<typename _Tp, typename _Up>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp>(), std::declval<_Up>()))
          &&
          noexcept(swap(std::declval<_Up>(), std::declval<_Tp>()))
        > __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp, typename _Up>
    struct __is_swappable_with_impl
    : public __swappable_with_details::__do_is_swappable_with_impl
    {
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp>
    struct __is_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp&>(0)) type;
    };

  template<typename _Tp, typename _Up>
    struct __is_nothrow_swappable_with_impl
    : public __swappable_with_details::__do_is_nothrow_swappable_with_impl
    {
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp>
    struct __is_nothrow_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp&>(0)) type;
    };


  template<typename _Tp, typename _Up>
    struct is_swappable_with
    : public __is_swappable_with_impl<_Tp, _Up>::type
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_swappable_with
    : public __is_nothrow_swappable_with_impl<_Tp, _Up>::type
    { };



  template<typename _Tp, typename _Up>
    inline constexpr bool is_swappable_with_v =
      is_swappable_with<_Tp, _Up>::value;


  template<typename _Tp, typename _Up>
    inline constexpr bool is_nothrow_swappable_with_v =
      is_nothrow_swappable_with<_Tp, _Up>::value;







  template<typename _Result, typename _Ret,
    bool = is_void<_Ret>::value, typename = void>
    struct __is_invocable_impl : false_type { };


  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                                true,
          __void_t<typename _Result::type>>
    : true_type
    { };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"

  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                                false,
          __void_t<typename _Result::type>>
    {
    private:


      static typename _Result::type _S_get();

      template<typename _Tp>
 static void _S_conv(_Tp);


      template<typename _Tp, typename = decltype(_S_conv<_Tp>(_S_get()))>
 static true_type
 _S_test(int);

      template<typename _Tp>
 static false_type
 _S_test(...);

    public:
      using type = decltype(_S_test<_Ret>(1));
    };
#pragma GCC diagnostic pop

  template<typename _Fn, typename... _ArgTypes>
    struct __is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    { };

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept((std::declval<_Up>().*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_deref)
    {
      return noexcept(((*std::declval<_Tp>()).*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept(std::declval<_Up>().*std::declval<_Fn>());
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_deref)
    {
      return noexcept((*std::declval<_Tp>()).*std::declval<_Fn>());
    }

  template<typename _Fn, typename... _Args>
    constexpr bool __call_is_nt(__invoke_other)
    {
      return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
    }

  template<typename _Result, typename _Fn, typename... _Args>
    struct __call_is_nothrow
    : __bool_constant<
 std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type{})
      >
    { };

  template<typename _Fn, typename... _Args>
    using __call_is_nothrow_
      = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    struct __is_nothrow_invocable
    : __and_<__is_invocable<_Fn, _Args...>,
             __call_is_nothrow_<_Fn, _Args...>>::type
    { };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
  struct __nonesuchbase {};
  struct __nonesuch : private __nonesuchbase {
    ~__nonesuch() = delete;
    __nonesuch(__nonesuch const&) = delete;
    void operator=(__nonesuch const&) = delete;
  };
#pragma GCC diagnostic pop





  template<typename _Functor, typename... _ArgTypes>
    struct invoke_result
    : public __invoke_result<_Functor, _ArgTypes...>
    { };


  template<typename _Fn, typename... _Args>
    using invoke_result_t = typename invoke_result<_Fn, _Args...>::type;


  template<typename _Fn, typename... _ArgTypes>
    struct is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
    };


  template<typename _Ret, typename _Fn, typename... _ArgTypes>
    struct is_invocable_r
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
    };


  template<typename _Fn, typename... _ArgTypes>
    struct is_nothrow_invocable
    : __and_<__is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>,
      __call_is_nothrow_<_Fn, _ArgTypes...>>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
    };

  template<typename _Result, typename _Ret, typename = void>
    struct __is_nt_invocable_impl : false_type { };

  template<typename _Result, typename _Ret>
    struct __is_nt_invocable_impl<_Result, _Ret,
      __void_t<typename _Result::type>>
    : __or_<is_void<_Ret>,
     __is_nothrow_convertible<typename _Result::type, _Ret>>
    { };


  template<typename _Ret, typename _Fn, typename... _ArgTypes>
    struct is_nothrow_invocable_r
    : __and_<__is_nt_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>,
             __call_is_nothrow_<_Fn, _ArgTypes...>>::type
    { };


  template<typename _Fn, typename... _Args>
    inline constexpr bool is_invocable_v = is_invocable<_Fn, _Args...>::value;


  template<typename _Fn, typename... _Args>
    inline constexpr bool is_nothrow_invocable_v
      = is_nothrow_invocable<_Fn, _Args...>::value;


  template<typename _Ret, typename _Fn, typename... _Args>
    inline constexpr bool is_invocable_r_v
      = is_invocable_r<_Ret, _Fn, _Args...>::value;


  template<typename _Ret, typename _Fn, typename... _Args>
    inline constexpr bool is_nothrow_invocable_r_v
      = is_nothrow_invocable_r<_Ret, _Fn, _Args...>::value;




template <typename _Tp>
  inline constexpr bool is_void_v = is_void<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_null_pointer_v = is_null_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_integral_v = is_integral<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_floating_point_v = is_floating_point<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_array_v = is_array<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_pointer_v = is_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_lvalue_reference_v =
    is_lvalue_reference<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_rvalue_reference_v =
    is_rvalue_reference<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_member_object_pointer_v =
    is_member_object_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_member_function_pointer_v =
    is_member_function_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_enum_v = is_enum<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_union_v = is_union<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_class_v = is_class<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_function_v = is_function<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_reference_v = is_reference<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_arithmetic_v = is_arithmetic<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_fundamental_v = is_fundamental<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_object_v = is_object<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_scalar_v = is_scalar<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_compound_v = is_compound<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_member_pointer_v = is_member_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_const_v = is_const<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_volatile_v = is_volatile<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_trivial_v = is_trivial<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_trivially_copyable_v =
    is_trivially_copyable<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_standard_layout_v = is_standard_layout<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_pod_v = is_pod<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_literal_type_v = is_literal_type<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_empty_v = is_empty<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_polymorphic_v = is_polymorphic<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_abstract_v = is_abstract<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_final_v = is_final<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_signed_v = is_signed<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_unsigned_v = is_unsigned<_Tp>::value;
template <typename _Tp, typename... _Args>
  inline constexpr bool is_constructible_v =
    is_constructible<_Tp, _Args...>::value;
template <typename _Tp>
  inline constexpr bool is_default_constructible_v =
    is_default_constructible<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_copy_constructible_v =
    is_copy_constructible<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_move_constructible_v =
    is_move_constructible<_Tp>::value;
template <typename _Tp, typename _Up>
  inline constexpr bool is_assignable_v = is_assignable<_Tp, _Up>::value;
template <typename _Tp>
  inline constexpr bool is_copy_assignable_v = is_copy_assignable<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_move_assignable_v = is_move_assignable<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_destructible_v = is_destructible<_Tp>::value;
template <typename _Tp, typename... _Args>
  inline constexpr bool is_trivially_constructible_v =
    is_trivially_constructible<_Tp, _Args...>::value;
template <typename _Tp>
  inline constexpr bool is_trivially_default_constructible_v =
    is_trivially_default_constructible<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_trivially_copy_constructible_v =
    is_trivially_copy_constructible<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_trivially_move_constructible_v =
    is_trivially_move_constructible<_Tp>::value;
template <typename _Tp, typename _Up>
  inline constexpr bool is_trivially_assignable_v =
    is_trivially_assignable<_Tp, _Up>::value;
template <typename _Tp>
  inline constexpr bool is_trivially_copy_assignable_v =
    is_trivially_copy_assignable<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_trivially_move_assignable_v =
    is_trivially_move_assignable<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_trivially_destructible_v =
    is_trivially_destructible<_Tp>::value;
template <typename _Tp, typename... _Args>
  inline constexpr bool is_nothrow_constructible_v =
    is_nothrow_constructible<_Tp, _Args...>::value;
template <typename _Tp>
  inline constexpr bool is_nothrow_default_constructible_v =
    is_nothrow_default_constructible<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_nothrow_copy_constructible_v =
    is_nothrow_copy_constructible<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_nothrow_move_constructible_v =
    is_nothrow_move_constructible<_Tp>::value;
template <typename _Tp, typename _Up>
  inline constexpr bool is_nothrow_assignable_v =
    is_nothrow_assignable<_Tp, _Up>::value;
template <typename _Tp>
  inline constexpr bool is_nothrow_copy_assignable_v =
    is_nothrow_copy_assignable<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_nothrow_move_assignable_v =
    is_nothrow_move_assignable<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_nothrow_destructible_v =
    is_nothrow_destructible<_Tp>::value;
template <typename _Tp>
  inline constexpr bool has_virtual_destructor_v =
    has_virtual_destructor<_Tp>::value;
template <typename _Tp>
  inline constexpr size_t alignment_of_v = alignment_of<_Tp>::value;
template <typename _Tp>
  inline constexpr size_t rank_v = rank<_Tp>::value;
template <typename _Tp, unsigned _Idx = 0>
  inline constexpr size_t extent_v = extent<_Tp, _Idx>::value;

template <typename _Tp, typename _Up>
  inline constexpr bool is_same_v = __is_same_as(_Tp, _Up);




template <typename _Base, typename _Derived>
  inline constexpr bool is_base_of_v = is_base_of<_Base, _Derived>::value;
template <typename _From, typename _To>
  inline constexpr bool is_convertible_v = is_convertible<_From, _To>::value;




  template<typename _Tp>
    struct has_unique_object_representations
    : bool_constant<__has_unique_object_representations(
      remove_cv_t<remove_all_extents_t<_Tp>>
      )>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp>
    inline constexpr bool has_unique_object_representations_v
      = has_unique_object_representations<_Tp>::value;





  template<typename _Tp>
    struct is_aggregate
    : bool_constant<__is_aggregate(remove_cv_t<_Tp>)>
    { };


  template<typename _Tp>
    inline constexpr bool is_aggregate_v = is_aggregate<_Tp>::value;





  template<typename _Tp>
    struct remove_cvref
    {
      using type = __remove_cvref_t<_Tp>;
    };

  template<typename _Tp>
    using remove_cvref_t = __remove_cvref_t<_Tp>;


  template<typename _Tp>
    struct type_identity { using type = _Tp; };

  template<typename _Tp>
    using type_identity_t = typename type_identity<_Tp>::type;


  template<typename _Tp>
    struct unwrap_reference { using type = _Tp; };

  template<typename _Tp>
    struct unwrap_reference<reference_wrapper<_Tp>> { using type = _Tp&; };

  template<typename _Tp>
    using unwrap_reference_t = typename unwrap_reference<_Tp>::type;


  template<typename _Tp>
    struct unwrap_ref_decay { using type = unwrap_reference_t<decay_t<_Tp>>; };

  template<typename _Tp>
    using unwrap_ref_decay_t = typename unwrap_ref_decay<_Tp>::type;




  template<typename _Tp>
    struct is_bounded_array
    : public __is_array_known_bounds<_Tp>
    { };


  template<typename _Tp>
    struct is_unbounded_array
    : public __is_array_unknown_bounds<_Tp>
    { };

  template<typename _Tp>
    inline constexpr bool is_bounded_array_v
      = is_bounded_array<_Tp>::value;

  template<typename _Tp>
    inline constexpr bool is_unbounded_array_v
      = is_unbounded_array<_Tp>::value;





  constexpr inline bool
  is_constant_evaluated() noexcept
  { return __builtin_is_constant_evaluated(); }


  template<typename _From, typename _To>
    using __copy_cv = typename __match_cv_qualifiers<_From, _To>::__type;

  template<typename _Xp, typename _Yp>
    using __cond_res
      = decltype(false ? declval<_Xp(&)()>()() : declval<_Yp(&)()>()());

  template<typename _Ap, typename _Bp, typename = void>
    struct __common_ref_impl
    { };


  template<typename _Ap, typename _Bp>
    using __common_ref = typename __common_ref_impl<_Ap, _Bp>::type;


  template<typename _Xp, typename _Yp>
    struct __common_ref_impl<_Xp&, _Yp&,
      __void_t<__cond_res<__copy_cv<_Xp, _Yp>&, __copy_cv<_Yp, _Xp>&>>>
    { using type = __cond_res<__copy_cv<_Xp, _Yp>&, __copy_cv<_Yp, _Xp>&>; };


  template<typename _Xp, typename _Yp>
    using __common_ref_C = remove_reference_t<__common_ref<_Xp&, _Yp&>>&&;


  template<typename _Xp, typename _Yp>
    struct __common_ref_impl<_Xp&&, _Yp&&,
      _Require<is_convertible<_Xp&&, __common_ref_C<_Xp, _Yp>>,
        is_convertible<_Yp&&, __common_ref_C<_Xp, _Yp>>>>
    { using type = __common_ref_C<_Xp, _Yp>; };


  template<typename _Xp, typename _Yp>
    using __common_ref_D = __common_ref<const _Xp&, _Yp&>;


  template<typename _Xp, typename _Yp>
    struct __common_ref_impl<_Xp&&, _Yp&,
      _Require<is_convertible<_Xp&&, __common_ref_D<_Xp, _Yp>>>>
    { using type = __common_ref_D<_Xp, _Yp>; };


  template<typename _Xp, typename _Yp>
    struct __common_ref_impl<_Xp&, _Yp&&>
    : __common_ref_impl<_Yp&&, _Xp&>
    { };

  template<typename _Tp, typename _Up,
    template<typename> class _TQual, template<typename> class _UQual>
    struct basic_common_reference
    { };

  template<typename _Tp>
    struct __xref
    { template<typename _Up> using __type = __copy_cv<_Tp, _Up>; };

  template<typename _Tp>
    struct __xref<_Tp&>
    { template<typename _Up> using __type = __copy_cv<_Tp, _Up>&; };

  template<typename _Tp>
    struct __xref<_Tp&&>
    { template<typename _Up> using __type = __copy_cv<_Tp, _Up>&&; };

  template<typename _Tp1, typename _Tp2>
    using __basic_common_ref
      = typename basic_common_reference<remove_cvref_t<_Tp1>,
     remove_cvref_t<_Tp2>,
     __xref<_Tp1>::template __type,
     __xref<_Tp2>::template __type>::type;

  template<typename... _Tp>
    struct common_reference;

  template<typename... _Tp>
    using common_reference_t = typename common_reference<_Tp...>::type;


  template<>
    struct common_reference<>
    { };


  template<typename _Tp0>
    struct common_reference<_Tp0>
    { using type = _Tp0; };

  template<typename _Tp1, typename _Tp2, int _Bullet = 1, typename = void>
    struct __common_reference_impl
    : __common_reference_impl<_Tp1, _Tp2, _Bullet + 1>
    { };


  template<typename _Tp1, typename _Tp2>
    struct common_reference<_Tp1, _Tp2>
    : __common_reference_impl<_Tp1, _Tp2>
    { };


  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1&, _Tp2&, 1,
       void_t<__common_ref<_Tp1&, _Tp2&>>>
    { using type = __common_ref<_Tp1&, _Tp2&>; };

  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1&&, _Tp2&&, 1,
       void_t<__common_ref<_Tp1&&, _Tp2&&>>>
    { using type = __common_ref<_Tp1&&, _Tp2&&>; };

  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1&, _Tp2&&, 1,
       void_t<__common_ref<_Tp1&, _Tp2&&>>>
    { using type = __common_ref<_Tp1&, _Tp2&&>; };

  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1&&, _Tp2&, 1,
       void_t<__common_ref<_Tp1&&, _Tp2&>>>
    { using type = __common_ref<_Tp1&&, _Tp2&>; };


  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1, _Tp2, 2,
       void_t<__basic_common_ref<_Tp1, _Tp2>>>
    { using type = __basic_common_ref<_Tp1, _Tp2>; };


  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1, _Tp2, 3,
       void_t<__cond_res<_Tp1, _Tp2>>>
    { using type = __cond_res<_Tp1, _Tp2>; };


  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1, _Tp2, 4,
       void_t<common_type_t<_Tp1, _Tp2>>>
    { using type = common_type_t<_Tp1, _Tp2>; };


  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1, _Tp2, 5, void>
    { };


  template<typename _Tp1, typename _Tp2, typename... _Rest>
    struct common_reference<_Tp1, _Tp2, _Rest...>
    : __common_type_fold<common_reference<_Tp1, _Tp2>,
    __common_type_pack<_Rest...>>
    { };


  template<typename _Tp1, typename _Tp2, typename... _Rest>
    struct __common_type_fold<common_reference<_Tp1, _Tp2>,
         __common_type_pack<_Rest...>,
         void_t<common_reference_t<_Tp1, _Tp2>>>
    : public common_reference<common_reference_t<_Tp1, _Tp2>, _Rest...>
    { };




}
# 9 "fast_io/fast_io_core.h" 2
# 1 "/usr/local/include/c++/10.0.0/concepts" 1 3
# 35 "/usr/local/include/c++/10.0.0/concepts" 3
       
# 36 "/usr/local/include/c++/10.0.0/concepts" 3
# 46 "/usr/local/include/c++/10.0.0/concepts" 3
namespace std __attribute__ ((__visibility__ ("default")))
{






  namespace __detail
  {
    template<typename _Tp, typename _Up>
      concept __same_as = std::is_same_v<_Tp, _Up>;
  }


  template<typename _Tp, typename _Up>
    concept same_as
      = __detail::__same_as<_Tp, _Up> && __detail::__same_as<_Up, _Tp>;


  template<typename _Derived, typename _Base>
    concept derived_from = __is_base_of(_Base, _Derived)
      && is_convertible_v<const volatile _Derived*, const volatile _Base*>;


  template<typename _From, typename _To>
    concept convertible_to = is_convertible_v<_From, _To>
      && requires(add_rvalue_reference_t<_From> (&__f)()) {
   static_cast<_To>(__f());
      };


  template<typename _Tp, typename _Up>
    concept common_reference_with
      = same_as<common_reference_t<_Tp, _Up>, common_reference_t<_Up, _Tp>>
      && convertible_to<_Tp, common_reference_t<_Tp, _Up>>
      && convertible_to<_Up, common_reference_t<_Tp, _Up>>;


  template<typename _Tp, typename _Up>
    concept common_with
      = same_as<common_type_t<_Tp, _Up>, common_type_t<_Up, _Tp>>
      && requires {
 static_cast<common_type_t<_Tp, _Up>>(std::declval<_Tp>());
 static_cast<common_type_t<_Tp, _Up>>(std::declval<_Up>());
      }
      && common_reference_with<add_lvalue_reference_t<const _Tp>,
          add_lvalue_reference_t<const _Up>>
      && common_reference_with<add_lvalue_reference_t<common_type_t<_Tp, _Up>>,
          common_reference_t<
     add_lvalue_reference_t<const _Tp>,
     add_lvalue_reference_t<const _Up>>>;



  template<typename _Tp>
    concept integral = is_integral_v<_Tp>;

  template<typename _Tp>
    concept signed_integral = integral<_Tp> && is_signed_v<_Tp>;

  template<typename _Tp>
    concept unsigned_integral = integral<_Tp> && !signed_integral<_Tp>;

  template<typename _Tp>
    concept floating_point = is_floating_point_v<_Tp>;

  namespace __detail
  {
    template<typename _Tp>
      using __cref = const remove_reference_t<_Tp>&;

      template<typename _Tp>
 concept __class_or_enum
   = is_class_v<_Tp> || is_union_v<_Tp> || is_enum_v<_Tp>;
  }


  template<typename _Lhs, typename _Rhs>
    concept assignable_from
      = is_lvalue_reference_v<_Lhs>
      && common_reference_with<__detail::__cref<_Lhs>, __detail::__cref<_Rhs>>
      && requires(_Lhs __lhs, _Rhs&& __rhs) {
 { __lhs = static_cast<_Rhs&&>(__rhs) } -> same_as<_Lhs>;
      };


  template<typename _Tp>
    concept destructible = is_nothrow_destructible_v<_Tp>;


  template<typename _Tp, typename... _Args>
    concept constructible_from
      = destructible<_Tp> && is_constructible_v<_Tp, _Args...>;


  template<typename _Tp>
    concept default_initializable = constructible_from<_Tp>
      && requires
      {
 _Tp{};
 (void) ::new _Tp;
      };


  template<typename _Tp>
    concept move_constructible
    = constructible_from<_Tp, _Tp> && convertible_to<_Tp, _Tp>;


  template<typename _Tp>
    concept copy_constructible
      = move_constructible<_Tp>
      && constructible_from<_Tp, _Tp&> && convertible_to<_Tp&, _Tp>
      && constructible_from<_Tp, const _Tp&> && convertible_to<const _Tp&, _Tp>
      && constructible_from<_Tp, const _Tp> && convertible_to<const _Tp, _Tp>;



  namespace ranges
  {
    namespace __cust_swap
    {
      template<typename _Tp> void swap(_Tp&, _Tp&) = delete;

      template<typename _Tp, typename _Up>
 concept __adl_swap
   = (__detail::__class_or_enum<remove_reference_t<_Tp>>
     || __detail::__class_or_enum<remove_reference_t<_Up>>)
   && requires(_Tp&& __t, _Up&& __u) {
     swap(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u));
   };

      struct _Swap
      {
      private:
 template<typename _Tp, typename _Up>
   static constexpr bool
   _S_noexcept()
   {
     if constexpr (__adl_swap<_Tp, _Up>)
       return noexcept(swap(std::declval<_Tp>(), std::declval<_Up>()));
     else
       return is_nothrow_move_constructible_v<remove_reference_t<_Tp>>
     && is_nothrow_move_assignable_v<remove_reference_t<_Tp>>;
   }

      public:
 template<typename _Tp, typename _Up>
   requires __adl_swap<_Tp, _Up>
   || (same_as<_Tp, _Up> && is_lvalue_reference_v<_Tp>
       && move_constructible<remove_reference_t<_Tp>>
       && assignable_from<_Tp, remove_reference_t<_Tp>>)
   constexpr void
   operator()(_Tp&& __t, _Up&& __u) const
   noexcept(_S_noexcept<_Tp, _Up>())
   {
     if constexpr (__adl_swap<_Tp, _Up>)
       swap(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u));
     else
       {
  auto __tmp = static_cast<remove_reference_t<_Tp>&&>(__t);
  __t = static_cast<remove_reference_t<_Tp>&&>(__u);
  __u = static_cast<remove_reference_t<_Tp>&&>(__tmp);
       }
   }

 template<typename _Tp, typename _Up, size_t _Num>
   requires requires(const _Swap& __swap, _Tp& __e1, _Up& __e2) {
     __swap(__e1, __e2);
   }
   constexpr void
   operator()(_Tp (&__e1)[_Num], _Up (&__e2)[_Num]) const
   noexcept(noexcept(std::declval<const _Swap&>()(*__e1, *__e2)))
   {
     for (size_t __n = 0; __n < _Num; ++__n)
       (*this)(__e1[__n], __e2[__n]);
   }
      };
    }

    inline namespace __cust
    {
      inline constexpr __cust_swap::_Swap swap{};
    }
  }

  template<typename _Tp>
    concept swappable
      = requires(_Tp& __a, _Tp& __b) { ranges::swap(__a, __b); };

  template<typename _Tp, typename _Up>
    concept swappable_with = common_reference_with<_Tp, _Up>
      && requires(_Tp&& __t, _Up&& __u) {
 ranges::swap(static_cast<_Tp&&>(__t), static_cast<_Tp&&>(__t));
 ranges::swap(static_cast<_Up&&>(__u), static_cast<_Up&&>(__u));
 ranges::swap(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u));
 ranges::swap(static_cast<_Up&&>(__u), static_cast<_Tp&&>(__t));
      };



  template<typename _Tp>
    concept movable = is_object_v<_Tp> && move_constructible<_Tp>
      && assignable_from<_Tp&, _Tp> && swappable<_Tp>;

  template<typename _Tp>
    concept copyable = copy_constructible<_Tp> && movable<_Tp>
      && assignable_from<_Tp&, const _Tp&>;

  template<typename _Tp>
    concept semiregular = copyable<_Tp> && default_initializable<_Tp>;




  template<typename _Bp>
    concept boolean
      = movable<remove_cvref_t<_Bp>>
      && requires(__detail::__cref<_Bp> __b1, __detail::__cref<_Bp> __b2,
    const bool __a) {
 { __b1 } -> convertible_to<bool>;
 { !__b1 } -> convertible_to<bool>;
 { __b1 && __b2 } -> same_as<bool>;
 { __b1 && __a } -> same_as<bool>;
 { __a && __b2 } -> same_as<bool>;
 { __b1 || __b2 } -> same_as<bool>;
 { __b1 || __a } -> same_as<bool>;
 { __a || __b2 } -> same_as<bool>;
 { __b1 == __b2 } -> convertible_to<bool>;
 { __b1 == __a } -> convertible_to<bool>;
 { __a == __b2 } -> convertible_to<bool>;
 { __b1 != __b2 } -> convertible_to<bool>;
 { __b1 != __a } -> convertible_to<bool>;
 { __a != __b2 } -> convertible_to<bool>;
      };



  namespace __detail
  {
    template<typename _Tp, typename _Up>
      concept __weakly_eq_cmp_with
 = requires(__detail::__cref<_Tp> __t, __detail::__cref<_Up> __u) {
   { __t == __u } -> boolean;
   { __t != __u } -> boolean;
   { __u == __t } -> boolean;
   { __u != __t } -> boolean;
 };
  }

  template<typename _Tp>
    concept equality_comparable = __detail::__weakly_eq_cmp_with<_Tp, _Tp>;

  template<typename _Tp, typename _Up>
    concept equality_comparable_with
      = equality_comparable<_Tp> && equality_comparable<_Up>
      && common_reference_with<__detail::__cref<_Tp>, __detail::__cref<_Up>>
      && equality_comparable<common_reference_t<__detail::__cref<_Tp>,
      __detail::__cref<_Up>>>
      && __detail::__weakly_eq_cmp_with<_Tp, _Up>;


  template<typename _Tp>
    concept totally_ordered
      = equality_comparable<_Tp>
      && requires(__detail::__cref<_Tp> __a, __detail::__cref<_Tp> __b) {
 { __a < __b } -> boolean;
 { __a > __b } -> boolean;
 { __a <= __b } -> boolean;
 { __a >= __b } -> boolean;
      };

  template<typename _Tp, typename _Up>
    concept totally_ordered_with
      = totally_ordered<_Tp> && totally_ordered<_Up>
      && common_reference_with<__detail::__cref<_Tp>, __detail::__cref<_Up>>
      && totally_ordered<common_reference_t<__detail::__cref<_Tp>,
         __detail::__cref<_Up>>>
      && equality_comparable_with<_Tp, _Up>
      && requires(__detail::__cref<_Tp> __t, __detail::__cref<_Up> __u) {
 { __t < __u } -> boolean;
 { __t > __u } -> boolean;
 { __t <= __u } -> boolean;
 { __t >= __u } -> boolean;
 { __u < __t } -> boolean;
 { __u > __t } -> boolean;
 { __u <= __t } -> boolean;
 { __u >= __t } -> boolean;
      };

  template<typename _Tp>
    concept regular = semiregular<_Tp> && equality_comparable<_Tp>;




  template<typename _Fn, typename... _Args>
    concept invocable = is_invocable_v<_Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    concept regular_invocable = invocable<_Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    concept predicate = regular_invocable<_Fn, _Args...>
      && boolean<invoke_result_t<_Fn, _Args...>>;


  template<typename _Rel, typename _Tp, typename _Up>
    concept relation
      = predicate<_Rel, _Tp, _Tp> && predicate<_Rel, _Up, _Up>
      && predicate<_Rel, _Tp, _Up> && predicate<_Rel, _Up, _Tp>;


  template<typename _Rel, typename _Tp, typename _Up>
    concept equivalence_relation = relation<_Rel, _Tp, _Up>;


  template<typename _Rel, typename _Tp, typename _Up>
    concept strict_weak_order = relation<_Rel, _Tp, _Up>;


}
# 10 "fast_io/fast_io_core.h" 2
# 1 "/usr/local/include/c++/10.0.0/cstdint" 1 3
# 32 "/usr/local/include/c++/10.0.0/cstdint" 3
       
# 33 "/usr/local/include/c++/10.0.0/cstdint" 3
# 41 "/usr/local/include/c++/10.0.0/cstdint" 3
# 1 "/usr/local/lib/gcc/x86_64-pc-linux-gnu/10.0.0/include/stdint.h" 1 3 4
# 9 "/usr/local/lib/gcc/x86_64-pc-linux-gnu/10.0.0/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 130 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 131 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 28 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 35 "/usr/include/stdint.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4





typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;

typedef long int int_least64_t;






typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;

typedef unsigned long int uint_least64_t;
# 68 "/usr/include/stdint.h" 3 4
typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 81 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 97 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 111 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 10 "/usr/local/lib/gcc/x86_64-pc-linux-gnu/10.0.0/include/stdint.h" 2 3 4
# 42 "/usr/local/include/c++/10.0.0/cstdint" 2 3


namespace std
{

  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;

  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;

  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;

  using ::intmax_t;
  using ::intptr_t;

  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;

  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;

  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;

  using ::uintmax_t;
  using ::uintptr_t;





}
# 11 "fast_io/fast_io_core.h" 2
# 19 "fast_io/fast_io_core.h"
# 1 "/usr/local/include/c++/10.0.0/utility" 1 3
# 58 "/usr/local/include/c++/10.0.0/utility" 3
       
# 59 "/usr/local/include/c++/10.0.0/utility" 3
# 69 "/usr/local/include/c++/10.0.0/utility" 3
# 1 "/usr/local/include/c++/10.0.0/bits/stl_relops.h" 1 3
# 67 "/usr/local/include/c++/10.0.0/bits/stl_relops.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  namespace rel_ops
  {
# 85 "/usr/local/include/c++/10.0.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 98 "/usr/local/include/c++/10.0.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 111 "/usr/local/include/c++/10.0.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 124 "/usr/local/include/c++/10.0.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }
  }


}
# 70 "/usr/local/include/c++/10.0.0/utility" 2 3
# 1 "/usr/local/include/c++/10.0.0/bits/stl_pair.h" 1 3
# 59 "/usr/local/include/c++/10.0.0/bits/stl_pair.h" 3
# 1 "/usr/local/include/c++/10.0.0/bits/move.h" 1 3
# 38 "/usr/local/include/c++/10.0.0/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Tp>
    inline constexpr _Tp*
    __addressof(_Tp& __r) noexcept
    { return __builtin_addressof(__r); }




}



namespace std __attribute__ ((__visibility__ ("default")))
{

# 74 "/usr/local/include/c++/10.0.0/bits/move.h" 3
  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
      " substituting _Tp is an lvalue reference type");
      return static_cast<_Tp&&>(__t);
    }






  template<typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
# 118 "/usr/local/include/c++/10.0.0/bits/move.h" 3
  template<typename _Tp>
    constexpr typename
    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
# 138 "/usr/local/include/c++/10.0.0/bits/move.h" 3
  template<typename _Tp>
    inline constexpr _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }



  template<typename _Tp>
    const _Tp* addressof(const _Tp&&) = delete;


  template <typename _Tp, typename _Up = _Tp>
    constexpr
    inline _Tp
    __exchange(_Tp& __obj, _Up&& __new_val)
    {
      _Tp __old_val = std::move(__obj);
      __obj = std::forward<_Up>(__new_val);
      return __old_val;
    }
# 179 "/usr/local/include/c++/10.0.0/bits/move.h" 3
  template<typename _Tp>
    constexpr
    inline

    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type



    swap(_Tp& __a, _Tp& __b)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>::value)

    {




      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
    constexpr
    inline

    typename enable_if<__is_swappable<_Tp>::value>::type



    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value)
    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 60 "/usr/local/include/c++/10.0.0/bits/stl_pair.h" 2 3





# 1 "/usr/local/include/c++/10.0.0/compare" 1 3
# 33 "/usr/local/include/c++/10.0.0/compare" 3
       
# 34 "/usr/local/include/c++/10.0.0/compare" 3



#pragma GCC visibility push(default)



namespace std
{




  namespace __cmp_cat
  {
    enum class _Eq
    { equal = 0, equivalent = equal, nonequal = 1, nonequivalent = nonequal };

    enum class _Ord { _Less = -1, _Greater = 1 };

    enum class _Ncmp { _Unordered = -127 };

    struct __unspec
    {
      constexpr __unspec(__unspec*) { }
    };
  }

  class partial_ordering
  {
    int _M_value;
    bool _M_is_ordered;

    constexpr explicit
    partial_ordering(__cmp_cat::_Eq __v) noexcept
    : _M_value(int(__v)), _M_is_ordered(true)
    { }

    constexpr explicit
    partial_ordering(__cmp_cat::_Ord __v) noexcept
    : _M_value(int(__v)), _M_is_ordered(true)
    { }

    constexpr explicit
    partial_ordering(__cmp_cat::_Ncmp __v) noexcept
    : _M_value(int(__v)), _M_is_ordered(false)
    { }

  public:

    static const partial_ordering less;
    static const partial_ordering equivalent;
    static const partial_ordering greater;
    static const partial_ordering unordered;


    friend constexpr bool
    operator==(partial_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_is_ordered && __v._M_value == 0; }

    friend constexpr bool
    operator==(partial_ordering, partial_ordering) noexcept = default;

    friend constexpr bool
    operator< (partial_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_is_ordered && __v._M_value < 0; }

    friend constexpr bool
    operator> (partial_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_is_ordered && __v._M_value > 0; }

    friend constexpr bool
    operator<=(partial_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_is_ordered && __v._M_value <= 0; }

    friend constexpr bool
    operator>=(partial_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_is_ordered && __v._M_value >= 0; }

    friend constexpr bool
    operator< (__cmp_cat::__unspec, partial_ordering __v) noexcept
    { return __v._M_is_ordered && 0 < __v._M_value; }

    friend constexpr bool
    operator> (__cmp_cat::__unspec, partial_ordering __v) noexcept
    { return __v._M_is_ordered && 0 > __v._M_value; }

    friend constexpr bool
    operator<=(__cmp_cat::__unspec, partial_ordering __v) noexcept
    { return __v._M_is_ordered && 0 <= __v._M_value; }

    friend constexpr bool
    operator>=(__cmp_cat::__unspec, partial_ordering __v) noexcept
    { return __v._M_is_ordered && 0 >= __v._M_value; }

    friend constexpr partial_ordering
    operator<=>(partial_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v; }

    friend constexpr partial_ordering
    operator<=>(__cmp_cat::__unspec, partial_ordering __v) noexcept
    {
      if (__v < 0)
 return partial_ordering::greater;
      else if (__v > 0)
 return partial_ordering::less;
      else
 return __v;
    }
  };


  inline constexpr partial_ordering
  partial_ordering::less(__cmp_cat::_Ord::_Less);

  inline constexpr partial_ordering
  partial_ordering::equivalent(__cmp_cat::_Eq::equivalent);

  inline constexpr partial_ordering
  partial_ordering::greater(__cmp_cat::_Ord::_Greater);

  inline constexpr partial_ordering
  partial_ordering::unordered(__cmp_cat::_Ncmp::_Unordered);

  class weak_ordering
  {
    int _M_value;

    constexpr explicit
    weak_ordering(__cmp_cat::_Eq __v) noexcept : _M_value(int(__v))
    { }

    constexpr explicit
    weak_ordering(__cmp_cat::_Ord __v) noexcept : _M_value(int(__v))
    { }

  public:

    static const weak_ordering less;
    static const weak_ordering equivalent;
    static const weak_ordering greater;

    constexpr operator partial_ordering() const noexcept
    {
      if (_M_value == 0)
 return partial_ordering::equivalent;
      else if (_M_value < 0)
 return partial_ordering::less;
      else
 return partial_ordering::greater;
    }


    friend constexpr bool
    operator==(weak_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value == 0; }

    friend constexpr bool
    operator==(weak_ordering, weak_ordering) noexcept = default;

    friend constexpr bool
    operator< (weak_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value < 0; }

    friend constexpr bool
    operator> (weak_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value > 0; }

    friend constexpr bool
    operator<=(weak_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value <= 0; }

    friend constexpr bool
    operator>=(weak_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value >= 0; }

    friend constexpr bool
    operator< (__cmp_cat::__unspec, weak_ordering __v) noexcept
    { return 0 < __v._M_value; }

    friend constexpr bool
    operator> (__cmp_cat::__unspec, weak_ordering __v) noexcept
    { return 0 > __v._M_value; }

    friend constexpr bool
    operator<=(__cmp_cat::__unspec, weak_ordering __v) noexcept
    { return 0 <= __v._M_value; }

    friend constexpr bool
    operator>=(__cmp_cat::__unspec, weak_ordering __v) noexcept
    { return 0 >= __v._M_value; }

    friend constexpr weak_ordering
    operator<=>(weak_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v; }

    friend constexpr weak_ordering
    operator<=>(__cmp_cat::__unspec, weak_ordering __v) noexcept
    {
      if (__v < 0)
 return weak_ordering::greater;
      else if (__v > 0)
 return weak_ordering::less;
      else
 return __v;
    }
  };


  inline constexpr weak_ordering
  weak_ordering::less(__cmp_cat::_Ord::_Less);

  inline constexpr weak_ordering
  weak_ordering::equivalent(__cmp_cat::_Eq::equivalent);

  inline constexpr weak_ordering
  weak_ordering::greater(__cmp_cat::_Ord::_Greater);

  class strong_ordering
  {
    int _M_value;

    constexpr explicit
    strong_ordering(__cmp_cat::_Eq __v) noexcept
    : _M_value(int(__v))
    { }

    constexpr explicit
    strong_ordering(__cmp_cat::_Ord __v) noexcept
    : _M_value(int(__v))
    { }

  public:

    static const strong_ordering less;
    static const strong_ordering equal;
    static const strong_ordering equivalent;
    static const strong_ordering greater;

    constexpr operator partial_ordering() const noexcept
    {
      if (_M_value == 0)
 return partial_ordering::equivalent;
      else if (_M_value < 0)
 return partial_ordering::less;
      else
 return partial_ordering::greater;
    }

    constexpr operator weak_ordering() const noexcept
    {
      if (_M_value == 0)
 return weak_ordering::equivalent;
      else if (_M_value < 0)
 return weak_ordering::less;
      else
 return weak_ordering::greater;
    }


    friend constexpr bool
    operator==(strong_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value == 0; }

    friend constexpr bool
    operator==(strong_ordering, strong_ordering) noexcept = default;

    friend constexpr bool
    operator< (strong_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value < 0; }

    friend constexpr bool
    operator> (strong_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value > 0; }

    friend constexpr bool
    operator<=(strong_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value <= 0; }

    friend constexpr bool
    operator>=(strong_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value >= 0; }

    friend constexpr bool
    operator< (__cmp_cat::__unspec, strong_ordering __v) noexcept
    { return 0 < __v._M_value; }

    friend constexpr bool
    operator> (__cmp_cat::__unspec, strong_ordering __v) noexcept
    { return 0 > __v._M_value; }

    friend constexpr bool
    operator<=(__cmp_cat::__unspec, strong_ordering __v) noexcept
    { return 0 <= __v._M_value; }

    friend constexpr bool
    operator>=(__cmp_cat::__unspec, strong_ordering __v) noexcept
    { return 0 >= __v._M_value; }

    friend constexpr strong_ordering
    operator<=>(strong_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v; }

    friend constexpr strong_ordering
    operator<=>(__cmp_cat::__unspec, strong_ordering __v) noexcept
    {
      if (__v < 0)
 return strong_ordering::greater;
      else if (__v > 0)
 return strong_ordering::less;
      else
 return __v;
    }
  };


  inline constexpr strong_ordering
  strong_ordering::less(__cmp_cat::_Ord::_Less);

  inline constexpr strong_ordering
  strong_ordering::equal(__cmp_cat::_Eq::equal);

  inline constexpr strong_ordering
  strong_ordering::equivalent(__cmp_cat::_Eq::equivalent);

  inline constexpr strong_ordering
  strong_ordering::greater(__cmp_cat::_Ord::_Greater);



  constexpr bool
  is_eq(partial_ordering __cmp) noexcept
  { return __cmp == 0; }

  constexpr bool
  is_neq(partial_ordering __cmp) noexcept
  { return __cmp != 0; }

  constexpr bool
  is_lt (partial_ordering __cmp) noexcept
  { return __cmp < 0; }

  constexpr bool
  is_lteq(partial_ordering __cmp) noexcept
  { return __cmp <= 0; }

  constexpr bool
  is_gt (partial_ordering __cmp) noexcept
  { return __cmp > 0; }

  constexpr bool
  is_gteq(partial_ordering __cmp) noexcept
  { return __cmp >= 0; }

  namespace __detail
  {
    template<typename _Tp>
      inline constexpr unsigned __cmp_cat_id = 1;
    template<>
      inline constexpr unsigned __cmp_cat_id<partial_ordering> = 2;
    template<>
      inline constexpr unsigned __cmp_cat_id<weak_ordering> = 4;
    template<>
      inline constexpr unsigned __cmp_cat_id<strong_ordering> = 8;

    template<typename... _Ts>
      constexpr auto __common_cmp_cat()
      {
 constexpr unsigned __cats = (__cmp_cat_id<_Ts> | ...);

 if constexpr (__cats & 1)
   return;


 else if constexpr (bool(__cats & __cmp_cat_id<partial_ordering>))
   return partial_ordering::equivalent;


 else if constexpr (bool(__cats & __cmp_cat_id<weak_ordering>))
   return weak_ordering::equivalent;

 else
   return strong_ordering::equivalent;
      }
  }


  template<typename... _Ts>
    struct common_comparison_category
    {
      using type = decltype(__detail::__common_cmp_cat<_Ts...>());
    };



  template<typename _Tp>
    struct common_comparison_category<_Tp>
    { using type = void; };

  template<>
    struct common_comparison_category<partial_ordering>
    { using type = partial_ordering; };

  template<>
    struct common_comparison_category<weak_ordering>
    { using type = weak_ordering; };

  template<>
    struct common_comparison_category<strong_ordering>
    { using type = strong_ordering; };

  template<>
    struct common_comparison_category<>
    { using type = strong_ordering; };

  template<typename... _Ts>
    using common_comparison_category_t
      = typename common_comparison_category<_Ts...>::type;


  namespace __detail
  {
    template<typename _Tp, typename _Cat>
      concept __compares_as
 = same_as<common_comparison_category_t<_Tp, _Cat>, _Cat>;

    template<typename _Tp, typename _Up>
      concept __partially_ordered_with
 = requires(const remove_reference_t<_Tp>& __t,
     const remove_reference_t<_Up>& __u) {
   { __t < __u } -> boolean;
   { __t > __u } -> boolean;
   { __t <= __u } -> boolean;
   { __t >= __u } -> boolean;
   { __u < __t } -> boolean;
   { __u > __t } -> boolean;
   { __u <= __t } -> boolean;
   { __u >= __t } -> boolean;
 };
  }


  template<typename _Tp, typename _Cat = partial_ordering>
    concept three_way_comparable
      = __detail::__weakly_eq_cmp_with<_Tp, _Tp>
      && (!convertible_to<_Cat, partial_ordering>
   || __detail::__partially_ordered_with<_Tp, _Tp>)
      && requires(const remove_reference_t<_Tp>& __a,
    const remove_reference_t<_Tp>& __b) {
 { __a <=> __b } -> __detail::__compares_as<_Cat>;
      };

  template<typename _Tp, typename _Up, typename _Cat = partial_ordering>
    concept three_way_comparable_with
      = __detail::__weakly_eq_cmp_with<_Tp, _Up>
      && (!convertible_to<_Cat, partial_ordering>
   || __detail::__partially_ordered_with<_Tp, _Up>)
      && three_way_comparable<_Tp, _Cat>
      && three_way_comparable<_Up, _Cat>
      && common_reference_with<const remove_reference_t<_Tp>&,
          const remove_reference_t<_Up>&>
      && three_way_comparable<
   common_reference_t<const remove_reference_t<_Tp>&,
        const remove_reference_t<_Up>&>, _Cat>
      && requires(const remove_reference_t<_Tp>& __t,
    const remove_reference_t<_Up>& __u) {
 { __t <=> __u } -> __detail::__compares_as<_Cat>;
 { __u <=> __t } -> __detail::__compares_as<_Cat>;
      };

  namespace __detail
  {
    template<typename _Tp, typename _Up>
      using __cmp3way_res_t
 = decltype(std::declval<_Tp>() <=> std::declval<_Up>());






    template<typename _Tp, typename _Up>
      struct __cmp3way_res_impl
      { };

    template<typename _Tp, typename _Up>
      requires requires { typename __cmp3way_res_t<__cref<_Tp>, __cref<_Up>>; }
      struct __cmp3way_res_impl<_Tp, _Up>
      {
 using type = __cmp3way_res_t<__cref<_Tp>, __cref<_Up>>;
      };
  }


  template<typename _Tp, typename _Up = _Tp>
    struct compare_three_way_result
    : __detail::__cmp3way_res_impl<_Tp, _Up>
    { };


  template<typename _Tp, typename _Up = _Tp>
    using compare_three_way_result_t
      = typename __detail::__cmp3way_res_impl<_Tp, _Up>::type;

  namespace __detail
  {

    template<typename _Tp, typename _Up>
      concept __3way_builtin_ptr_cmp
 = convertible_to<_Tp, const volatile void*>
   && convertible_to<_Up, const volatile void*>
   && ! requires(_Tp&& __t, _Up&& __u)
      { operator<=>(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u)); }
   && ! requires(_Tp&& __t, _Up&& __u)
      { static_cast<_Tp&&>(__t).operator<=>(static_cast<_Up&&>(__u)); };


    template<typename _Tp, typename _Up>
      concept __3way_cmp_with = three_way_comparable_with<_Tp, _Up>;
  }


  struct compare_three_way
  {
    template<typename _Tp, typename _Up>
      requires (__detail::__3way_cmp_with<_Tp, _Up>
   || __detail::__3way_builtin_ptr_cmp<_Tp, _Up>)
      constexpr auto
      operator()(_Tp&& __t, _Up&& __u) const noexcept
      {
 if constexpr (__detail::__3way_builtin_ptr_cmp<_Tp, _Up>)
   {
     auto __pt = static_cast<const volatile void*>(__t);
     auto __pu = static_cast<const volatile void*>(__u);
     if (__builtin_is_constant_evaluated())
       return __pt <=> __pu;
     auto __it = reinterpret_cast<long unsigned int>(__pt);
     auto __iu = reinterpret_cast<long unsigned int>(__pu);
     return __it <=> __iu;
   }
 else
   return static_cast<_Tp&&>(__t) <=> static_cast<_Up&&>(__u);
      }

    using is_transparent = void;
  };

  namespace __cmp_cust
  {
    template<floating_point _Tp>
      constexpr weak_ordering
      __fp_weak_ordering(_Tp __e, _Tp __f)
      {


 auto __cat = [](_Tp __fp) -> int {
   const int __sign = __builtin_signbit(__fp) ? -1 : 1;
   if (__builtin_isnormal(__fp))
     return (__fp == 0 ? 1 : 3) * __sign;
   if (__builtin_isnan(__fp))
     return 5 * __sign;
   if (int __inf = __builtin_isinf_sign(__fp))
     return 4 * __inf;
   return 2 * __sign;
 };

 auto __po = __e <=> __f;
 if (is_lt(__po))
   return weak_ordering::less;
 else if (is_gt(__po))
   return weak_ordering::greater;
 else if (__po == partial_ordering::equivalent)
   return weak_ordering::equivalent;
 else
   {

     auto __isnan_sign = [](_Tp __fp) -> int {
       return __builtin_isnan(__fp)
  ? __builtin_signbit(__fp) ? -1 : 1
  : 0;
     };
     auto __ord = __isnan_sign(__e) <=> __isnan_sign(__f);
     if (is_eq(__ord))
       return weak_ordering::equivalent;
     else if (is_lt(__ord))
       return weak_ordering::less;
     else
       return weak_ordering::greater;
   }
      }

    template<typename _Tp, typename _Up>
      concept __adl_strong = requires(_Tp&& __t, _Up&& __u)
 {
   strong_ordering(strong_order(static_cast<_Tp&&>(__t),
           static_cast<_Up&&>(__u)));
 };

    template<typename _Tp, typename _Up>
      concept __adl_weak = requires(_Tp&& __t, _Up&& __u)
 {
   weak_ordering(weak_order(static_cast<_Tp&&>(__t),
       static_cast<_Up&&>(__u)));
 };

    template<typename _Tp, typename _Up>
      concept __adl_partial = requires(_Tp&& __t, _Up&& __u)
 {
   partial_ordering(partial_order(static_cast<_Tp&&>(__t),
      static_cast<_Up&&>(__u)));
 };

    template<typename _Ord, typename _Tp, typename _Up>
      concept __op_cmp = requires(_Tp&& __t, _Up&& __u)
 {
   _Ord(static_cast<_Tp&&>(__t) <=> static_cast<_Up&&>(__u));
 };

    template<typename _Tp, typename _Up>
      concept __strongly_ordered
 = __adl_strong<_Tp, _Up>

   || __op_cmp<strong_ordering, _Tp, _Up>;

    class _Strong_order
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (floating_point<decay_t<_Tp>>)
     return true;
   else if constexpr (__adl_strong<_Tp, _Up>)
     return noexcept(strong_ordering(strong_order(std::declval<_Tp>(),
        std::declval<_Up>())));
   else if constexpr (__op_cmp<strong_ordering, _Tp, _Up>)
     return noexcept(std::declval<_Tp>() <=> std::declval<_Up>());
 }

      friend class _Weak_order;
      friend class _Strong_fallback;

    public:
      template<typename _Tp, typename _Up>
 requires __strongly_ordered<_Tp, _Up>
 constexpr strong_ordering
 operator()(_Tp&& __e, _Up&& __f) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   static_assert(same_as<decay_t<_Tp>, decay_t<_Up>>);




           if constexpr (__adl_strong<_Tp, _Up>)
     return strong_ordering(strong_order(static_cast<_Tp&&>(__e),
      static_cast<_Up&&>(__f)));
   else if constexpr (__op_cmp<strong_ordering, _Tp, _Up>)
     return static_cast<_Tp&&>(__e) <=> static_cast<_Up&&>(__f);
 }
    };

    template<typename _Tp, typename _Up>
      concept __weakly_ordered
 = floating_point<remove_reference_t<_Tp>>
   || __adl_weak<_Tp, _Up>
   || __op_cmp<weak_ordering, _Tp, _Up>
   || __strongly_ordered<_Tp, _Up>;

    class _Weak_order
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (floating_point<decay_t<_Tp>>)
     return true;
   else if constexpr (__adl_weak<_Tp, _Up>)
     return noexcept(weak_ordering(weak_order(std::declval<_Tp>(),
           std::declval<_Up>())));
   else if constexpr (__op_cmp<weak_ordering, _Tp, _Up>)
     return noexcept(std::declval<_Tp>() <=> std::declval<_Up>());
   else if constexpr (__strongly_ordered<_Tp, _Up>)
     return _Strong_order::_S_noexcept<_Tp, _Up>();
 }

      friend class _Partial_order;
      friend class _Weak_fallback;

    public:
      template<typename _Tp, typename _Up>
 requires __weakly_ordered<_Tp, _Up>
 constexpr weak_ordering
 operator()(_Tp&& __e, _Up&& __f) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   static_assert(same_as<decay_t<_Tp>, decay_t<_Up>>);

   if constexpr (floating_point<decay_t<_Tp>>)
     return __cmp_cust::__fp_weak_ordering(__e, __f);
   else if constexpr (__adl_weak<_Tp, _Up>)
     return weak_ordering(weak_order(static_cast<_Tp&&>(__e),
         static_cast<_Up&&>(__f)));
   else if constexpr (__op_cmp<weak_ordering, _Tp, _Up>)
     return static_cast<_Tp&&>(__e) <=> static_cast<_Up&&>(__f);
   else if constexpr (__strongly_ordered<_Tp, _Up>)
     return _Strong_order{}(static_cast<_Tp&&>(__e),
       static_cast<_Up&&>(__f));
 }
    };

    template<typename _Tp, typename _Up>
      concept __partially_ordered
 = __adl_partial<_Tp, _Up>
 || __op_cmp<partial_ordering, _Tp, _Up>
 || __weakly_ordered<_Tp, _Up>;

    class _Partial_order
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__adl_partial<_Tp, _Up>)
     return noexcept(partial_ordering(partial_order(std::declval<_Tp>(),
        std::declval<_Up>())));
   else if constexpr (__op_cmp<partial_ordering, _Tp, _Up>)
     return noexcept(std::declval<_Tp>() <=> std::declval<_Up>());
   else if constexpr (__weakly_ordered<_Tp, _Up>)
     return _Weak_order::_S_noexcept<_Tp, _Up>();
 }

      friend class _Partial_fallback;

    public:
      template<typename _Tp, typename _Up>
 requires __partially_ordered<_Tp, _Up>
 constexpr partial_ordering
 operator()(_Tp&& __e, _Up&& __f) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   static_assert(same_as<decay_t<_Tp>, decay_t<_Up>>);

   if constexpr (__adl_partial<_Tp, _Up>)
     return partial_ordering(partial_order(static_cast<_Tp&&>(__e),
        static_cast<_Up&&>(__f)));
   else if constexpr (__op_cmp<partial_ordering, _Tp, _Up>)
     return static_cast<_Tp&&>(__e) <=> static_cast<_Up&&>(__f);
   else if constexpr (__weakly_ordered<_Tp, _Up>)
     return _Weak_order{}(static_cast<_Tp&&>(__e),
     static_cast<_Up&&>(__f));
 }
    };

    template<typename _Tp, typename _Up>
      concept __op_eq_lt = requires(_Tp&& __t, _Up&& __u)
 {
   { static_cast<_Tp&&>(__t) == static_cast<_Up&&>(__u) }
     -> convertible_to<bool>;
   { static_cast<_Tp&&>(__t) < static_cast<_Up&&>(__u) }
     -> convertible_to<bool>;
 };

    class _Strong_fallback
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__strongly_ordered<_Tp, _Up>)
     return _Strong_order::_S_noexcept<_Tp, _Up>();
   else
     return noexcept(bool(std::declval<_Tp>() == std::declval<_Up>()))
       && noexcept(bool(std::declval<_Tp>() < std::declval<_Up>()));
 }

    public:
      template<typename _Tp, typename _Up>
 requires __strongly_ordered<_Tp, _Up> || __op_eq_lt<_Tp, _Up>
 constexpr decltype(auto)
 operator()(_Tp&& __e, _Up&& __f) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   static_assert(same_as<decay_t<_Tp>, decay_t<_Up>>);

   if constexpr (__strongly_ordered<_Tp, _Up>)
     return _Strong_order{}(static_cast<_Tp&&>(__e),
       static_cast<_Up&&>(__f));
   else if constexpr (__op_eq_lt<_Tp, _Up>)
     return static_cast<_Tp&&>(__e) == static_cast<_Up&&>(__f)
       ? strong_ordering::equal
       : static_cast<_Tp&&>(__e) < static_cast<_Up&&>(__f)
       ? strong_ordering::less
       : strong_ordering::greater;
 }
    };

    class _Weak_fallback
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__weakly_ordered<_Tp, _Up>)
     return _Weak_order::_S_noexcept<_Tp, _Up>();
   else
     return noexcept(bool(std::declval<_Tp>() == std::declval<_Up>()))
       && noexcept(bool(std::declval<_Tp>() < std::declval<_Up>()));
 }

    public:
      template<typename _Tp, typename _Up>
 requires __weakly_ordered<_Tp, _Up> || __op_eq_lt<_Tp, _Up>
 constexpr decltype(auto)
 operator()(_Tp&& __e, _Up&& __f) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   static_assert(same_as<decay_t<_Tp>, decay_t<_Up>>);

   if constexpr (__weakly_ordered<_Tp, _Up>)
     return _Weak_order{}(static_cast<_Tp&&>(__e),
     static_cast<_Up&&>(__f));
   else if constexpr (__op_eq_lt<_Tp, _Up>)
     return static_cast<_Tp&&>(__e) == static_cast<_Up&&>(__f)
       ? weak_ordering::equivalent
       : static_cast<_Tp&&>(__e) < static_cast<_Up&&>(__f)
       ? weak_ordering::less
       : weak_ordering::greater;
 }
    };

    class _Partial_fallback
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__partially_ordered<_Tp, _Up>)
     return _Partial_order::_S_noexcept<_Tp, _Up>();
   else
     return noexcept(bool(std::declval<_Tp>() == std::declval<_Up>()))
       && noexcept(bool(std::declval<_Tp>() < std::declval<_Up>()));
 }

    public:
      template<typename _Tp, typename _Up>
 requires __partially_ordered<_Tp, _Up> || __op_eq_lt<_Tp, _Up>
 constexpr decltype(auto)
 operator()(_Tp&& __e, _Up&& __f) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   static_assert(same_as<decay_t<_Tp>, decay_t<_Up>>);

   if constexpr (__partially_ordered<_Tp, _Up>)
     return _Partial_order{}(static_cast<_Tp&&>(__e),
        static_cast<_Up&&>(__f));
   else if constexpr (__op_eq_lt<_Tp, _Up>)
     return static_cast<_Tp&&>(__e) == static_cast<_Up&&>(__f)
       ? partial_ordering::equivalent
       : static_cast<_Tp&&>(__e) < static_cast<_Up&&>(__f)
       ? partial_ordering::less
       : static_cast<_Up&&>(__f) < static_cast<_Tp&&>(__e)
       ? partial_ordering::greater
       : partial_ordering::unordered;
 }
    };
  }


  inline namespace __cmp_alg
  {
    inline constexpr __cmp_cust::_Strong_order strong_order{};

    inline constexpr __cmp_cust::_Weak_order weak_order{};

    inline constexpr __cmp_cust::_Partial_order partial_order{};

    inline constexpr __cmp_cust::_Strong_fallback
    compare_strong_order_fallback{};

    inline constexpr __cmp_cust::_Weak_fallback
    compare_weak_order_fallback{};

    inline constexpr __cmp_cust::_Partial_fallback
    compare_partial_order_fallback{};
  }

  namespace __detail
  {

    inline constexpr struct _Synth3way
    {
      template<typename _Tp, typename _Up>
 constexpr auto
 operator()(const _Tp& __t, const _Up& __u) const
 requires requires
 {
   { __t < __u } -> convertible_to<bool>;
   { __u < __t } -> convertible_to<bool>;
 }
 {
   if constexpr (__3way_cmp_with<_Tp, _Up>)
     return __t <=> __u;
   else
     {
       if (__t < __u)
  return weak_ordering::less;
       else if (__u < __t)
  return weak_ordering::greater;
       else
  return weak_ordering::equivalent;
     }
 }
    } __synth3way = {};

    template<typename _Tp, typename _Up = _Tp>
      using __synth3way_t
 = decltype(__detail::__synth3way(std::declval<_Tp&>(),
      std::declval<_Up&>()));
  }

}

#pragma GCC visibility pop
# 66 "/usr/local/include/c++/10.0.0/bits/stl_pair.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

# 79 "/usr/local/include/c++/10.0.0/bits/stl_pair.h" 3
  struct piecewise_construct_t { explicit piecewise_construct_t() = default; };


  inline constexpr piecewise_construct_t piecewise_construct =
    piecewise_construct_t();




  template<typename...>
    class tuple;

  template<std::size_t...>
    struct _Index_tuple;






  template <bool, typename _T1, typename _T2>
    struct _PCC
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, const _U2&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return __and_<is_convertible<const _U1&, _T1>,
        is_convertible<const _U2&, _T2>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, _U2&&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return __and_<is_convertible<_U1&&, _T1>,
        is_convertible<_U2&&, _T2>>::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _CopyMovePair()
      {
 using __do_converts = __and_<is_convertible<const _U1&, _T1>,
      is_convertible<_U2&&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, _U2&&>,
        __converts
        >::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _MoveCopyPair()
      {
 using __do_converts = __and_<is_convertible<_U1&&, _T1>,
      is_convertible<const _U2&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, const _U2&&>,
        __converts
        >::value;
      }
  };

  template <typename _T1, typename _T2>
    struct _PCC<false, _T1, _T2>
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return false;
      }
  };


  template<typename _U1, typename _U2> class __pair_base
  {

    template<typename _T1, typename _T2> friend struct pair;
    __pair_base() = default;
    ~__pair_base() = default;
    __pair_base(const __pair_base&) = default;
    __pair_base& operator=(const __pair_base&) = delete;

  };
# 209 "/usr/local/include/c++/10.0.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    struct pair
    : private __pair_base<_T1, _T2>
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;






      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>

      constexpr pair()
      : first(), second() { }


      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                       is_default_constructible<_U1>,
                       is_default_constructible<_U2>,
                       __not_<
                         __and_<__is_implicitly_default_constructible<_U1>,
                                __is_implicitly_default_constructible<_U2>>>>
                                   ::value, bool>::type = false>
      explicit constexpr pair()
      : first(), second() { }
# 255 "/usr/local/include/c++/10.0.0/bits/stl_pair.h" 3
      using _PCCP = _PCC<true, _T1, _T2>;



      template<typename _U1 = _T1, typename _U2=_T2, typename
        enable_if<_PCCP::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCP::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
      constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }


       template<typename _U1 = _T1, typename _U2=_T2, typename
  enable_if<_PCCP::template
       _ConstructiblePair<_U1, _U2>()
                   && !_PCCP::template
       _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
      explicit constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }
# 287 "/usr/local/include/c++/10.0.0/bits/stl_pair.h" 3
      template <typename _U1, typename _U2>
        using _PCCFP = _PCC<!is_same<_T1, _U1>::value
       || !is_same<_T2, _U2>::value,
       _T1, _T2>;


      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
     bool>::type=true>
        constexpr pair(const pair<_U1, _U2>& __p)
        : first(__p.first), second(__p.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
    && !_PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }



      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;


      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<true, _U1, _T2>(),
                         bool>::type=true>
       constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<false, _U1, _T2>(),
                         bool>::type=false>
       explicit constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<true, _T1, _U2>(),
                         bool>::type=true>
       constexpr pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<false, _T1, _U2>(),
                         bool>::type=false>
       explicit pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }


      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename... _Args1, typename... _Args2>
 constexpr
        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

      constexpr pair&
      operator=(typename conditional<
  __and_<is_copy_assignable<_T1>,
         is_copy_assignable<_T2>>::value,
  const pair&, const __nonesuch&>::type __p)
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }

      constexpr pair&
      operator=(typename conditional<
  __and_<is_move_assignable<_T1>,
         is_move_assignable<_T2>>::value,
  pair&&, __nonesuch&&>::type __p)
      noexcept(__and_<is_nothrow_move_assignable<_T1>,
        is_nothrow_move_assignable<_T2>>::value)
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }

      template<typename _U1, typename _U2>
 constexpr
 typename enable_if<__and_<is_assignable<_T1&, const _U1&>,
      is_assignable<_T2&, const _U2&>>::value,
      pair&>::type
 operator=(const pair<_U1, _U2>& __p)
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }

      template<typename _U1, typename _U2>
 constexpr
 typename enable_if<__and_<is_assignable<_T1&, _U1&&>,
      is_assignable<_T2&, _U2&&>>::value,
      pair&>::type
 operator=(pair<_U1, _U2>&& __p)
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }


      constexpr void
      swap(pair& __p)
      noexcept(__and_<__is_nothrow_swappable<_T1>,
                      __is_nothrow_swappable<_T2>>::value)
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }

    private:
      template<typename... _Args1, std::size_t... _Indexes1,
               typename... _Args2, std::size_t... _Indexes2>
 constexpr
        pair(tuple<_Args1...>&, tuple<_Args2...>&,
             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);

    };




  template<typename _T1, typename _T2> pair(_T1, _T2) -> pair<_T1, _T2>;



  template<typename _T1, typename _T2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<typename _T1, typename _T2>
    constexpr common_comparison_category_t<__detail::__synth3way_t<_T1>,
        __detail::__synth3way_t<_T2>>
    operator<=>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    {
      if (auto __c = __detail::__synth3way(__x.first, __y.first); __c != 0)
 return __c;
      return __detail::__synth3way(__x.second, __y.second);
    }
# 523 "/usr/local/include/c++/10.0.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    constexpr inline


    typename enable_if<__and_<__is_swappable<_T1>,
                              __is_swappable<_T2>>::value>::type



    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


  template<typename _T1, typename _T2>
    typename enable_if<!__and_<__is_swappable<_T1>,
          __is_swappable<_T2>>::value>::type
    swap(pair<_T1, _T2>&, pair<_T1, _T2>&) = delete;
# 563 "/usr/local/include/c++/10.0.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
# 582 "/usr/local/include/c++/10.0.0/bits/stl_pair.h" 3

}
# 71 "/usr/local/include/c++/10.0.0/utility" 2 3





# 1 "/usr/local/include/c++/10.0.0/initializer_list" 1 3
# 33 "/usr/local/include/c++/10.0.0/initializer_list" 3
       
# 34 "/usr/local/include/c++/10.0.0/initializer_list" 3





#pragma GCC visibility push(default)



namespace std
{

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;

    private:
      iterator _M_array;
      size_type _M_len;


      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }


      constexpr size_type
      size() const noexcept { return _M_len; }


      constexpr const_iterator
      begin() const noexcept { return _M_array; }


      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
    };







  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils) noexcept
    { return __ils.begin(); }







  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils) noexcept
    { return __ils.end(); }
}

#pragma GCC visibility pop
# 77 "/usr/local/include/c++/10.0.0/utility" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp>
    struct tuple_size;





  template<typename _Tp,
    typename _Up = typename remove_cv<_Tp>::type,
    typename = typename enable_if<is_same<_Tp, _Up>::value>::type,
    size_t = tuple_size<_Tp>::value>
    using __enable_if_has_tuple_size = _Tp;

  template<typename _Tp>
    struct tuple_size<const __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<const volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };


  template<std::size_t __i, typename _Tp>
    struct tuple_element;


  template<std::size_t __i, typename _Tp>
    using __tuple_element_t = typename tuple_element<__i, _Tp>::type;

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const _Tp>
    {
      typedef typename add_const<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, volatile _Tp>
    {
      typedef typename add_volatile<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const volatile _Tp>
    {
      typedef typename add_cv<__tuple_element_t<__i, _Tp>>::type type;
    };







  template<std::size_t __i, typename _Tp>
    using tuple_element_t = typename tuple_element<__i, _Tp>::type;





  template<typename _T1, typename _T2>
    struct __is_tuple_like_impl<std::pair<_T1, _T2>> : true_type
    { };


  template<class _Tp1, class _Tp2>
    struct tuple_size<std::pair<_Tp1, _Tp2>>
    : public integral_constant<std::size_t, 2> { };


  template<class _Tp1, class _Tp2>
    struct tuple_element<0, std::pair<_Tp1, _Tp2>>
    { typedef _Tp1 type; };


  template<class _Tp1, class _Tp2>
    struct tuple_element<1, std::pair<_Tp1, _Tp2>>
    { typedef _Tp2 type; };

  template<std::size_t _Int>
    struct __pair_get;

  template<>
    struct __pair_get<0>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp1>(__pair.first); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&&
        __const_move_get(const std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<const _Tp1>(__pair.first); }
    };

  template<>
    struct __pair_get<1>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp2>(__pair.second); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&&
        __const_move_get(const std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<const _Tp2>(__pair.second); }
    };

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__move_get(std::move(__in)); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(const std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__const_get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(const std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__const_move_get(std::move(__in)); }





  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&&
    get(const pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&&
    get(const pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }
# 288 "/usr/local/include/c++/10.0.0/utility" 3
  template <typename _Tp, typename _Up = _Tp>
    constexpr
    inline _Tp
    exchange(_Tp& __obj, _Up&& __new_val)
    { return std::__exchange(__obj, std::forward<_Up>(__new_val)); }





  template<size_t... _Indexes> struct _Index_tuple { };
# 307 "/usr/local/include/c++/10.0.0/utility" 3
  template<size_t _Num>
    struct _Build_index_tuple
    {






      using __type = _Index_tuple<__integer_pack(_Num)...>;

    };






  template<typename _Tp, _Tp... _Idx>
    struct integer_sequence
    {
      typedef _Tp value_type;
      static constexpr size_t size() noexcept { return sizeof...(_Idx); }
    };


  template<typename _Tp, _Tp _Num>
    using make_integer_sequence



      = integer_sequence<_Tp, __integer_pack(_Num)...>;





  template<size_t... _Idx>
    using index_sequence = integer_sequence<size_t, _Idx...>;


  template<size_t _Num>
    using make_index_sequence = make_integer_sequence<size_t, _Num>;


  template<typename... _Types>
    using index_sequence_for = make_index_sequence<sizeof...(_Types)>;




  struct in_place_t {
    explicit in_place_t() = default;
  };

  inline constexpr in_place_t in_place{};

  template<typename _Tp> struct in_place_type_t
  {
    explicit in_place_type_t() = default;
  };

  template<typename _Tp>
    inline constexpr in_place_type_t<_Tp> in_place_type{};

  template<size_t _Idx> struct in_place_index_t
  {
    explicit in_place_index_t() = default;
  };

  template<size_t _Idx>
    inline constexpr in_place_index_t<_Idx> in_place_index{};

  template<typename>
    struct __is_in_place_type_impl : false_type
    { };

  template<typename _Tp>
    struct __is_in_place_type_impl<in_place_type_t<_Tp>> : true_type
    { };

  template<typename _Tp>
    struct __is_in_place_type
      : public __is_in_place_type_impl<_Tp>
    { };


  template<typename _Tp>
    constexpr add_const_t<_Tp>& as_const(_Tp& __t) noexcept { return __t; }

  template<typename _Tp>
    void as_const(const _Tp&&) = delete;




}
# 20 "fast_io/fast_io_core.h" 2
# 1 "/usr/local/include/c++/10.0.0/memory" 1 3
# 47 "/usr/local/include/c++/10.0.0/memory" 3
       
# 48 "/usr/local/include/c++/10.0.0/memory" 3
# 63 "/usr/local/include/c++/10.0.0/memory" 3
# 1 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 1 3
# 60 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 3
# 1 "/usr/local/include/c++/10.0.0/bits/functexcept.h" 1 3
# 40 "/usr/local/include/c++/10.0.0/bits/functexcept.h" 3
# 1 "/usr/local/include/c++/10.0.0/bits/exception_defines.h" 1 3
# 41 "/usr/local/include/c++/10.0.0/bits/functexcept.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range_fmt(const char*, ...) __attribute__((__noreturn__))
    __attribute__((__format__(__gnu_printf__, 1, 2)));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_ios_failure(const char*, int) __attribute__((__noreturn__));


  void
  __throw_system_error(int) __attribute__((__noreturn__));


  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));


}
# 61 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 2 3
# 1 "/usr/local/include/c++/10.0.0/bits/cpp_type_traits.h" 1 3
# 35 "/usr/local/include/c++/10.0.0/bits/cpp_type_traits.h" 3
       
# 36 "/usr/local/include/c++/10.0.0/bits/cpp_type_traits.h" 3
# 67 "/usr/local/include/c++/10.0.0/bits/cpp_type_traits.h" 3
extern "C++" {

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };





  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_integer<char8_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 287 "/usr/local/include/c++/10.0.0/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  enum class byte : unsigned char;

  template<>
    struct __is_byte<byte>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_byte<char8_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };





  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };



  template<typename _Iterator>
    constexpr
    inline _Iterator
    __miter_base(_Iterator __it)
    { return __it; }


}
}
# 62 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 2 3
# 1 "/usr/local/include/c++/10.0.0/ext/type_traits.h" 1 3
# 32 "/usr/local/include/c++/10.0.0/ext/type_traits.h" 3
       
# 33 "/usr/local/include/c++/10.0.0/ext/type_traits.h" 3




extern "C++" {

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }


  inline bool
  __is_null_pointer(std::nullptr_t)
  { return true; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
}
# 63 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 2 3
# 1 "/usr/local/include/c++/10.0.0/ext/numeric_traits.h" 1 3
# 32 "/usr/local/include/c++/10.0.0/ext/numeric_traits.h" 3
       
# 33 "/usr/local/include/c++/10.0.0/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 54 "/usr/local/include/c++/10.0.0/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? -(((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0) - 1 : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 99 "/usr/local/include/c++/10.0.0/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };


}
# 64 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 2 3

# 1 "/usr/local/include/c++/10.0.0/bits/stl_iterator_base_types.h" 1 3
# 62 "/usr/local/include/c++/10.0.0/bits/stl_iterator_base_types.h" 3
       
# 63 "/usr/local/include/c++/10.0.0/bits/stl_iterator_base_types.h" 3
# 71 "/usr/local/include/c++/10.0.0/bits/stl_iterator_base_types.h" 3
# 1 "/usr/local/include/c++/10.0.0/bits/iterator_concepts.h" 1 3
# 33 "/usr/local/include/c++/10.0.0/bits/iterator_concepts.h" 3
       
# 34 "/usr/local/include/c++/10.0.0/bits/iterator_concepts.h" 3


# 1 "/usr/local/include/c++/10.0.0/bits/ptr_traits.h" 1 3
# 37 "/usr/local/include/c++/10.0.0/bits/ptr_traits.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  class __undefined;


  template<typename _Tp>
    struct __get_first_arg
    { using type = __undefined; };

  template<template<typename, typename...> class _Template, typename _Tp,
           typename... _Types>
    struct __get_first_arg<_Template<_Tp, _Types...>>
    { using type = _Tp; };

  template<typename _Tp>
    using __get_first_arg_t = typename __get_first_arg<_Tp>::type;


  template<typename _Tp, typename _Up>
    struct __replace_first_arg
    { };

  template<template<typename, typename...> class _Template, typename _Up,
           typename _Tp, typename... _Types>
    struct __replace_first_arg<_Template<_Tp, _Types...>, _Up>
    { using type = _Template<_Up, _Types...>; };

  template<typename _Tp, typename _Up>
    using __replace_first_arg_t = typename __replace_first_arg<_Tp, _Up>::type;

  template<typename _Tp>
    using __make_not_void
      = typename conditional<is_void<_Tp>::value, __undefined, _Tp>::type;





  template<typename _Ptr>
    struct pointer_traits
    {
    private:
      template<typename _Tp>
 using __element_type = typename _Tp::element_type;

      template<typename _Tp>
 using __difference_type = typename _Tp::difference_type;

      template<typename _Tp, typename _Up, typename = void>
 struct __rebind : __replace_first_arg<_Tp, _Up> { };

      template<typename _Tp, typename _Up>
 struct __rebind<_Tp, _Up, __void_t<typename _Tp::template rebind<_Up>>>
 { using type = typename _Tp::template rebind<_Up>; };

    public:

      using pointer = _Ptr;


      using element_type
 = __detected_or_t<__get_first_arg_t<_Ptr>, __element_type, _Ptr>;


      using difference_type
 = __detected_or_t<ptrdiff_t, __difference_type, _Ptr>;


      template<typename _Up>
        using rebind = typename __rebind<_Ptr, _Up>::type;

      static _Ptr
      pointer_to(__make_not_void<element_type>& __e)
      { return _Ptr::pointer_to(__e); }

      static_assert(!is_same<element_type, __undefined>::value,
   "pointer type defines element_type or is like SomePointer<T, Args>");
    };





  template<typename _Tp>
    struct pointer_traits<_Tp*>
    {

      typedef _Tp* pointer;

      typedef _Tp element_type;

      typedef ptrdiff_t difference_type;

      template<typename _Up>
        using rebind = _Up*;






      static constexpr pointer
      pointer_to(__make_not_void<element_type>& __r) noexcept
      { return std::addressof(__r); }
    };


  template<typename _Ptr, typename _Tp>
    using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;

  template<typename _Tp>
    constexpr _Tp*
    __to_address(_Tp* __ptr) noexcept
    {
      static_assert(!std::is_function<_Tp>::value, "not a function pointer");
      return __ptr;
    }







  template<typename _Ptr>
    constexpr auto
    __to_address(const _Ptr& __ptr) noexcept
    -> decltype(std::pointer_traits<_Ptr>::to_address(__ptr))
    { return std::pointer_traits<_Ptr>::to_address(__ptr); }

  template<typename _Ptr, typename... _None>
    constexpr auto
    __to_address(const _Ptr& __ptr, _None...) noexcept
    { return std::__to_address(__ptr.operator->()); }







  template<typename _Tp>
    constexpr _Tp*
    to_address(_Tp* __ptr) noexcept
    { return std::__to_address(__ptr); }
# 192 "/usr/local/include/c++/10.0.0/bits/ptr_traits.h" 3
  template<typename _Ptr>
    constexpr auto
    to_address(const _Ptr& __ptr) noexcept
    { return std::__to_address(__ptr); }



}
# 37 "/usr/local/include/c++/10.0.0/bits/iterator_concepts.h" 2 3
# 1 "/usr/local/include/c++/10.0.0/bits/range_cmp.h" 1 3
# 37 "/usr/local/include/c++/10.0.0/bits/range_cmp.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __is_transparent;





  struct identity
  {
    template<typename _Tp>
      constexpr _Tp&&
      operator()(_Tp&& __t) const noexcept
      { return std::forward<_Tp>(__t); }

    using is_transparent = __is_transparent;
  };


namespace ranges
{
  namespace __detail
  {

    template<typename _Tp, typename _Up>
      concept __eq_builtin_ptr_cmp
 = convertible_to<_Tp, const volatile void*>
   && convertible_to<_Up, const volatile void*>
   && (! requires(_Tp&& __t, _Up&& __u)
       { operator==(std::forward<_Tp>(__t), std::forward<_Up>(__u)); }
       &&
       ! requires(_Tp&& __t, _Up&& __u)
       { std::forward<_Tp>(__t).operator==(std::forward<_Up>(__u)); });


    template<typename _Tp, typename _Up>
      concept __less_builtin_ptr_cmp
 = convertible_to<_Tp, const volatile void*>
   && convertible_to<_Up, const volatile void*>
   && (! requires(_Tp&& __t, _Up&& __u)
       { operator<(std::forward<_Tp>(__t), std::forward<_Up>(__u)); }
       && ! requires(_Tp&& __t, _Up&& __u)
       { std::forward<_Tp>(__t).operator<(std::forward<_Up>(__u)); });
  }




  struct equal_to
  {
    template<typename _Tp, typename _Up>
      requires equality_comparable_with<_Tp, _Up>
 || __detail::__eq_builtin_ptr_cmp<_Tp, _Up>
      constexpr bool
      operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Tp>() == std::declval<_Up>()))
      { return std::forward<_Tp>(__t) == std::forward<_Up>(__u); }

    using is_transparent = __is_transparent;
  };


  struct not_equal_to
  {
    template<typename _Tp, typename _Up>
      requires equality_comparable_with<_Tp, _Up>
 || __detail::__eq_builtin_ptr_cmp<_Tp, _Up>
      constexpr bool
      operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Up>() == std::declval<_Tp>()))
      { return !equal_to{}(std::forward<_Tp>(__t), std::forward<_Up>(__u)); }

    using is_transparent = __is_transparent;
  };


  struct less
  {
    template<typename _Tp, typename _Up>
      requires totally_ordered_with<_Tp, _Up>
 || __detail::__less_builtin_ptr_cmp<_Tp, _Up>
      constexpr bool
      operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Tp>() < std::declval<_Up>()))
      {
 if constexpr (__detail::__less_builtin_ptr_cmp<_Tp, _Up>)
   {

     if (std::is_constant_evaluated())
       return __t < __u;

     auto __x = reinterpret_cast<long unsigned int>(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)));
     auto __y = reinterpret_cast<long unsigned int>(
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
     return __x < __y;
   }
 else
   return std::forward<_Tp>(__t) < std::forward<_Up>(__u);
      }

    using is_transparent = __is_transparent;
  };


  struct greater
  {
    template<typename _Tp, typename _Up>
      requires totally_ordered_with<_Tp, _Up>
 || __detail::__less_builtin_ptr_cmp<_Up, _Tp>
      constexpr bool
      operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Up>() < std::declval<_Tp>()))
      { return less{}(std::forward<_Up>(__u), std::forward<_Tp>(__t)); }

    using is_transparent = __is_transparent;
  };


  struct greater_equal
  {
    template<typename _Tp, typename _Up>
      requires totally_ordered_with<_Tp, _Up>
 || __detail::__less_builtin_ptr_cmp<_Tp, _Up>
      constexpr bool
      operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Tp>() < std::declval<_Up>()))
      { return !less{}(std::forward<_Tp>(__t), std::forward<_Up>(__u)); }

    using is_transparent = __is_transparent;
  };


  struct less_equal
  {
    template<typename _Tp, typename _Up>
      requires totally_ordered_with<_Tp, _Up>
 || __detail::__less_builtin_ptr_cmp<_Up, _Tp>
      constexpr bool
      operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Up>() < std::declval<_Tp>()))
      { return !less{}(std::forward<_Up>(__u), std::forward<_Tp>(__t)); }

    using is_transparent = __is_transparent;
  };

}


}
# 38 "/usr/local/include/c++/10.0.0/bits/iterator_concepts.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{


  struct input_iterator_tag;
  struct output_iterator_tag;
  struct forward_iterator_tag;
  struct bidirectional_iterator_tag;
  struct random_access_iterator_tag;
  struct contiguous_iterator_tag;

  template<typename _Iterator>
    struct iterator_traits;

  template<typename _Tp> requires is_object_v<_Tp>
    struct iterator_traits<_Tp*>;

  template<typename _Iterator, typename>
    struct __iterator_traits;

  namespace __detail
  {
    template<typename _Tp>
      using __with_ref = _Tp&;

    template<typename _Tp>
      concept __can_reference = requires { typename __with_ref<_Tp>; };

    template<typename _Tp>
      concept __dereferenceable = requires(_Tp& __t)
 {
   { *__t } -> __can_reference;
 };


    template<__detail::__dereferenceable _Tp>
      struct __iter_ref
      {
 using type = decltype(*std::declval<_Tp&>());
      };
  }

  template<typename _Tp>
    using iter_reference_t = typename __detail::__iter_ref<_Tp>::type;

  namespace ranges
  {
    namespace __cust_imove
    {
      template<typename _Tp>
 concept __adl_imove
   = (std::__detail::__class_or_enum<remove_reference_t<_Tp>>)
   && requires(_Tp&& __t) { iter_move(static_cast<_Tp&&>(__t)); };

      struct _IMove
      {
      private:
 template<typename _Tp>
   static constexpr bool
   _S_noexcept()
   {
     if constexpr (__adl_imove<_Tp>)
       return noexcept(iter_move(std::declval<_Tp>()));
     else
       return noexcept(*std::declval<_Tp>());
   }

      public:
 template<typename _Tp>
   requires __adl_imove<_Tp> || requires(_Tp& __e) { *__e; }
   constexpr decltype(auto)
   operator()(_Tp&& __e) const
   noexcept(_S_noexcept<_Tp>())
   {
     if constexpr (__adl_imove<_Tp>)
       return iter_move(static_cast<_Tp&&>(__e));
     else if constexpr (is_reference_v<iter_reference_t<_Tp>>)
       return std::move(*__e);
     else
       return *__e;
   }
      };
    }

    inline namespace __cust
    {
      inline constexpr __cust_imove::_IMove iter_move{};
    }
  }

  namespace __detail
  {

    template<__detail::__dereferenceable _Tp>
      struct __iter_rvalue_ref
      { };

    template<__detail::__dereferenceable _Tp>
      requires requires(_Tp& __t)
      {
 { ranges::iter_move(__t) } -> __detail::__can_reference;
      }
      struct __iter_rvalue_ref<_Tp>
      { using type = decltype(ranges::iter_move(std::declval<_Tp&>())); };

  }

  template<typename _Tp>
    using iter_rvalue_reference_t
      = typename __detail::__iter_rvalue_ref<_Tp>::type;

  template<typename> struct incrementable_traits { };

  template<typename _Tp> requires is_object_v<_Tp>
    struct incrementable_traits<_Tp*>
    { using difference_type = ptrdiff_t; };

  template<typename _Iter>
    struct incrementable_traits<const _Iter>
    : incrementable_traits<_Iter> { };

  template<typename _Tp> requires requires { typename _Tp::difference_type; }
    struct incrementable_traits<_Tp>
    { using difference_type = typename _Tp::difference_type; };

  template<typename _Tp>
    requires (!requires { typename _Tp::difference_type; }
       && requires(const _Tp& __a, const _Tp& __b)
       {
  requires (!is_void_v<remove_pointer_t<_Tp>>);
  { __a - __b } -> integral;
       })
    struct incrementable_traits<_Tp>
    {
      using difference_type
 = make_signed_t<decltype(std::declval<_Tp>() - std::declval<_Tp>())>;
    };

  namespace __detail
  {


    template<typename _Iter>
      concept __primary_traits_iter
 = __is_base_of(__iterator_traits<_Iter, void>, iterator_traits<_Iter>);

    template<typename _Iter, typename _Tp>
      struct __iter_traits_impl
      { using type = iterator_traits<_Iter>; };

    template<typename _Iter, typename _Tp>
      requires __primary_traits_iter<_Iter>
      struct __iter_traits_impl<_Iter, _Tp>
      { using type = _Tp; };


    template<typename _Iter, typename _Tp = _Iter>
      using __iter_traits = typename __iter_traits_impl<_Iter, _Tp>::type;
  }

  template<typename _Tp>
    using iter_difference_t = typename
      __detail::__iter_traits<_Tp, incrementable_traits<_Tp>>::difference_type;

  namespace __detail
  {
    template<typename> struct __cond_value_type { };

    template<typename _Tp> requires is_object_v<_Tp>
      struct __cond_value_type<_Tp>
      { using value_type = remove_cv_t<_Tp>; };
  }

  template<typename> struct readable_traits { };

  template<typename _Tp>
    struct readable_traits<_Tp*>
    : __detail::__cond_value_type<_Tp>
    { };

  template<typename _Iter> requires is_array_v<_Iter>
    struct readable_traits<_Iter>
    { using value_type = remove_cv_t<remove_extent_t<_Iter>>; };

  template<typename _Iter>
    struct readable_traits<const _Iter>
    : readable_traits<_Iter>
    { };

  template<typename _Tp> requires requires { typename _Tp::value_type; }
    struct readable_traits<_Tp>
    : __detail::__cond_value_type<typename _Tp::value_type>
    { };

  template<typename _Tp> requires requires { typename _Tp::element_type; }
    struct readable_traits<_Tp>
    : __detail::__cond_value_type<typename _Tp::element_type>
    { };

  template<typename _Tp>
    using iter_value_t = typename
      __detail::__iter_traits<_Tp, readable_traits<_Tp>>::value_type;

  namespace __detail
  {
    template<typename _Iter>
      concept __cpp17_iterator = copyable<_Iter>
 && requires(_Iter __it)
 {
   { *__it } -> __can_reference;
   { ++__it } -> same_as<_Iter&>;
   { *__it++ } -> __can_reference;
 };

    template<typename _Iter>
      concept __cpp17_input_iterator = __cpp17_iterator<_Iter>
 && equality_comparable<_Iter>
 && requires(_Iter __it)
 {
   typename incrementable_traits<_Iter>::difference_type;
   typename readable_traits<_Iter>::value_type;
   typename common_reference_t<iter_reference_t<_Iter>&&,
     typename readable_traits<_Iter>::value_type&>;
   typename common_reference_t<decltype(*__it++)&&,
     typename readable_traits<_Iter>::value_type&>;
   requires signed_integral<typename incrementable_traits<_Iter>::difference_type>;
 };

    template<typename _Iter>
      concept __cpp17_fwd_iterator = __cpp17_input_iterator<_Iter>
 && constructible_from<_Iter>
 && is_lvalue_reference_v<iter_reference_t<_Iter>>
 && same_as<remove_cvref_t<iter_reference_t<_Iter>>,
     typename readable_traits<_Iter>::value_type>
 && requires(_Iter __it)
 {
   { __it++ } -> convertible_to<const _Iter&>;
   { *__it++ } -> same_as<iter_reference_t<_Iter>>;
 };

    template<typename _Iter>
      concept __cpp17_bidi_iterator = __cpp17_fwd_iterator<_Iter>
 && requires(_Iter __it)
 {
   { --__it } -> same_as<_Iter&>;
   { __it-- } -> convertible_to<const _Iter&>;
   { *__it-- } -> same_as<iter_reference_t<_Iter>>;
 };

    template<typename _Iter>
      concept __cpp17_randacc_iterator = __cpp17_bidi_iterator<_Iter>
 && totally_ordered<_Iter>
 && requires(_Iter __it,
      typename incrementable_traits<_Iter>::difference_type __n)
 {
   { __it += __n } -> same_as<_Iter&>;
   { __it -= __n } -> same_as<_Iter&>;
   { __it + __n } -> same_as<_Iter>;
   { __n + __it } -> same_as<_Iter>;
   { __it - __n } -> same_as<_Iter>;
   { __it - __it } -> same_as<decltype(__n)>;
   { __it[__n] } -> convertible_to<iter_reference_t<_Iter>>;
 };

    template<typename _Iter>
      concept __iter_with_nested_types = requires {
 typename _Iter::iterator_category;
 typename _Iter::value_type;
 typename _Iter::difference_type;
 typename _Iter::reference;
      };

    template<typename _Iter>
      concept __iter_without_nested_types = !__iter_with_nested_types<_Iter>;

    template<typename _Iter, bool __use_arrow = false>
      struct __ptr
      { using type = void; };

    template<typename _Iter> requires requires { typename _Iter::pointer; }
      struct __ptr<_Iter, true>
      { using type = typename _Iter::pointer; };

    template<typename _Iter> requires requires { typename _Iter::pointer; }
      struct __ptr<_Iter, false>
      { using type = typename _Iter::pointer; };

    template<typename _Iter>
      requires (!requires { typename _Iter::pointer; }
   && requires(_Iter& __it) { __it.operator->(); })
      struct __ptr<_Iter, true>
      { using type = decltype(std::declval<_Iter&>().operator->()); };

    template<typename _Iter>
      struct __ref
      { using type = iter_reference_t<_Iter>; };

    template<typename _Iter> requires requires { typename _Iter::reference; }
      struct __ref<_Iter>
      { using type = typename _Iter::reference; };

    template<typename _Iter>
      struct __cat
      { using type = input_iterator_tag; };

    template<typename _Iter>
      requires requires { typename _Iter::iterator_category; }
      struct __cat<_Iter>
      { using type = typename _Iter::iterator_category; };

    template<typename _Iter>
      requires (!requires { typename _Iter::iterator_category; }
  && __detail::__cpp17_randacc_iterator<_Iter>)
      struct __cat<_Iter>
      { using type = random_access_iterator_tag; };

    template<typename _Iter>
      requires (!requires { typename _Iter::iterator_category; }
  && __detail::__cpp17_bidi_iterator<_Iter>)
      struct __cat<_Iter>
      { using type = bidirectional_iterator_tag; };

    template<typename _Iter>
      requires (!requires { typename _Iter::iterator_category; }
  && __detail::__cpp17_fwd_iterator<_Iter>)
      struct __cat<_Iter>
      { using type = forward_iterator_tag; };

    template<typename _Iter>
      struct __diff
      { using type = void; };

    template<typename _Iter>
      requires requires {
 typename incrementable_traits<_Iter>::difference_type;
      }
      struct __diff<_Iter>
      {
 using type = typename incrementable_traits<_Iter>::difference_type;
      };

  }

  template<typename _Iterator>
    requires __detail::__iter_with_nested_types<_Iterator>
    struct __iterator_traits<_Iterator, void>
    {
      using iterator_category = typename _Iterator::iterator_category;
      using value_type = typename _Iterator::value_type;
      using difference_type = typename _Iterator::difference_type;
      using pointer = typename __detail::__ptr<_Iterator>::type;
      using reference = typename _Iterator::reference;
    };

  template<typename _Iterator>
    requires __detail::__iter_without_nested_types<_Iterator>
       && __detail::__cpp17_input_iterator<_Iterator>
    struct __iterator_traits<_Iterator, void>
    {
      using iterator_category = typename __detail::__cat<_Iterator>::type;
      using value_type
 = typename readable_traits<_Iterator>::value_type;
      using difference_type
 = typename incrementable_traits<_Iterator>::difference_type;
      using pointer = typename __detail::__ptr<_Iterator, true>::type;
      using reference = typename __detail::__ref<_Iterator>::type;
    };

  template<typename _Iterator>
    requires __detail::__iter_without_nested_types<_Iterator>
       && __detail::__cpp17_iterator<_Iterator>
    struct __iterator_traits<_Iterator, void>
    {
      using iterator_category = output_iterator_tag;
      using value_type = void;
      using difference_type = typename __detail::__diff<_Iterator>::type;
      using pointer = void;
      using reference = void;
    };

  namespace __detail
  {
    template<typename _Iter>
      struct __iter_concept_impl;


    template<typename _Iter>
      requires requires { typename __iter_traits<_Iter>::iterator_concept; }
      struct __iter_concept_impl<_Iter>
      { using type = typename __iter_traits<_Iter>::iterator_concept; };


    template<typename _Iter>
      requires (!requires { typename __iter_traits<_Iter>::iterator_concept; }
   && requires { typename __iter_traits<_Iter>::iterator_category; })
      struct __iter_concept_impl<_Iter>
      { using type = typename __iter_traits<_Iter>::iterator_category; };


    template<typename _Iter>
      requires (!requires { typename __iter_traits<_Iter>::iterator_concept; }
   && !requires { typename __iter_traits<_Iter>::iterator_category; }
   && __primary_traits_iter<_Iter>)
      struct __iter_concept_impl<_Iter>
      { using type = random_access_iterator_tag; };


    template<typename _Iter>
      struct __iter_concept_impl
      { };


    template<typename _Iter>
      using __iter_concept = typename __iter_concept_impl<_Iter>::type;
  }


  template<typename _In>
    concept readable = requires
      {
 typename iter_value_t<_In>;
 typename iter_reference_t<_In>;
 typename iter_rvalue_reference_t<_In>;
      }
      && common_reference_with<iter_reference_t<_In>&&, iter_value_t<_In>&>
      && common_reference_with<iter_reference_t<_In>&&,
         iter_rvalue_reference_t<_In>&&>
      && common_reference_with<iter_rvalue_reference_t<_In>&&,
          const iter_value_t<_In>&>;

  namespace __detail
  {

    template<readable _Tp>
      struct __iter_common_ref
      : common_reference<iter_reference_t<_Tp>, iter_value_t<_Tp>&>
      { };
  }

  template<typename _Tp>
    using iter_common_reference_t
      = typename __detail::__iter_common_ref<_Tp>::type;


  template<typename _Out, typename _Tp>
    concept writable = requires(_Out&& __o, _Tp&& __t)
      {
 *__o = std::forward<_Tp>(__t);
 *std::forward<_Out>(__o) = std::forward<_Tp>(__t);
 const_cast<const iter_reference_t<_Out>&&>(*__o)
   = std::forward<_Tp>(__t);
 const_cast<const iter_reference_t<_Out>&&>(*std::forward<_Out>(__o))
   = std::forward<_Tp>(__t);
      };


  template<typename _Iter>
    concept weakly_incrementable = default_initializable<_Iter>
      && movable<_Iter>
      && requires(_Iter __i)
      {
 typename iter_difference_t<_Iter>;
 requires signed_integral<iter_difference_t<_Iter>>;
 { ++__i } -> same_as<_Iter&>;
 __i++;
      };

  template<typename _Iter>
    concept incrementable = regular<_Iter> && weakly_incrementable<_Iter>
      && requires(_Iter __i) { { __i++ } -> same_as<_Iter>; };

  template<typename _Iter>
    concept input_or_output_iterator
      = requires(_Iter __i) { { *__i } -> __detail::__can_reference; }
 && weakly_incrementable<_Iter>;

  template<typename _Sent, typename _Iter>
    concept sentinel_for = semiregular<_Sent>
      && input_or_output_iterator<_Iter>
      && __detail::__weakly_eq_cmp_with<_Sent, _Iter>;

  template<typename _Sent, typename _Iter>
    inline constexpr bool disable_sized_sentinel_for = false;

  template<typename _Sent, typename _Iter>
    concept sized_sentinel_for = sentinel_for<_Sent, _Iter>
    && !disable_sized_sentinel_for<remove_cv_t<_Sent>, remove_cv_t<_Iter>>
    && requires(const _Iter& __i, const _Sent& __s)
    {
      { __s - __i } -> same_as<iter_difference_t<_Iter>>;
      { __i - __s } -> same_as<iter_difference_t<_Iter>>;
    };

  template<typename _Iter>
    concept input_iterator = input_or_output_iterator<_Iter>
      && readable<_Iter>
      && requires { typename __detail::__iter_concept<_Iter>; }
      && derived_from<__detail::__iter_concept<_Iter>, input_iterator_tag>;

  template<typename _Iter, typename _Tp>
    concept output_iterator = input_or_output_iterator<_Iter>
      && writable<_Iter, _Tp>
      && requires(_Iter __i, _Tp&& __t) { *__i++ = std::forward<_Tp>(__t); };

  template<typename _Iter>
    concept forward_iterator = input_iterator<_Iter>
      && derived_from<__detail::__iter_concept<_Iter>, forward_iterator_tag>
      && incrementable<_Iter> && sentinel_for<_Iter, _Iter>;

  template<typename _Iter>
    concept bidirectional_iterator = forward_iterator<_Iter>
      && derived_from<__detail::__iter_concept<_Iter>,
        bidirectional_iterator_tag>
      && requires(_Iter __i)
      {
 { --__i } -> same_as<_Iter&>;
 { __i-- } -> same_as<_Iter>;
      };

  template<typename _Iter>
    concept random_access_iterator = bidirectional_iterator<_Iter>
      && derived_from<__detail::__iter_concept<_Iter>,
        random_access_iterator_tag>
      && totally_ordered<_Iter> && sized_sentinel_for<_Iter, _Iter>
      && requires(_Iter __i, const _Iter __j,
    const iter_difference_t<_Iter> __n)
      {
 { __i += __n } -> same_as<_Iter&>;
 { __j + __n } -> same_as<_Iter>;
 { __n + __j } -> same_as<_Iter>;
 { __i -= __n } -> same_as<_Iter&>;
 { __j - __n } -> same_as<_Iter>;
 { __j[__n] } -> same_as<iter_reference_t<_Iter>>;
      };

  template<typename _Iter>
    concept contiguous_iterator = random_access_iterator<_Iter>
      && derived_from<__detail::__iter_concept<_Iter>, contiguous_iterator_tag>
      && is_lvalue_reference_v<iter_reference_t<_Iter>>
      && same_as<iter_value_t<_Iter>, remove_cvref_t<iter_reference_t<_Iter>>>
      && requires(const _Iter& __i)
      {
 { std::to_address(__i) }
   -> same_as<add_pointer_t<iter_reference_t<_Iter>>>;
      };





  template<typename _Fn, typename _Iter>
    concept indirectly_unary_invocable = readable<_Iter>
      && copy_constructible<_Fn> && invocable<_Fn&, iter_value_t<_Iter>&>
      && invocable<_Fn&, iter_reference_t<_Iter>>
      && invocable<_Fn&, iter_common_reference_t<_Iter>>
      && common_reference_with<invoke_result_t<_Fn&, iter_value_t<_Iter>&>,
          invoke_result_t<_Fn&, iter_reference_t<_Iter>>>;

  template<typename _Fn, typename _Iter>
    concept indirectly_regular_unary_invocable = readable<_Iter>
      && copy_constructible<_Fn>
      && regular_invocable<_Fn&, iter_value_t<_Iter>&>
      && regular_invocable<_Fn&, iter_reference_t<_Iter>>
      && regular_invocable<_Fn&, iter_common_reference_t<_Iter>>
      && common_reference_with<invoke_result_t<_Fn&, iter_value_t<_Iter>&>,
          invoke_result_t<_Fn&, iter_reference_t<_Iter>>>;

  template<typename _Fn, typename _Iter>
    concept indirect_unary_predicate = readable<_Iter>
      && copy_constructible<_Fn> && predicate<_Fn&, iter_value_t<_Iter>&>
      && predicate<_Fn&, iter_reference_t<_Iter>>
      && predicate<_Fn&, iter_common_reference_t<_Iter>>;

  template<typename _Fn, typename _I1, typename _I2>
    concept indirect_binary_predicate = readable<_I1> && readable<_I2>
      && copy_constructible<_Fn>
      && predicate<_Fn&, iter_value_t<_I1>&, iter_value_t<_I2>&>
      && predicate<_Fn&, iter_value_t<_I1>&, iter_reference_t<_I2>>
      && predicate<_Fn&, iter_reference_t<_I1>, iter_value_t<_I2>&>
      && predicate<_Fn&, iter_reference_t<_I1>, iter_reference_t<_I2>>
      && predicate<_Fn&, iter_common_reference_t<_I1>,
     iter_common_reference_t<_I2>>;

  template<typename _Fn, typename _I1, typename _I2 = _I1>
    concept indirect_equivalence_relation = readable<_I1> && readable<_I2>
      && copy_constructible<_Fn>
      && equivalence_relation<_Fn&, iter_value_t<_I1>&, iter_value_t<_I2>&>
      && equivalence_relation<_Fn&, iter_value_t<_I1>&, iter_reference_t<_I2>>
      && equivalence_relation<_Fn&, iter_reference_t<_I1>, iter_value_t<_I2>&>
      && equivalence_relation<_Fn&, iter_reference_t<_I1>,
         iter_reference_t<_I2>>
      && equivalence_relation<_Fn&, iter_common_reference_t<_I1>,
         iter_common_reference_t<_I2>>;

  template<typename _Fn, typename _I1, typename _I2 = _I1>
    concept indirect_strict_weak_order = readable<_I1> && readable<_I2>
      && copy_constructible<_Fn>
      && strict_weak_order<_Fn&, iter_value_t<_I1>&, iter_value_t<_I2>&>
      && strict_weak_order<_Fn&, iter_value_t<_I1>&, iter_reference_t<_I2>>
      && strict_weak_order<_Fn&, iter_reference_t<_I1>, iter_value_t<_I2>&>
      && strict_weak_order<_Fn&, iter_reference_t<_I1>, iter_reference_t<_I2>>
      && strict_weak_order<_Fn&, iter_common_reference_t<_I1>,
      iter_common_reference_t<_I2>>;

  namespace __detail
  {

    template<typename _Fn, typename... _Is>
      struct __indirect_result
      { };

    template<typename _Fn, typename... _Is>
      requires (readable<_Is> && ...)
 && invocable<_Fn, iter_reference_t<_Is>...>
      struct __indirect_result<_Fn, _Is...>
      : invoke_result<_Fn, iter_reference_t<_Is>...>
      { };
  }

  template<typename _Fn, typename... _Is>
    using indirect_result_t = typename
      __detail::__indirect_result<_Fn, _Is...>::type;


  template<readable _Iter, indirectly_regular_unary_invocable<_Iter> _Proj>
    struct projected
    {
      using value_type = remove_cvref_t<indirect_result_t<_Proj&, _Iter>>;

      indirect_result_t<_Proj&, _Iter> operator*() const;
    };

  template<weakly_incrementable _Iter, typename _Proj>
    struct incrementable_traits<projected<_Iter, _Proj>>
    { using difference_type = iter_difference_t<_Iter>; };





  template<typename _In, typename _Out>
    concept indirectly_movable = readable<_In>
      && writable<_Out, iter_rvalue_reference_t<_In>>;

  template<typename _In, typename _Out>
    concept indirectly_movable_storable = indirectly_movable<_In, _Out>
      && writable<_Out, iter_value_t<_In>> && movable<iter_value_t<_In>>
      && constructible_from<iter_value_t<_In>, iter_rvalue_reference_t<_In>>
      && assignable_from<iter_value_t<_In>&, iter_rvalue_reference_t<_In>>;


  template<typename _In, typename _Out>
    concept indirectly_copyable = readable<_In>
      && writable<_Out, iter_reference_t<_In>>;

  template<typename _In, typename _Out>
    concept indirectly_copyable_storable = indirectly_copyable<_In, _Out>
      && writable<_Out, const iter_value_t<_In>&>
      && copyable<iter_value_t<_In>>
      && constructible_from<iter_value_t<_In>, iter_reference_t<_In>>
      && assignable_from<iter_value_t<_In>&, iter_reference_t<_In>>;

namespace ranges
{
  namespace __cust_iswap
  {
    template<typename _It1, typename _It2>
      void iter_swap(_It1, _It2) = delete;

    template<typename _Tp, typename _Up>
      concept __adl_iswap
 = (std::__detail::__class_or_enum<remove_reference_t<_Tp>>
   || std::__detail::__class_or_enum<remove_reference_t<_Up>>)
 && requires(_Tp&& __t, _Up&& __u) {
   iter_swap(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u));
 };

    template<typename _Xp, typename _Yp>
      constexpr iter_value_t<remove_reference_t<_Xp>>
      __iter_exchange_move(_Xp&& __x, _Yp&& __y)
      noexcept(noexcept(iter_value_t<remove_reference_t<_Xp>>(iter_move(__x)))
        && noexcept(*__x = iter_move(__y)))
      {
 iter_value_t<remove_reference_t<_Xp>> __old_value(iter_move(__x));
 *__x = iter_move(__y);
 return __old_value;
      }

    struct _IterSwap
    {
    private:
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__adl_iswap<_Tp, _Up>)
     return noexcept(iter_swap(std::declval<_Tp>(),
          std::declval<_Up>()));
   else if constexpr (readable<_Tp> && readable<_Up>
     && swappable_with<iter_reference_t<_Tp>, iter_reference_t<_Up>>)
     return noexcept(ranges::swap(*std::declval<_Tp>(),
      *std::declval<_Up>()));
   else
     return noexcept(*std::declval<_Tp>()
  = __iter_exchange_move(std::declval<_Up>(),
           std::declval<_Tp>()));
 }

    public:
      template<typename _Tp, typename _Up>
 requires __adl_iswap<_Tp, _Up>
 || (readable<remove_reference_t<_Tp>>
     && readable<remove_reference_t<_Up>>
     && swappable_with<iter_reference_t<_Tp>, iter_reference_t<_Up>>)
 || (indirectly_movable_storable<_Tp, _Up>
     && indirectly_movable_storable<_Up, _Tp>)
 constexpr void
 operator()(_Tp&& __e1, _Up&& __e2) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   if constexpr (__adl_iswap<_Tp, _Up>)
     iter_swap(static_cast<_Tp&&>(__e1), static_cast<_Up&&>(__e2));
   else if constexpr (readable<_Tp> && readable<_Up>
     && swappable_with<iter_reference_t<_Tp>, iter_reference_t<_Up>>)
     ranges::swap(*__e1, *__e2);
   else
     *__e1 = __iter_exchange_move(__e2, __e1);
 }
    };
  }

  inline namespace __cust
  {
    inline constexpr __cust_iswap::_IterSwap iter_swap{};
  }

}


  template<typename _I1, typename _I2 = _I1>
    concept indirectly_swappable = readable<_I1> && readable<_I2>
      && requires(_I1& __i1, _I2& __i2)
      {
 ranges::iter_swap(__i1, __i1);
 ranges::iter_swap(__i2, __i2);
 ranges::iter_swap(__i1, __i2);
 ranges::iter_swap(__i2, __i1);
      };


  template<typename _I1, typename _I2, typename _Rel, typename _P1 = identity,
    typename _P2 = identity>
    concept indirectly_comparable
      = indirect_binary_predicate<_Rel, projected<_I1, _P1>,
      projected<_I2, _P2>>;


  template<typename _Iter>
    concept permutable = forward_iterator<_Iter>
      && indirectly_movable_storable<_Iter, _Iter>
      && indirectly_swappable<_Iter, _Iter>;


  template<typename _I1, typename _I2, typename _Out,
    typename _Rel = ranges::less, typename _P1 = identity,
    typename _P2 = identity>
    concept mergeable = input_iterator<_I1> && input_iterator<_I2>
      && weakly_incrementable<_Out> && indirectly_copyable<_I1, _Out>
      && indirectly_copyable<_I2, _Out>
      && indirect_strict_weak_order<_Rel, projected<_I1, _P1>,
        projected<_I2, _P2>>;


  template<typename _Iter, typename _Rel = ranges::less,
    typename _Proj = identity>
    concept sortable = permutable<_Iter>
      && indirect_strict_weak_order<_Rel, projected<_Iter, _Proj>>;

  struct unreachable_sentinel_t
  {
    template<weakly_incrementable _It>
      friend constexpr bool
      operator==(unreachable_sentinel_t, const _It&) noexcept
      { return false; }
  };

  inline constexpr unreachable_sentinel_t unreachable_sentinel{};

  struct default_sentinel_t { };
  inline constexpr default_sentinel_t default_sentinel{};


}
# 72 "/usr/local/include/c++/10.0.0/bits/stl_iterator_base_types.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

# 93 "/usr/local/include/c++/10.0.0/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };



  struct contiguous_iterator_tag : public random_access_iterator_tag { };
# 125 "/usr/local/include/c++/10.0.0/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 149 "/usr/local/include/c++/10.0.0/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator>
    struct iterator_traits;




  template<typename _Iterator, typename = __void_t<>>
    struct __iterator_traits { };
# 176 "/usr/local/include/c++/10.0.0/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator>
    struct iterator_traits
    : public __iterator_traits<_Iterator> { };
# 194 "/usr/local/include/c++/10.0.0/bits/stl_iterator_base_types.h" 3
  template<typename _Tp>

    requires is_object_v<_Tp>

    struct iterator_traits<_Tp*>
    {
      using iterator_concept = contiguous_iterator_tag;
      using iterator_category = random_access_iterator_tag;
      using value_type = remove_cv_t<_Tp>;
      using difference_type = ptrdiff_t;
      using pointer = _Tp*;
      using reference = _Tp&;
    };
# 235 "/usr/local/include/c++/10.0.0/bits/stl_iterator_base_types.h" 3
  template<typename _Iter>
    inline constexpr
    typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }




  template<typename _Iter>
    using __iterator_category_t
      = typename iterator_traits<_Iter>::iterator_category;

  template<typename _InIter>
    using _RequireInputIter =
      __enable_if_t<is_convertible<__iterator_category_t<_InIter>,
       input_iterator_tag>::value>;

  template<typename _It,
    typename _Cat = __iterator_category_t<_It>>
    struct __is_random_access_iter
      : is_base_of<random_access_iterator_tag, _Cat>
    {
      typedef is_base_of<random_access_iterator_tag, _Cat> _Base;
      enum { __value = _Base::value };
    };








}
# 66 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 2 3
# 1 "/usr/local/include/c++/10.0.0/bits/stl_iterator_base_funcs.h" 1 3
# 62 "/usr/local/include/c++/10.0.0/bits/stl_iterator_base_funcs.h" 3
       
# 63 "/usr/local/include/c++/10.0.0/bits/stl_iterator_base_funcs.h" 3

# 1 "/usr/local/include/c++/10.0.0/bits/concept_check.h" 1 3
# 33 "/usr/local/include/c++/10.0.0/bits/concept_check.h" 3
       
# 34 "/usr/local/include/c++/10.0.0/bits/concept_check.h" 3
# 65 "/usr/local/include/c++/10.0.0/bits/stl_iterator_base_funcs.h" 2 3
# 1 "/usr/local/include/c++/10.0.0/debug/assertions.h" 1 3
# 66 "/usr/local/include/c++/10.0.0/bits/stl_iterator_base_funcs.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{




  template <typename> struct _List_iterator;
  template <typename> struct _List_const_iterator;


  template<typename _InputIterator>
    inline constexpr
    typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline constexpr
    typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }



  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_iterator<_Tp>,
        std::_List_iterator<_Tp>,
        input_iterator_tag);

  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_const_iterator<_Tp>,
        std::_List_const_iterator<_Tp>,
        input_iterator_tag);
# 135 "/usr/local/include/c++/10.0.0/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline constexpr
    typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline constexpr void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      ;
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline constexpr void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline constexpr void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      if (__builtin_constant_p(__n) && __n == 1)
 ++__i;
      else if (__builtin_constant_p(__n) && __n == -1)
 --__i;
      else
 __i += __n;
    }
# 200 "/usr/local/include/c++/10.0.0/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline constexpr void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }



  template<typename _InputIterator>
    inline constexpr _InputIterator
    next(_InputIterator __x, typename
  iterator_traits<_InputIterator>::difference_type __n = 1)
    {

     
      std::advance(__x, __n);
      return __x;
    }

  template<typename _BidirectionalIterator>
    inline constexpr _BidirectionalIterator
    prev(_BidirectionalIterator __x, typename
  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)
    {

     

      std::advance(__x, -__n);
      return __x;
    }




}
# 67 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 2 3
# 1 "/usr/local/include/c++/10.0.0/bits/stl_iterator.h" 1 3
# 78 "/usr/local/include/c++/10.0.0/bits/stl_iterator.h" 3
# 1 "/usr/local/include/c++/10.0.0/new" 1 3
# 38 "/usr/local/include/c++/10.0.0/new" 3
       
# 39 "/usr/local/include/c++/10.0.0/new" 3


# 1 "/usr/local/include/c++/10.0.0/exception" 1 3
# 33 "/usr/local/include/c++/10.0.0/exception" 3
       
# 34 "/usr/local/include/c++/10.0.0/exception" 3

#pragma GCC visibility push(default)


# 1 "/usr/local/include/c++/10.0.0/bits/exception.h" 1 3
# 34 "/usr/local/include/c++/10.0.0/bits/exception.h" 3
       
# 35 "/usr/local/include/c++/10.0.0/bits/exception.h" 3

#pragma GCC visibility push(default)



extern "C++" {

namespace std
{
# 60 "/usr/local/include/c++/10.0.0/bits/exception.h" 3
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;

    exception(const exception&) = default;
    exception& operator=(const exception&) = default;
    exception(exception&&) = default;
    exception& operator=(exception&&) = default;




    virtual const char*
    what() const noexcept;
  };

}

}

#pragma GCC visibility pop
# 39 "/usr/local/include/c++/10.0.0/exception" 2 3

extern "C++" {

namespace std
{






  class bad_exception : public exception
  {
  public:
    bad_exception() noexcept { }



    virtual ~bad_exception() noexcept;


    virtual const char*
    what() const noexcept;
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) noexcept;



  terminate_handler get_terminate() noexcept;




  void terminate() noexcept __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) noexcept;



  unexpected_handler get_unexpected() noexcept;




  void unexpected() __attribute__ ((__noreturn__));
# 105 "/usr/local/include/c++/10.0.0/exception" 3
  [[__deprecated__]]
  bool uncaught_exception() noexcept __attribute__ ((__pure__));




  int uncaught_exceptions() noexcept __attribute__ ((__pure__));



}

namespace __gnu_cxx
{

# 137 "/usr/local/include/c++/10.0.0/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop


# 1 "/usr/local/include/c++/10.0.0/bits/exception_ptr.h" 1 3
# 34 "/usr/local/include/c++/10.0.0/bits/exception_ptr.h" 3
#pragma GCC visibility push(default)



# 1 "/usr/local/include/c++/10.0.0/bits/cxxabi_init_exception.h" 1 3
# 34 "/usr/local/include/c++/10.0.0/bits/cxxabi_init_exception.h" 3
       
# 35 "/usr/local/include/c++/10.0.0/bits/cxxabi_init_exception.h" 3

#pragma GCC visibility push(default)

# 1 "/usr/local/lib/gcc/x86_64-pc-linux-gnu/10.0.0/include/stddef.h" 1 3 4
# 39 "/usr/local/include/c++/10.0.0/bits/cxxabi_init_exception.h" 2 3
# 50 "/usr/local/include/c++/10.0.0/bits/cxxabi_init_exception.h" 3
namespace std
{
  class type_info;
}

namespace __cxxabiv1
{
  struct __cxa_refcounted_exception;

  extern "C"
    {

      void*
      __cxa_allocate_exception(size_t) noexcept;

      void
      __cxa_free_exception(void*) noexcept;


      __cxa_refcounted_exception*
      __cxa_init_primary_exception(void *object, std::type_info *tinfo,
                void ( *dest) (void *)) noexcept;

    }
}



#pragma GCC visibility pop
# 39 "/usr/local/include/c++/10.0.0/bits/exception_ptr.h" 2 3
# 1 "/usr/local/include/c++/10.0.0/typeinfo" 1 3
# 32 "/usr/local/include/c++/10.0.0/typeinfo" 3
       
# 33 "/usr/local/include/c++/10.0.0/typeinfo" 3



# 1 "/usr/local/include/c++/10.0.0/bits/hash_bytes.h" 1 3
# 33 "/usr/local/include/c++/10.0.0/bits/hash_bytes.h" 3
       
# 34 "/usr/local/include/c++/10.0.0/bits/hash_bytes.h" 3



namespace std
{







  size_t
  _Hash_bytes(const void* __ptr, size_t __len, size_t __seed);





  size_t
  _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed);


}
# 37 "/usr/local/include/c++/10.0.0/typeinfo" 2 3


#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 80 "/usr/local/include/c++/10.0.0/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const noexcept
    { return __name[0] == '*' ? __name + 1 : __name; }
# 115 "/usr/local/include/c++/10.0.0/typeinfo" 3
    bool before(const type_info& __arg) const noexcept
    { return (__name[0] == '*' && __arg.__name[0] == '*')
 ? __name < __arg.__name
 : __builtin_strcmp (__name, __arg.__name) < 0; }

    bool operator==(const type_info& __arg) const noexcept
    {
      return ((__name == __arg.__name)
       || (__name[0] != '*' &&
    __builtin_strcmp (__name, __arg.__name) == 0));
    }
# 136 "/usr/local/include/c++/10.0.0/typeinfo" 3
    bool operator!=(const type_info& __arg) const noexcept
    { return !operator==(__arg); }


    size_t hash_code() const noexcept
    {

      return _Hash_bytes(name(), __builtin_strlen(name()),
    static_cast<size_t>(0xc70f6907UL));



    }



    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };







  class bad_cast : public exception
  {
  public:
    bad_cast() noexcept { }



    virtual ~bad_cast() noexcept;


    virtual const char* what() const noexcept;
  };





  class bad_typeid : public exception
  {
  public:
    bad_typeid () noexcept { }



    virtual ~bad_typeid() noexcept;


    virtual const char* what() const noexcept;
  };
}

}

#pragma GCC visibility pop
# 40 "/usr/local/include/c++/10.0.0/bits/exception_ptr.h" 2 3
# 1 "/usr/local/include/c++/10.0.0/new" 1 3
# 41 "/usr/local/include/c++/10.0.0/bits/exception_ptr.h" 2 3

extern "C++" {

namespace std
{
  class type_info;






  namespace __exception_ptr
  {
    class exception_ptr;
  }

  using __exception_ptr::exception_ptr;





  exception_ptr current_exception() noexcept;

  template<typename _Ex>
  exception_ptr make_exception_ptr(_Ex) noexcept;


  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));

  namespace __exception_ptr
  {
    using std::rethrow_exception;





    class exception_ptr
    {
      void* _M_exception_object;

      explicit exception_ptr(void* __e) noexcept;

      void _M_addref() noexcept;
      void _M_release() noexcept;

      void *_M_get() const noexcept __attribute__ ((__pure__));

      friend exception_ptr std::current_exception() noexcept;
      friend void std::rethrow_exception(exception_ptr);
      template<typename _Ex>
      friend exception_ptr std::make_exception_ptr(_Ex) noexcept;

    public:
      exception_ptr() noexcept;

      exception_ptr(const exception_ptr&) noexcept;


      exception_ptr(nullptr_t) noexcept
      : _M_exception_object(0)
      { }

      exception_ptr(exception_ptr&& __o) noexcept
      : _M_exception_object(__o._M_exception_object)
      { __o._M_exception_object = 0; }
# 118 "/usr/local/include/c++/10.0.0/bits/exception_ptr.h" 3
      exception_ptr&
      operator=(const exception_ptr&) noexcept;


      exception_ptr&
      operator=(exception_ptr&& __o) noexcept
      {
        exception_ptr(static_cast<exception_ptr&&>(__o)).swap(*this);
        return *this;
      }


      ~exception_ptr() noexcept;

      void
      swap(exception_ptr&) noexcept;
# 145 "/usr/local/include/c++/10.0.0/bits/exception_ptr.h" 3
      explicit operator bool() const
      { return _M_exception_object; }


      friend bool
      operator==(const exception_ptr&, const exception_ptr&)
 noexcept __attribute__ ((__pure__));

      const class std::type_info*
      __cxa_exception_type() const noexcept
 __attribute__ ((__pure__));
    };



    bool
    operator==(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    bool
    operator!=(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    inline void
    swap(exception_ptr& __lhs, exception_ptr& __rhs)
    { __lhs.swap(__rhs); }




    template<typename _Ex>
      inline void
      __dest_thunk(void* __x)
      { static_cast<_Ex*>(__x)->~_Ex(); }


  }


  template<typename _Ex>
    exception_ptr
    make_exception_ptr(_Ex __ex) noexcept
    {

      void* __e = __cxxabiv1::__cxa_allocate_exception(sizeof(_Ex));
      (void) __cxxabiv1::__cxa_init_primary_exception(
   __e, const_cast<std::type_info*>(&typeid(__ex)),
   __exception_ptr::__dest_thunk<_Ex>);
      try
 {
          ::new (__e) _Ex(__ex);
          return exception_ptr(__e);
 }
      catch(...)
 {
   __cxxabiv1::__cxa_free_exception(__e);
   return current_exception();
 }
# 215 "/usr/local/include/c++/10.0.0/bits/exception_ptr.h" 3
    }


}

}

#pragma GCC visibility pop
# 148 "/usr/local/include/c++/10.0.0/exception" 2 3
# 1 "/usr/local/include/c++/10.0.0/bits/nested_exception.h" 1 3
# 33 "/usr/local/include/c++/10.0.0/bits/nested_exception.h" 3
#pragma GCC visibility push(default)
# 42 "/usr/local/include/c++/10.0.0/bits/nested_exception.h" 3
extern "C++" {

namespace std
{






  class nested_exception
  {
    exception_ptr _M_ptr;

  public:
    nested_exception() noexcept : _M_ptr(current_exception()) { }

    nested_exception(const nested_exception&) noexcept = default;

    nested_exception& operator=(const nested_exception&) noexcept = default;

    virtual ~nested_exception() noexcept;

    [[noreturn]]
    void
    rethrow_nested() const
    {
      if (_M_ptr)
 rethrow_exception(_M_ptr);
      std::terminate();
    }

    exception_ptr
    nested_ptr() const noexcept
    { return _M_ptr; }
  };



  template<typename _Except>
    struct _Nested_exception : public _Except, public nested_exception
    {
      explicit _Nested_exception(const _Except& __ex)
      : _Except(__ex)
      { }

      explicit _Nested_exception(_Except&& __ex)
      : _Except(static_cast<_Except&&>(__ex))
      { }
    };




  template<typename _Tp>
    [[noreturn]]
    inline void
    __throw_with_nested_impl(_Tp&& __t, true_type)
    {
      using _Up = typename remove_reference<_Tp>::type;
      throw _Nested_exception<_Up>{std::forward<_Tp>(__t)};
    }

  template<typename _Tp>
    [[noreturn]]
    inline void
    __throw_with_nested_impl(_Tp&& __t, false_type)
    { throw std::forward<_Tp>(__t); }





  template<typename _Tp>
    [[noreturn]]
    inline void
    throw_with_nested(_Tp&& __t)
    {
      using _Up = typename decay<_Tp>::type;
      using _CopyConstructible
 = __and_<is_copy_constructible<_Up>, is_move_constructible<_Up>>;
      static_assert(_CopyConstructible::value,
   "throw_with_nested argument must be CopyConstructible");
      using __nest = __and_<is_class<_Up>, __bool_constant<!__is_final(_Up)>,
       __not_<is_base_of<nested_exception, _Up>>>;
      std::__throw_with_nested_impl(std::forward<_Tp>(__t), __nest{});
    }




  template<typename _Tp>
    using __rethrow_if_nested_cond = typename enable_if<
      __and_<is_polymorphic<_Tp>,
      __or_<__not_<is_base_of<nested_exception, _Tp>>,
     is_convertible<_Tp*, nested_exception*>>>::value
    >::type;


  template<typename _Ex>
    inline __rethrow_if_nested_cond<_Ex>
    __rethrow_if_nested_impl(const _Ex* __ptr)
    {
      if (auto __ne_ptr = dynamic_cast<const nested_exception*>(__ptr))
 __ne_ptr->rethrow_nested();
    }


  inline void
  __rethrow_if_nested_impl(const void*)
  { }




  template<typename _Ex>
    inline void
    rethrow_if_nested(const _Ex& __ex)
    { std::__rethrow_if_nested_impl(std::__addressof(__ex)); }


}

}



#pragma GCC visibility pop
# 149 "/usr/local/include/c++/10.0.0/exception" 2 3
# 42 "/usr/local/include/c++/10.0.0/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }


    bad_alloc(const bad_alloc&) = default;
    bad_alloc& operator=(const bad_alloc&) = default;




    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };


  class bad_array_new_length : public bad_alloc
  {
  public:
    bad_array_new_length() throw() { }



    virtual ~bad_array_new_length() throw();


    virtual const char* what() const throw();
  };



  enum class align_val_t: size_t {};


  struct nothrow_t
  {

    explicit nothrow_t() = default;

  };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();



  new_handler get_new_handler() noexcept;

}
# 126 "/usr/local/include/c++/10.0.0/new" 3
[[__nodiscard__]] void* operator new(std::size_t)
  __attribute__((__externally_visible__));
[[__nodiscard__]] void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));

void operator delete(void*, std::size_t) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t) noexcept
  __attribute__((__externally_visible__));

[[__nodiscard__]] void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__, __malloc__));
[[__nodiscard__]] void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__, __malloc__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));

[[__nodiscard__]] void* operator new(std::size_t, std::align_val_t)
  __attribute__((__externally_visible__));
[[__nodiscard__]] void* operator new(std::size_t, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__, __malloc__));
void operator delete(void*, std::align_val_t)
  noexcept __attribute__((__externally_visible__));
void operator delete(void*, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__));
[[__nodiscard__]] void* operator new[](std::size_t, std::align_val_t)
  __attribute__((__externally_visible__));
[[__nodiscard__]] void* operator new[](std::size_t, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__, __malloc__));
void operator delete[](void*, std::align_val_t)
  noexcept __attribute__((__externally_visible__));
void operator delete[](void*, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__));

void operator delete(void*, std::size_t, std::align_val_t)
  noexcept __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t, std::align_val_t)
  noexcept __attribute__((__externally_visible__));




[[__nodiscard__]] inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
[[__nodiscard__]] inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}



namespace std
{


  template<typename _Tp>
    [[nodiscard]] constexpr _Tp*
    launder(_Tp* __p) noexcept
    { return __builtin_launder(__p); }




  template<typename _Ret, typename... _Args , bool _NE>
    void launder(_Ret (*)(_Args...) noexcept (_NE)) = delete;
  template<typename _Ret, typename... _Args , bool _NE>
    void launder(_Ret (*)(_Args......) noexcept (_NE)) = delete;

  void launder(void*) = delete;
  void launder(const void*) = delete;
  void launder(volatile void*) = delete;
  void launder(const volatile void*) = delete;
}




namespace std
{


  struct destroying_delete_t
  {
    explicit destroying_delete_t() = default;
  };

  inline constexpr destroying_delete_t destroying_delete{};
}






#pragma GCC visibility pop
# 79 "/usr/local/include/c++/10.0.0/bits/stl_iterator.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

# 109 "/usr/local/include/c++/10.0.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;
# 135 "/usr/local/include/c++/10.0.0/bits/stl_iterator.h" 3
      constexpr
      reverse_iterator() : current() { }




      explicit constexpr
      reverse_iterator(iterator_type __x) : current(__x) { }




      constexpr
      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }


      reverse_iterator& operator=(const reverse_iterator&) = default;






      template<typename _Iter>
 constexpr
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      constexpr iterator_type
      base() const
      { return current; }
# 181 "/usr/local/include/c++/10.0.0/bits/stl_iterator.h" 3
      constexpr reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      constexpr pointer
      operator->() const

      requires is_pointer_v<_Iterator>
 || requires(const _Iterator __i) { __i.operator->(); }

      {


 _Iterator __tmp = current;
 --__tmp;
 return _S_to_pointer(__tmp);
      }






      constexpr reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      constexpr reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      constexpr reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      constexpr reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      constexpr reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }







      constexpr reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      constexpr reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }







      constexpr reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      constexpr reference
      operator[](difference_type __n) const
      { return *(*this + __n); }

    private:
      template<typename _Tp>
 static constexpr _Tp*
 _S_to_pointer(_Tp* __p)
        { return __p; }

      template<typename _Tp>
 static constexpr pointer
 _S_to_pointer(_Tp __t)
        { return __t.operator->(); }
    };
# 332 "/usr/local/include/c++/10.0.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline constexpr bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline constexpr bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline constexpr bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline constexpr bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline constexpr bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline constexpr bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }



  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }
# 422 "/usr/local/include/c++/10.0.0/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    inline constexpr auto
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())
    { return __y.base() - __x.base(); }


  template<typename _Iterator>
    inline constexpr reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _Iterator>
    inline constexpr reverse_iterator<_Iterator>
    __make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }







  template<typename _Iterator>
    inline constexpr reverse_iterator<_Iterator>
    make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }


  template<typename _Iterator1, typename _Iterator2>
    requires (!sized_sentinel_for<_Iterator1, _Iterator2>)
    inline constexpr bool
    disable_sized_sentinel_for<reverse_iterator<_Iterator1>,
          reverse_iterator<_Iterator2>> = true;



  template<typename _Iterator>
    constexpr
    auto
    __niter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__niter_base(__it.base())))
    { return __make_reverse_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<reverse_iterator<_Iterator> >
      : __is_move_iterator<_Iterator>
    { };

  template<typename _Iterator>
    constexpr
    auto
    __miter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__miter_base(__it.base())))
    { return __make_reverse_iterator(__miter_base(__it.base())); }
# 494 "/usr/local/include/c++/10.0.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 529 "/usr/local/include/c++/10.0.0/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_back(__value);
 return *this;
      }

      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_back(std::move(__value));
 return *this;
      }



      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 571 "/usr/local/include/c++/10.0.0/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 586 "/usr/local/include/c++/10.0.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 620 "/usr/local/include/c++/10.0.0/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_front(__value);
 return *this;
      }

      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_front(std::move(__value));
 return *this;
      }



      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 662 "/usr/local/include/c++/10.0.0/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 681 "/usr/local/include/c++/10.0.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(std::__addressof(__x)), iter(__i) {}
# 732 "/usr/local/include/c++/10.0.0/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }

      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 iter = container->insert(iter, std::move(__value));
 ++iter;
 return *this;
      }



      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 777 "/usr/local/include/c++/10.0.0/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }




}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 801 "/usr/local/include/c++/10.0.0/bits/stl_iterator.h" 3
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef std::iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;


      using iterator_concept = std::__detail::__iter_concept<_Iterator>;


      constexpr __normal_iterator() noexcept
      : _M_current(_Iterator()) { }

      explicit constexpr
      __normal_iterator(const _Iterator& __i) noexcept
      : _M_current(__i) { }


      template<typename _Iter>
        constexpr
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i) noexcept
        : _M_current(__i.base()) { }


      constexpr
      reference
      operator*() const noexcept
      { return *_M_current; }

      constexpr
      pointer
      operator->() const noexcept
      { return _M_current; }

      constexpr
      __normal_iterator&
      operator++() noexcept
      {
 ++_M_current;
 return *this;
      }

      constexpr
      __normal_iterator
      operator++(int) noexcept
      { return __normal_iterator(_M_current++); }


      constexpr
      __normal_iterator&
      operator--() noexcept
      {
 --_M_current;
 return *this;
      }

      constexpr
      __normal_iterator
      operator--(int) noexcept
      { return __normal_iterator(_M_current--); }


      constexpr
      reference
      operator[](difference_type __n) const noexcept
      { return _M_current[__n]; }

      constexpr
      __normal_iterator&
      operator+=(difference_type __n) noexcept
      { _M_current += __n; return *this; }

      constexpr
      __normal_iterator
      operator+(difference_type __n) const noexcept
      { return __normal_iterator(_M_current + __n); }

      constexpr
      __normal_iterator&
      operator-=(difference_type __n) noexcept
      { _M_current -= __n; return *this; }

      constexpr
      __normal_iterator
      operator-(difference_type __n) const noexcept
      { return __normal_iterator(_M_current - __n); }

      constexpr
      const _Iterator&
      base() const noexcept
      { return _M_current; }
    };
# 916 "/usr/local/include/c++/10.0.0/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    constexpr
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    constexpr
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    constexpr
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    constexpr
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    constexpr
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    constexpr
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    constexpr
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    constexpr
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    constexpr
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    constexpr
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    constexpr
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    constexpr
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>


    constexpr
    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept
    -> decltype(__lhs.base() - __rhs.base())





    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    constexpr
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    constexpr
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    noexcept
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Iterator, typename _Container>
    constexpr
    _Iterator
    __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)
    noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)
    { return __it.base(); }
# 1069 "/usr/local/include/c++/10.0.0/bits/stl_iterator.h" 3
  template<semiregular _Sent>
    class move_sentinel
    {
    public:
      constexpr
      move_sentinel()
      noexcept(is_nothrow_default_constructible_v<_Sent>)
      : _M_last() { }

      constexpr explicit
      move_sentinel(_Sent __s)
      noexcept(is_nothrow_move_constructible_v<_Sent>)
      : _M_last(std::move(__s)) { }

      template<typename _S2> requires convertible_to<const _S2&, _Sent>
 constexpr
 move_sentinel(const move_sentinel<_S2>& __s)
 noexcept(is_nothrow_constructible_v<_Sent, const _S2&>)
 : _M_last(__s.base())
 { }

      template<typename _S2> requires assignable_from<_Sent&, const _S2&>
 constexpr move_sentinel&
 operator=(const move_sentinel<_S2>& __s)
 noexcept(is_nothrow_assignable_v<_Sent, const _S2&>)
 {
   _M_last = __s.base();
   return *this;
 }

      constexpr _Sent
      base() const
      noexcept(is_nothrow_copy_constructible_v<_Sent>)
      { return _M_last; }

    private:
      _Sent _M_last;
    };

  namespace __detail
  {


    template<typename _Cat, typename _Limit, typename _Otherwise = _Cat>
      using __clamp_iter_cat
 = conditional_t<derived_from<_Cat, _Limit>, _Limit, _Otherwise>;
  }
# 1127 "/usr/local/include/c++/10.0.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class move_iterator
    {
      _Iterator _M_current;

      using __traits_type = iterator_traits<_Iterator>;

      using __base_cat = typename __traits_type::iterator_category;




    public:
      using iterator_type = _Iterator;


      using iterator_concept = input_iterator_tag;
      using iterator_category
 = __detail::__clamp_iter_cat<__base_cat, random_access_iterator_tag>;
      using value_type = iter_value_t<_Iterator>;
      using difference_type = iter_difference_t<_Iterator>;
      using pointer = _Iterator;
      using reference = iter_rvalue_reference_t<_Iterator>;
# 1163 "/usr/local/include/c++/10.0.0/bits/stl_iterator.h" 3
      constexpr
      move_iterator()
      : _M_current() { }

      explicit constexpr
      move_iterator(iterator_type __i)
      : _M_current(__i) { }

      template<typename _Iter>
 constexpr
 move_iterator(const move_iterator<_Iter>& __i)
 : _M_current(__i.base()) { }

      constexpr iterator_type
      base() const
      { return _M_current; }

      constexpr reference
      operator*() const
      { return static_cast<reference>(*_M_current); }

      constexpr pointer
      operator->() const
      { return _M_current; }

      constexpr move_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      constexpr move_iterator
      operator++(int)
      {
 move_iterator __tmp = *this;
 ++_M_current;
 return __tmp;
      }

      constexpr move_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      constexpr move_iterator
      operator--(int)
      {
 move_iterator __tmp = *this;
 --_M_current;
 return __tmp;
      }

      constexpr move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }

      constexpr move_iterator&
      operator+=(difference_type __n)
      {
 _M_current += __n;
 return *this;
      }

      constexpr move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }

      constexpr move_iterator&
      operator-=(difference_type __n)
      {
 _M_current -= __n;
 return *this;
      }

      constexpr reference
      operator[](difference_type __n) const
      { return std::move(_M_current[__n]); }


      template<sentinel_for<_Iterator> _Sent>
 friend constexpr bool
 operator==(const move_iterator& __x, const move_sentinel<_Sent>& __y)
 { return __x.base() == __y.base(); }

      template<sized_sentinel_for<_Iterator> _Sent>
 friend constexpr iter_difference_t<_Iterator>
 operator-(const move_sentinel<_Sent>& __x, const move_iterator& __y)
 { return __x.base() - __y.base(); }

      template<sized_sentinel_for<_Iterator> _Sent>
 friend constexpr iter_difference_t<_Iterator>
 operator-(const move_iterator& __x, const move_sentinel<_Sent>& __y)
 { return __x.base() - __y.base(); }

      friend constexpr iter_rvalue_reference_t<_Iterator>
      iter_move(const move_iterator& __i)
      noexcept(noexcept(ranges::iter_move(__i._M_current)))
      { return ranges::iter_move(__i._M_current); }

      template<indirectly_swappable<_Iterator> _Iter2>
 friend constexpr void
 iter_swap(const move_iterator& __x, const move_iterator<_Iter2>& __y)
 noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))
 { return ranges::iter_swap(__x._M_current, __y._M_current); }

    };




  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator==(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline constexpr bool
    operator==(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator!=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline constexpr bool
    operator!=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator<(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __x.base() < __y.base(); }

  template<typename _Iterator>
    inline constexpr bool
    operator<(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator<=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline constexpr bool
    operator<=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator>(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline constexpr bool
    operator>(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline constexpr bool
    operator>=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline constexpr bool
    operator>=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x < __y); }


  template<typename _IteratorL, typename _IteratorR>
    inline constexpr auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline constexpr move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)
    { return __x + __n; }

  template<typename _Iterator>
    inline constexpr move_iterator<_Iterator>
    make_move_iterator(_Iterator __i)
    { return move_iterator<_Iterator>(__i); }

  template<typename _Iterator, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond
      <typename iterator_traits<_Iterator>::value_type>::value,
                _Iterator, move_iterator<_Iterator>>::type>
    inline constexpr _ReturnType
    __make_move_if_noexcept_iterator(_Iterator __i)
    { return _ReturnType(__i); }



  template<typename _Tp, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond<_Tp>::value,
      const _Tp*, move_iterator<_Tp*>>::type>
    inline constexpr _ReturnType
    __make_move_if_noexcept_iterator(_Tp* __i)
    { return _ReturnType(__i); }




  namespace __detail
  {
    template<input_or_output_iterator _It>
      class _Common_iter_proxy
      {
 iter_value_t<_It> _M_keep;

 _Common_iter_proxy(iter_reference_t<_It>&& __x)
 : _M_keep(std::move(__x)) { }

 template<typename _Iter, typename _Sent>
   friend class common_iterator;

      public:
 const iter_value_t<_It>*
 operator->() const
 { return std::__addressof(_M_keep); }
      };

    template<typename _It>
      concept __common_iter_has_arrow = readable<const _It>
 && (requires(const _It& __it) { __it.operator->(); }
     || is_reference_v<iter_reference_t<_It>>
     || constructible_from<iter_value_t<_It>, iter_reference_t<_It>>);

  }


  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
    requires (!same_as<_It, _Sent>)
  class common_iterator
  {
    template<typename _Tp, typename _Up>
      static constexpr bool
      _S_noexcept1()
      {
 if constexpr (is_trivially_default_constructible_v<_Tp>)
   return is_nothrow_assignable_v<_Tp, _Up>;
 else
   return is_nothrow_constructible_v<_Tp, _Up>;
      }

    template<typename _It2, typename _Sent2>
      static constexpr bool
      _S_noexcept()
      { return _S_noexcept1<_It, _It2>() && _S_noexcept1<_Sent, _Sent2>(); }

  public:
    constexpr
    common_iterator()
    noexcept(is_nothrow_default_constructible_v<_It>)
    : _M_it(), _M_index(0)
    { }

    constexpr
    common_iterator(_It __i)
    noexcept(is_nothrow_move_constructible_v<_It>)
    : _M_it(std::move(__i)), _M_index(0)
    { }

    constexpr
    common_iterator(_Sent __s)
    noexcept(is_nothrow_move_constructible_v<_Sent>)
    : _M_sent(std::move(__s)), _M_index(1)
    { }

    template<typename _It2, typename _Sent2>
      requires convertible_to<const _It2&, _It>
 && convertible_to<const _Sent2&, _Sent>
      constexpr
      common_iterator(const common_iterator<_It2, _Sent2>& __x)
      noexcept(_S_noexcept<const _It2&, const _Sent2&>())
      : _M_valueless(), _M_index(__x._M_index)
      {
 if (_M_index == 0)
   {
     if constexpr (is_trivially_default_constructible_v<_It>)
       _M_it = std::move(__x._M_it);
     else
       ::new((void*)std::__addressof(_M_it)) _It(__x._M_it);
   }
 else if (_M_index == 1)
   {
     if constexpr (is_trivially_default_constructible_v<_Sent>)
       _M_sent = std::move(__x._M_sent);
     else
       ::new((void*)std::__addressof(_M_sent)) _Sent(__x._M_sent);
   }
      }

    constexpr
    common_iterator(const common_iterator& __x)
    noexcept(_S_noexcept<const _It&, const _Sent&>())
    : _M_valueless(), _M_index(__x._M_index)
    {
      if (_M_index == 0)
 {
   if constexpr (is_trivially_default_constructible_v<_It>)
     _M_it = std::move(__x._M_it);
   else
     ::new((void*)std::__addressof(_M_it)) _It(__x._M_it);
 }
      else if (_M_index == 1)
 {
   if constexpr (is_trivially_default_constructible_v<_Sent>)
     _M_sent = std::move(__x._M_sent);
   else
     ::new((void*)std::__addressof(_M_sent)) _Sent(__x._M_sent);
 }
    }

    common_iterator&
    operator=(const common_iterator& __x)
    noexcept(is_nothrow_copy_assignable_v<_It>
      && is_nothrow_copy_assignable_v<_Sent>
      && is_nothrow_copy_constructible_v<_It>
      && is_nothrow_copy_constructible_v<_Sent>)
    {
      return this->operator=<_It, _Sent>(__x);
    }

    template<typename _It2, typename _Sent2>
      requires convertible_to<const _It2&, _It>
 && convertible_to<const _Sent2&, _Sent>
 && assignable_from<_It&, const _It2&>
 && assignable_from<_Sent&, const _Sent2&>
      common_iterator&
      operator=(const common_iterator<_It2, _Sent2>& __x)
      noexcept(is_nothrow_constructible_v<_It, const _It2&>
        && is_nothrow_constructible_v<_Sent, const _Sent2&>
        && is_nothrow_assignable_v<_It, const _It2&>
        && is_nothrow_assignable_v<_Sent, const _Sent2&>)
      {
 switch(_M_index << 2 | __x._M_index)
   {
   case 0b0000:
     _M_it = __x._M_it;
     break;
   case 0b0101:
     _M_sent = __x._M_sent;
     break;
   case 0b0001:
     _M_it.~_It();
     _M_index = -1;
     [[fallthrough]];
   case 0b1001:
     ::new((void*)std::__addressof(_M_sent)) _Sent(__x._M_sent);
     _M_index = 1;
     break;
   case 0b0100:
     _M_sent.~_Sent();
     _M_index = -1;
     [[fallthrough]];
   case 0b1000:
     ::new((void*)std::__addressof(_M_it)) _It(__x._M_it);
     _M_index = 0;
     break;
   default:
     ;
     __builtin_unreachable();
   }
 return *this;
      }

    ~common_iterator()
    {
      switch (_M_index)
 {
 case 0:
   _M_it.~_It();
   break;
 case 1:
   _M_sent.~_Sent();
   break;
 }
    }

    decltype(auto)
    operator*()
    {
      ;
      return *_M_it;
    }

    decltype(auto)
    operator*() const requires __detail::__dereferenceable<const _It>
    {
      ;
      return *_M_it;
    }

    decltype(auto)
    operator->() const requires __detail::__common_iter_has_arrow<_It>
    {
      ;
      if constexpr (is_pointer_v<_It> || requires { _M_it.operator->(); })
 return _M_it;
      else if constexpr (is_reference_v<iter_reference_t<_It>>)
 {
   auto&& __tmp = *_M_it;
   return std::__addressof(__tmp);
 }
      else
 return _Common_iter_proxy(*_M_it);
    }

    common_iterator&
    operator++()
    {
      ;
      ++_M_it;
      return *this;
    }

    decltype(auto)
    operator++(int)
    {
      ;
      if constexpr (forward_iterator<_It>)
 {
   common_iterator __tmp = *this;
   ++*this;
   return __tmp;
 }
      else
 return _M_it++;
    }

    template<typename _It2, sentinel_for<_It> _Sent2>
      requires sentinel_for<_Sent, _It2>
      friend bool
      operator==(const common_iterator& __x,
   const common_iterator<_It2, _Sent2>& __y)
      {
 switch(__x._M_index << 2 | __y._M_index)
   {
   case 0b0000:
   case 0b0101:
     return true;
   case 0b0001:
     return __x._M_it == __y._M_sent;
   case 0b0100:
     return __x._M_sent == __y._M_it;
   default:
     ;
     ;
     __builtin_unreachable();
   }
      }

    template<typename _It2, sentinel_for<_It> _Sent2>
      requires sentinel_for<_Sent, _It2> && equality_comparable_with<_It, _It2>
      friend bool
      operator==(const common_iterator& __x,
   const common_iterator<_It2, _Sent2>& __y)
      {
 switch(__x._M_index << 2 | __y._M_index)
   {
   case 0b0101:
     return true;
   case 0b0000:
     return __x._M_it == __y._M_it;
   case 0b0001:
     return __x._M_it == __y._M_sent;
   case 0b0100:
     return __x._M_sent == __y._M_it;
   default:
     ;
     ;
     __builtin_unreachable();
   }
      }

    template<sized_sentinel_for<_It> _It2, sized_sentinel_for<_It> _Sent2>
      requires sized_sentinel_for<_Sent, _It2>
      friend iter_difference_t<_It2>
      operator-(const common_iterator& __x,
  const common_iterator<_It2, _Sent2>& __y)
      {
 switch(__x._M_index << 2 | __y._M_index)
   {
   case 0b0101:
     return 0;
   case 0b0000:
     return __x._M_it - __y._M_it;
   case 0b0001:
     return __x._M_it - __y._M_sent;
   case 0b0100:
     return __x._M_sent - __y._M_it;
   default:
     ;
     ;
     __builtin_unreachable();
   }
      }

    friend iter_rvalue_reference_t<_It>
    iter_move(const common_iterator& __i)
    noexcept(noexcept(ranges::iter_move(std::declval<const _It&>())))
    requires input_iterator<_It>
    {
      ;
      return ranges::iter_move(__i._M_it);
    }

    template<indirectly_swappable<_It> _It2, typename _Sent2>
      friend void
      iter_swap(const common_iterator& __x,
  const common_iterator<_It2, _Sent2>& __y)
      noexcept(noexcept(ranges::iter_swap(std::declval<const _It&>(),
       std::declval<const _It2&>())))
      {
 ;
 ;
 return ranges::iter_swap(__x._M_it, __y._M_it);
      }

  private:
    template<input_or_output_iterator _It2, sentinel_for<_It2> _Sent2>
      friend class common_iterator;

    bool _M_has_value() const noexcept { return _M_index < 2; }

    union
    {
      _It _M_it;
      _Sent _M_sent;
      unsigned char _M_valueless;
    };
    unsigned char _M_index;
  };

  template<typename _It, typename _Sent>
    struct incrementable_traits<common_iterator<_It, _Sent>>
    {
      using difference_type = iter_difference_t<_It>;
    };

  namespace __detail
  {

    template<typename _Iter>
      struct __common_iter_ptr
 {
   using type = void;
 };

    template<typename _Iter>
      requires __detail::__common_iter_has_arrow<_Iter>
      struct __common_iter_ptr<_Iter>
      {
 using type = decltype(std::declval<const _Iter&>().operator->());
      };
  }

  template<input_iterator _It, typename _Sent>
    struct iterator_traits<common_iterator<_It, _Sent>>
    {
      using iterator_concept = conditional_t<forward_iterator<_It>,
     forward_iterator_tag, input_iterator_tag>;
      using iterator_category = __detail::__clamp_iter_cat<
 typename iterator_traits<_It>::iterator_category,
 forward_iterator_tag, input_iterator_tag>;
      using value_type = iter_value_t<_It>;
      using difference_type = iter_difference_t<_It>;
      using pointer = typename
 __detail::__common_iter_ptr<common_iterator<_It, _Sent>>::type;
      using reference = iter_reference_t<_It>;
    };




  template<input_or_output_iterator _It>
    class counted_iterator
    {
    public:
      using iterator_type = _It;

      constexpr counted_iterator() = default;

      constexpr
      counted_iterator(_It __i, iter_difference_t<_It> __n)
      : _M_current(__i), _M_length(__n)
      { ; }

      template<typename _It2>
 requires convertible_to<const _It2&, _It>
 constexpr
 counted_iterator(const counted_iterator<_It2>& __x)
 : _M_current(__x._M_current), _M_length(__x._M_length)
 { }

      template<typename _It2>
 requires assignable_from<_It&, const _It2&>
 constexpr counted_iterator&
 operator=(const counted_iterator<_It2>& __x)
 {
   _M_current = __x._M_current;
   _M_length = __x._M_length;
   return *this;
 }

      constexpr _It
      base() const &
      noexcept(is_nothrow_copy_constructible_v<_It>)
      requires copy_constructible<_It>
      { return _M_current; }

      constexpr _It
      base() &&
      noexcept(is_nothrow_move_constructible_v<_It>)
      { return std::move(_M_current); }

      constexpr iter_difference_t<_It>
      count() const noexcept { return _M_length; }

      constexpr decltype(auto)
      operator*()
      noexcept(noexcept(*_M_current))
      { return *_M_current; }

      constexpr decltype(auto)
      operator*() const
      noexcept(noexcept(*_M_current))
      requires __detail::__dereferenceable<const _It>
      { return *_M_current; }

      constexpr counted_iterator&
      operator++()
      {
 ;
 ++_M_current;
 --_M_length;
 return *this;
      }

      decltype(auto)
      operator++(int)
      {
 ;
 --_M_length;
 try
   {
     return _M_current++;
   } catch(...) {
     ++_M_length;
     throw;
   }

      }

      constexpr counted_iterator
      operator++(int) requires forward_iterator<_It>
      {
 auto __tmp = *this;
 ++*this;
 return __tmp;
      }

      constexpr counted_iterator&
      operator--() requires bidirectional_iterator<_It>
      {
 --_M_current;
 ++_M_length;
 return *this;
      }

      constexpr counted_iterator
      operator--(int) requires bidirectional_iterator<_It>
      {
 auto __tmp = *this;
 --*this;
 return __tmp;
      }

      constexpr counted_iterator
      operator+(iter_difference_t<_It> __n) const
 requires random_access_iterator<_It>
      { return counted_iterator(_M_current + __n, _M_length - __n); }

      friend constexpr counted_iterator
      operator+(iter_difference_t<_It> __n, const counted_iterator& __x)
      requires random_access_iterator<_It>
      { return __x + __n; }

      constexpr counted_iterator&
      operator+=(iter_difference_t<_It> __n)
      requires random_access_iterator<_It>
      {
 ;
 _M_current += __n;
 _M_length -= __n;
 return *this;
      }

      constexpr counted_iterator
      operator-(iter_difference_t<_It> __n) const
      requires random_access_iterator<_It>
      { return counted_iterator(_M_current - __n, _M_length + __n); }

      template<common_with<_It> _It2>
 friend constexpr iter_difference_t<_It2>
 operator-(const counted_iterator& __x,
    const counted_iterator<_It2>& __y)
 { return __y._M_length - __x._M_length; }

      friend constexpr iter_difference_t<_It>
      operator-(const counted_iterator& __x, default_sentinel_t)
      { return -__x._M_length; }

      friend constexpr iter_difference_t<_It>
      operator-(default_sentinel_t, const counted_iterator& __y)
      { return __y._M_length; }

      constexpr counted_iterator&
      operator-=(iter_difference_t<_It> __n)
      requires random_access_iterator<_It>
      {
 ;
 _M_current -= __n;
 _M_length += __n;
 return *this;
      }

      constexpr decltype(auto)
      operator[](iter_difference_t<_It> __n) const
      noexcept(noexcept(_M_current[__n]))
      requires random_access_iterator<_It>
      {
 ;
 return _M_current[__n];
      }

      template<common_with<_It> _It2>
 friend constexpr bool
 operator==(const counted_iterator& __x,
     const counted_iterator<_It2>& __y)
 { return __x._M_length == __y._M_length; }

      friend constexpr bool
      operator==(const counted_iterator& __x, default_sentinel_t)
      { return __x._M_length == 0; }

      template<common_with<_It> _It2>
 friend constexpr strong_ordering
 operator<=>(const counted_iterator& __x,
      const counted_iterator<_It2>& __y)
 { return __y._M_length <=> __x._M_length; }

      friend constexpr iter_rvalue_reference_t<_It>
      iter_move(const counted_iterator& __i)
      noexcept(noexcept(ranges::iter_move(__i._M_current)))
      requires input_iterator<_It>
      { return ranges::iter_move(__i._M_current); }

      template<indirectly_swappable<_It> _It2>
 friend constexpr void
 iter_swap(const counted_iterator& __x,
    const counted_iterator<_It2>& __y)
 noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))
 { ranges::iter_swap(__x._M_current, __y._M_current); }

    private:
      template<input_or_output_iterator _It2> friend class counted_iterator;

      _It _M_current = _It();
      iter_difference_t<_It> _M_length = 0;
    };

  template<typename _It>
    struct incrementable_traits<counted_iterator<_It>>
    {
      using difference_type = iter_difference_t<_It>;
    };

  template<input_iterator _It>
    struct iterator_traits<counted_iterator<_It>> : iterator_traits<_It>
    {
      using pointer = void;
    };




  template<typename _Iterator>
    auto
    __niter_base(move_iterator<_Iterator> __it)
    -> decltype(make_move_iterator(__niter_base(__it.base())))
    { return make_move_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<typename _Iterator>
    auto
    __miter_base(move_iterator<_Iterator> __it)
    -> decltype(__miter_base(__it.base()))
    { return __miter_base(__it.base()); }
# 2002 "/usr/local/include/c++/10.0.0/bits/stl_iterator.h" 3
  template<typename _InputIterator>
    using __iter_key_t = remove_const_t<
    typename iterator_traits<_InputIterator>::value_type::first_type>;

  template<typename _InputIterator>
    using __iter_val_t =
    typename iterator_traits<_InputIterator>::value_type::second_type;

  template<typename _T1, typename _T2>
    struct pair;

  template<typename _InputIterator>
    using __iter_to_alloc_t =
    pair<add_const_t<__iter_key_t<_InputIterator>>,
  __iter_val_t<_InputIterator>>;



}
# 68 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 2 3

# 1 "/usr/local/include/c++/10.0.0/debug/debug.h" 1 3
# 48 "/usr/local/include/c++/10.0.0/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;

  template<typename _Ite, typename _Seq, typename _Cat>
    struct _Safe_iterator;
}
# 70 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 2 3

# 1 "/usr/local/include/c++/10.0.0/bits/predefined_ops.h" 1 3
# 33 "/usr/local/include/c++/10.0.0/bits/predefined_ops.h" 3
namespace __gnu_cxx
{
namespace __ops
{
  struct _Iter_less_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      constexpr
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 < *__it2; }
  };

  constexpr
  inline _Iter_less_iter
  __iter_less_iter()
  { return _Iter_less_iter(); }

  struct _Iter_less_val
  {

    constexpr _Iter_less_val() = default;




    constexpr
    explicit
    _Iter_less_val(_Iter_less_iter) { }

    template<typename _Iterator, typename _Value>
      constexpr
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it < __val; }
  };

  constexpr
  inline _Iter_less_val
  __iter_less_val()
  { return _Iter_less_val(); }

  constexpr
  inline _Iter_less_val
  __iter_comp_val(_Iter_less_iter)
  { return _Iter_less_val(); }

  struct _Val_less_iter
  {

    constexpr _Val_less_iter() = default;




    constexpr
    explicit
    _Val_less_iter(_Iter_less_iter) { }

    template<typename _Value, typename _Iterator>
      constexpr
      bool
      operator()(_Value& __val, _Iterator __it) const
      { return __val < *__it; }
  };

  constexpr
  inline _Val_less_iter
  __val_less_iter()
  { return _Val_less_iter(); }

  constexpr
  inline _Val_less_iter
  __val_comp_iter(_Iter_less_iter)
  { return _Val_less_iter(); }

  struct _Iter_equal_to_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      constexpr
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 == *__it2; }
  };

  constexpr
  inline _Iter_equal_to_iter
  __iter_equal_to_iter()
  { return _Iter_equal_to_iter(); }

  struct _Iter_equal_to_val
  {
    template<typename _Iterator, typename _Value>
      constexpr
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it == __val; }
  };

  constexpr
  inline _Iter_equal_to_val
  __iter_equal_to_val()
  { return _Iter_equal_to_val(); }

  constexpr
  inline _Iter_equal_to_val
  __iter_comp_val(_Iter_equal_to_iter)
  { return _Iter_equal_to_val(); }

  template<typename _Compare>
    struct _Iter_comp_iter
    {
      _Compare _M_comp;

      explicit constexpr
      _Iter_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      template<typename _Iterator1, typename _Iterator2>
        constexpr
        bool
        operator()(_Iterator1 __it1, _Iterator2 __it2)
        { return bool(_M_comp(*__it1, *__it2)); }
    };

  template<typename _Compare>
    constexpr
    inline _Iter_comp_iter<_Compare>
    __iter_comp_iter(_Compare __comp)
    { return _Iter_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Iter_comp_val
    {
      _Compare _M_comp;

      constexpr
      explicit
      _Iter_comp_val(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      constexpr
      explicit
      _Iter_comp_val(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


      constexpr
      explicit
      _Iter_comp_val(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Iterator, typename _Value>
 constexpr
 bool
 operator()(_Iterator __it, _Value& __val)
 { return bool(_M_comp(*__it, __val)); }
    };

  template<typename _Compare>
    constexpr
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Compare __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    constexpr
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Iter_comp_iter<_Compare> __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Val_comp_iter
    {
      _Compare _M_comp;

      constexpr
      explicit
      _Val_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      constexpr
      explicit
      _Val_comp_iter(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


      constexpr
      explicit
      _Val_comp_iter(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Value, typename _Iterator>
 constexpr
 bool
 operator()(_Value& __val, _Iterator __it)
 { return bool(_M_comp(__val, *__it)); }
    };

  template<typename _Compare>
    constexpr
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Compare __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    constexpr
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Iter_comp_iter<_Compare> __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Value>
    struct _Iter_equals_val
    {
      _Value& _M_value;

      constexpr
      explicit
      _Iter_equals_val(_Value& __value)
 : _M_value(__value)
      { }

      template<typename _Iterator>
 constexpr
 bool
 operator()(_Iterator __it)
 { return *__it == _M_value; }
    };

  template<typename _Value>
    constexpr
    inline _Iter_equals_val<_Value>
    __iter_equals_val(_Value& __val)
    { return _Iter_equals_val<_Value>(__val); }

  template<typename _Iterator1>
    struct _Iter_equals_iter
    {
      _Iterator1 _M_it1;

      constexpr
      explicit
      _Iter_equals_iter(_Iterator1 __it1)
 : _M_it1(__it1)
      { }

      template<typename _Iterator2>
 constexpr
 bool
 operator()(_Iterator2 __it2)
 { return *__it2 == *_M_it1; }
    };

  template<typename _Iterator>
    constexpr
    inline _Iter_equals_iter<_Iterator>
    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)
    { return _Iter_equals_iter<_Iterator>(__it); }

  template<typename _Predicate>
    struct _Iter_pred
    {
      _Predicate _M_pred;

      constexpr
      explicit
      _Iter_pred(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>
 constexpr
 bool
 operator()(_Iterator __it)
 { return bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    constexpr
    inline _Iter_pred<_Predicate>
    __pred_iter(_Predicate __pred)
    { return _Iter_pred<_Predicate>(std::move(__pred)); }

  template<typename _Compare, typename _Value>
    struct _Iter_comp_to_val
    {
      _Compare _M_comp;
      _Value& _M_value;

      constexpr
      _Iter_comp_to_val(_Compare __comp, _Value& __value)
 : _M_comp(std::move(__comp)), _M_value(__value)
      { }

      template<typename _Iterator>
 constexpr
 bool
 operator()(_Iterator __it)
 { return bool(_M_comp(*__it, _M_value)); }
    };

  template<typename _Compare, typename _Value>
    _Iter_comp_to_val<_Compare, _Value>
    constexpr
    __iter_comp_val(_Compare __comp, _Value &__val)
    {
      return _Iter_comp_to_val<_Compare, _Value>(std::move(__comp), __val);
    }

  template<typename _Compare, typename _Iterator1>
    struct _Iter_comp_to_iter
    {
      _Compare _M_comp;
      _Iterator1 _M_it1;

      constexpr
      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
 : _M_comp(std::move(__comp)), _M_it1(__it1)
      { }

      template<typename _Iterator2>
 constexpr
 bool
 operator()(_Iterator2 __it2)
 { return bool(_M_comp(*__it2, *_M_it1)); }
    };

  template<typename _Compare, typename _Iterator>
    constexpr
    inline _Iter_comp_to_iter<_Compare, _Iterator>
    __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)
    {
      return _Iter_comp_to_iter<_Compare, _Iterator>(
   std::move(__comp._M_comp), __it);
    }

  template<typename _Predicate>
    struct _Iter_negate
    {
      _Predicate _M_pred;

      constexpr
      explicit
      _Iter_negate(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>
 constexpr
 bool
 operator()(_Iterator __it)
 { return !bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    constexpr
    inline _Iter_negate<_Predicate>
    __negate(_Iter_pred<_Predicate> __pred)
    { return _Iter_negate<_Predicate>(std::move(__pred._M_pred)); }

}
}
# 72 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 2 3







namespace std __attribute__ ((__visibility__ ("default")))
{






  template<bool _IsMove, typename _Tp>
    constexpr
    inline void*
    __memmove(_Tp* __dst, const _Tp* __src, size_t __num)
    {

      if (std::is_constant_evaluated())
 {
   for(; __num > 0; --__num)
     {
       if constexpr (_IsMove)
  *__dst = std::move(*__src);
       else
  *__dst = *__src;
       ++__src;
       ++__dst;
     }
   return __dst;
 }
      else

 return __builtin_memmove(__dst, __src, sizeof(_Tp) * __num);
      return __dst;
    }





  template<typename _Tp>
    constexpr
    inline int
    __memcmp(const _Tp* __first1, const _Tp* __first2, size_t __num)
    {

      if (std::is_constant_evaluated())
 {
   for(; __num > 0; ++__first1, ++__first2, --__num)
     if (*__first1 != *__first2)
       return *__first1 < *__first2 ? -1 : 1;
   return 0;
 }
      else

 return __builtin_memcmp(__first1, __first2, sizeof(_Tp) * __num);
    }
# 177 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    constexpr
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {

     

     
# 208 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 3
      swap(*__a, *__b);

    }
# 224 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    constexpr
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 253 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 3
  template<typename _Tp>
    constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 277 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 3
  template<typename _Tp>
    constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 301 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 323 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
    constexpr
    inline _Iterator
    __niter_base(_Iterator __it)
    noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)
    { return __it; }




  template<typename _From, typename _To>
    constexpr
    inline _From
    __niter_wrap(_From __from, _To __res)
    { return __from + (__res - std::__niter_base(__from)); }


  template<typename _Iterator>
    constexpr
    inline _Iterator
    __niter_wrap(const _Iterator&, _Iterator __res)
    { return __res; }







  template<bool _IsMove, bool _IsSimple, typename _Category>
    struct __copy_move
    {
      template<typename _II, typename _OI>
 constexpr
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = *__first;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>
 constexpr
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = std::move(*__first);
   return __result;
 }
    };


  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
 constexpr
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
 constexpr
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = std::move(*__first);
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
 constexpr
 static _Tp*
 __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
 {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     std::__memmove<_IsMove>(__result, __first, _Num);
   return __result + _Num;
 }
    };



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    constexpr
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_trivially_copyable(_ValueTypeI)
        && __is_pointer<_II>::__value
        && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);
      return std::__copy_move<_IsMove, __simple,
         _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _Tp, typename _Ref, typename _Ptr>
    struct _Deque_iterator;



  template<bool _IsMove,
    typename _Tp, typename _Ref, typename _Ptr, typename _OI>
    _OI
    __copy_move_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
     std::_Deque_iterator<_Tp, _Ref, _Ptr>,
     _OI);

  template<bool _IsMove,
    typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
    std::_Deque_iterator<_OTp, _OTp&, _OTp*>
    __copy_move_a1(std::_Deque_iterator<_ITp, _IRef, _IPtr>,
     std::_Deque_iterator<_ITp, _IRef, _IPtr>,
     std::_Deque_iterator<_OTp, _OTp&, _OTp*>);

  template<bool _IsMove, typename _II, typename _Tp>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value,
      std::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
    __copy_move_a1(_II, _II, std::_Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<bool _IsMove, typename _II, typename _OI>
    constexpr
    inline _OI
    __copy_move_a1(_II __first, _II __last, _OI __result)
    { return std::__copy_move_a2<_IsMove>(__first, __last, __result); }

  template<bool _IsMove, typename _II, typename _OI>
    constexpr
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      return std::__niter_wrap(__result,
  std::__copy_move_a1<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }

  template<bool _IsMove,
    typename _Ite, typename _Seq, typename _Cat, typename _OI>
    _OI
    __copy_move_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
    const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
    _OI);

  template<bool _IsMove,
    typename _II, typename _Ite, typename _Seq, typename _Cat>
    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __copy_move_a(_II, _II,
    const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);

  template<bool _IsMove,
    typename _IIte, typename _ISeq, typename _ICat,
    typename _OIte, typename _OSeq, typename _OCat>
    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>
    __copy_move_a(const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
    const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
    const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);
# 584 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    constexpr
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a<__is_move_iterator<_II>::__value>
      (std::__miter_base(__first), std::__miter_base(__last), __result);
    }
# 617 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    constexpr
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a<true>(std::__miter_base(__first),
          std::__miter_base(__last), __result);
    }






  template<bool _IsMove, bool _IsSimple, typename _Category>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
 constexpr
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>
 constexpr
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   while (__first != __last)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
 constexpr
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   typename iterator_traits<_BI1>::difference_type
     __n = __last - __first;
   for (; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
 constexpr
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   typename iterator_traits<_BI1>::difference_type
     __n = __last - __first;
   for (; __n > 0; --__n)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
 constexpr
 static _Tp*
 __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
 {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     std::__memmove<_IsMove>(__result - _Num, __first, _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    constexpr
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_trivially_copyable(_ValueType1)
        && __is_pointer<_BI1>::__value
        && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);


      if (std::is_constant_evaluated())
 return std::__copy_move_backward<true, false,
         _Category>::__copy_move_b(__first, __last,
       __result);

      return std::__copy_move_backward<_IsMove, __simple,
           _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    constexpr
    inline _BI2
    __copy_move_backward_a1(_BI1 __first, _BI1 __last, _BI2 __result)
    { return std::__copy_move_backward_a2<_IsMove>(__first, __last, __result); }

  template<bool _IsMove,
    typename _Tp, typename _Ref, typename _Ptr, typename _OI>
    _OI
    __copy_move_backward_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
       std::_Deque_iterator<_Tp, _Ref, _Ptr>,
       _OI);

  template<bool _IsMove,
    typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
    std::_Deque_iterator<_OTp, _OTp&, _OTp*>
    __copy_move_backward_a1(
   std::_Deque_iterator<_ITp, _IRef, _IPtr>,
   std::_Deque_iterator<_ITp, _IRef, _IPtr>,
   std::_Deque_iterator<_OTp, _OTp&, _OTp*>);

  template<bool _IsMove, typename _II, typename _Tp>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value,
      std::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
    __copy_move_backward_a1(_II, _II,
       std::_Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<bool _IsMove, typename _II, typename _OI>
    constexpr
    inline _OI
    __copy_move_backward_a(_II __first, _II __last, _OI __result)
    {
      return std::__niter_wrap(__result,
  std::__copy_move_backward_a1<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }

  template<bool _IsMove,
    typename _Ite, typename _Seq, typename _Cat, typename _OI>
    _OI
    __copy_move_backward_a(
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
  _OI);

  template<bool _IsMove,
    typename _II, typename _Ite, typename _Seq, typename _Cat>
    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __copy_move_backward_a(_II, _II,
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);

  template<bool _IsMove,
    typename _IIte, typename _ISeq, typename _ICat,
    typename _OIte, typename _OSeq, typename _OCat>
    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>
    __copy_move_backward_a(
  const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
  const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
  const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);
# 828 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    constexpr
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return std::__copy_move_backward_a<__is_move_iterator<_BI1>::__value>
      (std::__miter_base(__first), std::__miter_base(__last), __result);
    }
# 864 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    constexpr
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return std::__copy_move_backward_a<true>(std::__miter_base(__first),
            std::__miter_base(__last),
            __result);
    }






  template<typename _ForwardIterator, typename _Tp>
    constexpr
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    constexpr
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a1(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      if (const size_t __len = __last - __first)
 __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }

  template<typename _Ite, typename _Cont, typename _Tp>
    constexpr
    inline void
    __fill_a1(::__gnu_cxx::__normal_iterator<_Ite, _Cont> __first,
       ::__gnu_cxx::__normal_iterator<_Ite, _Cont> __last,
       const _Tp& __value)
    { std::__fill_a1(__first.base(), __last.base(), __value); }

  template<typename _Tp, typename _VTp>
    void
    __fill_a1(const std::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
       const std::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
       const _VTp&);

  template<typename _FIte, typename _Tp>
    constexpr
    inline void
    __fill_a(_FIte __first, _FIte __last, const _Tp& __value)
    { std::__fill_a1(__first, __last, __value); }

  template<typename _Ite, typename _Seq, typename _Cat, typename _Tp>
    void
    __fill_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
      const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
      const _Tp&);
# 959 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    constexpr
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(__first, __last, __value);
    }


  inline constexpr int
  __size_to_integer(int __n) { return __n; }
  inline constexpr unsigned
  __size_to_integer(unsigned __n) { return __n; }
  inline constexpr long
  __size_to_integer(long __n) { return __n; }
  inline constexpr unsigned long
  __size_to_integer(unsigned long __n) { return __n; }
  inline constexpr long long
  __size_to_integer(long long __n) { return __n; }
  inline constexpr unsigned long long
  __size_to_integer(unsigned long long __n) { return __n; }
# 1011 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 3
  inline constexpr long long
  __size_to_integer(float __n) { return __n; }
  inline constexpr long long
  __size_to_integer(double __n) { return __n; }
  inline constexpr long long
  __size_to_integer(long double __n) { return __n; }





  template<typename _OutputIterator, typename _Size, typename _Tp>
    constexpr
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (; __n > 0; --__n, (void) ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    constexpr
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __n > 0; --__n, (void) ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Ite, typename _Seq, typename _Cat, typename _Size,
    typename _Tp>
    ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __fill_n_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>& __first,
        _Size __n, const _Tp& __value,
        std::input_iterator_tag);

  template<typename _OutputIterator, typename _Size, typename _Tp>
    constexpr
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::output_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      return __fill_n_a1(__first, __n, __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    constexpr
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::input_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      return __fill_n_a1(__first, __n, __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    constexpr
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::random_access_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      if (__n <= 0)
 return __first;

      ;

      std::__fill_a(__first, __first + __n, __value);
      return __first + __n;
    }
# 1111 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    constexpr
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     

      return std::__fill_n_a(__first, std::__size_to_integer(__n), __value,
          std::__iterator_category(__first));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
 constexpr
 static bool
 equal(_II1 __first1, _II1 __last1, _II2 __first2)
 {
   for (; __first1 != __last1; ++__first1, (void) ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
 constexpr
 static bool
 equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
 {
   if (const size_t __len = (__last1 - __first1))
     return !std::__memcmp(__first1, __first2, __len);
   return true;
 }
    };

  template<typename _Tp, typename _Ref, typename _Ptr, typename _II>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value, bool>::__type
    __equal_aux1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
   std::_Deque_iterator<_Tp, _Ref, _Ptr>,
   _II);

  template<typename _Tp1, typename _Ref1, typename _Ptr1,
    typename _Tp2, typename _Ref2, typename _Ptr2>
    bool
    __equal_aux1(std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
   std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
   std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

  template<typename _II, typename _Tp, typename _Ref, typename _Ptr>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value, bool>::__type
    __equal_aux1(_II, _II,
  std::_Deque_iterator<_Tp, _Ref, _Ptr>);

  template<typename _II1, typename _II2>
    constexpr
    inline bool
    __equal_aux1(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = ((__is_integer<_ValueType1>::__value
         || __is_pointer<_ValueType1>::__value)
        && __is_pointer<_II1>::__value
        && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }

  template<typename _II1, typename _II2>
    constexpr
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      return std::__equal_aux1(std::__niter_base(__first1),
          std::__niter_base(__last1),
          std::__niter_base(__first2));
    }

  template<typename _II1, typename _Seq1, typename _Cat1, typename _II2>
    bool
    __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  _II2);

  template<typename _II1, typename _II2, typename _Seq2, typename _Cat2>
    bool
    __equal_aux(_II1, _II1,
  const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>&);

  template<typename _II1, typename _Seq1, typename _Cat1,
    typename _II2, typename _Seq2, typename _Cat2>
    bool
    __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>&);

  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
 constexpr
 static _II1
 __newlast1(_II1, _II1 __last1, _II2, _II2)
 { return __last1; }

      template<typename _II>
 constexpr
 static bool
 __cnd2(_II __first, _II __last)
 { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
 constexpr
 static _RAI1
 __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
 {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
 static constexpr bool
 __cnd2(_RAI, _RAI)
 { return true; }
    };

  template<typename _II1, typename _II2, typename _Compare>
    constexpr
    bool
    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2,
       _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, (void)++__first2)
 {
   if (__comp(__first1, __first2))
     return true;
   if (__comp(__first2, __first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
 constexpr
 static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      constexpr
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 return std::__lexicographical_compare_impl(__first1, __last1,
         __first2, __last2,
     __gnu_cxx::__ops::__iter_less_iter());
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
 constexpr
 static bool
 __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   if (const size_t __len = std::min(__len1, __len2))
     if (int __result = std::__memcmp(__first1, __first2, __len))
       return __result < 0;
   return __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    constexpr
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    constexpr
    _ForwardIterator
    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 1373 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    constexpr
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

      ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val());
    }



  inline constexpr int
  __lg(int __n)
  { return (int)sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr unsigned
  __lg(unsigned __n)
  { return (int)sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr long
  __lg(long __n)
  { return (int)sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr unsigned long
  __lg(unsigned long __n)
  { return (int)sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr long long
  __lg(long long __n)
  { return (int)sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }

  inline constexpr unsigned long long
  __lg(unsigned long long __n)
  { return (int)sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }


# 1429 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    constexpr
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(__first1, __last1, __first2);
    }
# 1460 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    constexpr
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }



  template<typename _II1, typename _II2>
    constexpr
    inline bool
    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!(*__first1 == *__first2))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }


  template<typename _II1, typename _II2, typename _BinaryPredicate>
    constexpr
    inline bool
    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2,
      _BinaryPredicate __binary_pred)
    {
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2,
           __binary_pred);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
# 1550 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    constexpr
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {

     
     
     


      ;
      ;

      return std::__equal4(__first1, __last1, __first2, __last2);
    }
# 1583 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    constexpr
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      return std::__equal4(__first1, __last1, __first2, __last2,
          __binary_pred);
    }
# 1615 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    constexpr
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {





     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
# 1652 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    constexpr
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {

     
     
      ;
      ;

      return std::__lexicographical_compare_impl
 (__first1, __last1, __first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }





  template<typename _Iter>
    concept __is_byte_iter = contiguous_iterator<_Iter>
      && __is_byte<iter_value_t<_Iter>>::__value != 0
      && !__gnu_cxx::__numeric_traits<iter_value_t<_Iter>>::__is_signed;



  template<typename _Tp>
    constexpr auto
    __min_cmp(_Tp __x, _Tp __y)
    {
      struct _Res {
 _Tp _M_min;
 decltype(__x <=> __y) _M_cmp;
      };
      auto __c = __x <=> __y;
      if (__c > 0)
 return _Res{__y, __c};
      return _Res{__x, __c};
    }
# 1706 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 3
  template<typename _InputIter1, typename _InputIter2, typename _Comp>
    constexpr auto
    lexicographical_compare_three_way(_InputIter1 __first1,
          _InputIter1 __last1,
          _InputIter2 __first2,
          _InputIter2 __last2,
          _Comp __comp)
    -> decltype(__comp(*__first1, *__first2))
    {

     
     
      ;
      ;


      using _Cat = decltype(__comp(*__first1, *__first2));
      static_assert(same_as<common_comparison_category_t<_Cat>, _Cat>);

      if (!std::is_constant_evaluated())
 if constexpr (same_as<_Comp, __detail::_Synth3way>
        || same_as<_Comp, compare_three_way>)
   if constexpr (__is_byte_iter<_InputIter1>)
     if constexpr (__is_byte_iter<_InputIter2>)
       {
  const auto [__len, __lencmp]
    = std::__min_cmp(__last1 - __first1, __last2 - __first2);
  if (__len)
    {
      const auto __c
        = __builtin_memcmp(&*__first1, &*__first2, __len) <=> 0;
      if (__c != 0)
        return __c;
    }
  return __lencmp;
       }

      while (__first1 != __last1 && __first2 != __last2)
 {
   if (auto __cmp = __comp(*__first1, *__first2); __cmp != 0)
     return __cmp;
   ++__first1;
   ++__first2;
 }
      return __first1 != __last1 ? strong_ordering::greater
 : __first2 != __last2 ? strong_ordering::less : strong_ordering::equal;
    }

  template<typename _InputIter1, typename _InputIter2>
    constexpr auto
    lexicographical_compare_three_way(_InputIter1 __first1,
          _InputIter1 __last1,
          _InputIter2 __first2,
          _InputIter2 __last2)
    {
      return std::lexicographical_compare_three_way(__first1, __last1,
          __first2, __last2,
          compare_three_way{});
    }


  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    constexpr
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __binary_pred(__first1, __first2))
 {
   ++__first1;
   ++__first2;
 }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1795 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    constexpr
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      return std::__mismatch(__first1, __last1, __first2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1829 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    constexpr
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      return std::__mismatch(__first1, __last1, __first2,
 __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }



  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    constexpr
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __first2 != __last2
      && __binary_pred(__first1, __first2))
 {
   ++__first1;
   ++__first2;
 }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1878 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    constexpr
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1914 "/usr/local/include/c++/10.0.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    constexpr
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }




}
# 64 "/usr/local/include/c++/10.0.0/memory" 2 3
# 1 "/usr/local/include/c++/10.0.0/bits/allocator.h" 1 3
# 46 "/usr/local/include/c++/10.0.0/bits/allocator.h" 3
# 1 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/c++allocator.h" 1 3
# 33 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/c++allocator.h" 3
# 1 "/usr/local/include/c++/10.0.0/ext/new_allocator.h" 1 3
# 40 "/usr/local/include/c++/10.0.0/ext/new_allocator.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 54 "/usr/local/include/c++/10.0.0/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef _Tp value_type;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;
# 75 "/usr/local/include/c++/10.0.0/ext/new_allocator.h" 3
      typedef std::true_type propagate_on_container_move_assignment;


      constexpr
      new_allocator() noexcept { }

      constexpr
      new_allocator(const new_allocator&) noexcept { }

      template<typename _Tp1>
 constexpr
 new_allocator(const new_allocator<_Tp1>&) noexcept { }
# 102 "/usr/local/include/c++/10.0.0/ext/new_allocator.h" 3
      [[__nodiscard__]] _Tp*
      allocate(size_type __n, const void* = static_cast<const void*>(0))
      {
 if (__n > this->_M_max_size())
   std::__throw_bad_alloc();


 if (alignof(_Tp) > 16)
   {
     std::align_val_t __al = std::align_val_t(alignof(_Tp));
     return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), __al));
   }

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(_Tp* __p, size_type __t)
      {

 if (alignof(_Tp) > 16)
   {
     ::operator delete(__p,

         __t * sizeof(_Tp),

         std::align_val_t(alignof(_Tp)));
     return;
   }

 ::operator delete(__p

     , __t * sizeof(_Tp)

    );
      }
# 170 "/usr/local/include/c++/10.0.0/ext/new_allocator.h" 3
      template<typename _Up>
 friend constexpr bool
 operator==(const new_allocator&, const new_allocator<_Up>&)
 noexcept
 { return true; }

      template<typename _Up>
 friend constexpr bool
 operator!=(const new_allocator&, const new_allocator<_Up>&)
 noexcept
 { return false; }

    private:
      constexpr size_type
      _M_max_size() const noexcept
      {

 return std::size_t(0x7fffffffffffffffL) / sizeof(_Tp);



      }
    };


}
# 34 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/c++allocator.h" 2 3


namespace std
{
# 47 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/c++allocator.h" 3
  template<typename _Tp>
    using __allocator_base = __gnu_cxx::new_allocator<_Tp>;
}
# 47 "/usr/local/include/c++/10.0.0/bits/allocator.h" 2 3
# 1 "/usr/local/include/c++/10.0.0/bits/memoryfwd.h" 1 3
# 46 "/usr/local/include/c++/10.0.0/bits/memoryfwd.h" 3
       
# 47 "/usr/local/include/c++/10.0.0/bits/memoryfwd.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{

# 63 "/usr/local/include/c++/10.0.0/bits/memoryfwd.h" 3
  template<typename>
    class allocator;
# 73 "/usr/local/include/c++/10.0.0/bits/memoryfwd.h" 3
  template<typename, typename>
    struct uses_allocator;





}
# 48 "/usr/local/include/c++/10.0.0/bits/allocator.h" 2 3
# 57 "/usr/local/include/c++/10.0.0/bits/allocator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{








  template<>
    class allocator<void>
    {
    public:
      typedef void value_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
# 82 "/usr/local/include/c++/10.0.0/bits/allocator.h" 3
      allocator() = default;

      template<typename _Up>
 constexpr
 allocator(const allocator<_Up>&) { }
# 109 "/usr/local/include/c++/10.0.0/bits/allocator.h" 3
    };
# 119 "/usr/local/include/c++/10.0.0/bits/allocator.h" 3
  template<typename _Tp>
    class allocator : public __allocator_base<_Tp>
    {
    public:
      typedef _Tp value_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
# 140 "/usr/local/include/c++/10.0.0/bits/allocator.h" 3
      typedef true_type propagate_on_container_move_assignment;

      typedef true_type is_always_equal;




      constexpr
      allocator() noexcept { }

      constexpr
      allocator(const allocator& __a) noexcept
      : __allocator_base<_Tp>(__a) { }



      allocator& operator=(const allocator&) = default;


      template<typename _Tp1>
 constexpr
 allocator(const allocator<_Tp1>&) noexcept { }


      constexpr

      ~allocator() noexcept { }


      [[nodiscard,__gnu__::__always_inline__]]
      constexpr _Tp*
      allocate(size_t __n)
      {

 if (std::is_constant_evaluated())
   return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));

 return __allocator_base<_Tp>::allocate(__n, 0);
      }

      [[__gnu__::__always_inline__]]
      constexpr void
      deallocate(_Tp* __p, size_t __n)
      {

 if (std::is_constant_evaluated())
   {
     ::operator delete(__p);
     return;
   }

   __allocator_base<_Tp>::deallocate(__p, __n);
      }


      friend constexpr bool
      operator==(const allocator&, const allocator&) noexcept
      { return true; }

      friend constexpr bool
      operator!=(const allocator&, const allocator&) noexcept
      { return false; }


    };

  template<typename _T1, typename _T2>
    inline constexpr bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return true; }

  template<typename _T1, typename _T2>
    inline constexpr bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return false; }



  template<typename _Tp>
    class allocator<const _Tp>
    {
    public:
      typedef _Tp value_type;
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };

  template<typename _Tp>
    class allocator<volatile _Tp>
    {
    public:
      typedef _Tp value_type;
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };

  template<typename _Tp>
    class allocator<const volatile _Tp>
    {
    public:
      typedef _Tp value_type;
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };






  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) noexcept { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two) noexcept
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };


  template<typename _Tp, bool
    = __or_<is_copy_constructible<typename _Tp::value_type>,
            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
    struct __shrink_to_fit_aux
    { static bool _S_do_it(_Tp&) noexcept { return false; } };

  template<typename _Tp>
    struct __shrink_to_fit_aux<_Tp, true>
    {
      static bool
      _S_do_it(_Tp& __c) noexcept
      {

 try
   {
     _Tp(__make_move_if_noexcept_iterator(__c.begin()),
  __make_move_if_noexcept_iterator(__c.end()),
  __c.get_allocator()).swap(__c);
     return true;
   }
 catch(...)
   { return false; }



      }
    };



}
# 65 "/usr/local/include/c++/10.0.0/memory" 2 3
# 1 "/usr/local/include/c++/10.0.0/bits/stl_construct.h" 1 3
# 73 "/usr/local/include/c++/10.0.0/bits/stl_construct.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template <typename _Tp>
    constexpr inline void
    destroy_at(_Tp* __location)
    {
      if constexpr (201709L > 201703L && is_array_v<_Tp>)
 {
   for (auto& __x : *__location)
     std::destroy_at(std::__addressof(__x));
 }
      else
 __location->~_Tp();
    }


  template<typename _Tp, typename... _Args>
    constexpr auto
    construct_at(_Tp* __location, _Args&&... __args)
    noexcept(noexcept(::new((void*)0) _Tp(std::declval<_Args>()...)))
    -> decltype(::new((void*)0) _Tp(std::declval<_Args>()...))
    { return ::new((void*)__location) _Tp(std::forward<_Args>(__args)...); }
# 106 "/usr/local/include/c++/10.0.0/bits/stl_construct.h" 3
  template<typename _Tp, typename... _Args>
    constexpr _Tp*
    _Construct(_Tp* __p, _Args&&... __args)
    {

      return std::construct_at(__p, std::forward<_Args>(__args)...);



    }
# 127 "/usr/local/include/c++/10.0.0/bits/stl_construct.h" 3
  template<typename _T1>
    inline void
    _Construct_novalue(_T1* __p)
    { ::new(static_cast<void*>(__p)) _T1; }

  template<typename _ForwardIterator>
    constexpr void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last);




  template<typename _Tp>
    constexpr inline void
    _Destroy(_Tp* __pointer)
    {

      std::destroy_at(__pointer);



    }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
 static constexpr void
 __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(std::__addressof(*__first));
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    constexpr inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;


      static_assert(is_destructible<_Value_type>::value,
      "value type is destructible");


      if (std::is_constant_evaluated())
 return _Destroy_aux<false>::__destroy(__first, __last);

      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }

  template<bool>
    struct _Destroy_n_aux
    {
      template<typename _ForwardIterator, typename _Size>
 static constexpr _ForwardIterator
 __destroy_n(_ForwardIterator __first, _Size __count)
 {
   for (; __count > 0; (void)++__first, --__count)
     std::_Destroy(std::__addressof(*__first));
   return __first;
 }
    };

  template<>
    struct _Destroy_n_aux<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __destroy_n(_ForwardIterator __first, _Size __count)
 {
   std::advance(__first, __count);
   return __first;
 }
    };






  template<typename _ForwardIterator, typename _Size>
    constexpr inline _ForwardIterator
    _Destroy_n(_ForwardIterator __first, _Size __count)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;


      static_assert(is_destructible<_Value_type>::value,
      "value type is destructible");


      if (std::is_constant_evaluated())
 return _Destroy_n_aux<false>::__destroy_n(__first, __count);

      return std::_Destroy_n_aux<__has_trivial_destructor(_Value_type)>::
 __destroy_n(__first, __count);
    }


  template <typename _ForwardIterator>
    constexpr inline void
    destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      std::_Destroy(__first, __last);
    }

  template <typename _ForwardIterator, typename _Size>
    constexpr inline _ForwardIterator
    destroy_n(_ForwardIterator __first, _Size __count)
    {
      return std::_Destroy_n(__first, __count);
    }



}
# 66 "/usr/local/include/c++/10.0.0/memory" 2 3
# 1 "/usr/local/include/c++/10.0.0/bits/stl_uninitialized.h" 1 3
# 67 "/usr/local/include/c++/10.0.0/bits/stl_uninitialized.h" 3
# 1 "/usr/local/include/c++/10.0.0/ext/alloc_traits.h" 1 3
# 32 "/usr/local/include/c++/10.0.0/ext/alloc_traits.h" 3
       
# 33 "/usr/local/include/c++/10.0.0/ext/alloc_traits.h" 3

# 1 "/usr/local/include/c++/10.0.0/bits/alloc_traits.h" 1 3
# 41 "/usr/local/include/c++/10.0.0/bits/alloc_traits.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{





  struct __allocator_traits_base
  {
    template<typename _Tp, typename _Up, typename = void>
      struct __rebind : __replace_first_arg<_Tp, _Up> { };

    template<typename _Tp, typename _Up>
      struct __rebind<_Tp, _Up,
        __void_t<typename _Tp::template rebind<_Up>::other>>
      { using type = typename _Tp::template rebind<_Up>::other; };

  protected:
    template<typename _Tp>
      using __pointer = typename _Tp::pointer;
    template<typename _Tp>
      using __c_pointer = typename _Tp::const_pointer;
    template<typename _Tp>
      using __v_pointer = typename _Tp::void_pointer;
    template<typename _Tp>
      using __cv_pointer = typename _Tp::const_void_pointer;
    template<typename _Tp>
      using __pocca = typename _Tp::propagate_on_container_copy_assignment;
    template<typename _Tp>
      using __pocma = typename _Tp::propagate_on_container_move_assignment;
    template<typename _Tp>
      using __pocs = typename _Tp::propagate_on_container_swap;
    template<typename _Tp>
      using __equal = typename _Tp::is_always_equal;
  };

  template<typename _Alloc, typename _Up>
    using __alloc_rebind
      = typename __allocator_traits_base::template __rebind<_Alloc, _Up>::type;





  template<typename _Alloc>
    struct allocator_traits : __allocator_traits_base
    {

      typedef _Alloc allocator_type;

      typedef typename _Alloc::value_type value_type;






      using pointer = __detected_or_t<value_type*, __pointer, _Alloc>;

    private:

      template<template<typename> class _Func, typename _Tp, typename = void>
 struct _Ptr
 {
   using type = typename pointer_traits<pointer>::template rebind<_Tp>;
 };

      template<template<typename> class _Func, typename _Tp>
 struct _Ptr<_Func, _Tp, __void_t<_Func<_Alloc>>>
 {
   using type = _Func<_Alloc>;
 };


      template<typename _A2, typename _PtrT, typename = void>
 struct _Diff
 { using type = typename pointer_traits<_PtrT>::difference_type; };

      template<typename _A2, typename _PtrT>
 struct _Diff<_A2, _PtrT, __void_t<typename _A2::difference_type>>
 { using type = typename _A2::difference_type; };


      template<typename _A2, typename _DiffT, typename = void>
 struct _Size : make_unsigned<_DiffT> { };

      template<typename _A2, typename _DiffT>
 struct _Size<_A2, _DiffT, __void_t<typename _A2::size_type>>
 { using type = typename _A2::size_type; };

    public:






      using const_pointer = typename _Ptr<__c_pointer, const value_type>::type;







      using void_pointer = typename _Ptr<__v_pointer, void>::type;







      using const_void_pointer = typename _Ptr<__cv_pointer, const void>::type;







      using difference_type = typename _Diff<_Alloc, pointer>::type;







      using size_type = typename _Size<_Alloc, difference_type>::type;







      using propagate_on_container_copy_assignment
 = __detected_or_t<false_type, __pocca, _Alloc>;







      using propagate_on_container_move_assignment
 = __detected_or_t<false_type, __pocma, _Alloc>;







      using propagate_on_container_swap
 = __detected_or_t<false_type, __pocs, _Alloc>;







      using is_always_equal
 = __detected_or_t<typename is_empty<_Alloc>::type, __equal, _Alloc>;

      template<typename _Tp>
 using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;
      template<typename _Tp>
 using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;

    private:
      template<typename _Alloc2>
 static constexpr auto
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint, int)
 -> decltype(__a.allocate(__n, __hint))
 { return __a.allocate(__n, __hint); }

      template<typename _Alloc2>
 static constexpr pointer
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer, ...)
 { return __a.allocate(__n); }

      template<typename _Tp, typename... _Args>
 struct __construct_helper
 {
   template<typename _Alloc2,
     typename = decltype(std::declval<_Alloc2*>()->construct(
    std::declval<_Tp*>(), std::declval<_Args>()...))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   using type = decltype(__test<_Alloc>(0));
 };

      template<typename _Tp, typename... _Args>
 using __has_construct
   = typename __construct_helper<_Tp, _Args...>::type;

      template<typename _Tp, typename... _Args>
 static constexpr _Require<__has_construct<_Tp, _Args...>>
 _S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 noexcept(noexcept(__a.construct(__p, std::forward<_Args>(__args)...)))
 { __a.construct(__p, std::forward<_Args>(__args)...); }

      template<typename _Tp, typename... _Args>
 static constexpr
 _Require<__and_<__not_<__has_construct<_Tp, _Args...>>,
          is_constructible<_Tp, _Args...>>>
 _S_construct(_Alloc&, _Tp* __p, _Args&&... __args)
 noexcept(noexcept(::new((void*)__p)
     _Tp(std::forward<_Args>(__args)...)))
 { std::_Construct(__p, std::forward<_Args>(__args)...); }

      template<typename _Alloc2, typename _Tp>
 static constexpr auto
 _S_destroy(_Alloc2& __a, _Tp* __p, int)
 noexcept(noexcept(__a.destroy(__p)))
 -> decltype(__a.destroy(__p))
 { __a.destroy(__p); }

      template<typename _Alloc2, typename _Tp>
 static constexpr void
 _S_destroy(_Alloc2&, _Tp* __p, ...)
 noexcept(noexcept(__p->~_Tp()))
 { std::_Destroy(__p); }

      template<typename _Alloc2>
 static constexpr auto
 _S_max_size(_Alloc2& __a, int)
 -> decltype(__a.max_size())
 { return __a.max_size(); }

      template<typename _Alloc2>
 static constexpr size_type
 _S_max_size(_Alloc2&, ...)
 {


   return __gnu_cxx::__numeric_traits<size_type>::__max
     / sizeof(value_type);
 }

      template<typename _Alloc2>
 static constexpr auto
 _S_select(_Alloc2& __a, int)
 -> decltype(__a.select_on_container_copy_construction())
 { return __a.select_on_container_copy_construction(); }

      template<typename _Alloc2>
 static constexpr _Alloc2
 _S_select(_Alloc2& __a, ...)
 { return __a; }

    public:
# 307 "/usr/local/include/c++/10.0.0/bits/alloc_traits.h" 3
      [[__nodiscard__]] static constexpr pointer
      allocate(_Alloc& __a, size_type __n)
      { return __a.allocate(__n); }
# 322 "/usr/local/include/c++/10.0.0/bits/alloc_traits.h" 3
      [[__nodiscard__]] static constexpr pointer
      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)
      { return _S_allocate(__a, __n, __hint, 0); }
# 334 "/usr/local/include/c++/10.0.0/bits/alloc_traits.h" 3
      static constexpr void
      deallocate(_Alloc& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 349 "/usr/local/include/c++/10.0.0/bits/alloc_traits.h" 3
      template<typename _Tp, typename... _Args>
 static constexpr auto
 construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 noexcept(noexcept(_S_construct(__a, __p,
           std::forward<_Args>(__args)...)))
 -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))
 { _S_construct(__a, __p, std::forward<_Args>(__args)...); }
# 365 "/usr/local/include/c++/10.0.0/bits/alloc_traits.h" 3
      template<typename _Tp>
 static constexpr void
 destroy(_Alloc& __a, _Tp* __p)
 noexcept(noexcept(_S_destroy(__a, __p, 0)))
 { _S_destroy(__a, __p, 0); }
# 379 "/usr/local/include/c++/10.0.0/bits/alloc_traits.h" 3
      static constexpr size_type
      max_size(const _Alloc& __a) noexcept
      { return _S_max_size(__a, 0); }
# 391 "/usr/local/include/c++/10.0.0/bits/alloc_traits.h" 3
      static constexpr _Alloc
      select_on_container_copy_construction(const _Alloc& __rhs)
      { return _S_select(__rhs, 0); }
    };






  template<typename _Tp>
    struct allocator_traits<allocator<_Tp>>
    {

      using allocator_type = allocator<_Tp>;


      using value_type = _Tp;


      using pointer = _Tp*;


      using const_pointer = const _Tp*;


      using void_pointer = void*;


      using const_void_pointer = const void*;


      using difference_type = std::ptrdiff_t;


      using size_type = std::size_t;


      using propagate_on_container_copy_assignment = false_type;


      using propagate_on_container_move_assignment = true_type;


      using propagate_on_container_swap = false_type;


      using is_always_equal = true_type;

      template<typename _Up>
 using rebind_alloc = allocator<_Up>;

      template<typename _Up>
 using rebind_traits = allocator_traits<allocator<_Up>>;
# 453 "/usr/local/include/c++/10.0.0/bits/alloc_traits.h" 3
      [[__nodiscard__]] static constexpr pointer
      allocate(allocator_type& __a, size_type __n)
      { return __a.allocate(__n); }
# 467 "/usr/local/include/c++/10.0.0/bits/alloc_traits.h" 3
      [[__nodiscard__]] static constexpr pointer
      allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
      {



 return __a.allocate(__n);

      }
# 485 "/usr/local/include/c++/10.0.0/bits/alloc_traits.h" 3
      static constexpr void
      deallocate(allocator_type& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 500 "/usr/local/include/c++/10.0.0/bits/alloc_traits.h" 3
      template<typename _Up, typename... _Args>
 static constexpr void
 construct(allocator_type& __a __attribute__((__unused__)), _Up* __p,
    _Args&&... __args)
 noexcept(noexcept(::new((void*)__p) _Up(std::declval<_Args>()...)))
 {



   std::construct_at(__p, std::forward<_Args>(__args)...);

 }
# 520 "/usr/local/include/c++/10.0.0/bits/alloc_traits.h" 3
      template<typename _Up>
 static constexpr void
 destroy(allocator_type& __a __attribute__((__unused__)), _Up* __p)
 noexcept(is_nothrow_destructible<_Up>::value)
 {



   std::destroy_at(__p);

 }






      static constexpr size_type
      max_size(const allocator_type& __a __attribute__((__unused__))) noexcept
      {



 return size_t(-1) / sizeof(value_type);

      }






      static constexpr allocator_type
      select_on_container_copy_construction(const allocator_type& __rhs)
      { return __rhs; }
    };
# 569 "/usr/local/include/c++/10.0.0/bits/alloc_traits.h" 3
  template<typename _Alloc>
    constexpr inline void
    __alloc_on_copy(_Alloc& __one, const _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_copy_assignment __pocca;

      if constexpr (__pocca::value)
 __one = __two;



    }

  template<typename _Alloc>
    constexpr _Alloc
    __alloc_on_copy(const _Alloc& __a)
    {
      typedef allocator_traits<_Alloc> __traits;
      return __traits::select_on_container_copy_construction(__a);
    }
# 601 "/usr/local/include/c++/10.0.0/bits/alloc_traits.h" 3
  template<typename _Alloc>
    constexpr inline void
    __alloc_on_move(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_move_assignment __pocma;

      if constexpr (__pocma::value)
 __one = std::move(__two);



    }
# 628 "/usr/local/include/c++/10.0.0/bits/alloc_traits.h" 3
  template<typename _Alloc>
    constexpr inline void
    __alloc_on_swap(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_swap __pocs;

      if constexpr (__pocs::value)
 {
   using std::swap;
   swap(__one, __two);
 }



    }

  template<typename _Alloc, typename _Tp,
    typename _ValueT = __remove_cvref_t<typename _Alloc::value_type>,
    typename = void>
    struct __is_alloc_insertable_impl
    : false_type
    { };

  template<typename _Alloc, typename _Tp, typename _ValueT>
    struct __is_alloc_insertable_impl<_Alloc, _Tp, _ValueT,
      __void_t<decltype(allocator_traits<_Alloc>::construct(
     std::declval<_Alloc&>(), std::declval<_ValueT*>(),
     std::declval<_Tp>()))>>
    : true_type
    { };




  template<typename _Alloc>
    struct __is_copy_insertable
    : __is_alloc_insertable_impl<_Alloc,
     typename _Alloc::value_type const&>::type
    { };


  template<typename _Tp>
    struct __is_copy_insertable<allocator<_Tp>>
    : is_copy_constructible<_Tp>
    { };




  template<typename _Alloc>
    struct __is_move_insertable
    : __is_alloc_insertable_impl<_Alloc, typename _Alloc::value_type>::type
    { };


  template<typename _Tp>
    struct __is_move_insertable<allocator<_Tp>>
    : is_move_constructible<_Tp>
    { };


  template<typename _Alloc, typename = void>
    struct __is_allocator : false_type { };

  template<typename _Alloc>
    struct __is_allocator<_Alloc,
      __void_t<typename _Alloc::value_type,
        decltype(std::declval<_Alloc&>().allocate(size_t{}))>>
    : true_type { };

  template<typename _Alloc>
    using _RequireAllocator
      = typename enable_if<__is_allocator<_Alloc>::value, _Alloc>::type;

  template<typename _Alloc>
    using _RequireNotAllocator
      = typename enable_if<!__is_allocator<_Alloc>::value, _Alloc>::type;
# 714 "/usr/local/include/c++/10.0.0/bits/alloc_traits.h" 3
  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      for (; __first != __last; ++__first)



 allocator_traits<_Allocator>::destroy(__alloc,
           std::__addressof(*__first));

    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }


}
# 35 "/usr/local/include/c++/10.0.0/ext/alloc_traits.h" 2 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{






template<typename _Alloc, typename = typename _Alloc::value_type>
  struct __alloc_traits

  : std::allocator_traits<_Alloc>

  {
    typedef _Alloc allocator_type;

    typedef std::allocator_traits<_Alloc> _Base_type;
    typedef typename _Base_type::value_type value_type;
    typedef typename _Base_type::pointer pointer;
    typedef typename _Base_type::const_pointer const_pointer;
    typedef typename _Base_type::size_type size_type;
    typedef typename _Base_type::difference_type difference_type;

    typedef value_type& reference;
    typedef const value_type& const_reference;
    using _Base_type::allocate;
    using _Base_type::deallocate;
    using _Base_type::construct;
    using _Base_type::destroy;
    using _Base_type::max_size;

  private:
    template<typename _Ptr>
      using __is_custom_pointer
 = std::__and_<std::is_same<pointer, _Ptr>,
        std::__not_<std::is_pointer<_Ptr>>>;

  public:

    template<typename _Ptr, typename... _Args>
      static constexpr
      std::__enable_if_t<__is_custom_pointer<_Ptr>::value>
      construct(_Alloc& __a, _Ptr __p, _Args&&... __args)
      noexcept(noexcept(_Base_type::construct(__a, std::__to_address(__p),
           std::forward<_Args>(__args)...)))
      {
 _Base_type::construct(__a, std::__to_address(__p),
         std::forward<_Args>(__args)...);
      }


    template<typename _Ptr>
      static constexpr
      std::__enable_if_t<__is_custom_pointer<_Ptr>::value>
      destroy(_Alloc& __a, _Ptr __p)
      noexcept(noexcept(_Base_type::destroy(__a, std::__to_address(__p))))
      { _Base_type::destroy(__a, std::__to_address(__p)); }

    static constexpr _Alloc _S_select_on_copy(const _Alloc& __a)
    { return _Base_type::select_on_container_copy_construction(__a); }

    static constexpr void _S_on_swap(_Alloc& __a, _Alloc& __b)
    { std::__alloc_on_swap(__a, __b); }

    static constexpr bool _S_propagate_on_copy_assign()
    { return _Base_type::propagate_on_container_copy_assignment::value; }

    static constexpr bool _S_propagate_on_move_assign()
    { return _Base_type::propagate_on_container_move_assignment::value; }

    static constexpr bool _S_propagate_on_swap()
    { return _Base_type::propagate_on_container_swap::value; }

    static constexpr bool _S_always_equal()
    { return _Base_type::is_always_equal::value; }

    static constexpr bool _S_nothrow_move()
    { return _S_propagate_on_move_assign() || _S_always_equal(); }

    template<typename _Tp>
      struct rebind
      { typedef typename _Base_type::template rebind_alloc<_Tp> other; };
# 166 "/usr/local/include/c++/10.0.0/ext/alloc_traits.h" 3
  };


}
# 68 "/usr/local/include/c++/10.0.0/bits/stl_uninitialized.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{








  template<bool _TrivialValueTypes>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        {
   _ForwardIterator __cur = __result;
   try
     {
       for (; __first != __last; ++__first, (void)++__cur)
  std::_Construct(std::__addressof(*__cur), *__first);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__result, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };
# 123 "/usr/local/include/c++/10.0.0/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;





      static_assert(is_constructible<_ValueType2, decltype(*__first)>::value,
   "result type must be constructible from value type of input range");

      typedef typename iterator_traits<_InputIterator>::reference _RefType1;
      typedef typename iterator_traits<_ForwardIterator>::reference _RefType2;


      const bool __assignable = is_assignable<_RefType2, _RefType1>::value;


      return std::__uninitialized_copy<__is_trivial(_ValueType1)
           && __is_trivial(_ValueType2)
           && __assignable>::
 __uninit_copy(__first, __last, __result);
    }



  template<bool _TrivialValueType>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };
# 198 "/usr/local/include/c++/10.0.0/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;





      static_assert(is_constructible<_ValueType, const _Tp&>::value,
   "result type must be constructible from input type");



      const bool __assignable = is_copy_assignable<_ValueType>::value;


      std::__uninitialized_fill<__is_trivial(_ValueType) && __assignable>::
 __uninit_fill(__first, __last, __x);
    }



  template<bool _TrivialValueType>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, (void) ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        { return std::fill_n(__first, __n, __x); }
    };
# 270 "/usr/local/include/c++/10.0.0/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;





      static_assert(is_constructible<_ValueType, const _Tp&>::value,
   "result type must be constructible from input type");



      const bool __assignable = is_copy_assignable<_ValueType>::value;

      return __uninitialized_fill_n<__is_trivial(_ValueType) && __assignable>::
 __uninit_fill_n(__first, __n, __x);
    }
# 300 "/usr/local/include/c++/10.0.0/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __first != __last; ++__first, (void)++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a(std::make_move_iterator(__first),
      std::make_move_iterator(__last),
      __result, __alloc);
    }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_if_noexcept_a(_InputIterator __first,
           _InputIterator __last,
           _ForwardIterator __result,
           _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a
 (std::__make_move_if_noexcept_iterator(__first),
  std::__make_move_if_noexcept_iterator(__last), __result, __alloc);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, (void) ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, allocator<_Tp2>&)
    { return std::uninitialized_fill_n(__first, __n, __x); }
# 414 "/usr/local/include/c++/10.0.0/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }





  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }
# 521 "/usr/local/include/c++/10.0.0/bits/stl_uninitialized.h" 3
  template<bool _TrivialValueType>
    struct __uninitialized_default_1
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur));
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_1<true>
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   std::fill(__first, __last, _ValueType());
 }
    };

  template<bool _TrivialValueType>
    struct __uninitialized_default_n_1
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, (void) ++__cur)
  std::_Construct(std::__addressof(*__cur));
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_n_1<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   return std::fill_n(__first, __n, _ValueType());
 }
    };




  template<typename _ForwardIterator>
    inline void
    __uninitialized_default(_ForwardIterator __first,
       _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      const bool __assignable = is_copy_assignable<_ValueType>::value;

      std::__uninitialized_default_1<__is_trivial(_ValueType)
         && __assignable>::
 __uninit_default(__first, __last);
    }



  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    __uninitialized_default_n(_ForwardIterator __first, _Size __n)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      const bool __assignable = is_copy_assignable<_ValueType>::value;

      return __uninitialized_default_n_1<__is_trivial(_ValueType)
           && __assignable>::
 __uninit_default_n(__first, __n);
    }





  template<typename _ForwardIterator, typename _Allocator>
    void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         allocator<_Tp>&)
    { std::__uninitialized_default(__first, __last); }





  template<typename _ForwardIterator, typename _Size, typename _Allocator>
    _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, (void) ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    allocator<_Tp>&)
    { return std::__uninitialized_default_n(__first, __n); }

  template<bool _TrivialValueType>
    struct __uninitialized_default_novalue_1
    {
      template<typename _ForwardIterator>
 static void
 __uninit_default_novalue(_ForwardIterator __first,
     _ForwardIterator __last)
 {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct_novalue(std::__addressof(*__cur));
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_novalue_1<true>
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default_novalue(_ForwardIterator __first,
     _ForwardIterator __last)
 {
 }
    };

  template<bool _TrivialValueType>
    struct __uninitialized_default_novalue_n_1
    {
      template<typename _ForwardIterator, typename _Size>
 static _ForwardIterator
 __uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
 {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, (void) ++__cur)
  std::_Construct_novalue(std::__addressof(*__cur));
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_novalue_n_1<true>
    {
      template<typename _ForwardIterator, typename _Size>
 static _ForwardIterator
 __uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
 { return std::next(__first, __n); }
    };




  template<typename _ForwardIterator>
    inline void
    __uninitialized_default_novalue(_ForwardIterator __first,
        _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_default_novalue_1<
 is_trivially_default_constructible<_ValueType>::value>::
 __uninit_default_novalue(__first, __last);
    }



  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    __uninitialized_default_novalue_n(_ForwardIterator __first, _Size __n)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      return __uninitialized_default_novalue_n_1<
 is_trivially_default_constructible<_ValueType>::value>::
 __uninit_default_novalue_n(__first, __n);
    }

  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    _ForwardIterator
    __uninitialized_copy_n(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __n > 0; --__n, (void) ++__first, ++__cur)
     std::_Construct(std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    { return std::uninitialized_copy(__first, __first + __n, __result); }

  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    pair<_InputIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __n > 0; --__n, (void) ++__first, ++__cur)
     std::_Construct(std::__addressof(*__cur), *__first);
   return {__first, __cur};
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline pair<_RandomAccessIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    {
      auto __second_res = uninitialized_copy(__first, __first + __n, __result);
      auto __first_res = std::next(__first, __n);
      return {__first_res, __second_res};
    }
# 852 "/usr/local/include/c++/10.0.0/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy_n(_InputIterator __first, _Size __n,
    _ForwardIterator __result)
    { return std::__uninitialized_copy_n(__first, __n, __result,
      std::__iterator_category(__first)); }


  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline pair<_InputIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,
         _ForwardIterator __result)
    {
      return
 std::__uninitialized_copy_n_pair(__first, __n, __result,
      std::__iterator_category(__first));
    }
# 880 "/usr/local/include/c++/10.0.0/bits/stl_uninitialized.h" 3
  template <typename _ForwardIterator>
    inline void
    uninitialized_default_construct(_ForwardIterator __first,
        _ForwardIterator __last)
    {
      __uninitialized_default_novalue(__first, __last);
    }







  template <typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    uninitialized_default_construct_n(_ForwardIterator __first, _Size __count)
    {
      return __uninitialized_default_novalue_n(__first, __count);
    }






  template <typename _ForwardIterator>
    inline void
    uninitialized_value_construct(_ForwardIterator __first,
      _ForwardIterator __last)
    {
      return __uninitialized_default(__first, __last);
    }







  template <typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    uninitialized_value_construct_n(_ForwardIterator __first, _Size __count)
    {
      return __uninitialized_default_n(__first, __count);
    }
# 934 "/usr/local/include/c++/10.0.0/bits/stl_uninitialized.h" 3
  template <typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_move(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      return std::uninitialized_copy
 (std::make_move_iterator(__first),
  std::make_move_iterator(__last), __result);
    }
# 951 "/usr/local/include/c++/10.0.0/bits/stl_uninitialized.h" 3
  template <typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline pair<_InputIterator, _ForwardIterator>
    uninitialized_move_n(_InputIterator __first, _Size __count,
    _ForwardIterator __result)
    {
      auto __res = std::__uninitialized_copy_n_pair
 (std::make_move_iterator(__first),
  __count, __result);
      return {__res.first.base(), __res.second};
    }





  template<typename _Tp, typename _Up, typename _Allocator>
    inline void
    __relocate_object_a(_Tp* __restrict __dest, _Up* __restrict __orig,
   _Allocator& __alloc)
    noexcept(noexcept(std::allocator_traits<_Allocator>::construct(__alloc,
    __dest, std::move(*__orig)))
      && noexcept(std::allocator_traits<_Allocator>::destroy(
       __alloc, std::__addressof(*__orig))))
    {
      typedef std::allocator_traits<_Allocator> __traits;
      __traits::construct(__alloc, __dest, std::move(*__orig));
      __traits::destroy(__alloc, std::__addressof(*__orig));
    }



  template<typename _Tp, typename = void>
    struct __is_bitwise_relocatable
    : is_trivial<_Tp> { };

  template <typename _Tp, typename _Up>
    inline __enable_if_t<std::__is_bitwise_relocatable<_Tp>::value, _Tp*>
    __relocate_a_1(_Tp* __first, _Tp* __last,
     _Tp* __result, allocator<_Up>&) noexcept
    {
      ptrdiff_t __count = __last - __first;
      if (__count > 0)
 __builtin_memmove(__result, __first, __count * sizeof(_Tp));
      return __result + __count;
    }

  template <typename _InputIterator, typename _ForwardIterator,
     typename _Allocator>
    inline _ForwardIterator
    __relocate_a_1(_InputIterator __first, _InputIterator __last,
     _ForwardIterator __result, _Allocator& __alloc)
    noexcept(noexcept(std::__relocate_object_a(std::addressof(*__result),
            std::addressof(*__first),
            __alloc)))
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;
      static_assert(std::is_same<_ValueType, _ValueType2>::value,
   "relocation is only possible for values of the same type");
      _ForwardIterator __cur = __result;
      for (; __first != __last; ++__first, (void)++__cur)
 std::__relocate_object_a(std::__addressof(*__cur),
     std::__addressof(*__first), __alloc);
      return __cur;
    }

  template <typename _InputIterator, typename _ForwardIterator,
     typename _Allocator>
    inline _ForwardIterator
    __relocate_a(_InputIterator __first, _InputIterator __last,
   _ForwardIterator __result, _Allocator& __alloc)
    noexcept(noexcept(__relocate_a_1(std::__niter_base(__first),
         std::__niter_base(__last),
         std::__niter_base(__result), __alloc)))
    {
      return __relocate_a_1(std::__niter_base(__first),
       std::__niter_base(__last),
       std::__niter_base(__result), __alloc);
    }







}
# 67 "/usr/local/include/c++/10.0.0/memory" 2 3
# 1 "/usr/local/include/c++/10.0.0/bits/stl_tempbuf.h" 1 3
# 62 "/usr/local/include/c++/10.0.0/bits/stl_tempbuf.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  namespace __detail
  {
    template<typename _Tp>
      inline void
      __return_temporary_buffer(_Tp* __p,
    size_t __len __attribute__((__unused__)))
      {

 ::operator delete(__p, __len * sizeof(_Tp));



      }
  }
# 98 "/usr/local/include/c++/10.0.0/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len) noexcept
    {
      const ptrdiff_t __max =
 __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
      if (__len > __max)
 __len = __max;

      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       std::nothrow));
   if (__tmp != 0)
     return std::pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return std::pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
# 125 "/usr/local/include/c++/10.0.0/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    inline void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p); }






  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {

     

    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;

    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;

    public:

      size_type
      size() const
      { return _M_len; }


      size_type
      requested_size() const
      { return _M_original_len; }


      iterator
      begin()
      { return _M_buffer; }


      iterator
      end()
      { return _M_buffer + _M_len; }





      _Temporary_buffer(_ForwardIterator __seed, size_type __original_len);

      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::__detail::__return_temporary_buffer(_M_buffer, _M_len);
      }

    private:

      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };


  template<bool>
    struct __uninitialized_construct_buf_dispatch
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer __first, _Pointer __last,
       _ForwardIterator __seed)
        {
   if (__first == __last)
     return;

   _Pointer __cur = __first;
   try
     {
       std::_Construct(std::__addressof(*__first),
         std::move(*__seed));
       _Pointer __prev = __cur;
       ++__cur;
       for(; __cur != __last; ++__cur, ++__prev)
  std::_Construct(std::__addressof(*__cur),
    std::move(*__prev));
       *__seed = std::move(*__prev);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_construct_buf_dispatch<true>
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer, _Pointer, _ForwardIterator) { }
    };
# 243 "/usr/local/include/c++/10.0.0/bits/stl_tempbuf.h" 3
  template<typename _Pointer, typename _ForwardIterator>
    inline void
    __uninitialized_construct_buf(_Pointer __first, _Pointer __last,
      _ForwardIterator __seed)
    {
      typedef typename std::iterator_traits<_Pointer>::value_type
 _ValueType;

      std::__uninitialized_construct_buf_dispatch<
        __has_trivial_constructor(_ValueType)>::
   __ucr(__first, __last, __seed);
    }

  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __seed, size_type __original_len)
    : _M_original_len(__original_len), _M_len(0), _M_buffer(0)
    {
      std::pair<pointer, size_type> __p(
  std::get_temporary_buffer<value_type>(_M_original_len));

      if (__p.first)
 {
   try
     {
       std::__uninitialized_construct_buf(__p.first, __p.first + __p.second,
       __seed);
       _M_buffer = __p.first;
       _M_len = __p.second;
     }
   catch(...)
     {
       std::__detail::__return_temporary_buffer(__p.first, __p.second);
       throw;
     }
 }
    }


}
# 68 "/usr/local/include/c++/10.0.0/memory" 2 3
# 1 "/usr/local/include/c++/10.0.0/bits/stl_raw_storage_iter.h" 1 3
# 59 "/usr/local/include/c++/10.0.0/bits/stl_raw_storage_iter.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{






  template <class _OutputIterator, class _Tp>
    class raw_storage_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _OutputIterator _M_iter;

    public:
      explicit
      raw_storage_iterator(_OutputIterator __x)
      : _M_iter(__x) {}

      raw_storage_iterator&
      operator*() { return *this; }

      raw_storage_iterator&
      operator=(const _Tp& __element)
      {
 std::_Construct(std::__addressof(*_M_iter), __element);
 return *this;
      }




      raw_storage_iterator&
      operator=(_Tp&& __element)
      {
 std::_Construct(std::__addressof(*_M_iter), std::move(__element));
 return *this;
      }


      raw_storage_iterator&
      operator++()
      {
 ++_M_iter;
 return *this;
      }

      raw_storage_iterator
      operator++(int)
      {
 raw_storage_iterator __tmp = *this;
 ++_M_iter;
 return __tmp;
      }



      _OutputIterator base() const { return _M_iter; }
    };


}
# 69 "/usr/local/include/c++/10.0.0/memory" 2 3




# 1 "/usr/local/include/c++/10.0.0/iosfwd" 1 3
# 36 "/usr/local/include/c++/10.0.0/iosfwd" 3
       
# 37 "/usr/local/include/c++/10.0.0/iosfwd" 3


# 1 "/usr/local/include/c++/10.0.0/bits/stringfwd.h" 1 3
# 37 "/usr/local/include/c++/10.0.0/bits/stringfwd.h" 3
       
# 38 "/usr/local/include/c++/10.0.0/bits/stringfwd.h" 3




namespace std __attribute__ ((__visibility__ ("default")))
{








  template<class _CharT>
    struct char_traits;

  template<> struct char_traits<char>;


  template<> struct char_traits<wchar_t>;



  template<> struct char_traits<char8_t>;



  template<> struct char_traits<char16_t>;
  template<> struct char_traits<char32_t>;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

}


  typedef basic_string<char> string;



  typedef basic_string<wchar_t> wstring;




  typedef basic_string<char8_t> u8string;




  typedef basic_string<char16_t> u16string;


  typedef basic_string<char32_t> u32string;





}
# 40 "/usr/local/include/c++/10.0.0/iosfwd" 2 3
# 1 "/usr/local/include/c++/10.0.0/bits/postypes.h" 1 3
# 38 "/usr/local/include/c++/10.0.0/bits/postypes.h" 3
       
# 39 "/usr/local/include/c++/10.0.0/bits/postypes.h" 3

# 1 "/usr/local/include/c++/10.0.0/cwchar" 1 3
# 39 "/usr/local/include/c++/10.0.0/cwchar" 3
       
# 40 "/usr/local/include/c++/10.0.0/cwchar" 3




# 1 "/usr/include/wchar.h" 1 3 4
# 27 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 75 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
typedef _Complex float __cfloat128 __attribute__ ((__mode__ (__TC__)));
# 87 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
typedef __float128 _Float128;
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 207 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef float _Float32;
# 244 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float64;
# 261 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float32x;
# 278 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef long double _Float64x;
# 121 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 31 "/usr/include/wchar.h" 2 3 4




# 1 "/usr/local/lib/gcc/x86_64-pc-linux-gnu/10.0.0/include/stddef.h" 1 3 4
# 36 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/local/lib/gcc/x86_64-pc-linux-gnu/10.0.0/include/stdarg.h" 1 3 4
# 40 "/usr/local/lib/gcc/x86_64-pc-linux-gnu/10.0.0/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 39 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h" 3 4
typedef unsigned int wint_t;
# 42 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h" 2 3 4

typedef __mbstate_t mbstate_t;
# 43 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 44 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 47 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 50 "/usr/include/wchar.h" 2 3 4
# 79 "/usr/include/wchar.h" 3 4
extern "C" {



struct tm;



extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int wcscmp (const wchar_t *__s1, const wchar_t *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) throw ();


extern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,
   size_t __n) throw ();



extern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
    locale_t __loc) throw ();

extern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
     size_t __n, locale_t __loc) throw ();




extern int wcscoll (const wchar_t *__s1, const wchar_t *__s2) throw ();



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         const wchar_t *__restrict __s2, size_t __n) throw ();







extern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,
        locale_t __loc) throw ();




extern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,
    size_t __n, locale_t __loc) throw ();


extern wchar_t *wcsdup (const wchar_t *__s) throw () __attribute__ ((__malloc__));




extern "C++" wchar_t *wcschr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsrchr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));
# 181 "/usr/include/wchar.h" 3 4
extern wchar_t *wcschrnul (const wchar_t *__s, wchar_t __wc)
     throw () __attribute__ ((__pure__));




extern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)
     throw () __attribute__ ((__pure__));


extern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)
     throw () __attribute__ ((__pure__));


extern "C++" wchar_t *wcspbrk (wchar_t *__wcs, const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcspbrk (const wchar_t *__wcs,
         const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsstr (wchar_t *__haystack, const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsstr (const wchar_t *__haystack,
        const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));






extern wchar_t *wcstok (wchar_t *__restrict __s,
   const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) throw ();


extern size_t wcslen (const wchar_t *__s) throw () __attribute__ ((__pure__));




extern "C++" wchar_t *wcswcs (wchar_t *__haystack, const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcswcs (const wchar_t *__haystack,
        const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
# 240 "/usr/include/wchar.h" 3 4
extern size_t wcsnlen (const wchar_t *__s, size_t __maxlen)
     throw () __attribute__ ((__pure__));





extern "C++" wchar_t *wmemchr (wchar_t *__s, wchar_t __c, size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wmemchr (const wchar_t *__s, wchar_t __c,
         size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));






extern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    const wchar_t *__restrict __s2, size_t __n) throw ();



extern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw ();


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();




extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     const wchar_t *__restrict __s2, size_t __n)
     throw ();





extern wint_t btowc (int __c) throw ();



extern int wctob (wint_t __c) throw ();



extern int mbsinit (const mbstate_t *__ps) throw () __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         const char *__restrict __s, size_t __n,
         mbstate_t *__restrict __p) throw ();


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) throw ();


extern size_t __mbrlen (const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) throw ();
extern size_t mbrlen (const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) throw ();







extern wint_t __btowc_alias (int __c) __asm ("btowc");
extern __inline __attribute__ ((__gnu_inline__)) wint_t
__attribute__ ((__leaf__)) btowc (int __c) throw ()
{ return (__builtin_constant_p (__c) && __c >= '\0' && __c <= '\x7f'
   ? (wint_t) __c : __btowc_alias (__c)); }

extern int __wctob_alias (wint_t __c) __asm ("wctob");
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) wctob (wint_t __wc) throw ()
{ return (__builtin_constant_p (__wc) && __wc >= L'\0' && __wc <= L'\x7f'
   ? (int) __wc : __wctob_alias (__wc)); }

extern __inline __attribute__ ((__gnu_inline__)) size_t
__attribute__ ((__leaf__)) mbrlen (const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps) throw ()

{ return (__ps != __null
   ? mbrtowc (__null, __s, __n, __ps) : __mbrlen (__s, __n, __null)); }




extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();



extern size_t wcsrtombs (char *__restrict __dst,
    const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();





extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) throw ();



extern size_t wcsnrtombs (char *__restrict __dst,
     const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) throw ();






extern int wcwidth (wchar_t __c) throw ();



extern int wcswidth (const wchar_t *__s, size_t __n) throw ();





extern double wcstod (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) throw ();



extern float wcstof (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
extern long double wcstold (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
# 396 "/usr/include/wchar.h" 3 4
extern _Float32 wcstof32 (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr) throw ();



extern _Float64 wcstof64 (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr) throw ();



extern _Float128 wcstof128 (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();



extern _Float32x wcstof32x (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();



extern _Float64x wcstof64x (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
# 428 "/usr/include/wchar.h" 3 4
extern long int wcstol (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) throw ();



extern unsigned long int wcstoul (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();




__extension__
extern long long int wcstoll (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstoull (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) throw ();





__extension__
extern long long int wcstoq (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstouq (const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) throw ();






extern long int wcstol_l (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     locale_t __loc) throw ();

extern unsigned long int wcstoul_l (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, locale_t __loc) throw ();

__extension__
extern long long int wcstoll_l (const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, locale_t __loc) throw ();

__extension__
extern unsigned long long int wcstoull_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, locale_t __loc)
     throw ();

extern double wcstod_l (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, locale_t __loc)
     throw ();

extern float wcstof_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, locale_t __loc)
     throw ();

extern long double wcstold_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();
# 511 "/usr/include/wchar.h" 3 4
extern _Float32 wcstof32_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       locale_t __loc) throw ();



extern _Float64 wcstof64_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       locale_t __loc) throw ();



extern _Float128 wcstof128_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();



extern _Float32x wcstof32x_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();



extern _Float64x wcstof64x_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) throw ();
# 551 "/usr/include/wchar.h" 3 4
extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) throw ();



extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw ();
# 567 "/usr/include/wchar.h" 3 4
extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) throw ();





extern int fwide (__FILE *__fp, int __mode) throw ();






extern int fwprintf (__FILE *__restrict __stream,
       const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       const wchar_t *__restrict __format, ...)
     throw () ;





extern int vfwprintf (__FILE *__restrict __s,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     throw () ;






extern int fwscanf (__FILE *__restrict __stream,
      const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (const wchar_t *__restrict __s,
      const wchar_t *__restrict __format, ...)
     throw () ;
# 673 "/usr/include/wchar.h" 3 4
extern int vfwscanf (__FILE *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (const wchar_t *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     throw () ;
# 727 "/usr/include/wchar.h" 3 4
extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);
# 782 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 808 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 818 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);






extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   const wchar_t *__restrict __format,
   const struct tm *__restrict __tp) throw ();




extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     const wchar_t *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) throw ();
# 857 "/usr/include/wchar.h" 3 4
}
# 45 "/usr/local/include/c++/10.0.0/cwchar" 2 3
# 62 "/usr/local/include/c++/10.0.0/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
# 135 "/usr/local/include/c++/10.0.0/cwchar" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;


  using ::vswprintf;


  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;
# 234 "/usr/local/include/c++/10.0.0/cwchar" 3

}
}







namespace __gnu_cxx
{





  using ::wcstold;
# 260 "/usr/local/include/c++/10.0.0/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
}
# 280 "/usr/local/include/c++/10.0.0/cwchar" 3
namespace std
{

  using std::wcstof;


  using std::vfwscanf;


  using std::vswscanf;


  using std::vwscanf;



  using std::wcstold;
  using std::wcstoll;
  using std::wcstoull;

}
# 41 "/usr/local/include/c++/10.0.0/bits/postypes.h" 2 3
# 68 "/usr/local/include/c++/10.0.0/bits/postypes.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 88 "/usr/local/include/c++/10.0.0/bits/postypes.h" 3
  typedef long streamoff;
# 98 "/usr/local/include/c++/10.0.0/bits/postypes.h" 3
  typedef ptrdiff_t streamsize;
# 111 "/usr/local/include/c++/10.0.0/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 133 "/usr/local/include/c++/10.0.0/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      fpos(const fpos&) = default;
      fpos& operator=(const fpos&) = default;
      ~fpos() = default;



      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;



  typedef fpos<mbstate_t> u8streampos;




  typedef fpos<mbstate_t> u16streampos;

  typedef fpos<mbstate_t> u32streampos;



}
# 41 "/usr/local/include/c++/10.0.0/iosfwd" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 74 "/usr/local/include/c++/10.0.0/iosfwd" 3
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

}

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  typedef basic_ios<char> ios;


  typedef basic_streambuf<char> streambuf;


  typedef basic_istream<char> istream;


  typedef basic_ostream<char> ostream;


  typedef basic_iostream<char> iostream;


  typedef basic_stringbuf<char> stringbuf;


  typedef basic_istringstream<char> istringstream;


  typedef basic_ostringstream<char> ostringstream;


  typedef basic_stringstream<char> stringstream;


  typedef basic_filebuf<char> filebuf;


  typedef basic_ifstream<char> ifstream;


  typedef basic_ofstream<char> ofstream;


  typedef basic_fstream<char> fstream;



  typedef basic_ios<wchar_t> wios;


  typedef basic_streambuf<wchar_t> wstreambuf;


  typedef basic_istream<wchar_t> wistream;


  typedef basic_ostream<wchar_t> wostream;


  typedef basic_iostream<wchar_t> wiostream;


  typedef basic_stringbuf<wchar_t> wstringbuf;


  typedef basic_istringstream<wchar_t> wistringstream;


  typedef basic_ostringstream<wchar_t> wostringstream;


  typedef basic_stringstream<wchar_t> wstringstream;


  typedef basic_filebuf<wchar_t> wfilebuf;


  typedef basic_ifstream<wchar_t> wifstream;


  typedef basic_ofstream<wchar_t> wofstream;


  typedef basic_fstream<wchar_t> wfstream;




}
# 74 "/usr/local/include/c++/10.0.0/memory" 2 3
# 1 "/usr/local/include/c++/10.0.0/ext/atomicity.h" 1 3
# 32 "/usr/local/include/c++/10.0.0/ext/atomicity.h" 3
       
# 33 "/usr/local/include/c++/10.0.0/ext/atomicity.h" 3


# 1 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/gthr.h" 1 3
# 30 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 148 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/gthr.h" 3
# 1 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 1 3
# 35 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
# 1 "/usr/include/pthread.h" 1 3 4
# 22 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 36 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 2 3 4
# 60 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4






# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap-16.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline unsigned int
__bswap_32 (unsigned int __bsx)
{
  return __builtin_bswap32 (__bsx);
}
# 108 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
  return __builtin_bswap64 (__bsx);
}
# 61 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 62 "/usr/include/endian.h" 2 3 4
# 23 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 29 "/usr/include/sched.h" 3 4
# 1 "/usr/local/lib/gcc/x86_64-pc-linux-gnu/10.0.0/include/stddef.h" 1 3 4
# 30 "/usr/include/sched.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4






typedef __time_t time_t;
# 32 "/usr/include/sched.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4







struct timespec
{
  __time_t tv_sec;
  __syscall_slong_t tv_nsec;
};
# 33 "/usr/include/sched.h" 2 3 4





typedef __pid_t pid_t;




# 1 "/usr/include/x86_64-linux-gnu/bits/sched.h" 1 3 4
# 75 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
struct sched_param
{
  int sched_priority;
};

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) throw ();


extern int unshare (int __flags) throw ();


extern int sched_getcpu (void) throw ();


extern int setns (int __fd, int __nstype) throw ();


}
# 44 "/usr/include/sched.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 115 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 3 4
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
     throw ();
extern cpu_set_t *__sched_cpualloc (size_t __count) throw () ;
extern void __sched_cpufree (cpu_set_t *__set) throw ();

}
# 45 "/usr/include/sched.h" 2 3 4






extern "C" {


extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     throw ();


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) throw ();


extern int sched_getscheduler (__pid_t __pid) throw ();


extern int sched_yield (void) throw ();


extern int sched_get_priority_max (int __algorithm) throw ();


extern int sched_get_priority_min (int __algorithm) throw ();


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();
# 121 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) throw ();


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) throw ();


}
# 24 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
# 1 "/usr/local/lib/gcc/x86_64-pc-linux-gnu/10.0.0/include/stddef.h" 1 3 4
# 30 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 73 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timex.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};
# 23 "/usr/include/x86_64-linux-gnu/bits/timex.h" 2 3 4



struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
# 74 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4

extern "C" {


extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) throw ();

}
# 34 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 38 "/usr/include/time.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h" 1 3 4






struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};
# 40 "/usr/include/time.h" 2 3 4






# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 47 "/usr/include/time.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 48 "/usr/include/time.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h" 1 3 4







struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };
# 49 "/usr/include/time.h" 2 3 4
struct sigevent;
# 68 "/usr/include/time.h" 3 4
extern "C" {



extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) throw ();




extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     throw ();






extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) throw ();



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    locale_t __loc) throw ();





extern struct tm *gmtime (const time_t *__timer) throw ();



extern struct tm *localtime (const time_t *__timer) throw ();




extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();




extern char *asctime (const struct tm *__tp) throw ();


extern char *ctime (const time_t *__timer) throw ();






extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;





extern int stime (const time_t *__when) throw ();
# 196 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
# 211 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();





extern int timespec_get (struct timespec *__ts, int __base)
     throw () __attribute__ ((__nonnull__ (1)));
# 280 "/usr/include/time.h" 3 4
extern int getdate_err;
# 289 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 303 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 25 "/usr/include/pthread.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 77 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 65 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 99 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
};
# 78 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 118 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
struct __pthread_mutex_s
{
  int __lock ;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;
 




  short __spins; short __elision;
  __pthread_list_t __list;
# 145 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
 
};




struct __pthread_cond_s
{
  __extension__ union
  {
    __extension__ unsigned long long int __wseq;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __wseq32;
  };
  __extension__ union
  {
    __extension__ unsigned long long int __g1_start;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __g1_start32;
  };
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 27 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 28 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/pthread.h" 2 3 4




enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 115 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 156 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 191 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 229 "/usr/include/pthread.h" 3 4
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) throw () __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) throw ();



extern pthread_t pthread_self (void) throw () __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  throw () __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));


extern int pthread_getattr_default_np (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_setattr_default_np (const pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));




extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     throw ();




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     throw () __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) throw ();


extern int pthread_setconcurrency (int __level) throw ();







extern int pthread_yield (void) throw ();




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));
# 495 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 507 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 541 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};




class __pthread_cleanup_class
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;

 public:
  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)
    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }
  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }
  void __setdoit (int __newval) { __do_it = __newval; }
  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,
        &__cancel_type); }
  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }
};
# 743 "/usr/include/pthread.h" 3 4
struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) throw ();





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     throw () __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));
# 807 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (const pthread_mutexattr_t *__attr,
        int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));
# 889 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) throw () __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 1001 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     throw () __attribute__ ((__nonnull__ (1)));
# 1045 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
# 1112 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) throw ();


extern void *pthread_getspecific (pthread_key_t __key) throw ();


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer) throw () ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     throw () __attribute__ ((__nonnull__ (2)));
# 1146 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) throw ();




extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) pthread_equal (pthread_t __thread1, pthread_t __thread2) throw ()
{
  return __thread1 == __thread2;
}


}
# 36 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 2 3
# 47 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
# 102 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static __typeof(pthread_once) __gthrw_pthread_once __attribute__ ((__weakref__("pthread_once"), __copy__ (pthread_once)));
static __typeof(pthread_getspecific) __gthrw_pthread_getspecific __attribute__ ((__weakref__("pthread_getspecific"), __copy__ (pthread_getspecific)));
static __typeof(pthread_setspecific) __gthrw_pthread_setspecific __attribute__ ((__weakref__("pthread_setspecific"), __copy__ (pthread_setspecific)));

static __typeof(pthread_create) __gthrw_pthread_create __attribute__ ((__weakref__("pthread_create"), __copy__ (pthread_create)));
static __typeof(pthread_join) __gthrw_pthread_join __attribute__ ((__weakref__("pthread_join"), __copy__ (pthread_join)));
static __typeof(pthread_equal) __gthrw_pthread_equal __attribute__ ((__weakref__("pthread_equal"), __copy__ (pthread_equal)));
static __typeof(pthread_self) __gthrw_pthread_self __attribute__ ((__weakref__("pthread_self"), __copy__ (pthread_self)));
static __typeof(pthread_detach) __gthrw_pthread_detach __attribute__ ((__weakref__("pthread_detach"), __copy__ (pthread_detach)));

static __typeof(pthread_cancel) __gthrw_pthread_cancel __attribute__ ((__weakref__("pthread_cancel"), __copy__ (pthread_cancel)));

static __typeof(sched_yield) __gthrw_sched_yield __attribute__ ((__weakref__("sched_yield"), __copy__ (sched_yield)));

static __typeof(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__ ((__weakref__("pthread_mutex_lock"), __copy__ (pthread_mutex_lock)));
static __typeof(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute__ ((__weakref__("pthread_mutex_trylock"), __copy__ (pthread_mutex_trylock)));

static __typeof(pthread_mutex_timedlock) __gthrw_pthread_mutex_timedlock __attribute__ ((__weakref__("pthread_mutex_timedlock"), __copy__ (pthread_mutex_timedlock)));

static __typeof(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute__ ((__weakref__("pthread_mutex_unlock"), __copy__ (pthread_mutex_unlock)));
static __typeof(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute__ ((__weakref__("pthread_mutex_init"), __copy__ (pthread_mutex_init)));
static __typeof(pthread_mutex_destroy) __gthrw_pthread_mutex_destroy __attribute__ ((__weakref__("pthread_mutex_destroy"), __copy__ (pthread_mutex_destroy)));

static __typeof(pthread_cond_init) __gthrw_pthread_cond_init __attribute__ ((__weakref__("pthread_cond_init"), __copy__ (pthread_cond_init)));
static __typeof(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute__ ((__weakref__("pthread_cond_broadcast"), __copy__ (pthread_cond_broadcast)));
static __typeof(pthread_cond_signal) __gthrw_pthread_cond_signal __attribute__ ((__weakref__("pthread_cond_signal"), __copy__ (pthread_cond_signal)));
static __typeof(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute__ ((__weakref__("pthread_cond_wait"), __copy__ (pthread_cond_wait)));
static __typeof(pthread_cond_timedwait) __gthrw_pthread_cond_timedwait __attribute__ ((__weakref__("pthread_cond_timedwait"), __copy__ (pthread_cond_timedwait)));
static __typeof(pthread_cond_destroy) __gthrw_pthread_cond_destroy __attribute__ ((__weakref__("pthread_cond_destroy"), __copy__ (pthread_cond_destroy)));

static __typeof(pthread_key_create) __gthrw_pthread_key_create __attribute__ ((__weakref__("pthread_key_create"), __copy__ (pthread_key_create)));
static __typeof(pthread_key_delete) __gthrw_pthread_key_delete __attribute__ ((__weakref__("pthread_key_delete"), __copy__ (pthread_key_delete)));
static __typeof(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute__ ((__weakref__("pthread_mutexattr_init"), __copy__ (pthread_mutexattr_init)));
static __typeof(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute__ ((__weakref__("pthread_mutexattr_settype"), __copy__ (pthread_mutexattr_settype)));
static __typeof(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute__ ((__weakref__("pthread_mutexattr_destroy"), __copy__ (pthread_mutexattr_destroy)));
# 237 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static __typeof(pthread_key_create) __gthrw___pthread_key_create __attribute__ ((__weakref__("__pthread_key_create"), __copy__ (pthread_key_create)));
# 247 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  static void *const __gthread_active_ptr
    = __extension__ (void *) &__gthrw___pthread_key_create;
  return __gthread_active_ptr != 0;
}
# 659 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return __gthrw_pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return __gthrw_pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return __gthrw_pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return __gthrw_pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return __gthrw_pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return __gthrw_sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return __gthrw_pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return __gthrw_pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return __gthrw_pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return __gthrw_pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return __gthrw_pthread_setspecific (__key, __ptr);
}

static inline void
__gthread_mutex_init_function (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    __gthrw_pthread_mutex_init (__mutex, __null);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_trylock (__mutex);
  else
    return 0;
}


static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
      const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_timedlock (__mutex, __abs_timeout);
  else
    return 0;
}


static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_unlock (__mutex);
  else
    return 0;
}
# 808 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}


static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
         const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}


static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_destroy (__mutex);
}
# 850 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return __gthrw_pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return __gthrw_pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return __gthrw_pthread_cond_destroy (__cond);
}
# 149 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/gthr.h" 2 3


#pragma GCC visibility pop
# 36 "/usr/local/include/c++/10.0.0/ext/atomicity.h" 2 3
# 1 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/atomic_word.h" 1 3
# 32 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 37 "/usr/local/include/c++/10.0.0/ext/atomicity.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{







  inline _Atomic_word
  __attribute__((__always_inline__))
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, 4); }

  inline void
  __attribute__((__always_inline__))
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __atomic_fetch_add(__mem, __val, 4); }
# 64 "/usr/local/include/c++/10.0.0/ext/atomicity.h" 3
  inline _Atomic_word
  __attribute__((__always_inline__))
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  inline void
  __attribute__((__always_inline__))
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  inline _Atomic_word
  __attribute__ ((__always_inline__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);

    return __exchange_and_add_single(__mem, __val);
  }

  inline void
  __attribute__ ((__always_inline__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      {
 __atomic_add(__mem, __val);
 return;
      }

    __atomic_add_single(__mem, __val);
  }


}
# 75 "/usr/local/include/c++/10.0.0/memory" 2 3
# 1 "/usr/local/include/c++/10.0.0/ext/concurrence.h" 1 3
# 32 "/usr/local/include/c++/10.0.0/ext/concurrence.h" 3
       
# 33 "/usr/local/include/c++/10.0.0/ext/concurrence.h" 3







namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{







  enum _Lock_policy { _S_single, _S_mutex, _S_atomic };



  static const _Lock_policy __default_lock_policy =



  _S_atomic;






  class __concurrence_lock_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_lock_error"; }
  };

  class __concurrence_unlock_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_unlock_error"; }
  };

  class __concurrence_broadcast_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_broadcast_error"; }
  };

  class __concurrence_wait_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_wait_error"; }
  };


  inline void
  __throw_concurrence_lock_error()
  { (throw (__concurrence_lock_error())); }

  inline void
  __throw_concurrence_unlock_error()
  { (throw (__concurrence_unlock_error())); }


  inline void
  __throw_concurrence_broadcast_error()
  { (throw (__concurrence_broadcast_error())); }

  inline void
  __throw_concurrence_wait_error()
  { (throw (__concurrence_wait_error())); }


  class __mutex
  {
  private:

    __gthread_mutex_t _M_mutex = { { 0, 0, 0, 0, 0, 0, 0, { 0, 0 } } };




    __mutex(const __mutex&);
    __mutex& operator=(const __mutex&);

  public:
    __mutex()
    {




    }
# 144 "/usr/local/include/c++/10.0.0/ext/concurrence.h" 3
    void lock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_mutex_lock(&_M_mutex) != 0)
     __throw_concurrence_lock_error();
 }

    }

    void unlock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_mutex_unlock(&_M_mutex) != 0)
     __throw_concurrence_unlock_error();
 }

    }

    __gthread_mutex_t* gthread_mutex(void)
      { return &_M_mutex; }
  };

  class __recursive_mutex
  {
  private:

    __gthread_recursive_mutex_t _M_mutex = { { 0, 0, 0, 0, PTHREAD_MUTEX_RECURSIVE_NP, 0, 0, { 0, 0 } } };




    __recursive_mutex(const __recursive_mutex&);
    __recursive_mutex& operator=(const __recursive_mutex&);

  public:
    __recursive_mutex()
    {




    }
# 199 "/usr/local/include/c++/10.0.0/ext/concurrence.h" 3
    void lock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_recursive_mutex_lock(&_M_mutex) != 0)
     __throw_concurrence_lock_error();
 }

    }

    void unlock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_recursive_mutex_unlock(&_M_mutex) != 0)
     __throw_concurrence_unlock_error();
 }

    }

    __gthread_recursive_mutex_t* gthread_recursive_mutex(void)
    { return &_M_mutex; }
  };




  class __scoped_lock
  {
  public:
    typedef __mutex __mutex_type;

  private:
    __mutex_type& _M_device;

    __scoped_lock(const __scoped_lock&);
    __scoped_lock& operator=(const __scoped_lock&);

  public:
    explicit __scoped_lock(__mutex_type& __name) : _M_device(__name)
    { _M_device.lock(); }

    ~__scoped_lock() throw()
    { _M_device.unlock(); }
  };


  class __cond
  {
  private:

    __gthread_cond_t _M_cond = { { {0}, {0}, {0, 0}, {0, 0}, 0, 0, {0, 0} } };




    __cond(const __cond&);
    __cond& operator=(const __cond&);

  public:
    __cond()
    {




    }
# 277 "/usr/local/include/c++/10.0.0/ext/concurrence.h" 3
    void broadcast()
    {

      if (__gthread_active_p())
 {
   if (__gthread_cond_broadcast(&_M_cond) != 0)
     __throw_concurrence_broadcast_error();
 }

    }

    void wait(__mutex *mutex)
    {

      {
   if (__gthread_cond_wait(&_M_cond, mutex->gthread_mutex()) != 0)
     __throw_concurrence_wait_error();
      }

    }

    void wait_recursive(__recursive_mutex *mutex)
    {

      {
   if (__gthread_cond_wait_recursive(&_M_cond,
         mutex->gthread_recursive_mutex())
       != 0)
     __throw_concurrence_wait_error();
      }

    }
  };



}
# 76 "/usr/local/include/c++/10.0.0/memory" 2 3

# 1 "/usr/local/include/c++/10.0.0/bits/stl_function.h" 1 3
# 63 "/usr/local/include/c++/10.0.0/bits/stl_function.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 104 "/usr/local/include/c++/10.0.0/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    };
# 144 "/usr/local/include/c++/10.0.0/bits/stl_function.h" 3
  struct __is_transparent;

  template<typename _Tp = void>
    struct plus;

  template<typename _Tp = void>
    struct minus;

  template<typename _Tp = void>
    struct multiplies;

  template<typename _Tp = void>
    struct divides;

  template<typename _Tp = void>
    struct modulus;

  template<typename _Tp = void>
    struct negate;



  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };





  template<>
    struct plus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) + std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) + std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct minus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) - std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) - std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct multiplies<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) * std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) * std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct divides<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) / std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) / std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct modulus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) % std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) % std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct negate<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(-std::forward<_Tp>(__t)))
 -> decltype(-std::forward<_Tp>(__t))
 { return -std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
# 330 "/usr/local/include/c++/10.0.0/bits/stl_function.h" 3
  template<typename _Tp = void>
    struct equal_to;

  template<typename _Tp = void>
    struct not_equal_to;

  template<typename _Tp = void>
    struct greater;

  template<typename _Tp = void>
    struct less;

  template<typename _Tp = void>
    struct greater_equal;

  template<typename _Tp = void>
    struct less_equal;



  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };


  template<typename _Tp>
    struct greater<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      constexpr bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {


 if (__builtin_is_constant_evaluated())



   return __x > __y;

 return (long unsigned int)__x > (long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct less<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      constexpr bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {


 if (__builtin_is_constant_evaluated())



   return __x < __y;

 return (long unsigned int)__x < (long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct greater_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      constexpr bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {


 if (__builtin_is_constant_evaluated())



   return __x >= __y;

 return (long unsigned int)__x >= (long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct less_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      constexpr bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {


 if (__builtin_is_constant_evaluated())



   return __x <= __y;

 return (long unsigned int)__x <= (long unsigned int)__y;
      }
    };



  template<>
    struct equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) == std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct not_equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) != std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) != std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct greater<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) > std::forward<_Up>(__u))
 {
   return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
   __ptr_cmp<_Tp, _Up>{});
 }

      template<typename _Tp, typename _Up>
 constexpr bool
 operator()(_Tp* __t, _Up* __u) const noexcept
 { return greater<common_type_t<_Tp*, _Up*>>{}(__t, __u); }

      typedef __is_transparent is_transparent;

    private:
      template <typename _Tp, typename _Up>
 static constexpr decltype(auto)
 _S_cmp(_Tp&& __t, _Up&& __u, false_type)
 { return std::forward<_Tp>(__t) > std::forward<_Up>(__u); }

      template <typename _Tp, typename _Up>
 static constexpr bool
 _S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
 {
   return greater<const volatile void*>{}(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)),
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
 }


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded2 : true_type { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded2<_Tp, _Up, __void_t<
   decltype(std::declval<_Tp>().operator>(std::declval<_Up>()))>>
 : false_type { };


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded<_Tp, _Up, __void_t<
   decltype(operator>(std::declval<_Tp>(), std::declval<_Up>()))>>
 : false_type { };

      template<typename _Tp, typename _Up>
 using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
       is_convertible<_Tp, const volatile void*>,
       is_convertible<_Up, const volatile void*>>;
    };


  template<>
    struct less<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u))
 {
   return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
   __ptr_cmp<_Tp, _Up>{});
 }

      template<typename _Tp, typename _Up>
 constexpr bool
 operator()(_Tp* __t, _Up* __u) const noexcept
 { return less<common_type_t<_Tp*, _Up*>>{}(__t, __u); }

      typedef __is_transparent is_transparent;

    private:
      template <typename _Tp, typename _Up>
 static constexpr decltype(auto)
 _S_cmp(_Tp&& __t, _Up&& __u, false_type)
 { return std::forward<_Tp>(__t) < std::forward<_Up>(__u); }

      template <typename _Tp, typename _Up>
 static constexpr bool
 _S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
 {
   return less<const volatile void*>{}(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)),
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
 }


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded2 : true_type { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded2<_Tp, _Up, __void_t<
   decltype(std::declval<_Tp>().operator<(std::declval<_Up>()))>>
 : false_type { };


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded<_Tp, _Up, __void_t<
   decltype(operator<(std::declval<_Tp>(), std::declval<_Up>()))>>
 : false_type { };

      template<typename _Tp, typename _Up>
 using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
       is_convertible<_Tp, const volatile void*>,
       is_convertible<_Up, const volatile void*>>;
    };


  template<>
    struct greater_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))
 {
   return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
   __ptr_cmp<_Tp, _Up>{});
 }

      template<typename _Tp, typename _Up>
 constexpr bool
 operator()(_Tp* __t, _Up* __u) const noexcept
 { return greater_equal<common_type_t<_Tp*, _Up*>>{}(__t, __u); }

      typedef __is_transparent is_transparent;

    private:
      template <typename _Tp, typename _Up>
 static constexpr decltype(auto)
 _S_cmp(_Tp&& __t, _Up&& __u, false_type)
 { return std::forward<_Tp>(__t) >= std::forward<_Up>(__u); }

      template <typename _Tp, typename _Up>
 static constexpr bool
 _S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
 {
   return greater_equal<const volatile void*>{}(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)),
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
 }


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded2 : true_type { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded2<_Tp, _Up, __void_t<
   decltype(std::declval<_Tp>().operator>=(std::declval<_Up>()))>>
 : false_type { };


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded<_Tp, _Up, __void_t<
   decltype(operator>=(std::declval<_Tp>(), std::declval<_Up>()))>>
 : false_type { };

      template<typename _Tp, typename _Up>
 using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
       is_convertible<_Tp, const volatile void*>,
       is_convertible<_Up, const volatile void*>>;
    };


  template<>
    struct less_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))
 {
   return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
   __ptr_cmp<_Tp, _Up>{});
 }

      template<typename _Tp, typename _Up>
 constexpr bool
 operator()(_Tp* __t, _Up* __u) const noexcept
 { return less_equal<common_type_t<_Tp*, _Up*>>{}(__t, __u); }

      typedef __is_transparent is_transparent;

    private:
      template <typename _Tp, typename _Up>
 static constexpr decltype(auto)
 _S_cmp(_Tp&& __t, _Up&& __u, false_type)
 { return std::forward<_Tp>(__t) <= std::forward<_Up>(__u); }

      template <typename _Tp, typename _Up>
 static constexpr bool
 _S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
 {
   return less_equal<const volatile void*>{}(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)),
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
 }


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded2 : true_type { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded2<_Tp, _Up, __void_t<
   decltype(std::declval<_Tp>().operator<=(std::declval<_Up>()))>>
 : false_type { };


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded<_Tp, _Up, __void_t<
   decltype(operator<=(std::declval<_Tp>(), std::declval<_Up>()))>>
 : false_type { };

      template<typename _Tp, typename _Up>
 using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
       is_convertible<_Tp, const volatile void*>,
       is_convertible<_Up, const volatile void*>>;
    };
# 774 "/usr/local/include/c++/10.0.0/bits/stl_function.h" 3
  template<typename _Tp = void>
    struct logical_and;

  template<typename _Tp = void>
    struct logical_or;

  template<typename _Tp = void>
    struct logical_not;



  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };



  template<>
    struct logical_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) && std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) && std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) || std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) || std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(!std::forward<_Tp>(__t)))
 -> decltype(!std::forward<_Tp>(__t))
 { return !std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };




  template<typename _Tp = void>
    struct bit_and;

  template<typename _Tp = void>
    struct bit_or;

  template<typename _Tp = void>
    struct bit_xor;

  template<typename _Tp = void>
    struct bit_not;




  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };

  template<typename _Tp>
    struct bit_not : public unary_function<_Tp, _Tp>
    {
    constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return ~__x; }
    };


  template <>
    struct bit_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) & std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) & std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) | std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) | std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_xor<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) ^ std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(~std::forward<_Tp>(__t)))
 -> decltype(~std::forward<_Tp>(__t))
 { return ~std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
# 1002 "/usr/local/include/c++/10.0.0/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    constexpr
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    constexpr
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 1079 "/usr/local/include/c++/10.0.0/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity
    : public unary_function<_Tp, _Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };


  template<typename _Tp> struct _Identity<const _Tp> : _Identity<_Tp> { };

  template<typename _Pair>
    struct _Select1st
    : public unary_function<_Pair, typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }


      template<typename _Pair2>
        typename _Pair2::first_type&
        operator()(_Pair2& __x) const
        { return __x.first; }

      template<typename _Pair2>
        const typename _Pair2::first_type&
        operator()(const _Pair2& __x) const
        { return __x.first; }

    };

  template<typename _Pair>
    struct _Select2nd
    : public unary_function<_Pair, typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 1202 "/usr/local/include/c++/10.0.0/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }




}


# 1 "/usr/local/include/c++/10.0.0/backward/binders.h" 1 3
# 60 "/usr/local/include/c++/10.0.0/backward/binders.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

namespace std __attribute__ ((__visibility__ ("default")))
{

# 107 "/usr/local/include/c++/10.0.0/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}

#pragma GCC diagnostic pop
# 1393 "/usr/local/include/c++/10.0.0/bits/stl_function.h" 2 3
# 78 "/usr/local/include/c++/10.0.0/memory" 2 3
# 1 "/usr/local/include/c++/10.0.0/bits/uses_allocator.h" 1 3
# 35 "/usr/local/include/c++/10.0.0/bits/uses_allocator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  struct __erased_type { };




  template<typename _Alloc, typename _Tp>
    using __is_erased_or_convertible
      = __or_<is_convertible<_Alloc, _Tp>, is_same<_Tp, __erased_type>>;


  struct allocator_arg_t { explicit allocator_arg_t() = default; };

  inline constexpr allocator_arg_t allocator_arg =
    allocator_arg_t();

  template<typename _Tp, typename _Alloc, typename = __void_t<>>
    struct __uses_allocator_helper
    : false_type { };

  template<typename _Tp, typename _Alloc>
    struct __uses_allocator_helper<_Tp, _Alloc,
       __void_t<typename _Tp::allocator_type>>
    : __is_erased_or_convertible<_Alloc, typename _Tp::allocator_type>::type
    { };


  template<typename _Tp, typename _Alloc>
    struct uses_allocator
    : __uses_allocator_helper<_Tp, _Alloc>::type
    { };

  struct __uses_alloc_base { };

  struct __uses_alloc0 : __uses_alloc_base
  {
    struct _Sink { void constexpr operator=(const void*) { } } _M_a;
  };

  template<typename _Alloc>
    struct __uses_alloc1 : __uses_alloc_base { const _Alloc* _M_a; };

  template<typename _Alloc>
    struct __uses_alloc2 : __uses_alloc_base { const _Alloc* _M_a; };

  template<bool, typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc;

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<true, _Tp, _Alloc, _Args...>
    : conditional<
        is_constructible<_Tp, allocator_arg_t, const _Alloc&, _Args...>::value,
        __uses_alloc1<_Alloc>,
        __uses_alloc2<_Alloc>>::type
    {


      static_assert(__or_<
   is_constructible<_Tp, allocator_arg_t, const _Alloc&, _Args...>,
   is_constructible<_Tp, _Args..., const _Alloc&>>::value,
   "construction with an allocator must be possible"
   " if uses_allocator is true");
    };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<false, _Tp, _Alloc, _Args...>
    : __uses_alloc0 { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    using __uses_alloc_t =
      __uses_alloc<uses_allocator<_Tp, _Alloc>::value, _Tp, _Alloc, _Args...>;

  template<typename _Tp, typename _Alloc, typename... _Args>
    constexpr
    inline __uses_alloc_t<_Tp, _Alloc, _Args...>
    __use_alloc(const _Alloc& __a)
    {
      __uses_alloc_t<_Tp, _Alloc, _Args...> __ret;
      __ret._M_a = std::__addressof(__a);
      return __ret;
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void
    __use_alloc(const _Alloc&&) = delete;


  template <typename _Tp, typename _Alloc>
    inline constexpr bool uses_allocator_v =
      uses_allocator<_Tp, _Alloc>::value;


  template<template<typename...> class _Predicate,
    typename _Tp, typename _Alloc, typename... _Args>
    struct __is_uses_allocator_predicate
    : conditional<uses_allocator<_Tp, _Alloc>::value,
      __or_<_Predicate<_Tp, allocator_arg_t, _Alloc, _Args...>,
     _Predicate<_Tp, _Args..., _Alloc>>,
      _Predicate<_Tp, _Args...>>::type { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __is_uses_allocator_constructible
    : __is_uses_allocator_predicate<is_constructible, _Tp, _Alloc, _Args...>
    { };


  template<typename _Tp, typename _Alloc, typename... _Args>
    inline constexpr bool __is_uses_allocator_constructible_v =
      __is_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;


  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __is_nothrow_uses_allocator_constructible
    : __is_uses_allocator_predicate<is_nothrow_constructible,
        _Tp, _Alloc, _Args...>
    { };



  template<typename _Tp, typename _Alloc, typename... _Args>
    inline constexpr bool
    __is_nothrow_uses_allocator_constructible_v =
      __is_nothrow_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;


  template<typename _Tp, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc0 __a, _Tp* __ptr,
      _Args&&... __args)
    { ::new ((void*)__ptr) _Tp(std::forward<_Args>(__args)...); }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc1<_Alloc> __a, _Tp* __ptr,
      _Args&&... __args)
    {
      ::new ((void*)__ptr) _Tp(allocator_arg, *__a._M_a,
          std::forward<_Args>(__args)...);
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc2<_Alloc> __a, _Tp* __ptr,
      _Args&&... __args)
    { ::new ((void*)__ptr) _Tp(std::forward<_Args>(__args)..., *__a._M_a); }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct(const _Alloc& __a, _Tp* __ptr,
        _Args&&... __args)
    {
      std::__uses_allocator_construct_impl(
   std::__use_alloc<_Tp, _Alloc, _Args...>(__a), __ptr,
   std::forward<_Args>(__args)...);
    }


}
# 79 "/usr/local/include/c++/10.0.0/memory" 2 3



# 1 "/usr/local/include/c++/10.0.0/bits/unique_ptr.h" 1 3
# 37 "/usr/local/include/c++/10.0.0/bits/unique_ptr.h" 3
# 1 "/usr/local/include/c++/10.0.0/tuple" 1 3
# 32 "/usr/local/include/c++/10.0.0/tuple" 3
       
# 33 "/usr/local/include/c++/10.0.0/tuple" 3






# 1 "/usr/local/include/c++/10.0.0/array" 1 3
# 32 "/usr/local/include/c++/10.0.0/array" 3
       
# 33 "/usr/local/include/c++/10.0.0/array" 3
# 41 "/usr/local/include/c++/10.0.0/array" 3
# 1 "/usr/local/include/c++/10.0.0/bits/range_access.h" 1 3
# 33 "/usr/local/include/c++/10.0.0/bits/range_access.h" 3
       
# 34 "/usr/local/include/c++/10.0.0/bits/range_access.h" 3





namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Container>
    inline constexpr auto
    begin(_Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline constexpr auto
    begin(const _Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline constexpr auto
    end(_Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }






  template<typename _Container>
    inline constexpr auto
    end(const _Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }





  template<typename _Tp, size_t _Nm>
    inline constexpr _Tp*
    begin(_Tp (&__arr)[_Nm])
    { return __arr; }






  template<typename _Tp, size_t _Nm>
    inline constexpr _Tp*
    end(_Tp (&__arr)[_Nm])
    { return __arr + _Nm; }



  template<typename _Tp> class valarray;

  template<typename _Tp> _Tp* begin(valarray<_Tp>&);
  template<typename _Tp> const _Tp* begin(const valarray<_Tp>&);
  template<typename _Tp> _Tp* end(valarray<_Tp>&);
  template<typename _Tp> const _Tp* end(const valarray<_Tp>&);






  template<typename _Container>
    inline constexpr auto
    cbegin(const _Container& __cont) noexcept(noexcept(std::begin(__cont)))
      -> decltype(std::begin(__cont))
    { return std::begin(__cont); }






  template<typename _Container>
    inline constexpr auto
    cend(const _Container& __cont) noexcept(noexcept(std::end(__cont)))
      -> decltype(std::end(__cont))
    { return std::end(__cont); }






  template<typename _Container>
    inline constexpr auto
    rbegin(_Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    inline constexpr auto
    rbegin(const _Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    inline constexpr auto
    rend(_Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Container>
    inline constexpr auto
    rend(const _Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Tp, size_t _Nm>
    inline constexpr reverse_iterator<_Tp*>
    rbegin(_Tp (&__arr)[_Nm])
    { return reverse_iterator<_Tp*>(__arr + _Nm); }






  template<typename _Tp, size_t _Nm>
    inline constexpr reverse_iterator<_Tp*>
    rend(_Tp (&__arr)[_Nm])
    { return reverse_iterator<_Tp*>(__arr); }






  template<typename _Tp>
    inline constexpr reverse_iterator<const _Tp*>
    rbegin(initializer_list<_Tp> __il)
    { return reverse_iterator<const _Tp*>(__il.end()); }






  template<typename _Tp>
    inline constexpr reverse_iterator<const _Tp*>
    rend(initializer_list<_Tp> __il)
    { return reverse_iterator<const _Tp*>(__il.begin()); }






  template<typename _Container>
    inline constexpr auto
    crbegin(const _Container& __cont) -> decltype(std::rbegin(__cont))
    { return std::rbegin(__cont); }






  template<typename _Container>
    inline constexpr auto
    crend(const _Container& __cont) -> decltype(std::rend(__cont))
    { return std::rend(__cont); }
# 242 "/usr/local/include/c++/10.0.0/bits/range_access.h" 3
  template <typename _Container>
    constexpr auto
    size(const _Container& __cont) noexcept(noexcept(__cont.size()))
    -> decltype(__cont.size())
    { return __cont.size(); }




  template <typename _Tp, size_t _Nm>
    constexpr size_t
    size(const _Tp (&)[_Nm]) noexcept
    { return _Nm; }





  template <typename _Container>
    [[nodiscard]] constexpr auto
    empty(const _Container& __cont) noexcept(noexcept(__cont.empty()))
    -> decltype(__cont.empty())
    { return __cont.empty(); }




  template <typename _Tp, size_t _Nm>
    [[nodiscard]] constexpr bool
    empty(const _Tp (&)[_Nm]) noexcept
    { return false; }





  template <typename _Tp>
    [[nodiscard]] constexpr bool
    empty(initializer_list<_Tp> __il) noexcept
    { return __il.size() == 0;}





  template <typename _Container>
    constexpr auto
    data(_Container& __cont) noexcept(noexcept(__cont.data()))
    -> decltype(__cont.data())
    { return __cont.data(); }





  template <typename _Container>
    constexpr auto
    data(const _Container& __cont) noexcept(noexcept(__cont.data()))
    -> decltype(__cont.data())
    { return __cont.data(); }





  template <typename _Tp, size_t _Nm>
    constexpr _Tp*
    data(_Tp (&__array)[_Nm]) noexcept
    { return __array; }





  template <typename _Tp>
    constexpr const _Tp*
    data(initializer_list<_Tp> __il) noexcept
    { return __il.begin(); }




  template<typename _Container>
    constexpr auto
    ssize(const _Container& __cont)
    noexcept(noexcept(__cont.size()))
    -> common_type_t<ptrdiff_t, make_signed_t<decltype(__cont.size())>>
    {
      using type = make_signed_t<decltype(__cont.size())>;
      return static_cast<common_type_t<ptrdiff_t, type>>(__cont.size());
    }

  template<typename _Tp, ptrdiff_t _Num>
    constexpr ptrdiff_t
    ssize(const _Tp (&)[_Num]) noexcept
    { return _Num; }


namespace ranges
{
  template<typename>
    inline constexpr bool disable_sized_range = false;

  template<typename _Tp>
    inline constexpr bool enable_safe_range = false;

  namespace __detail
  {
    using __max_diff_type = long long;
    using __max_size_type = unsigned long long;

    template<typename _Tp>
      concept __is_integer_like = integral<_Tp>
 || same_as<_Tp, __max_diff_type> || same_as<_Tp, __max_size_type>;

    template<typename _Tp>
      concept __is_signed_integer_like = signed_integral<_Tp>
 || same_as<_Tp, __max_diff_type>;

    template<integral _Tp>
      constexpr make_unsigned_t<_Tp>
      __to_unsigned_like(_Tp __t) noexcept
      { return __t; }


    template<typename _Tp>
      concept __maybe_safe_range
 = is_lvalue_reference_v<_Tp> || enable_safe_range<remove_cvref_t<_Tp>>;

  }

  namespace __cust_access
  {
    using std::ranges::__detail::__maybe_safe_range;
    using std::__detail::__class_or_enum;

    template<typename _Tp>
      constexpr decay_t<_Tp>
      __decay_copy(_Tp&& __t)
      noexcept(is_nothrow_convertible_v<_Tp, decay_t<_Tp>>)
      { return std::forward<_Tp>(__t); }

    template<typename _Tp>
      concept __member_begin = requires(_Tp& __t)
 {
   { __decay_copy(__t.begin()) } -> input_or_output_iterator;
 };

    template<typename _Tp> void begin(_Tp&&) = delete;
    template<typename _Tp> void begin(initializer_list<_Tp>&&) = delete;

    template<typename _Tp>
      concept __adl_begin = __class_or_enum<remove_reference_t<_Tp>>
 && requires(_Tp& __t)
 {
   { __decay_copy(begin(__t)) } -> input_or_output_iterator;
 };

    struct _Begin
    {
    private:
      template<typename _Tp>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (is_array_v<remove_reference_t<_Tp>>)
     return true;
   else if constexpr (__member_begin<_Tp>)
     return noexcept(__decay_copy(std::declval<_Tp&>().begin()));
   else
     return noexcept(__decay_copy(begin(std::declval<_Tp&>())));
 }

    public:
      template<__maybe_safe_range _Tp>
 requires is_array_v<remove_reference_t<_Tp>> || __member_begin<_Tp>
   || __adl_begin<_Tp>
 constexpr auto
 operator()(_Tp&& __t) const noexcept(_S_noexcept<_Tp>())
 {
   if constexpr (is_array_v<remove_reference_t<_Tp>>)
     {
       static_assert(is_lvalue_reference_v<_Tp>);
       return __t;
     }
   else if constexpr (__member_begin<_Tp>)
     return __t.begin();
   else
     return begin(__t);
 }
    };

    template<typename _Tp>
      concept __member_end = requires(_Tp& __t)
 {
   { __decay_copy(__t.end()) }
     -> sentinel_for<decltype(_Begin{}(std::forward<_Tp>(__t)))>;
 };

    template<typename _Tp> void end(_Tp&&) = delete;
    template<typename _Tp> void end(initializer_list<_Tp>&&) = delete;

    template<typename _Tp>
      concept __adl_end = __class_or_enum<remove_reference_t<_Tp>>
 && requires(_Tp& __t)
 {
   { __decay_copy(end(__t)) }
     -> sentinel_for<decltype(_Begin{}(std::forward<_Tp>(__t)))>;
 };

    struct _End
    {
    private:
      template<typename _Tp>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (is_array_v<remove_reference_t<_Tp>>)
     return true;
   else if constexpr (__member_end<_Tp>)
     return noexcept(__decay_copy(std::declval<_Tp&>().end()));
   else
     return noexcept(__decay_copy(end(std::declval<_Tp&>())));
 }

    public:
      template<__maybe_safe_range _Tp>
 requires is_array_v<remove_reference_t<_Tp>> || __member_end<_Tp>
 || __adl_end<_Tp>
 constexpr auto
 operator()(_Tp&& __t) const noexcept(_S_noexcept<_Tp>())
 {
   if constexpr (is_array_v<remove_reference_t<_Tp>>)
     {
       static_assert(is_lvalue_reference_v<_Tp>);
       static_assert(is_bounded_array_v<remove_reference_t<_Tp>>);
       return __t + extent_v<remove_reference_t<_Tp>>;
     }
   else if constexpr (__member_end<_Tp>)
     return __t.end();
   else
     return end(__t);
 }
    };

    template<typename _Tp>
      constexpr decltype(auto)
      __as_const(_Tp&& __t) noexcept
      {
 if constexpr (is_lvalue_reference_v<_Tp>)
   return static_cast<const remove_reference_t<_Tp>&>(__t);
 else
   return static_cast<const _Tp&&>(__t);
      }

    struct _CBegin
    {
      template<typename _Tp>
 constexpr auto
 operator()(_Tp&& __e) const
 noexcept(noexcept(_Begin{}(__cust_access::__as_const((_Tp&&)__e))))
 requires requires { _Begin{}(__cust_access::__as_const((_Tp&&)__e)); }
 {
   return _Begin{}(__cust_access::__as_const(std::forward<_Tp>(__e)));
 }
    };

    struct _CEnd
    {
      template<typename _Tp>
 constexpr auto
 operator()(_Tp&& __e) const
 noexcept(noexcept(_End{}(__cust_access::__as_const((_Tp&&)__e))))
 requires requires { _End{}(__cust_access::__as_const((_Tp&&)__e)); }
 {
   return _End{}(__cust_access::__as_const(std::forward<_Tp>(__e)));
 }
    };

    template<typename _Tp>
      concept __member_rbegin = requires(_Tp& __t)
 {
   { __decay_copy(__t.rbegin()) } -> input_or_output_iterator;
 };

    template<typename _Tp> void rbegin(_Tp&&) = delete;

    template<typename _Tp>
      concept __adl_rbegin = __class_or_enum<remove_reference_t<_Tp>>
 && requires(_Tp& __t)
 {
   { __decay_copy(rbegin(__t)) } -> input_or_output_iterator;
 };

    template<typename _Tp>
      concept __reversable = requires(_Tp& __t)
 {
   { _Begin{}(__t) } -> bidirectional_iterator;
   { _End{}(__t) } -> same_as<decltype(_Begin{}(__t))>;
 };

    struct _RBegin
    {
    private:
      template<typename _Tp>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__member_rbegin<_Tp>)
     return noexcept(__decay_copy(std::declval<_Tp&>().rbegin()));
   else if constexpr (__adl_rbegin<_Tp>)
     return noexcept(__decay_copy(rbegin(std::declval<_Tp&>())));
   else
     {
       if constexpr (noexcept(_End{}(std::declval<_Tp&>())))
  {
    using _It = decltype(_End{}(std::declval<_Tp&>()));

    return is_nothrow_copy_constructible_v<_It>;
  }
       else
  return false;
     }
 }

    public:
      template<__maybe_safe_range _Tp>
 requires __member_rbegin<_Tp> || __adl_rbegin<_Tp> || __reversable<_Tp>
 constexpr auto
 operator()(_Tp&& __t) const
 noexcept(_S_noexcept<_Tp>())
 {
   if constexpr (__member_rbegin<_Tp>)
     return __t.rbegin();
   else if constexpr (__adl_rbegin<_Tp>)
     return rbegin(__t);
   else
     return std::make_reverse_iterator(_End{}(__t));
 }
    };

    template<typename _Tp>
      concept __member_rend = requires(_Tp& __t)
 {
   { __decay_copy(__t.rend()) }
     -> sentinel_for<decltype(_RBegin{}(__t))>;
 };

    template<typename _Tp> void rend(_Tp&&) = delete;

    template<typename _Tp>
      concept __adl_rend = __class_or_enum<remove_reference_t<_Tp>>
 && requires(_Tp& __t)
 {
   { __decay_copy(rend(__t)) }
     -> sentinel_for<decltype(_RBegin{}(std::forward<_Tp>(__t)))>;
 };

    struct _REnd
    {
    private:
      template<typename _Tp>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__member_rend<_Tp>)
     return noexcept(__decay_copy(std::declval<_Tp&>().rend()));
   else if constexpr (__adl_rend<_Tp>)
     return noexcept(__decay_copy(rend(std::declval<_Tp&>())));
   else
     {
       if constexpr (noexcept(_Begin{}(std::declval<_Tp&>())))
  {
    using _It = decltype(_Begin{}(std::declval<_Tp&>()));

    return is_nothrow_copy_constructible_v<_It>;
  }
       else
  return false;
     }
 }

    public:
      template<__maybe_safe_range _Tp>
 requires __member_rend<_Tp> || __adl_rend<_Tp> || __reversable<_Tp>
 constexpr auto
 operator()(_Tp&& __t) const
 noexcept(_S_noexcept<_Tp>())
 {
   if constexpr (__member_rend<_Tp>)
     return __t.rend();
   else if constexpr (__adl_rend<_Tp>)
     return rend(__t);
   else
     return std::make_reverse_iterator(_Begin{}(__t));
 }
    };

    struct _CRBegin
    {
      template<typename _Tp>
 constexpr auto
 operator()(_Tp&& __e) const
 noexcept(noexcept(_RBegin{}(__cust_access::__as_const((_Tp&&)__e))))
 requires requires { _RBegin{}(__cust_access::__as_const((_Tp&&)__e)); }
 {
   return _RBegin{}(__cust_access::__as_const(std::forward<_Tp>(__e)));
 }
    };

    struct _CREnd
    {
      template<typename _Tp>
 constexpr auto
 operator()(_Tp&& __e) const
 noexcept(noexcept(_REnd{}(__cust_access::__as_const((_Tp&&)__e))))
 requires requires { _REnd{}(__cust_access::__as_const((_Tp&&)__e)); }
 {
   return _REnd{}(__cust_access::__as_const(std::forward<_Tp>(__e)));
 }
    };

    template<typename _Tp>
      concept __member_size = !disable_sized_range<remove_cvref_t<_Tp>>
 && requires(_Tp&& __t)
 {
   { __decay_copy(std::forward<_Tp>(__t).size()) }
     -> __detail::__is_integer_like;
 };

    template<typename _Tp> void size(_Tp&&) = delete;

    template<typename _Tp>
      concept __adl_size = __class_or_enum<remove_reference_t<_Tp>>
 && !disable_sized_range<remove_cvref_t<_Tp>>
 && requires(_Tp&& __t)
 {
   { __decay_copy(size(std::forward<_Tp>(__t))) }
     -> __detail::__is_integer_like;
 };

    template<typename _Tp>
      concept __sentinel_size = requires(_Tp&& __t)
 {
   { _Begin{}(std::forward<_Tp>(__t)) } -> forward_iterator;

   { _End{}(std::forward<_Tp>(__t)) }
     -> sized_sentinel_for<decltype(_Begin{}(std::forward<_Tp>(__t)))>;
 };

    struct _Size
    {
    private:
      template<typename _Tp>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (is_array_v<remove_reference_t<_Tp>>)
     return true;
   else if constexpr (__member_size<_Tp>)
     return noexcept(__decay_copy(std::declval<_Tp>().size()));
   else if constexpr (__adl_size<_Tp>)
     return noexcept(__decay_copy(size(std::declval<_Tp>())));
   else if constexpr (__sentinel_size<_Tp>)
     return noexcept(_End{}(std::declval<_Tp>())
       - _Begin{}(std::declval<_Tp>()));
 }

    public:
      template<typename _Tp>
 requires is_array_v<remove_reference_t<_Tp>>
   || __member_size<_Tp> || __adl_size<_Tp> || __sentinel_size<_Tp>
 constexpr auto
 operator()(_Tp&& __e) const noexcept(_S_noexcept<_Tp>())
 {
   if constexpr (is_array_v<remove_reference_t<_Tp>>)
     {
       static_assert(is_bounded_array_v<remove_reference_t<_Tp>>);
       return extent_v<remove_reference_t<_Tp>>;
     }
   else if constexpr (__member_size<_Tp>)
     return std::forward<_Tp>(__e).size();
   else if constexpr (__adl_size<_Tp>)
     return size(std::forward<_Tp>(__e));
   else if constexpr (__sentinel_size<_Tp>)
     return __detail::__to_unsigned_like(
  _End{}(std::forward<_Tp>(__e))
  - _Begin{}(std::forward<_Tp>(__e)));
 }
    };

    template<typename _Tp>
      concept __member_empty = requires(_Tp&& __t)
 { bool(std::forward<_Tp>(__t).empty()); };

    template<typename _Tp>
      concept __size0_empty = requires(_Tp&& __t)
 { _Size{}(std::forward<_Tp>(__t)) == 0; };

    template<typename _Tp>
      concept __eq_iter_empty = requires(_Tp&& __t)
 {
   { _Begin{}(std::forward<_Tp>(__t)) } -> forward_iterator;
   bool(_Begin{}(std::forward<_Tp>(__t))
       == _End{}(std::forward<_Tp>(__t)));
 };

    struct _Empty
    {
    private:
      template<typename _Tp>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__member_empty<_Tp>)
     return noexcept(std::declval<_Tp>().empty());
   else if constexpr (__size0_empty<_Tp>)
     return noexcept(_Size{}(std::declval<_Tp>()) == 0);
   else
     return noexcept(bool(_Begin{}(std::declval<_Tp>())
  == _End{}(std::declval<_Tp>())));
 }

    public:
      template<typename _Tp>
 requires __member_empty<_Tp> || __size0_empty<_Tp>
 || __eq_iter_empty<_Tp>
 constexpr auto
 operator()(_Tp&& __e) const noexcept(_S_noexcept<_Tp>())
 {
   if constexpr (__member_empty<_Tp>)
     return bool(std::forward<_Tp>(__e).empty());
   else if constexpr (__size0_empty<_Tp>)
     return _Size{}(std::forward<_Tp>(__e)) == 0;
   else
     return bool(_Begin{}(std::forward<_Tp>(__e))
  == _End{}(std::forward<_Tp>(__e)));
 }
    };

    template<typename _Tp>
      concept __pointer_to_object = is_pointer_v<_Tp>
        && is_object_v<remove_pointer_t<_Tp>>;

    template<typename _Tp>
      concept __member_data = is_lvalue_reference_v<_Tp>
 && requires(_Tp __t) { { __t.data() } -> __pointer_to_object; };

    template<typename _Tp>
      concept __begin_data = requires(_Tp&& __t)
 { { _Begin{}(std::forward<_Tp>(__t)) } -> contiguous_iterator; };

    struct _Data
    {
    private:
      template<typename _Tp>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__member_data<_Tp>)
     return noexcept(__decay_copy(std::declval<_Tp>().data()));
   else
     return noexcept(_Begin{}(std::declval<_Tp>()));
 }

    public:
      template<typename _Tp> requires __member_data<_Tp> || __begin_data<_Tp>
 constexpr auto
 operator()(_Tp&& __e) const noexcept(_S_noexcept<_Tp>())
 {
   if constexpr (__member_data<_Tp>)
     return __e.data();
   else
     return std::to_address(_Begin{}(std::forward<_Tp>(__e)));
 }
    };

    struct _CData
    {
      template<typename _Tp>
 constexpr auto
 operator()(_Tp&& __e) const
 noexcept(noexcept(_Data{}(__cust_access::__as_const((_Tp&&)__e))))
 requires requires { _Data{}(__cust_access::__as_const((_Tp&&)__e)); }
 {
   return _Data{}(__cust_access::__as_const(std::forward<_Tp>(__e)));
 }
    };

  }

  inline namespace __cust
  {
    inline constexpr __cust_access::_Begin begin{};
    inline constexpr __cust_access::_End end{};
    inline constexpr __cust_access::_CBegin cbegin{};
    inline constexpr __cust_access::_CEnd cend{};
    inline constexpr __cust_access::_RBegin rbegin{};
    inline constexpr __cust_access::_REnd rend{};
    inline constexpr __cust_access::_CRBegin crbegin{};
    inline constexpr __cust_access::_CREnd crend{};
    inline constexpr __cust_access::_Size size{};
    inline constexpr __cust_access::_Empty empty{};
    inline constexpr __cust_access::_Data data{};
    inline constexpr __cust_access::_CData cdata{};
  }


  template<typename _Tp>
    concept range = requires(_Tp& __t)
      {
 ranges::begin(__t);
 ranges::end(__t);
      };


  template<typename _Tp>
    concept safe_range = range<_Tp> && __detail::__maybe_safe_range<_Tp>;

  template<range _Range>
    using iterator_t = decltype(ranges::begin(std::declval<_Range&>()));

  template<range _Range>
    using sentinel_t = decltype(ranges::end(std::declval<_Range&>()));

  template<range _Range>
    using range_difference_t = iter_difference_t<iterator_t<_Range>>;

  template<range _Range>
    using range_value_t = iter_value_t<iterator_t<_Range>>;

  template<range _Range>
    using range_reference_t = iter_reference_t<iterator_t<_Range>>;

  template<range _Range>
    using range_rvalue_reference_t
      = iter_rvalue_reference_t<iterator_t<_Range>>;


  template<typename _Tp>
    concept sized_range = range<_Tp>
      && requires(_Tp& __t) { ranges::size(__t); };




  template<typename _Range, typename _Tp>
    concept output_range
      = range<_Range> && output_iterator<iterator_t<_Range>, _Tp>;


  template<typename _Tp>
    concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;


  template<typename _Tp>
    concept forward_range
      = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;


  template<typename _Tp>
    concept bidirectional_range
      = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;


  template<typename _Tp>
    concept random_access_range
      = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;


  template<typename _Tp>
    concept contiguous_range
      = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>>
      && requires(_Tp& __t)
      {
 { ranges::data(__t) } -> same_as<add_pointer_t<range_reference_t<_Tp>>>;
      };


  template<typename _Tp>
    concept common_range
      = range<_Tp> && same_as<iterator_t<_Tp>, sentinel_t<_Tp>>;



  template<input_or_output_iterator _It>
    constexpr void
    advance(_It& __it, iter_difference_t<_It> __n)
    {
      if constexpr (random_access_iterator<_It>)
 __it += __n;
      else if constexpr (bidirectional_iterator<_It>)
 {
   if (__n > 0)
     {
       do
  {
    ++__it;
  }
       while (--__n);
     }
   else if (__n < 0)
     {
       do
  {
    --__it;
  }
       while (++__n);
     }
 }
      else
 {

   if (std::is_constant_evaluated() && __n < 0)
     throw "attempt to decrement a non-bidirectional iterator";

   ;
   while (__n-- > 0)
     ++__it;
 }
    }

  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
    constexpr void
    advance(_It& __it, _Sent __bound)
    {
      if constexpr (assignable_from<_It&, _Sent>)
 __it = std::move(__bound);
      else if constexpr (sized_sentinel_for<_Sent, _It>)
 ranges::advance(__it, __bound - __it);
      else
 {
   while (__it != __bound)
     ++__it;
 }
    }

  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
    constexpr iter_difference_t<_It>
    advance(_It& __it, iter_difference_t<_It> __n, _Sent __bound)
    {
      if constexpr (sized_sentinel_for<_Sent, _It>)
 {
   const auto __diff = __bound - __it;

   if (std::is_constant_evaluated()
       && !(__n == 0 || __diff == 0 || (__n < 0 == __diff < 0)))
     throw "inconsistent directions for distance and bound";


   ;
   const auto __absdiff = __diff < 0 ? -__diff : __diff;
   const auto __absn = __n < 0 ? -__n : __n;;
   if (__absn >= __absdiff)
     {
       ranges::advance(__it, __bound);
       return __n - __diff;
     }
   else
     {
       ranges::advance(__it, __n);
       return 0;
     }
 }
      else if (__it == __bound || __n == 0)
 return iter_difference_t<_It>(0);
      else if (__n > 0)
 {
   iter_difference_t<_It> __m = 0;
   do
     {
       ++__it;
       ++__m;
     }
   while (__m != __n && __it != __bound);
   return __n - __m;
 }
      else if constexpr (bidirectional_iterator<_It> && same_as<_It, _Sent>)
 {
   iter_difference_t<_It> __m = 0;
   do
     {
       --__it;
       --__m;
     }
   while (__m != __n && __it != __bound);
   return __n - __m;
 }
      else
 {

   if (std::is_constant_evaluated() && __n < 0)
     throw "attempt to decrement a non-bidirectional iterator";

   ;
   return __n;
 }
    }

  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
    constexpr iter_difference_t<_It>
    distance(_It __first, _Sent __last)
    {
      if constexpr (sized_sentinel_for<_Sent, _It>)
 return __last - __first;
      else
 {
   iter_difference_t<_It> __n = 0;
   while (__first != __last)
     {
       ++__first;
       ++__n;
     }
   return __n;
 }
    }

  template<range _Range>
    constexpr range_difference_t<_Range>
    distance(_Range&& __r)
    {
      if constexpr (sized_range<_Range>)
 return static_cast<range_difference_t<_Range>>(ranges::size(__r));
      else
 return ranges::distance(ranges::begin(__r), ranges::end(__r));
    }

  template<input_or_output_iterator _It>
    constexpr _It
    next(_It __x)
    {
      ++__x;
      return __x;
    }

  template<input_or_output_iterator _It>
    constexpr _It
    next(_It __x, iter_difference_t<_It> __n)
    {
      ranges::advance(__x, __n);
      return __x;
    }

  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
    constexpr _It
    next(_It __x, _Sent __bound)
    {
      ranges::advance(__x, __bound);
      return __x;
    }

  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
    constexpr _It
    next(_It __x, iter_difference_t<_It> __n, _Sent __bound)
    {
      ranges::advance(__x, __n, __bound);
      return __x;
    }

  template<bidirectional_iterator _It>
    constexpr _It
    prev(_It __x)
    {
      --__x;
      return __x;
    }

  template<bidirectional_iterator _It>
    constexpr _It
    prev(_It __x, iter_difference_t<_It> __n)
    {
      ranges::advance(__x, -__n);
      return __x;
    }

  template<bidirectional_iterator _It>
    constexpr _It
    prev(_It __x, iter_difference_t<_It> __n, _It __bound)
    {
      ranges::advance(__x, -__n, __bound);
      return __x;
    }

}



}
# 42 "/usr/local/include/c++/10.0.0/array" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, std::size_t _Nm>
    struct __array_traits
    {
      typedef _Tp _Type[_Nm];
      typedef __is_swappable<_Tp> _Is_swappable;
      typedef __is_nothrow_swappable<_Tp> _Is_nothrow_swappable;

      static constexpr _Tp&
      _S_ref(const _Type& __t, std::size_t __n) noexcept
      { return const_cast<_Tp&>(__t[__n]); }

      static constexpr _Tp*
      _S_ptr(const _Type& __t) noexcept
      { return const_cast<_Tp*>(__t); }
    };

 template<typename _Tp>
   struct __array_traits<_Tp, 0>
   {
     struct _Type { };
     typedef true_type _Is_swappable;
     typedef true_type _Is_nothrow_swappable;

     static constexpr _Tp&
     _S_ref(const _Type&, std::size_t) noexcept
     { return *static_cast<_Tp*>(nullptr); }

     static constexpr _Tp*
     _S_ptr(const _Type&) noexcept
     { return nullptr; }
   };
# 93 "/usr/local/include/c++/10.0.0/array" 3
  template<typename _Tp, std::size_t _Nm>
    struct array
    {
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef value_type* iterator;
      typedef const value_type* const_iterator;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;


      typedef std::__array_traits<_Tp, _Nm> _AT_Type;
      typename _AT_Type::_Type _M_elems;




      constexpr void
      fill(const value_type& __u)
      { std::fill_n(begin(), size(), __u); }

      constexpr void
      swap(array& __other)
      noexcept(_AT_Type::_Is_nothrow_swappable::value)
      { std::swap_ranges(begin(), end(), __other.begin()); }


      constexpr iterator
      begin() noexcept
      { return iterator(data()); }

      constexpr const_iterator
      begin() const noexcept
      { return const_iterator(data()); }

      constexpr iterator
      end() noexcept
      { return iterator(data() + _Nm); }

      constexpr const_iterator
      end() const noexcept
      { return const_iterator(data() + _Nm); }

      constexpr reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      constexpr const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      constexpr reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      constexpr const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }

      constexpr const_iterator
      cbegin() const noexcept
      { return const_iterator(data()); }

      constexpr const_iterator
      cend() const noexcept
      { return const_iterator(data() + _Nm); }

      constexpr const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }

      constexpr const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }


      constexpr size_type
      size() const noexcept { return _Nm; }

      constexpr size_type
      max_size() const noexcept { return _Nm; }

      [[__nodiscard__]] constexpr bool
      empty() const noexcept { return size() == 0; }


      constexpr reference
      operator[](size_type __n) noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

      constexpr const_reference
      operator[](size_type __n) const noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

      constexpr reference
      at(size_type __n)
      {
 if (__n >= _Nm)
   std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)")
                                 ,
     __n, _Nm);
 return _AT_Type::_S_ref(_M_elems, __n);
      }

      constexpr const_reference
      at(size_type __n) const
      {


 return __n < _Nm ? _AT_Type::_S_ref(_M_elems, __n)
   : (std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)")
                                    ,
        __n, _Nm),
      _AT_Type::_S_ref(_M_elems, 0));
      }

      constexpr reference
      front() noexcept
      { return *begin(); }

      constexpr const_reference
      front() const noexcept
      { return _AT_Type::_S_ref(_M_elems, 0); }

      constexpr reference
      back() noexcept
      { return _Nm ? *(end() - 1) : *end(); }

      constexpr const_reference
      back() const noexcept
      {
 return _Nm ? _AT_Type::_S_ref(_M_elems, _Nm - 1)
             : _AT_Type::_S_ref(_M_elems, 0);
      }

      constexpr pointer
      data() noexcept
      { return _AT_Type::_S_ptr(_M_elems); }

      constexpr const_pointer
      data() const noexcept
      { return _AT_Type::_S_ptr(_M_elems); }
    };


  template<typename _Tp, typename... _Up>
    array(_Tp, _Up...)
      -> array<enable_if_t<(is_same_v<_Tp, _Up> && ...), _Tp>,
        1 + sizeof...(_Up)>;



  template<typename _Tp, std::size_t _Nm>
    constexpr
    inline bool
    operator==(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return std::equal(__one.begin(), __one.end(), __two.begin()); }


  template<typename _Tp, size_t _Nm>
    constexpr __detail::__synth3way_t<_Tp>
    operator<=>(const array<_Tp, _Nm>& __a, const array<_Tp, _Nm>& __b)
    {
      if constexpr (_Nm && __is_byte<_Tp>::__value)
 return __builtin_memcmp(__a.data(), __b.data(), _Nm) <=> 0;
      else
 {
   for (size_t __i = 0; __i < _Nm; ++__i)
     {
       auto __c = __detail::__synth3way(__a[__i], __b[__i]);
       if (__c != 0)
  return __c;
     }
 }
      return strong_ordering::equal;
    }
# 310 "/usr/local/include/c++/10.0.0/array" 3
  template<typename _Tp, std::size_t _Nm>
    constexpr
    inline


    typename enable_if<
      std::__array_traits<_Tp, _Nm>::_Is_swappable::value
    >::type



    swap(array<_Tp, _Nm>& __one, array<_Tp, _Nm>& __two)
    noexcept(noexcept(__one.swap(__two)))
    { __one.swap(__two); }


  template<typename _Tp, std::size_t _Nm>
    typename enable_if<
      !std::__array_traits<_Tp, _Nm>::_Is_swappable::value>::type
    swap(array<_Tp, _Nm>&, array<_Tp, _Nm>&) = delete;


  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&
    get(array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&&
    get(array<_Tp, _Nm>&& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::move(std::get<_Int>(__arr));
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr const _Tp&
    get(const array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr const _Tp&&
    get(const array<_Tp, _Nm>&& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::move(std::get<_Int>(__arr));
    }




  template<bool _Move = false, typename _Tp, size_t... _Idx>
    constexpr array<remove_cv_t<_Tp>, sizeof...(_Idx)>
    __to_array(_Tp (&__a)[sizeof...(_Idx)], index_sequence<_Idx...>)
    {
      if constexpr (_Move)
 return {{std::move(__a[_Idx])...}};
      else
 return {{__a[_Idx]...}};
    }

  template<typename _Tp, size_t _Nm>
    constexpr array<remove_cv_t<_Tp>, _Nm>
    to_array(_Tp (&__a)[_Nm])
    noexcept(is_nothrow_constructible_v<_Tp, _Tp&>)
    {
      static_assert(!is_array_v<_Tp>);
      static_assert(is_constructible_v<_Tp, _Tp&>);
      if constexpr (is_constructible_v<_Tp, _Tp&>)
 return std::__to_array(__a, make_index_sequence<_Nm>{});
      __builtin_unreachable();
    }

  template<typename _Tp, size_t _Nm>
    constexpr array<remove_cv_t<_Tp>, _Nm>
    to_array(_Tp (&&__a)[_Nm])
    noexcept(is_nothrow_move_constructible_v<_Tp>)
    {
      static_assert(!is_array_v<_Tp>);
      static_assert(is_move_constructible_v<_Tp>);
      if constexpr (is_move_constructible_v<_Tp>)
 return std::__to_array<1>(__a, make_index_sequence<_Nm>{});
      __builtin_unreachable();
    }



}

namespace std __attribute__ ((__visibility__ ("default")))
{





  template<typename _Tp>
    struct tuple_size;


  template<typename _Tp, std::size_t _Nm>
    struct tuple_size<std::array<_Tp, _Nm>>
    : public integral_constant<std::size_t, _Nm> { };


  template<std::size_t _Int, typename _Tp>
    struct tuple_element;


  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    struct tuple_element<_Int, std::array<_Tp, _Nm>>
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      typedef _Tp type;
    };

  template<typename _Tp, std::size_t _Nm>
    struct __is_tuple_like_impl<std::array<_Tp, _Nm>> : true_type
    { };


}
# 40 "/usr/local/include/c++/10.0.0/tuple" 2 3

# 1 "/usr/local/include/c++/10.0.0/bits/invoke.h" 1 3
# 33 "/usr/local/include/c++/10.0.0/bits/invoke.h" 3
       
# 34 "/usr/local/include/c++/10.0.0/bits/invoke.h" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

# 52 "/usr/local/include/c++/10.0.0/bits/invoke.h" 3
  template<typename _Tp, typename _Up = typename __inv_unwrap<_Tp>::type>
    constexpr _Up&&
    __invfwd(typename remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Up&&>(__t); }

  template<typename _Res, typename _Fn, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_other, _Fn&& __f, _Args&&... __args)
    { return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_memfun_ref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    { return (__invfwd<_Tp>(__t).*__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_memfun_deref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    {
      return ((*std::forward<_Tp>(__t)).*__f)(std::forward<_Args>(__args)...);
    }

  template<typename _Res, typename _MemPtr, typename _Tp>
    constexpr _Res
    __invoke_impl(__invoke_memobj_ref, _MemPtr&& __f, _Tp&& __t)
    { return __invfwd<_Tp>(__t).*__f; }

  template<typename _Res, typename _MemPtr, typename _Tp>
    constexpr _Res
    __invoke_impl(__invoke_memobj_deref, _MemPtr&& __f, _Tp&& __t)
    { return (*std::forward<_Tp>(__t)).*__f; }


  template<typename _Callable, typename... _Args>
    constexpr typename __invoke_result<_Callable, _Args...>::type
    __invoke(_Callable&& __fn, _Args&&... __args)
    noexcept(__is_nothrow_invocable<_Callable, _Args...>::value)
    {
      using __result = __invoke_result<_Callable, _Args...>;
      using __type = typename __result::type;
      using __tag = typename __result::__invoke_type;
      return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
     std::forward<_Args>(__args)...);
    }



  template<typename _Res, typename _Callable, typename... _Args>
    constexpr enable_if_t<is_invocable_r_v<_Res, _Callable, _Args...>, _Res>
    __invoke_r(_Callable&& __fn, _Args&&... __args)
    noexcept(is_nothrow_invocable_r_v<_Res, _Callable, _Args...>)
    {
      using __result = __invoke_result<_Callable, _Args...>;
      using __type = typename __result::type;
      using __tag = typename __result::__invoke_type;
      if constexpr (is_void_v<_Res>)
 std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
     std::forward<_Args>(__args)...);
      else
 return std::__invoke_impl<__type>(__tag{},
       std::forward<_Callable>(__fn),
       std::forward<_Args>(__args)...);
    }
# 158 "/usr/local/include/c++/10.0.0/bits/invoke.h" 3

}
# 42 "/usr/local/include/c++/10.0.0/tuple" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename... _Elements>
    class tuple;

  template<typename _Tp>
    struct __is_empty_non_tuple : is_empty<_Tp> { };


  template<typename _El0, typename... _El>
    struct __is_empty_non_tuple<tuple<_El0, _El...>> : false_type { };


  template<typename _Tp>
    using __empty_not_final
    = typename conditional<__is_final(_Tp), false_type,
      __is_empty_non_tuple<_Tp>>::type;

  template<std::size_t _Idx, typename _Head,
    bool = __empty_not_final<_Head>::value>
    struct _Head_base;

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, true>
    : public _Head
    {
      constexpr _Head_base()
      : _Head() { }

      constexpr _Head_base(const _Head& __h)
      : _Head(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _Head(std::forward<_UHead>(__h)) { }

      _Head_base(allocator_arg_t, __uses_alloc0)
      : _Head() { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _Head(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _Head(*__a._M_a) { }

      template<typename _UHead>
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _Head(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b; }
    };

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, false>
    {
      constexpr _Head_base()
      : _M_head_impl() { }

      constexpr _Head_base(const _Head& __h)
      : _M_head_impl(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _M_head_impl(std::forward<_UHead>(__h)) { }

      constexpr
      _Head_base(allocator_arg_t, __uses_alloc0)
      : _M_head_impl() { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _M_head_impl(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _M_head_impl(*__a._M_a) { }

      template<typename _UHead>
 constexpr
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
 { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }

      _Head _M_head_impl;
    };
# 178 "/usr/local/include/c++/10.0.0/tuple" 3
  template<std::size_t _Idx, typename... _Elements>
    struct _Tuple_impl;






  template<std::size_t _Idx, typename _Head, typename... _Tail>
    struct _Tuple_impl<_Idx, _Head, _Tail...>
    : public _Tuple_impl<_Idx + 1, _Tail...>,
      private _Head_base<_Idx, _Head>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
      typedef _Head_base<_Idx, _Head> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr _Inherited&
      _M_tail(_Tuple_impl& __t) noexcept { return __t; }

      static constexpr const _Inherited&
      _M_tail(const _Tuple_impl& __t) noexcept { return __t; }

      constexpr _Tuple_impl()
      : _Inherited(), _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head, const _Tail&... __tail)
      : _Inherited(__tail...), _Base(__head) { }

      template<typename _UHead, typename... _UTail, typename = typename
               enable_if<sizeof...(_Tail) == sizeof...(_UTail)>::type>
        explicit
        constexpr _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
 : _Inherited(std::forward<_UTail>(__tail)...),
   _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;



      _Tuple_impl& operator=(const _Tuple_impl&) = delete;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_constructible<_Head>,
               is_nothrow_move_constructible<_Inherited>>::value)
      : _Inherited(std::move(_M_tail(__in))),
 _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename... _UElements>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _UHead, typename... _UTails>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      template<typename _Alloc>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a),
          _Base(__tag, __use_alloc<_Head>(__a)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head, const _Tail&... __tail)
 : _Inherited(__tag, __a, __tail...),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead, typename... _UTail,
               typename = typename enable_if<sizeof...(_Tail)
          == sizeof...(_UTail)>::type>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head, _UTail&&... __tail)
 : _Inherited(__tag, __a, std::forward<_UTail>(__tail)...),
          _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>
 constexpr
        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Inherited(__tag, __a, _M_tail(__in)),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Inherited(__tag, __a, std::move(_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename... _UElements>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(__tag, __a,
       _Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  _Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead, typename... _UTails>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(__tag, __a, std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      template<typename... _UElements>
 constexpr
        void
        _M_assign(const _Tuple_impl<_Idx, _UElements...>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);
   _M_tail(*this)._M_assign(
       _Tuple_impl<_Idx, _UElements...>::_M_tail(__in));
 }

      template<typename _UHead, typename... _UTails>
 constexpr
        void
        _M_assign(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
        {
   _M_head(*this) = std::forward<_UHead>
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));
   _M_tail(*this)._M_assign(
       std::move(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)));
 }

    protected:
      constexpr
      void
      _M_swap(_Tuple_impl& __in)
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
 _Inherited::_M_swap(_M_tail(__in));
      }
    };


  template<std::size_t _Idx, typename _Head>
    struct _Tuple_impl<_Idx, _Head>
    : private _Head_base<_Idx, _Head>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Head_base<_Idx, _Head> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      constexpr _Tuple_impl()
      : _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head)
      : _Base(__head) { }

      template<typename _UHead>
        explicit
        constexpr _Tuple_impl(_UHead&& __head)
 : _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;



      _Tuple_impl& operator=(const _Tuple_impl&) = delete;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(is_nothrow_move_constructible<_Head>::value)
      : _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename _UHead>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }

      template<typename _UHead>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      template<typename _Alloc>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Base(__tag, __use_alloc<_Head>(__a)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>
 constexpr
        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename _UHead>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  _Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      template<typename _UHead>
 constexpr
        void
        _M_assign(const _Tuple_impl<_Idx, _UHead>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(__in);
 }

      template<typename _UHead>
 constexpr
        void
        _M_assign(_Tuple_impl<_Idx, _UHead>&& __in)
        {
   _M_head(*this)
     = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in));
 }

    protected:
      constexpr
      void
      _M_swap(_Tuple_impl& __in)
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
      }
    };



  template<bool, typename... _Types>
    struct _TupleConstraints
    {



      template<typename... _UTypes>
 static constexpr bool __is_implicitly_constructible()
 {
   return __and_<is_constructible<_Types, _UTypes>...,
   is_convertible<_UTypes, _Types>...
   >::value;
 }




      template<typename... _UTypes>
 static constexpr bool __is_explicitly_constructible()
 {
   return __and_<is_constructible<_Types, _UTypes>...,
   __not_<__and_<is_convertible<_UTypes, _Types>...>>
   >::value;
 }

      static constexpr bool __is_implicitly_default_constructible()
      {
 return __and_<std::__is_implicitly_default_constructible<_Types>...
        >::value;
      }

      static constexpr bool __is_explicitly_default_constructible()
      {
 return __and_<is_default_constructible<_Types>...,
        __not_<__and_<
   std::__is_implicitly_default_constructible<_Types>...>
        >>::value;
      }
    };



  template<typename... _Types>
    struct _TupleConstraints<false, _Types...>
    {
      template<typename... _UTypes>
 static constexpr bool __is_implicitly_constructible()
 { return false; }

      template<typename... _UTypes>
 static constexpr bool __is_explicitly_constructible()
 { return false; }
    };


  template<typename... _Elements>
    class tuple : public _Tuple_impl<0, _Elements...>
    {
      typedef _Tuple_impl<0, _Elements...> _Inherited;

      template<bool _Cond>
 using _TCC = _TupleConstraints<_Cond, _Elements...>;


      template<bool _Dummy>
 using _ImplicitDefaultCtor = __enable_if_t<
   _TCC<_Dummy>::__is_implicitly_default_constructible(),
   bool>;


      template<bool _Dummy>
 using _ExplicitDefaultCtor = __enable_if_t<
   _TCC<_Dummy>::__is_explicitly_default_constructible(),
   bool>;


      template<bool _Cond, typename... _Args>
 using _ImplicitCtor = __enable_if_t<
   _TCC<_Cond>::template __is_implicitly_constructible<_Args...>(),
   bool>;


      template<bool _Cond, typename... _Args>
 using _ExplicitCtor = __enable_if_t<
   _TCC<_Cond>::template __is_explicitly_constructible<_Args...>(),
   bool>;

      template<typename... _UElements>
 static constexpr
 __enable_if_t<sizeof...(_UElements) == sizeof...(_Elements), bool>
 __assignable()
 { return __and_<is_assignable<_Elements&, _UElements>...>::value; }


      template<typename... _UElements>
 static constexpr bool __nothrow_assignable()
 {
   return
     __and_<is_nothrow_assignable<_Elements&, _UElements>...>::value;
 }


      template<typename... _UElements>
 static constexpr bool __nothrow_constructible()
 {
   return
     __and_<is_nothrow_constructible<_Elements, _UElements>...>::value;
 }


      template<typename _Up>
 static constexpr bool __valid_args()
 {
   return sizeof...(_Elements) == 1
     && !is_same<tuple, __remove_cvref_t<_Up>>::value;
 }


      template<typename, typename, typename... _Tail>
 static constexpr bool __valid_args()
 { return (sizeof...(_Tail) + 2) == sizeof...(_Elements); }
# 587 "/usr/local/include/c++/10.0.0/tuple" 3
      template<typename _Tuple, typename = tuple,
        typename = __remove_cvref_t<_Tuple>>
 struct _UseOtherCtor
 : false_type
 { };


      template<typename _Tuple, typename _Tp, typename _Up>
 struct _UseOtherCtor<_Tuple, tuple<_Tp>, tuple<_Up>>
 : __or_<is_convertible<_Tuple, _Tp>, is_constructible<_Tp, _Tuple>>
 { };


      template<typename _Tuple, typename _Tp>
 struct _UseOtherCtor<_Tuple, tuple<_Tp>, tuple<_Tp>>
 : true_type
 { };




      template<typename _Tuple>
 static constexpr bool __use_other_ctor()
 { return _UseOtherCtor<_Tuple>::value; }

    public:
      template<typename _Dummy = void,
        _ImplicitDefaultCtor<is_void<_Dummy>::value> = true>
 constexpr
 tuple()
 noexcept(__and_<is_nothrow_default_constructible<_Elements>...>::value)
 : _Inherited() { }

      template<typename _Dummy = void,
        _ExplicitDefaultCtor<is_void<_Dummy>::value> = false>
 explicit constexpr
 tuple()
 noexcept(__and_<is_nothrow_default_constructible<_Elements>...>::value)
 : _Inherited() { }

      template<bool _NotEmpty = (sizeof...(_Elements) >= 1),
        _ImplicitCtor<_NotEmpty, const _Elements&...> = true>
 constexpr
 tuple(const _Elements&... __elements)
 noexcept(__nothrow_constructible<const _Elements&...>())
 : _Inherited(__elements...) { }

      template<bool _NotEmpty = (sizeof...(_Elements) >= 1),
        _ExplicitCtor<_NotEmpty, const _Elements&...> = false>
 explicit constexpr
 tuple(const _Elements&... __elements)
 noexcept(__nothrow_constructible<const _Elements&...>())
 : _Inherited(__elements...) { }

      template<typename... _UElements,
        bool _Valid = __valid_args<_UElements...>(),
        _ImplicitCtor<_Valid, _UElements...> = true>
 constexpr
 tuple(_UElements&&... __elements)
 noexcept(__nothrow_constructible<_UElements...>())
 : _Inherited(std::forward<_UElements>(__elements)...) { }

      template<typename... _UElements,
        bool _Valid = __valid_args<_UElements...>(),
        _ExplicitCtor<_Valid, _UElements...> = false>
 explicit constexpr
 tuple(_UElements&&... __elements)
 noexcept(__nothrow_constructible<_UElements...>())
 : _Inherited(std::forward<_UElements>(__elements)...) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;

      template<typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
      && !__use_other_ctor<const tuple<_UElements...>&>(),
        _ImplicitCtor<_Valid, const _UElements&...> = true>
 constexpr
 tuple(const tuple<_UElements...>& __in)
 noexcept(__nothrow_constructible<const _UElements&...>())
 : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
      && !__use_other_ctor<const tuple<_UElements...>&>(),
        _ExplicitCtor<_Valid, const _UElements&...> = false>
 explicit constexpr
 tuple(const tuple<_UElements...>& __in)
 noexcept(__nothrow_constructible<const _UElements&...>())
 : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
        && !__use_other_ctor<tuple<_UElements...>&&>(),
        _ImplicitCtor<_Valid, _UElements...> = true>
 constexpr
 tuple(tuple<_UElements...>&& __in)
 noexcept(__nothrow_constructible<_UElements...>())
 : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }

      template<typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
        && !__use_other_ctor<tuple<_UElements...>&&>(),
        _ExplicitCtor<_Valid, _UElements...> = false>
 explicit constexpr
 tuple(tuple<_UElements...>&& __in)
 noexcept(__nothrow_constructible<_UElements...>())
 : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }



      template<typename _Alloc,
        _ImplicitDefaultCtor<is_object<_Alloc>::value> = true>
 constexpr
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc, bool _NotEmpty = (sizeof...(_Elements) >= 1),
        _ImplicitCtor<_NotEmpty, const _Elements&...> = true>
 constexpr
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, bool _NotEmpty = (sizeof...(_Elements) >= 1),
        _ExplicitCtor<_NotEmpty, const _Elements&...> = false>
 constexpr
 explicit
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, typename... _UElements,
        bool _Valid = __valid_args<_UElements...>(),
        _ImplicitCtor<_Valid, _UElements...> = true>
 constexpr
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
 { }

      template<typename _Alloc, typename... _UElements,
   bool _Valid = __valid_args<_UElements...>(),
        _ExplicitCtor<_Valid, _UElements...> = false>
 constexpr
 explicit
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
 { }

      template<typename _Alloc>
 constexpr
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>
 constexpr
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
        && !__use_other_ctor<const tuple<_UElements...>&>(),
        _ImplicitCtor<_Valid, const _UElements&...> = true>
 constexpr
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
        && !__use_other_ctor<const tuple<_UElements...>&>(),
        _ExplicitCtor<_Valid, const _UElements&...> = false>
 constexpr
 explicit
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
        && !__use_other_ctor<tuple<_UElements...>&&>(),
        _ImplicitCtor<_Valid, _UElements...> = true>
 constexpr
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }

      template<typename _Alloc, typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
        && !__use_other_ctor<tuple<_UElements...>&&>(),
        _ExplicitCtor<_Valid, _UElements...> = false>
 constexpr
 explicit
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }



      constexpr
      tuple&
      operator=(typename conditional<__assignable<const _Elements&...>(),
         const tuple&,
         const __nonesuch&>::type __in)
      noexcept(__nothrow_assignable<const _Elements&...>())
      {
 this->_M_assign(__in);
 return *this;
      }

      constexpr
      tuple&
      operator=(typename conditional<__assignable<_Elements...>(),
         tuple&&,
         __nonesuch&&>::type __in)
      noexcept(__nothrow_assignable<_Elements...>())
      {
 this->_M_assign(std::move(__in));
 return *this;
      }

      template<typename... _UElements>
 constexpr
 __enable_if_t<__assignable<const _UElements&...>(), tuple&>
 operator=(const tuple<_UElements...>& __in)
 noexcept(__nothrow_assignable<const _UElements&...>())
 {
   this->_M_assign(__in);
   return *this;
 }

      template<typename... _UElements>
 constexpr
 __enable_if_t<__assignable<_UElements...>(), tuple&>
 operator=(tuple<_UElements...>&& __in)
 noexcept(__nothrow_assignable<_UElements...>())
 {
   this->_M_assign(std::move(__in));
   return *this;
 }


      constexpr
      void
      swap(tuple& __in)
      noexcept(__and_<__is_nothrow_swappable<_Elements>...>::value)
      { _Inherited::_M_swap(__in); }
    };


  template<typename... _UTypes>
    tuple(_UTypes...) -> tuple<_UTypes...>;
  template<typename _T1, typename _T2>
    tuple(pair<_T1, _T2>) -> tuple<_T1, _T2>;
  template<typename _Alloc, typename... _UTypes>
    tuple(allocator_arg_t, _Alloc, _UTypes...) -> tuple<_UTypes...>;
  template<typename _Alloc, typename _T1, typename _T2>
    tuple(allocator_arg_t, _Alloc, pair<_T1, _T2>) -> tuple<_T1, _T2>;
  template<typename _Alloc, typename... _UTypes>
    tuple(allocator_arg_t, _Alloc, tuple<_UTypes...>) -> tuple<_UTypes...>;



  template<>
    class tuple<>
    {
    public:
      void swap(tuple&) noexcept { }


      tuple() = default;

      template<typename _Alloc>
 constexpr
 tuple(allocator_arg_t, const _Alloc&) noexcept { }
      template<typename _Alloc>
 constexpr
 tuple(allocator_arg_t, const _Alloc&, const tuple&) noexcept { }
    };



  template<typename _T1, typename _T2>
    class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>
    {
      typedef _Tuple_impl<0, _T1, _T2> _Inherited;


      template<bool _Dummy, typename _U1, typename _U2>
 using _ImplicitDefaultCtor = __enable_if_t<
   _TupleConstraints<_Dummy, _U1, _U2>::
     __is_implicitly_default_constructible(),
   bool>;


      template<bool _Dummy, typename _U1, typename _U2>
 using _ExplicitDefaultCtor = __enable_if_t<
   _TupleConstraints<_Dummy, _U1, _U2>::
     __is_explicitly_default_constructible(),
   bool>;

      template<bool _Dummy>
 using _TCC = _TupleConstraints<_Dummy, _T1, _T2>;


      template<bool _Cond, typename _U1, typename _U2>
 using _ImplicitCtor = __enable_if_t<
   _TCC<_Cond>::template __is_implicitly_constructible<_U1, _U2>(),
   bool>;


      template<bool _Cond, typename _U1, typename _U2>
 using _ExplicitCtor = __enable_if_t<
   _TCC<_Cond>::template __is_explicitly_constructible<_U1, _U2>(),
   bool>;

      template<typename _U1, typename _U2>
 static constexpr bool __assignable()
 {
   return __and_<is_assignable<_T1&, _U1>,
   is_assignable<_T2&, _U2>>::value;
 }

      template<typename _U1, typename _U2>
 static constexpr bool __nothrow_assignable()
 {
   return __and_<is_nothrow_assignable<_T1&, _U1>,
   is_nothrow_assignable<_T2&, _U2>>::value;
 }

      template<typename _U1, typename _U2>
 static constexpr bool __nothrow_constructible()
 {
   return __and_<is_nothrow_constructible<_T1, _U1>,
       is_nothrow_constructible<_T2, _U2>>::value;
 }

      static constexpr bool __nothrow_default_constructible()
      {
 return __and_<is_nothrow_default_constructible<_T1>,
        is_nothrow_default_constructible<_T2>>::value;
      }

      template<typename _U1>
 static constexpr bool __is_alloc_arg()
 { return is_same<__remove_cvref_t<_U1>, allocator_arg_t>::value; }

    public:
      template<bool _Dummy = true,
        _ImplicitDefaultCtor<_Dummy, _T1, _T2> = true>
 constexpr
 tuple()
 noexcept(__nothrow_default_constructible())
 : _Inherited() { }

      template<bool _Dummy = true,
        _ExplicitDefaultCtor<_Dummy, _T1, _T2> = false>
 explicit constexpr
 tuple()
 noexcept(__nothrow_default_constructible())
 : _Inherited() { }

      template<bool _Dummy = true,
        _ImplicitCtor<_Dummy, const _T1&, const _T2&> = true>
 constexpr
 tuple(const _T1& __a1, const _T2& __a2)
 noexcept(__nothrow_constructible<const _T1&, const _T2&>())
 : _Inherited(__a1, __a2) { }

      template<bool _Dummy = true,
        _ExplicitCtor<_Dummy, const _T1&, const _T2&> = false>
 explicit constexpr
 tuple(const _T1& __a1, const _T2& __a2)
 noexcept(__nothrow_constructible<const _T1&, const _T2&>())
 : _Inherited(__a1, __a2) { }

      template<typename _U1, typename _U2,
        _ImplicitCtor<!__is_alloc_arg<_U1>(), _U1, _U2> = true>
 constexpr
 tuple(_U1&& __a1, _U2&& __a2)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      template<typename _U1, typename _U2,
        _ExplicitCtor<!__is_alloc_arg<_U1>(), _U1, _U2> = false>
 explicit constexpr
 tuple(_U1&& __a1, _U2&& __a2)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;

      template<typename _U1, typename _U2,
        _ImplicitCtor<true, const _U1&, const _U2&> = true>
 constexpr
 tuple(const tuple<_U1, _U2>& __in)
 noexcept(__nothrow_constructible<const _U1&, const _U2&>())
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2,
        _ExplicitCtor<true, const _U1&, const _U2&> = false>
 explicit constexpr
 tuple(const tuple<_U1, _U2>& __in)
 noexcept(__nothrow_constructible<const _U1&, const _U2&>())
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2,
        _ImplicitCtor<true, _U1, _U2> = true>
 constexpr
 tuple(tuple<_U1, _U2>&& __in)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2,
        _ExplicitCtor<true, _U1, _U2> = false>
 explicit constexpr
 tuple(tuple<_U1, _U2>&& __in)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2,
        _ImplicitCtor<true, const _U1&, const _U2&> = true>
 constexpr
 tuple(const pair<_U1, _U2>& __in)
 noexcept(__nothrow_constructible<const _U1&, const _U2&>())
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2,
        _ExplicitCtor<true, const _U1&, const _U2&> = false>
 explicit constexpr
 tuple(const pair<_U1, _U2>& __in)
 noexcept(__nothrow_constructible<const _U1&, const _U2&>())
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2,
        _ImplicitCtor<true, _U1, _U2> = true>
 constexpr
 tuple(pair<_U1, _U2>&& __in)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      template<typename _U1, typename _U2,
        _ExplicitCtor<true, _U1, _U2> = false>
 explicit constexpr
 tuple(pair<_U1, _U2>&& __in)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }



      template<typename _Alloc,
        _ImplicitDefaultCtor<is_object<_Alloc>::value, _T1, _T2> = true>
 constexpr
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc, bool _Dummy = true,
        _ImplicitCtor<_Dummy, const _T1&, const _T2&> = true>
 constexpr
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, bool _Dummy = true,
        _ExplicitCtor<_Dummy, const _T1&, const _T2&> = false>
 explicit
 constexpr
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ImplicitCtor<true, _U1, _U2> = true>
 constexpr
 tuple(allocator_arg_t __tag, const _Alloc& __a, _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ExplicitCtor<true, _U1, _U2> = false>
 explicit
 constexpr
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc>
 constexpr
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>
 constexpr
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ImplicitCtor<true, const _U1&, const _U2&> = true>
 constexpr
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ExplicitCtor<true, const _U1&, const _U2&> = false>
 explicit
 constexpr
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ImplicitCtor<true, _U1, _U2> = true>
 constexpr
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ExplicitCtor<true, _U1, _U2> = false>
 explicit
 constexpr
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ImplicitCtor<true, const _U1&, const _U2&> = true>
 constexpr
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ExplicitCtor<true, const _U1&, const _U2&> = false>
 explicit
 constexpr
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ImplicitCtor<true, _U1, _U2> = true>
 constexpr
 tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ExplicitCtor<true, _U1, _U2> = false>
 explicit
 constexpr
 tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }



      constexpr
      tuple&
      operator=(typename conditional<__assignable<const _T1&, const _T2&>(),
         const tuple&,
         const __nonesuch&>::type __in)
      noexcept(__nothrow_assignable<const _T1&, const _T2&>())
      {
 this->_M_assign(__in);
 return *this;
      }

      constexpr
      tuple&
      operator=(typename conditional<__assignable<_T1, _T2>(),
         tuple&&,
         __nonesuch&&>::type __in)
      noexcept(__nothrow_assignable<_T1, _T2>())
      {
 this->_M_assign(std::move(__in));
 return *this;
      }

      template<typename _U1, typename _U2>
 constexpr
 __enable_if_t<__assignable<const _U1&, const _U2&>(), tuple&>
 operator=(const tuple<_U1, _U2>& __in)
 noexcept(__nothrow_assignable<const _U1&, const _U2&>())
 {
   this->_M_assign(__in);
   return *this;
 }

      template<typename _U1, typename _U2>
 constexpr
 __enable_if_t<__assignable<_U1, _U2>(), tuple&>
 operator=(tuple<_U1, _U2>&& __in)
 noexcept(__nothrow_assignable<_U1, _U2>())
 {
   this->_M_assign(std::move(__in));
   return *this;
 }

      template<typename _U1, typename _U2>
 constexpr
 __enable_if_t<__assignable<const _U1&, const _U2&>(), tuple&>
 operator=(const pair<_U1, _U2>& __in)
 noexcept(__nothrow_assignable<const _U1&, const _U2&>())
 {
   this->_M_head(*this) = __in.first;
   this->_M_tail(*this)._M_head(*this) = __in.second;
   return *this;
 }

      template<typename _U1, typename _U2>
 constexpr
 __enable_if_t<__assignable<_U1, _U2>(), tuple&>
 operator=(pair<_U1, _U2>&& __in)
 noexcept(__nothrow_assignable<_U1, _U2>())
 {
   this->_M_head(*this) = std::forward<_U1>(__in.first);
   this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__in.second);
   return *this;
 }

      constexpr
      void
      swap(tuple& __in)
      noexcept(__and_<__is_nothrow_swappable<_T1>,
        __is_nothrow_swappable<_T2>>::value)
      { _Inherited::_M_swap(__in); }
    };



  template<typename... _Elements>
    struct tuple_size<tuple<_Elements...>>
    : public integral_constant<std::size_t, sizeof...(_Elements)> { };


  template <typename _Tp>
    inline constexpr size_t tuple_size_v = tuple_size<_Tp>::value;






  template<std::size_t __i, typename _Head, typename... _Tail>
    struct tuple_element<__i, tuple<_Head, _Tail...> >
    : tuple_element<__i - 1, tuple<_Tail...> > { };




  template<typename _Head, typename... _Tail>
    struct tuple_element<0, tuple<_Head, _Tail...> >
    {
      typedef _Head type;
    };




  template<size_t __i>
    struct tuple_element<__i, tuple<>>
    {
      static_assert(__i < tuple_size<tuple<>>::value,
   "tuple index is in range");
    };

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr _Head&
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr const _Head&
    __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&
    get(tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&
    get(const tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&&
    get(tuple<_Elements...>&& __t) noexcept
    {
      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
      return std::forward<__element_type&&>(std::get<__i>(__t));
    }


  template<std::size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&&
    get(const tuple<_Elements...>&& __t) noexcept
    {
      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
      return std::forward<const __element_type&&>(std::get<__i>(__t));
    }





  template<typename _Head, size_t __i, typename... _Tail>
    constexpr _Head&
    __get_helper2(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<typename _Head, size_t __i, typename... _Tail>
    constexpr const _Head&
    __get_helper2(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }


  template <typename _Tp, typename... _Types>
    constexpr _Tp&
    get(tuple<_Types...>& __t) noexcept
    { return std::__get_helper2<_Tp>(__t); }


  template <typename _Tp, typename... _Types>
    constexpr _Tp&&
    get(tuple<_Types...>&& __t) noexcept
    { return std::forward<_Tp&&>(std::__get_helper2<_Tp>(__t)); }


  template <typename _Tp, typename... _Types>
    constexpr const _Tp&
    get(const tuple<_Types...>& __t) noexcept
    { return std::__get_helper2<_Tp>(__t); }



  template <typename _Tp, typename... _Types>
    constexpr const _Tp&&
    get(const tuple<_Types...>&& __t) noexcept
    { return std::forward<const _Tp&&>(std::__get_helper2<_Tp>(__t)); }



  template<typename _Tp, typename _Up, size_t __i, size_t __size>
    struct __tuple_compare
    {
      static constexpr bool
      __eq(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) == std::get<__i>(__u))
   && __tuple_compare<_Tp, _Up, __i + 1, __size>::__eq(__t, __u);
      }

      static constexpr bool
      __less(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) < std::get<__i>(__u))
   || (!bool(std::get<__i>(__u) < std::get<__i>(__t))
       && __tuple_compare<_Tp, _Up, __i + 1, __size>::__less(__t, __u));
      }
    };

  template<typename _Tp, typename _Up, size_t __size>
    struct __tuple_compare<_Tp, _Up, __size, __size>
    {
      static constexpr bool
      __eq(const _Tp&, const _Up&) { return true; }

      static constexpr bool
      __less(const _Tp&, const _Up&) { return false; }
    };

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator==(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__eq(__t, __u);
    }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__less(__t, __u);
    }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator!=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t == __u); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    { return __u < __t; }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__u < __t); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t < __u); }


  template<typename... _Elements>
    constexpr tuple<typename __decay_and_strip<_Elements>::__type...>
    make_tuple(_Elements&&... __args)
    {
      typedef tuple<typename __decay_and_strip<_Elements>::__type...>
 __result_type;
      return __result_type(std::forward<_Elements>(__args)...);
    }




  template<typename... _Elements>
    constexpr tuple<_Elements&&...>
    forward_as_tuple(_Elements&&... __args) noexcept
    { return tuple<_Elements&&...>(std::forward<_Elements>(__args)...); }

  template<size_t, typename, typename, size_t>
    struct __make_tuple_impl;

  template<size_t _Idx, typename _Tuple, typename... _Tp, size_t _Nm>
    struct __make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm>
    : __make_tuple_impl<_Idx + 1,
   tuple<_Tp..., __tuple_element_t<_Idx, _Tuple>>,
   _Tuple, _Nm>
    { };

  template<std::size_t _Nm, typename _Tuple, typename... _Tp>
    struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm>
    {
      typedef tuple<_Tp...> __type;
    };

  template<typename _Tuple>
    struct __do_make_tuple
    : __make_tuple_impl<0, tuple<>, _Tuple, std::tuple_size<_Tuple>::value>
    { };


  template<typename _Tuple>
    struct __make_tuple
    : public __do_make_tuple<__remove_cvref_t<_Tuple>>
    { };


  template<typename...>
    struct __combine_tuples;

  template<>
    struct __combine_tuples<>
    {
      typedef tuple<> __type;
    };

  template<typename... _Ts>
    struct __combine_tuples<tuple<_Ts...>>
    {
      typedef tuple<_Ts...> __type;
    };

  template<typename... _T1s, typename... _T2s, typename... _Rem>
    struct __combine_tuples<tuple<_T1s...>, tuple<_T2s...>, _Rem...>
    {
      typedef typename __combine_tuples<tuple<_T1s..., _T2s...>,
     _Rem...>::__type __type;
    };


  template<typename... _Tpls>
    struct __tuple_cat_result
    {
      typedef typename __combine_tuples
        <typename __make_tuple<_Tpls>::__type...>::__type __type;
    };



  template<typename...>
    struct __make_1st_indices;

  template<>
    struct __make_1st_indices<>
    {
      typedef std::_Index_tuple<> __type;
    };

  template<typename _Tp, typename... _Tpls>
    struct __make_1st_indices<_Tp, _Tpls...>
    {
      typedef typename std::_Build_index_tuple<std::tuple_size<
 typename std::remove_reference<_Tp>::type>::value>::__type __type;
    };




  template<typename _Ret, typename _Indices, typename... _Tpls>
    struct __tuple_concater;

  template<typename _Ret, std::size_t... _Is, typename _Tp, typename... _Tpls>
    struct __tuple_concater<_Ret, std::_Index_tuple<_Is...>, _Tp, _Tpls...>
    {
      template<typename... _Us>
        static constexpr _Ret
        _S_do(_Tp&& __tp, _Tpls&&... __tps, _Us&&... __us)
        {
   typedef typename __make_1st_indices<_Tpls...>::__type __idx;
   typedef __tuple_concater<_Ret, __idx, _Tpls...> __next;
   return __next::_S_do(std::forward<_Tpls>(__tps)...,
          std::forward<_Us>(__us)...,
          std::get<_Is>(std::forward<_Tp>(__tp))...);
 }
    };

  template<typename _Ret>
    struct __tuple_concater<_Ret, std::_Index_tuple<>>
    {
      template<typename... _Us>
 static constexpr _Ret
 _S_do(_Us&&... __us)
        {
   return _Ret(std::forward<_Us>(__us)...);
 }
    };


  template<typename... _Tpls, typename = typename
           enable_if<__and_<__is_tuple_like<_Tpls>...>::value>::type>
    constexpr auto
    tuple_cat(_Tpls&&... __tpls)
    -> typename __tuple_cat_result<_Tpls...>::__type
    {
      typedef typename __tuple_cat_result<_Tpls...>::__type __ret;
      typedef typename __make_1st_indices<_Tpls...>::__type __idx;
      typedef __tuple_concater<__ret, __idx, _Tpls...> __concater;
      return __concater::_S_do(std::forward<_Tpls>(__tpls)...);
    }




  template<typename... _Elements>
    constexpr tuple<_Elements&...>
    tie(_Elements&... __args) noexcept
    { return tuple<_Elements&...>(__args...); }


  template<typename... _Elements>
    constexpr
    inline


    typename enable_if<__and_<__is_swappable<_Elements>...>::value
      >::type



    swap(tuple<_Elements...>& __x, tuple<_Elements...>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


  template<typename... _Elements>
    constexpr
    typename enable_if<!__and_<__is_swappable<_Elements>...>::value>::type
    swap(tuple<_Elements...>&, tuple<_Elements...>&) = delete;






  struct _Swallow_assign
  {
    template<class _Tp>
      constexpr const _Swallow_assign&
      operator=(const _Tp&) const
      { return *this; }
  };



  inline constexpr _Swallow_assign ignore{};


  template<typename... _Types, typename _Alloc>
    struct uses_allocator<tuple<_Types...>, _Alloc> : true_type { };
# 1635 "/usr/local/include/c++/10.0.0/tuple" 3
  template<class _T1, class _T2>
    template<typename... _Args1, typename... _Args2>
      constexpr
      inline
      pair<_T1, _T2>::
      pair(piecewise_construct_t,
    tuple<_Args1...> __first, tuple<_Args2...> __second)
      : pair(__first, __second,
      typename _Build_index_tuple<sizeof...(_Args1)>::__type(),
      typename _Build_index_tuple<sizeof...(_Args2)>::__type())
      { }

  template<class _T1, class _T2>
    template<typename... _Args1, std::size_t... _Indexes1,
             typename... _Args2, std::size_t... _Indexes2>
      constexpr inline
      pair<_T1, _T2>::
      pair(tuple<_Args1...>& __tuple1, tuple<_Args2...>& __tuple2,
    _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)
      : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...),
        second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
      { }







  template<template<typename...> class _Trait, typename _Tp, typename _Tuple>
    inline constexpr bool __unpack_std_tuple = false;

  template<template<typename...> class _Trait, typename _Tp, typename... _Up>
    inline constexpr bool __unpack_std_tuple<_Trait, _Tp, tuple<_Up...>>
      = _Trait<_Tp, _Up...>::value;

  template<template<typename...> class _Trait, typename _Tp, typename... _Up>
    inline constexpr bool __unpack_std_tuple<_Trait, _Tp, tuple<_Up...>&>
      = _Trait<_Tp, _Up&...>::value;

  template<template<typename...> class _Trait, typename _Tp, typename... _Up>
    inline constexpr bool __unpack_std_tuple<_Trait, _Tp, const tuple<_Up...>>
      = _Trait<_Tp, const _Up...>::value;

  template<template<typename...> class _Trait, typename _Tp, typename... _Up>
    inline constexpr bool __unpack_std_tuple<_Trait, _Tp, const tuple<_Up...>&>
      = _Trait<_Tp, const _Up&...>::value;



  template <typename _Fn, typename _Tuple, size_t... _Idx>
    constexpr decltype(auto)
    __apply_impl(_Fn&& __f, _Tuple&& __t, index_sequence<_Idx...>)
    {
      return std::__invoke(std::forward<_Fn>(__f),
      std::get<_Idx>(std::forward<_Tuple>(__t))...);
    }

  template <typename _Fn, typename _Tuple>
    constexpr decltype(auto)
    apply(_Fn&& __f, _Tuple&& __t)
    noexcept(__unpack_std_tuple<is_nothrow_invocable, _Fn, _Tuple>)
    {
      using _Indices
 = make_index_sequence<tuple_size_v<remove_reference_t<_Tuple>>>;
      return std::__apply_impl(std::forward<_Fn>(__f),
          std::forward<_Tuple>(__t),
          _Indices{});
    }



  template <typename _Tp, typename _Tuple, size_t... _Idx>
    constexpr _Tp
    __make_from_tuple_impl(_Tuple&& __t, index_sequence<_Idx...>)
    { return _Tp(std::get<_Idx>(std::forward<_Tuple>(__t))...); }

  template <typename _Tp, typename _Tuple>
    constexpr _Tp
    make_from_tuple(_Tuple&& __t)
    noexcept(__unpack_std_tuple<is_nothrow_constructible, _Tp, _Tuple>)
    {
      return __make_from_tuple_impl<_Tp>(
        std::forward<_Tuple>(__t),
 make_index_sequence<tuple_size_v<remove_reference_t<_Tuple>>>{});
    }





}
# 38 "/usr/local/include/c++/10.0.0/bits/unique_ptr.h" 2 3

# 1 "/usr/local/include/c++/10.0.0/bits/functional_hash.h" 1 3
# 33 "/usr/local/include/c++/10.0.0/bits/functional_hash.h" 3
       
# 34 "/usr/local/include/c++/10.0.0/bits/functional_hash.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{

# 49 "/usr/local/include/c++/10.0.0/bits/functional_hash.h" 3
  template<typename _Result, typename _Arg>
    struct __hash_base
    {
      typedef _Result result_type [[__deprecated__]];
      typedef _Arg argument_type [[__deprecated__]];
    };


  template<typename _Tp>
    struct hash;

  template<typename _Tp, typename = void>
    struct __poison_hash
    {
      static constexpr bool __enable_hash_call = false;
    private:

      __poison_hash(__poison_hash&&);
      ~__poison_hash();
    };

  template<typename _Tp>
    struct __poison_hash<_Tp, __void_t<decltype(hash<_Tp>()(declval<_Tp>()))>>
    {
      static constexpr bool __enable_hash_call = true;
    };


  template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __hash_enum
    {
    private:

      __hash_enum(__hash_enum&&);
      ~__hash_enum();
    };


  template<typename _Tp>
    struct __hash_enum<_Tp, true> : public __hash_base<size_t, _Tp>
    {
      size_t
      operator()(_Tp __val) const noexcept
      {
       using __type = typename underlying_type<_Tp>::type;
       return hash<__type>{}(static_cast<__type>(__val));
      }
    };



  template<typename _Tp>
    struct hash : __hash_enum<_Tp>
    { };


  template<typename _Tp>
    struct hash<_Tp*> : public __hash_base<size_t, _Tp*>
    {
      size_t
      operator()(_Tp* __p) const noexcept
      { return reinterpret_cast<size_t>(__p); }
    };
# 124 "/usr/local/include/c++/10.0.0/bits/functional_hash.h" 3
  template<> struct hash<bool> : public __hash_base<size_t, bool> { size_t operator()(bool __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char> : public __hash_base<size_t, char> { size_t operator()(char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<signed char> : public __hash_base<size_t, signed char> { size_t operator()(signed char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned char> : public __hash_base<size_t, unsigned char> { size_t operator()(unsigned char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<wchar_t> : public __hash_base<size_t, wchar_t> { size_t operator()(wchar_t __val) const noexcept { return static_cast<size_t>(__val); } };



  template<> struct hash<char8_t> : public __hash_base<size_t, char8_t> { size_t operator()(char8_t __val) const noexcept { return static_cast<size_t>(__val); } };



  template<> struct hash<char16_t> : public __hash_base<size_t, char16_t> { size_t operator()(char16_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char32_t> : public __hash_base<size_t, char32_t> { size_t operator()(char32_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<short> : public __hash_base<size_t, short> { size_t operator()(short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<int> : public __hash_base<size_t, int> { size_t operator()(int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long> : public __hash_base<size_t, long> { size_t operator()(long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long long> : public __hash_base<size_t, long long> { size_t operator()(long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned short> : public __hash_base<size_t, unsigned short> { size_t operator()(unsigned short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned int> : public __hash_base<size_t, unsigned int> { size_t operator()(unsigned int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long> : public __hash_base<size_t, unsigned long> { size_t operator()(unsigned long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long long> : public __hash_base<size_t, unsigned long long> { size_t operator()(unsigned long long __val) const noexcept { return static_cast<size_t>(__val); } };
# 192 "/usr/local/include/c++/10.0.0/bits/functional_hash.h" 3
  struct _Hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(0xc70f6907UL))
    { return _Hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  struct _Fnv_hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(2166136261UL))
    { return _Fnv_hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  template<>
    struct hash<float> : public __hash_base<size_t, float>
    {
      size_t
      operator()(float __val) const noexcept
      {

 return __val != 0.0f ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<double> : public __hash_base<size_t, double>
    {
      size_t
      operator()(double __val) const noexcept
      {

 return __val != 0.0 ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<long double>
    : public __hash_base<size_t, long double>
    {
      __attribute__ ((__pure__)) size_t
      operator()(long double __val) const noexcept;
    };


  template<>
    struct hash<nullptr_t> : public __hash_base<size_t, nullptr_t>
    {
      size_t
      operator()(nullptr_t) const noexcept
      { return 0; }
    };
# 278 "/usr/local/include/c++/10.0.0/bits/functional_hash.h" 3
  template<typename _Hash>
    struct __is_fast_hash : public std::true_type
    { };

  template<>
    struct __is_fast_hash<hash<long double>> : public std::false_type
    { };


}
# 40 "/usr/local/include/c++/10.0.0/bits/unique_ptr.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{








#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
  template<typename> class auto_ptr;
#pragma GCC diagnostic pop



  template<typename _Tp>
    struct default_delete
    {

      constexpr default_delete() noexcept = default;






      template<typename _Up,
        typename = _Require<is_convertible<_Up*, _Tp*>>>
        default_delete(const default_delete<_Up>&) noexcept { }


      void
      operator()(_Tp* __ptr) const
      {
 static_assert(!is_void<_Tp>::value,
        "can't delete pointer to incomplete type");
 static_assert(sizeof(_Tp)>0,
        "can't delete pointer to incomplete type");
 delete __ptr;
      }
    };





  template<typename _Tp>
    struct default_delete<_Tp[]>
    {
    public:

      constexpr default_delete() noexcept = default;
# 105 "/usr/local/include/c++/10.0.0/bits/unique_ptr.h" 3
      template<typename _Up,
        typename = _Require<is_convertible<_Up(*)[], _Tp(*)[]>>>
        default_delete(const default_delete<_Up[]>&) noexcept { }


      template<typename _Up>
 typename enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value>::type
 operator()(_Up* __ptr) const
 {
   static_assert(sizeof(_Tp)>0,
   "can't delete pointer to incomplete type");
   delete [] __ptr;
 }
    };




  template <typename _Tp, typename _Dp>
    class __uniq_ptr_impl
    {
      template <typename _Up, typename _Ep, typename = void>
 struct _Ptr
 {
   using type = _Up*;
 };

      template <typename _Up, typename _Ep>
 struct
 _Ptr<_Up, _Ep, __void_t<typename remove_reference<_Ep>::type::pointer>>
 {
   using type = typename remove_reference<_Ep>::type::pointer;
 };

    public:
      using _DeleterConstraint = enable_if<
        __and_<__not_<is_pointer<_Dp>>,
        is_default_constructible<_Dp>>::value>;

      using pointer = typename _Ptr<_Tp, _Dp>::type;

      static_assert( !is_rvalue_reference<_Dp>::value,
       "unique_ptr's deleter type must be a function object type"
       " or an lvalue reference type" );

      __uniq_ptr_impl() = default;
      __uniq_ptr_impl(pointer __p) : _M_t() { _M_ptr() = __p; }

      template<typename _Del>
      __uniq_ptr_impl(pointer __p, _Del&& __d)
 : _M_t(__p, std::forward<_Del>(__d)) { }

      __uniq_ptr_impl(__uniq_ptr_impl&& __u) noexcept
      : _M_t(std::move(__u._M_t))
      { __u._M_ptr() = nullptr; }

      __uniq_ptr_impl& operator=(__uniq_ptr_impl&& __u) noexcept
      {
 reset(__u.release());
 _M_deleter() = std::forward<_Dp>(__u._M_deleter());
 return *this;
      }

      pointer& _M_ptr() { return std::get<0>(_M_t); }
      pointer _M_ptr() const { return std::get<0>(_M_t); }
      _Dp& _M_deleter() { return std::get<1>(_M_t); }
      const _Dp& _M_deleter() const { return std::get<1>(_M_t); }

      void reset(pointer __p) noexcept
      {
 const pointer __old_p = _M_ptr();
 _M_ptr() = __p;
 if (__old_p)
   _M_deleter()(__old_p);
      }

      pointer release() noexcept
      {
 pointer __p = _M_ptr();
 _M_ptr() = nullptr;
 return __p;
      }

    private:
      tuple<pointer, _Dp> _M_t;
    };


  template <typename _Tp, typename _Dp,
     bool = is_move_constructible<_Dp>::value,
     bool = is_move_assignable<_Dp>::value>
    struct __uniq_ptr_data : __uniq_ptr_impl<_Tp, _Dp>
    {
      using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;
      __uniq_ptr_data(__uniq_ptr_data&&) = default;
      __uniq_ptr_data& operator=(__uniq_ptr_data&&) = default;
    };

  template <typename _Tp, typename _Dp>
    struct __uniq_ptr_data<_Tp, _Dp, true, false> : __uniq_ptr_impl<_Tp, _Dp>
    {
      using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;
      __uniq_ptr_data(__uniq_ptr_data&&) = default;
      __uniq_ptr_data& operator=(__uniq_ptr_data&&) = delete;
    };

  template <typename _Tp, typename _Dp>
    struct __uniq_ptr_data<_Tp, _Dp, false, true> : __uniq_ptr_impl<_Tp, _Dp>
    {
      using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;
      __uniq_ptr_data(__uniq_ptr_data&&) = delete;
      __uniq_ptr_data& operator=(__uniq_ptr_data&&) = default;
    };

  template <typename _Tp, typename _Dp>
    struct __uniq_ptr_data<_Tp, _Dp, false, false> : __uniq_ptr_impl<_Tp, _Dp>
    {
      using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;
      __uniq_ptr_data(__uniq_ptr_data&&) = delete;
      __uniq_ptr_data& operator=(__uniq_ptr_data&&) = delete;
    };



  template <typename _Tp, typename _Dp = default_delete<_Tp>>
    class unique_ptr
    {
      template <typename _Up>
 using _DeleterConstraint =
   typename __uniq_ptr_impl<_Tp, _Up>::_DeleterConstraint::type;

      __uniq_ptr_data<_Tp, _Dp> _M_t;

    public:
      using pointer = typename __uniq_ptr_impl<_Tp, _Dp>::pointer;
      using element_type = _Tp;
      using deleter_type = _Dp;

    private:


      template<typename _Up, typename _Ep>
 using __safe_conversion_up = __and_<
   is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>,
   __not_<is_array<_Up>>
        >;

    public:



      template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
 constexpr unique_ptr() noexcept
 : _M_t()
 { }







      template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
 explicit
 unique_ptr(pointer __p) noexcept
 : _M_t(__p)
        { }
# 280 "/usr/local/include/c++/10.0.0/bits/unique_ptr.h" 3
      template<typename _Del = deleter_type,
        typename = _Require<is_copy_constructible<_Del>>>
 unique_ptr(pointer __p, const deleter_type& __d) noexcept
 : _M_t(__p, __d) { }
# 292 "/usr/local/include/c++/10.0.0/bits/unique_ptr.h" 3
      template<typename _Del = deleter_type,
        typename = _Require<is_move_constructible<_Del>>>
 unique_ptr(pointer __p,
     __enable_if_t<!is_lvalue_reference<_Del>::value,
     _Del&&> __d) noexcept
 : _M_t(__p, std::move(__d))
 { }

      template<typename _Del = deleter_type,
        typename _DelUnref = typename remove_reference<_Del>::type>
 unique_ptr(pointer,
     __enable_if_t<is_lvalue_reference<_Del>::value,
     _DelUnref&&>) = delete;


      template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
 constexpr unique_ptr(nullptr_t) noexcept
 : _M_t()
 { }




      unique_ptr(unique_ptr&&) = default;







      template<typename _Up, typename _Ep, typename = _Require<
               __safe_conversion_up<_Up, _Ep>,
        typename conditional<is_reference<_Dp>::value,
        is_same<_Ep, _Dp>,
        is_convertible<_Ep, _Dp>>::type>>
 unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
 : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
 { }


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

      template<typename _Up, typename = _Require<
        is_convertible<_Up*, _Tp*>, is_same<_Dp, default_delete<_Tp>>>>
 unique_ptr(auto_ptr<_Up>&& __u) noexcept;
#pragma GCC diagnostic pop



      ~unique_ptr() noexcept
      {
 static_assert(__is_invocable<deleter_type&, pointer>::value,
        "unique_ptr's deleter must be invocable with a pointer");
 auto& __ptr = _M_t._M_ptr();
 if (__ptr != nullptr)
   get_deleter()(std::move(__ptr));
 __ptr = pointer();
      }







      unique_ptr& operator=(unique_ptr&&) = default;
# 368 "/usr/local/include/c++/10.0.0/bits/unique_ptr.h" 3
      template<typename _Up, typename _Ep>
        typename enable_if< __and_<
          __safe_conversion_up<_Up, _Ep>,
          is_assignable<deleter_type&, _Ep&&>
          >::value,
          unique_ptr&>::type
 operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
 {
   reset(__u.release());
   get_deleter() = std::forward<_Ep>(__u.get_deleter());
   return *this;
 }


      unique_ptr&
      operator=(nullptr_t) noexcept
      {
 reset();
 return *this;
      }




      typename add_lvalue_reference<element_type>::type
      operator*() const
      {
 ;
 return *get();
      }


      pointer
      operator->() const noexcept
      {
 ;
 return get();
      }


      pointer
      get() const noexcept
      { return _M_t._M_ptr(); }


      deleter_type&
      get_deleter() noexcept
      { return _M_t._M_deleter(); }


      const deleter_type&
      get_deleter() const noexcept
      { return _M_t._M_deleter(); }


      explicit operator bool() const noexcept
      { return get() == pointer() ? false : true; }




      pointer
      release() noexcept
      { return _M_t.release(); }







      void
      reset(pointer __p = pointer()) noexcept
      {
 static_assert(__is_invocable<deleter_type&, pointer>::value,
        "unique_ptr's deleter must be invocable with a pointer");
 _M_t.reset(std::move(__p));
      }


      void
      swap(unique_ptr& __u) noexcept
      {
 using std::swap;
 swap(_M_t, __u._M_t);
      }


      unique_ptr(const unique_ptr&) = delete;
      unique_ptr& operator=(const unique_ptr&) = delete;
  };





  template<typename _Tp, typename _Dp>
    class unique_ptr<_Tp[], _Dp>
    {
      template <typename _Up>
      using _DeleterConstraint =
 typename __uniq_ptr_impl<_Tp, _Up>::_DeleterConstraint::type;

      __uniq_ptr_data<_Tp, _Dp> _M_t;

      template<typename _Up>
 using __remove_cv = typename remove_cv<_Up>::type;


      template<typename _Up>
 using __is_derived_Tp
   = __and_< is_base_of<_Tp, _Up>,
      __not_<is_same<__remove_cv<_Tp>, __remove_cv<_Up>>> >;

    public:
      using pointer = typename __uniq_ptr_impl<_Tp, _Dp>::pointer;
      using element_type = _Tp;
      using deleter_type = _Dp;



      template<typename _Up, typename _Ep,
               typename _UPtr = unique_ptr<_Up, _Ep>,
        typename _UP_pointer = typename _UPtr::pointer,
        typename _UP_element_type = typename _UPtr::element_type>
 using __safe_conversion_up = __and_<
          is_array<_Up>,
          is_same<pointer, element_type*>,
          is_same<_UP_pointer, _UP_element_type*>,
          is_convertible<_UP_element_type(*)[], element_type(*)[]>
        >;


      template<typename _Up>
        using __safe_conversion_raw = __and_<
          __or_<__or_<is_same<_Up, pointer>,
                      is_same<_Up, nullptr_t>>,
                __and_<is_pointer<_Up>,
                       is_same<pointer, element_type*>,
                       is_convertible<
                         typename remove_pointer<_Up>::type(*)[],
                         element_type(*)[]>
                >
          >
        >;




      template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
 constexpr unique_ptr() noexcept
 : _M_t()
 { }
# 529 "/usr/local/include/c++/10.0.0/bits/unique_ptr.h" 3
      template<typename _Up,
        typename _Vp = _Dp,
        typename = _DeleterConstraint<_Vp>,
        typename = typename enable_if<
                 __safe_conversion_raw<_Up>::value, bool>::type>
 explicit
 unique_ptr(_Up __p) noexcept
 : _M_t(__p)
        { }
# 547 "/usr/local/include/c++/10.0.0/bits/unique_ptr.h" 3
      template<typename _Up, typename _Del = deleter_type,
        typename = _Require<__safe_conversion_raw<_Up>,
       is_copy_constructible<_Del>>>
      unique_ptr(_Up __p, const deleter_type& __d) noexcept
      : _M_t(__p, __d) { }
# 561 "/usr/local/include/c++/10.0.0/bits/unique_ptr.h" 3
      template<typename _Up, typename _Del = deleter_type,
        typename = _Require<__safe_conversion_raw<_Up>,
       is_move_constructible<_Del>>>
 unique_ptr(_Up __p,
     __enable_if_t<!is_lvalue_reference<_Del>::value,
     _Del&&> __d) noexcept
 : _M_t(std::move(__p), std::move(__d))
 { }

      template<typename _Up, typename _Del = deleter_type,
        typename _DelUnref = typename remove_reference<_Del>::type,
        typename = _Require<__safe_conversion_raw<_Up>>>
 unique_ptr(_Up,
     __enable_if_t<is_lvalue_reference<_Del>::value,
     _DelUnref&&>) = delete;


      unique_ptr(unique_ptr&&) = default;


      template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
 constexpr unique_ptr(nullptr_t) noexcept
 : _M_t()
        { }

      template<typename _Up, typename _Ep, typename = _Require<
        __safe_conversion_up<_Up, _Ep>,
        typename conditional<is_reference<_Dp>::value,
        is_same<_Ep, _Dp>,
        is_convertible<_Ep, _Dp>>::type>>
 unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
 : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
 { }


      ~unique_ptr()
      {
 auto& __ptr = _M_t._M_ptr();
 if (__ptr != nullptr)
   get_deleter()(__ptr);
 __ptr = pointer();
      }







      unique_ptr&
      operator=(unique_ptr&&) = default;
# 620 "/usr/local/include/c++/10.0.0/bits/unique_ptr.h" 3
      template<typename _Up, typename _Ep>
 typename
 enable_if<__and_<__safe_conversion_up<_Up, _Ep>,
                         is_assignable<deleter_type&, _Ep&&>
                  >::value,
                  unique_ptr&>::type
 operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
 {
   reset(__u.release());
   get_deleter() = std::forward<_Ep>(__u.get_deleter());
   return *this;
 }


      unique_ptr&
      operator=(nullptr_t) noexcept
      {
 reset();
 return *this;
      }




      typename std::add_lvalue_reference<element_type>::type
      operator[](size_t __i) const
      {
 ;
 return get()[__i];
      }


      pointer
      get() const noexcept
      { return _M_t._M_ptr(); }


      deleter_type&
      get_deleter() noexcept
      { return _M_t._M_deleter(); }


      const deleter_type&
      get_deleter() const noexcept
      { return _M_t._M_deleter(); }


      explicit operator bool() const noexcept
      { return get() == pointer() ? false : true; }




      pointer
      release() noexcept
      { return _M_t.release(); }







      template <typename _Up,
                typename = _Require<
                  __or_<is_same<_Up, pointer>,
                        __and_<is_same<pointer, element_type*>,
                               is_pointer<_Up>,
                               is_convertible<
                                 typename remove_pointer<_Up>::type(*)[],
                                 element_type(*)[]
                               >
                        >
                  >
               >>
      void
      reset(_Up __p) noexcept
      { _M_t.reset(std::move(__p)); }

      void reset(nullptr_t = nullptr) noexcept
      { reset(pointer()); }


      void
      swap(unique_ptr& __u) noexcept
      {
 using std::swap;
 swap(_M_t, __u._M_t);
      }


      unique_ptr(const unique_ptr&) = delete;
      unique_ptr& operator=(const unique_ptr&) = delete;
    };




  template<typename _Tp, typename _Dp>
    inline


    typename enable_if<__is_swappable<_Dp>::value>::type



    swap(unique_ptr<_Tp, _Dp>& __x,
  unique_ptr<_Tp, _Dp>& __y) noexcept
    { __x.swap(__y); }


  template<typename _Tp, typename _Dp>
    typename enable_if<!__is_swappable<_Dp>::value>::type
    swap(unique_ptr<_Tp, _Dp>&,
  unique_ptr<_Tp, _Dp>&) = delete;



  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    [[__nodiscard__]] inline bool
    operator==(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return __x.get() == __y.get(); }


  template<typename _Tp, typename _Dp>
    [[__nodiscard__]] inline bool
    operator==(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
    { return !__x; }


  template<typename _Tp, typename _Dp>
    [[__nodiscard__]] inline bool
    operator==(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
    { return !__x; }


  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    [[__nodiscard__]] inline bool
    operator!=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return __x.get() != __y.get(); }


  template<typename _Tp, typename _Dp>
    [[__nodiscard__]] inline bool
    operator!=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
    { return (bool)__x; }


  template<typename _Tp, typename _Dp>
    [[__nodiscard__]] inline bool
    operator!=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
    { return (bool)__x; }


  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    [[__nodiscard__]] inline bool
    operator<(const unique_ptr<_Tp, _Dp>& __x,
       const unique_ptr<_Up, _Ep>& __y)
    {
      typedef typename
 std::common_type<typename unique_ptr<_Tp, _Dp>::pointer,
                  typename unique_ptr<_Up, _Ep>::pointer>::type _CT;
      return std::less<_CT>()(__x.get(), __y.get());
    }


  template<typename _Tp, typename _Dp>
    [[__nodiscard__]] inline bool
    operator<(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    {
      return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
         nullptr);
    }


  template<typename _Tp, typename _Dp>
    [[__nodiscard__]] inline bool
    operator<(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    {
      return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
         __x.get());
    }


  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    [[__nodiscard__]] inline bool
    operator<=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Dp>
    [[__nodiscard__]] inline bool
    operator<=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return !(nullptr < __x); }


  template<typename _Tp, typename _Dp>
    [[__nodiscard__]] inline bool
    operator<=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return !(__x < nullptr); }


  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    [[__nodiscard__]] inline bool
    operator>(const unique_ptr<_Tp, _Dp>& __x,
       const unique_ptr<_Up, _Ep>& __y)
    { return (__y < __x); }


  template<typename _Tp, typename _Dp>
    [[__nodiscard__]] inline bool
    operator>(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    {
      return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
         __x.get());
    }


  template<typename _Tp, typename _Dp>
    [[__nodiscard__]] inline bool
    operator>(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    {
      return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
         nullptr);
    }


  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    [[__nodiscard__]] inline bool
    operator>=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Dp>
    [[__nodiscard__]] inline bool
    operator>=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return !(__x < nullptr); }


  template<typename _Tp, typename _Dp>
    [[__nodiscard__]] inline bool
    operator>=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return !(nullptr < __x); }



  template<typename _Up, typename _Ptr = typename _Up::pointer,
    bool = __poison_hash<_Ptr>::__enable_hash_call>
    struct __uniq_ptr_hash

    : private __poison_hash<_Ptr>

    {
      size_t
      operator()(const _Up& __u) const
      noexcept(noexcept(std::declval<hash<_Ptr>>()(std::declval<_Ptr>())))
      { return hash<_Ptr>()(__u.get()); }
    };

  template<typename _Up, typename _Ptr>
    struct __uniq_ptr_hash<_Up, _Ptr, false>
    : private __poison_hash<_Ptr>
    { };



  template<typename _Tp, typename _Dp>
    struct hash<unique_ptr<_Tp, _Dp>>
    : public __hash_base<size_t, unique_ptr<_Tp, _Dp>>,
      public __uniq_ptr_hash<unique_ptr<_Tp, _Dp>>
    { };







  template<typename _Tp>
    struct _MakeUniq
    { typedef unique_ptr<_Tp> __single_object; };

  template<typename _Tp>
    struct _MakeUniq<_Tp[]>
    { typedef unique_ptr<_Tp[]> __array; };

  template<typename _Tp, size_t _Bound>
    struct _MakeUniq<_Tp[_Bound]>
    { struct __invalid_type { }; };




  template<typename _Tp, typename... _Args>
    inline typename _MakeUniq<_Tp>::__single_object
    make_unique(_Args&&... __args)
    { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...)); }


  template<typename _Tp>
    inline typename _MakeUniq<_Tp>::__array
    make_unique(size_t __num)
    { return unique_ptr<_Tp>(new remove_extent_t<_Tp>[__num]()); }


  template<typename _Tp, typename... _Args>
    inline typename _MakeUniq<_Tp>::__invalid_type
    make_unique(_Args&&...) = delete;






  namespace __detail::__variant
  {
    template<typename> struct _Never_valueless_alt;



    template<typename _Tp, typename _Del>
      struct _Never_valueless_alt<std::unique_ptr<_Tp, _Del>>
      : std::true_type
      { };
  }



}
# 83 "/usr/local/include/c++/10.0.0/memory" 2 3
# 1 "/usr/local/include/c++/10.0.0/bits/shared_ptr.h" 1 3
# 52 "/usr/local/include/c++/10.0.0/bits/shared_ptr.h" 3
# 1 "/usr/local/include/c++/10.0.0/bits/shared_ptr_base.h" 1 3
# 53 "/usr/local/include/c++/10.0.0/bits/shared_ptr_base.h" 3
# 1 "/usr/local/include/c++/10.0.0/bits/allocated_ptr.h" 1 3
# 40 "/usr/local/include/c++/10.0.0/bits/allocated_ptr.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Alloc>
    struct __allocated_ptr
    {
      using pointer = typename allocator_traits<_Alloc>::pointer;
      using value_type = typename allocator_traits<_Alloc>::value_type;


      __allocated_ptr(_Alloc& __a, pointer __ptr) noexcept
      : _M_alloc(std::__addressof(__a)), _M_ptr(__ptr)
      { }


      template<typename _Ptr,
        typename _Req = _Require<is_same<_Ptr, value_type*>>>
      __allocated_ptr(_Alloc& __a, _Ptr __ptr)
      : _M_alloc(std::__addressof(__a)),
 _M_ptr(pointer_traits<pointer>::pointer_to(*__ptr))
      { }


      __allocated_ptr(__allocated_ptr&& __gd) noexcept
      : _M_alloc(__gd._M_alloc), _M_ptr(__gd._M_ptr)
      { __gd._M_ptr = nullptr; }


      ~__allocated_ptr()
      {
 if (_M_ptr != nullptr)
   std::allocator_traits<_Alloc>::deallocate(*_M_alloc, _M_ptr, 1);
      }


      __allocated_ptr&
      operator=(std::nullptr_t) noexcept
      {
 _M_ptr = nullptr;
 return *this;
      }


      value_type* get() { return std::__to_address(_M_ptr); }

    private:
      _Alloc* _M_alloc;
      pointer _M_ptr;
    };


  template<typename _Alloc>
    __allocated_ptr<_Alloc>
    __allocate_guarded(_Alloc& __a)
    {
      return { __a, std::allocator_traits<_Alloc>::allocate(__a, 1) };
    }


}
# 54 "/usr/local/include/c++/10.0.0/bits/shared_ptr_base.h" 2 3
# 1 "/usr/local/include/c++/10.0.0/bits/refwrap.h" 1 3
# 33 "/usr/local/include/c++/10.0.0/bits/refwrap.h" 3
       
# 34 "/usr/local/include/c++/10.0.0/bits/refwrap.h" 3
# 43 "/usr/local/include/c++/10.0.0/bits/refwrap.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 54 "/usr/local/include/c++/10.0.0/bits/refwrap.h" 3
  template<typename _Res, typename... _ArgTypes>
    struct _Maybe_unary_or_binary_function { };


  template<typename _Res, typename _T1>
    struct _Maybe_unary_or_binary_function<_Res, _T1>
    : std::unary_function<_T1, _Res> { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>
    : std::binary_function<_T1, _T2, _Res> { };

  template<typename _Signature>
    struct _Mem_fn_traits;

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Mem_fn_traits_base
    {
      using __result_type = _Res;
      using __maybe_type
 = _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>;
      using __arity = integral_constant<size_t, sizeof...(_ArgTypes)>;
    };
# 99 "/usr/local/include/c++/10.0.0/bits/refwrap.h" 3
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) > : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) > : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const > : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const > : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile > : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile > : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile > : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile > : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };


template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) & noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) & noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const & noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const & noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile & noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile & noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile & noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile & noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) && noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) && noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const && noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const && noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile && noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile && noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile && noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile && noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };






  template<typename _Functor, typename = __void_t<>>
    struct _Maybe_get_result_type
    { };

  template<typename _Functor>
    struct _Maybe_get_result_type<_Functor,
      __void_t<typename _Functor::result_type>>
    { typedef typename _Functor::result_type result_type; };





  template<typename _Functor>
    struct _Weak_result_type_impl
    : _Maybe_get_result_type<_Functor>
    { };


  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) noexcept (_NE)>
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) noexcept (_NE)>
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct _Weak_result_type_impl<_Res(*)(_ArgTypes...) noexcept (_NE)>
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct
    _Weak_result_type_impl<_Res(*)(_ArgTypes......) noexcept (_NE)>
    { typedef _Res result_type; };


  template<typename _Functor,
    bool = is_member_function_pointer<_Functor>::value>
    struct _Weak_result_type_memfun
    : _Weak_result_type_impl<_Functor>
    { };


  template<typename _MemFunPtr>
    struct _Weak_result_type_memfun<_MemFunPtr, true>
    {
      using result_type = typename _Mem_fn_traits<_MemFunPtr>::__result_type;
    };


  template<typename _Func, typename _Class>
    struct _Weak_result_type_memfun<_Func _Class::*, false>
    { };





  template<typename _Functor>
    struct _Weak_result_type
    : _Weak_result_type_memfun<typename remove_cv<_Functor>::type>
    { };
# 293 "/usr/local/include/c++/10.0.0/bits/refwrap.h" 3
  template<typename _Tp>
    class reference_wrapper





    {
      _Tp* _M_data;

      constexpr
      static _Tp* _S_fun(_Tp& __r) noexcept { return std::__addressof(__r); }

      static void _S_fun(_Tp&&) = delete;

      template<typename _Up, typename _Up2 = __remove_cvref_t<_Up>>
 using __not_same
   = typename enable_if<!is_same<reference_wrapper, _Up2>::value>::type;

    public:
      typedef _Tp type;




      template<typename _Up, typename = __not_same<_Up>, typename
  = decltype(reference_wrapper::_S_fun(std::declval<_Up>()))>
 constexpr
 reference_wrapper(_Up&& __uref)
 noexcept(noexcept(reference_wrapper::_S_fun(std::declval<_Up>())))
 : _M_data(reference_wrapper::_S_fun(std::forward<_Up>(__uref)))
 { }

      reference_wrapper(const reference_wrapper&) = default;

      reference_wrapper&
      operator=(const reference_wrapper&) = default;

      constexpr
      operator _Tp&() const noexcept
      { return this->get(); }

      constexpr
      _Tp&
      get() const noexcept
      { return *_M_data; }

      template<typename... _Args>
 constexpr
 typename result_of<_Tp&(_Args&&...)>::type
 operator()(_Args&&... __args) const
 {

   static_assert(sizeof(type), "type must be complete");

   return std::__invoke(get(), std::forward<_Args>(__args)...);
 }
    };


  template<typename _Tp>
    reference_wrapper(_Tp&) -> reference_wrapper<_Tp>;





  template<typename _Tp>
    constexpr
    inline reference_wrapper<_Tp>
    ref(_Tp& __t) noexcept
    { return reference_wrapper<_Tp>(__t); }


  template<typename _Tp>
    constexpr
    inline reference_wrapper<const _Tp>
    cref(const _Tp& __t) noexcept
    { return reference_wrapper<const _Tp>(__t); }

  template<typename _Tp>
    void ref(const _Tp&&) = delete;

  template<typename _Tp>
    void cref(const _Tp&&) = delete;


  template<typename _Tp>
    constexpr
    inline reference_wrapper<_Tp>
    ref(reference_wrapper<_Tp> __t) noexcept
    { return __t; }


  template<typename _Tp>
    constexpr
    inline reference_wrapper<const _Tp>
    cref(reference_wrapper<_Tp> __t) noexcept
    { return { __t.get() }; }




}
# 55 "/usr/local/include/c++/10.0.0/bits/shared_ptr_base.h" 2 3

# 1 "/usr/local/include/c++/10.0.0/ext/aligned_buffer.h" 1 3
# 32 "/usr/local/include/c++/10.0.0/ext/aligned_buffer.h" 3
       
# 33 "/usr/local/include/c++/10.0.0/ext/aligned_buffer.h" 3







namespace __gnu_cxx
{




  template<typename _Tp>
    struct __aligned_membuf
    {





      struct _Tp2 { _Tp _M_t; };

      alignas(__alignof__(_Tp2::_M_t)) unsigned char _M_storage[sizeof(_Tp)];

      __aligned_membuf() = default;


      __aligned_membuf(std::nullptr_t) { }

      void*
      _M_addr() noexcept
      { return static_cast<void*>(&_M_storage); }

      const void*
      _M_addr() const noexcept
      { return static_cast<const void*>(&_M_storage); }

      _Tp*
      _M_ptr() noexcept
      { return static_cast<_Tp*>(_M_addr()); }

      const _Tp*
      _M_ptr() const noexcept
      { return static_cast<const _Tp*>(_M_addr()); }
    };
# 89 "/usr/local/include/c++/10.0.0/ext/aligned_buffer.h" 3
  template<typename _Tp>
    struct __aligned_buffer
    : std::aligned_storage<sizeof(_Tp), __alignof__(_Tp)>
    {
      typename
 std::aligned_storage<sizeof(_Tp), __alignof__(_Tp)>::type _M_storage;

      __aligned_buffer() = default;


      __aligned_buffer(std::nullptr_t) { }

      void*
      _M_addr() noexcept
      {
        return static_cast<void*>(&_M_storage);
      }

      const void*
      _M_addr() const noexcept
      {
        return static_cast<const void*>(&_M_storage);
      }

      _Tp*
      _M_ptr() noexcept
      { return static_cast<_Tp*>(_M_addr()); }

      const _Tp*
      _M_ptr() const noexcept
      { return static_cast<const _Tp*>(_M_addr()); }
    };


}
# 57 "/usr/local/include/c++/10.0.0/bits/shared_ptr_base.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
  template<typename> class auto_ptr;
#pragma GCC diagnostic pop






  class bad_weak_ptr : public std::exception
  {
  public:
    virtual char const* what() const noexcept;

    virtual ~bad_weak_ptr() noexcept;
  };


  inline void
  __throw_bad_weak_ptr()
  { (throw (bad_weak_ptr())); }

  using __gnu_cxx::_Lock_policy;
  using __gnu_cxx::__default_lock_policy;
  using __gnu_cxx::_S_single;
  using __gnu_cxx::_S_mutex;
  using __gnu_cxx::_S_atomic;


  template<_Lock_policy _Lp>
    class _Mutex_base
    {
    protected:

      enum { _S_need_barriers = 0 };
    };

  template<>
    class _Mutex_base<_S_mutex>
    : public __gnu_cxx::__mutex
    {
    protected:



      enum { _S_need_barriers = 1 };
    };

  template<_Lock_policy _Lp = __default_lock_policy>
    class _Sp_counted_base
    : public _Mutex_base<_Lp>
    {
    public:
      _Sp_counted_base() noexcept
      : _M_use_count(1), _M_weak_count(1) { }

      virtual
      ~_Sp_counted_base() noexcept
      { }



      virtual void
      _M_dispose() noexcept = 0;


      virtual void
      _M_destroy() noexcept
      { delete this; }

      virtual void*
      _M_get_deleter(const std::type_info&) noexcept = 0;

      void
      _M_add_ref_copy()
      { __gnu_cxx::__atomic_add_dispatch(&_M_use_count, 1); }

      void
      _M_add_ref_lock();

      bool
      _M_add_ref_lock_nothrow();

      void
      _M_release() noexcept
      {

        ;
 if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)
   {
            ;
     _M_dispose();




     if (_Mutex_base<_Lp>::_S_need_barriers)
       {
  __atomic_thread_fence (4);
       }


            ;
     if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count,
             -1) == 1)
              {
                ;
         _M_destroy();
              }
   }
      }

      void
      _M_weak_add_ref() noexcept
      { __gnu_cxx::__atomic_add_dispatch(&_M_weak_count, 1); }

      void
      _M_weak_release() noexcept
      {

        ;
 if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count, -1) == 1)
   {
            ;
     if (_Mutex_base<_Lp>::_S_need_barriers)
       {


  __atomic_thread_fence (4);
       }
     _M_destroy();
   }
      }

      long
      _M_get_use_count() const noexcept
      {


        return __atomic_load_n(&_M_use_count, 0);
      }

    private:
      _Sp_counted_base(_Sp_counted_base const&) = delete;
      _Sp_counted_base& operator=(_Sp_counted_base const&) = delete;

      _Atomic_word _M_use_count;
      _Atomic_word _M_weak_count;
    };

  template<>
    inline void
    _Sp_counted_base<_S_single>::
    _M_add_ref_lock()
    {
      if (_M_use_count == 0)
 __throw_bad_weak_ptr();
      ++_M_use_count;
    }

  template<>
    inline void
    _Sp_counted_base<_S_mutex>::
    _M_add_ref_lock()
    {
      __gnu_cxx::__scoped_lock sentry(*this);
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)
 {
   _M_use_count = 0;
   __throw_bad_weak_ptr();
 }
    }

  template<>
    inline void
    _Sp_counted_base<_S_atomic>::
    _M_add_ref_lock()
    {

      _Atomic_word __count = _M_get_use_count();
      do
 {
   if (__count == 0)
     __throw_bad_weak_ptr();


 }
      while (!__atomic_compare_exchange_n(&_M_use_count, &__count, __count + 1,
       true, 4,
       0));
    }

  template<>
    inline bool
    _Sp_counted_base<_S_single>::
    _M_add_ref_lock_nothrow()
    {
      if (_M_use_count == 0)
 return false;
      ++_M_use_count;
      return true;
    }

  template<>
    inline bool
    _Sp_counted_base<_S_mutex>::
    _M_add_ref_lock_nothrow()
    {
      __gnu_cxx::__scoped_lock sentry(*this);
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)
 {
   _M_use_count = 0;
   return false;
 }
      return true;
    }

  template<>
    inline bool
    _Sp_counted_base<_S_atomic>::
    _M_add_ref_lock_nothrow()
    {

      _Atomic_word __count = _M_get_use_count();
      do
 {
   if (__count == 0)
     return false;


 }
      while (!__atomic_compare_exchange_n(&_M_use_count, &__count, __count + 1,
       true, 4,
       0));
      return true;
    }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
          if (--_M_weak_count == 0)
            _M_destroy();
        }
    }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_weak_add_ref() noexcept
    { ++_M_weak_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_weak_release() noexcept
    {
      if (--_M_weak_count == 0)
        _M_destroy();
    }

  template<>
    inline long
    _Sp_counted_base<_S_single>::_M_get_use_count() const noexcept
    { return _M_use_count; }



  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
    class __shared_ptr;

  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
    class __weak_ptr;

  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
    class __enable_shared_from_this;

  template<typename _Tp>
    class shared_ptr;

  template<typename _Tp>
    class weak_ptr;

  template<typename _Tp>
    struct owner_less;

  template<typename _Tp>
    class enable_shared_from_this;

  template<_Lock_policy _Lp = __default_lock_policy>
    class __weak_count;

  template<_Lock_policy _Lp = __default_lock_policy>
    class __shared_count;



  template<typename _Ptr, _Lock_policy _Lp>
    class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>
    {
    public:
      explicit
      _Sp_counted_ptr(_Ptr __p) noexcept
      : _M_ptr(__p) { }

      virtual void
      _M_dispose() noexcept
      { delete _M_ptr; }

      virtual void
      _M_destroy() noexcept
      { delete this; }

      virtual void*
      _M_get_deleter(const std::type_info&) noexcept
      { return nullptr; }

      _Sp_counted_ptr(const _Sp_counted_ptr&) = delete;
      _Sp_counted_ptr& operator=(const _Sp_counted_ptr&) = delete;

    private:
      _Ptr _M_ptr;
    };

  template<>
    inline void
    _Sp_counted_ptr<nullptr_t, _S_single>::_M_dispose() noexcept { }

  template<>
    inline void
    _Sp_counted_ptr<nullptr_t, _S_mutex>::_M_dispose() noexcept { }

  template<>
    inline void
    _Sp_counted_ptr<nullptr_t, _S_atomic>::_M_dispose() noexcept { }

  template<int _Nm, typename _Tp,
    bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>
    struct _Sp_ebo_helper;


  template<int _Nm, typename _Tp>
    struct _Sp_ebo_helper<_Nm, _Tp, true> : private _Tp
    {
      explicit _Sp_ebo_helper(const _Tp& __tp) : _Tp(__tp) { }
      explicit _Sp_ebo_helper(_Tp&& __tp) : _Tp(std::move(__tp)) { }

      static _Tp&
      _S_get(_Sp_ebo_helper& __eboh) { return static_cast<_Tp&>(__eboh); }
    };


  template<int _Nm, typename _Tp>
    struct _Sp_ebo_helper<_Nm, _Tp, false>
    {
      explicit _Sp_ebo_helper(const _Tp& __tp) : _M_tp(__tp) { }
      explicit _Sp_ebo_helper(_Tp&& __tp) : _M_tp(std::move(__tp)) { }

      static _Tp&
      _S_get(_Sp_ebo_helper& __eboh)
      { return __eboh._M_tp; }

    private:
      _Tp _M_tp;
    };


  template<typename _Ptr, typename _Deleter, typename _Alloc, _Lock_policy _Lp>
    class _Sp_counted_deleter final : public _Sp_counted_base<_Lp>
    {
      class _Impl : _Sp_ebo_helper<0, _Deleter>, _Sp_ebo_helper<1, _Alloc>
      {
 typedef _Sp_ebo_helper<0, _Deleter> _Del_base;
 typedef _Sp_ebo_helper<1, _Alloc> _Alloc_base;

      public:
 _Impl(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
 : _M_ptr(__p), _Del_base(std::move(__d)), _Alloc_base(__a)
 { }

 _Deleter& _M_del() noexcept { return _Del_base::_S_get(*this); }
 _Alloc& _M_alloc() noexcept { return _Alloc_base::_S_get(*this); }

 _Ptr _M_ptr;
      };

    public:
      using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_deleter>;


      _Sp_counted_deleter(_Ptr __p, _Deleter __d) noexcept
      : _M_impl(__p, std::move(__d), _Alloc()) { }


      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
      : _M_impl(__p, std::move(__d), __a) { }

      ~_Sp_counted_deleter() noexcept { }

      virtual void
      _M_dispose() noexcept
      { _M_impl._M_del()(_M_impl._M_ptr); }

      virtual void
      _M_destroy() noexcept
      {
 __allocator_type __a(_M_impl._M_alloc());
 __allocated_ptr<__allocator_type> __guard_ptr{ __a, this };
 this->~_Sp_counted_deleter();
      }

      virtual void*
      _M_get_deleter(const std::type_info& __ti) noexcept
      {



        return __ti == typeid(_Deleter)
   ? std::__addressof(_M_impl._M_del())
   : nullptr;



      }

    private:
      _Impl _M_impl;
    };



  struct _Sp_make_shared_tag
  {
  private:
    template<typename _Tp, typename _Alloc, _Lock_policy _Lp>
      friend class _Sp_counted_ptr_inplace;

    static const type_info&
    _S_ti() noexcept __attribute__ ((__visibility__ ("default")))
    {
      alignas(type_info) static constexpr char __tag[sizeof(type_info)] = { };
      return reinterpret_cast<const type_info&>(__tag);
    }

    static bool _S_eq(const type_info&) noexcept;
  };

  template<typename _Alloc>
    struct _Sp_alloc_shared_tag
    {
      const _Alloc& _M_a;
    };

  template<typename _Tp, typename _Alloc, _Lock_policy _Lp>
    class _Sp_counted_ptr_inplace final : public _Sp_counted_base<_Lp>
    {
      class _Impl : _Sp_ebo_helper<0, _Alloc>
      {
 typedef _Sp_ebo_helper<0, _Alloc> _A_base;

      public:
 explicit _Impl(_Alloc __a) noexcept : _A_base(__a) { }

 _Alloc& _M_alloc() noexcept { return _A_base::_S_get(*this); }

 __gnu_cxx::__aligned_buffer<_Tp> _M_storage;
      };

    public:
      using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_ptr_inplace>;


      template<typename... _Args>
 _Sp_counted_ptr_inplace(_Alloc __a, _Args&&... __args)
 : _M_impl(__a)
 {


   allocator_traits<_Alloc>::construct(__a, _M_ptr(),
       std::forward<_Args>(__args)...);
 }

      ~_Sp_counted_ptr_inplace() noexcept { }

      virtual void
      _M_dispose() noexcept
      {
 allocator_traits<_Alloc>::destroy(_M_impl._M_alloc(), _M_ptr());
      }


      virtual void
      _M_destroy() noexcept
      {
 __allocator_type __a(_M_impl._M_alloc());
 __allocated_ptr<__allocator_type> __guard_ptr{ __a, this };
 this->~_Sp_counted_ptr_inplace();
      }

    private:
      friend class __shared_count<_Lp>;



      virtual void*
      _M_get_deleter(const std::type_info& __ti) noexcept override
      {
 auto __ptr = const_cast<typename remove_cv<_Tp>::type*>(_M_ptr());




 if (&__ti == &_Sp_make_shared_tag::_S_ti()
     ||

     __ti == typeid(_Sp_make_shared_tag)



    )
   return __ptr;
 return nullptr;
      }

      _Tp* _M_ptr() noexcept { return _M_impl._M_storage._M_ptr(); }

      _Impl _M_impl;
    };


  struct __sp_array_delete
  {
    template<typename _Yp>
      void operator()(_Yp* __p) const { delete[] __p; }
  };

  template<_Lock_policy _Lp>
    class __shared_count
    {
      template<typename _Tp>
 struct __not_alloc_shared_tag { using type = void; };

      template<typename _Tp>
 struct __not_alloc_shared_tag<_Sp_alloc_shared_tag<_Tp>> { };

    public:
      constexpr __shared_count() noexcept : _M_pi(0)
      { }

      template<typename _Ptr>
        explicit
 __shared_count(_Ptr __p) : _M_pi(0)
 {
   try
     {
       _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
     }
   catch(...)
     {
       delete __p;
       throw;
     }
 }

      template<typename _Ptr>
 __shared_count(_Ptr __p, false_type)
 : __shared_count(__p)
 { }

      template<typename _Ptr>
 __shared_count(_Ptr __p, true_type)
 : __shared_count(__p, __sp_array_delete{}, allocator<void>())
 { }

      template<typename _Ptr, typename _Deleter,
        typename = typename __not_alloc_shared_tag<_Deleter>::type>
 __shared_count(_Ptr __p, _Deleter __d)
 : __shared_count(__p, std::move(__d), allocator<void>())
 { }

      template<typename _Ptr, typename _Deleter, typename _Alloc,
        typename = typename __not_alloc_shared_tag<_Deleter>::type>
 __shared_count(_Ptr __p, _Deleter __d, _Alloc __a) : _M_pi(0)
 {
   typedef _Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp> _Sp_cd_type;
   try
     {
       typename _Sp_cd_type::__allocator_type __a2(__a);
       auto __guard = std::__allocate_guarded(__a2);
       _Sp_cd_type* __mem = __guard.get();
       ::new (__mem) _Sp_cd_type(__p, std::move(__d), std::move(__a));
       _M_pi = __mem;
       __guard = nullptr;
     }
   catch(...)
     {
       __d(__p);
       throw;
     }
 }

      template<typename _Tp, typename _Alloc, typename... _Args>
 __shared_count(_Tp*& __p, _Sp_alloc_shared_tag<_Alloc> __a,
         _Args&&... __args)
 {
   typedef _Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> _Sp_cp_type;
   typename _Sp_cp_type::__allocator_type __a2(__a._M_a);
   auto __guard = std::__allocate_guarded(__a2);
   _Sp_cp_type* __mem = __guard.get();
   auto __pi = ::new (__mem)
     _Sp_cp_type(__a._M_a, std::forward<_Args>(__args)...);
   __guard = nullptr;
   _M_pi = __pi;
   __p = __pi->_M_ptr();
 }


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

      template<typename _Tp>
        explicit
 __shared_count(std::auto_ptr<_Tp>&& __r);
#pragma GCC diagnostic pop



      template<typename _Tp, typename _Del>
        explicit
 __shared_count(std::unique_ptr<_Tp, _Del>&& __r) : _M_pi(0)
 {


   if (__r.get() == nullptr)
     return;

   using _Ptr = typename unique_ptr<_Tp, _Del>::pointer;
   using _Del2 = typename conditional<is_reference<_Del>::value,
       reference_wrapper<typename remove_reference<_Del>::type>,
       _Del>::type;
   using _Sp_cd_type
     = _Sp_counted_deleter<_Ptr, _Del2, allocator<void>, _Lp>;
   using _Alloc = allocator<_Sp_cd_type>;
   using _Alloc_traits = allocator_traits<_Alloc>;
   _Alloc __a;
   _Sp_cd_type* __mem = _Alloc_traits::allocate(__a, 1);
   _Alloc_traits::construct(__a, __mem, __r.release(),
       __r.get_deleter());
   _M_pi = __mem;
 }


      explicit __shared_count(const __weak_count<_Lp>& __r);


      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
      {
 if (_M_pi != nullptr)
   _M_pi->_M_release();
      }

      __shared_count(const __shared_count& __r) noexcept
      : _M_pi(__r._M_pi)
      {
 if (_M_pi != 0)
   _M_pi->_M_add_ref_copy();
      }

      __shared_count&
      operator=(const __shared_count& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 if (__tmp != _M_pi)
   {
     if (__tmp != 0)
       __tmp->_M_add_ref_copy();
     if (_M_pi != 0)
       _M_pi->_M_release();
     _M_pi = __tmp;
   }
 return *this;
      }

      void
      _M_swap(__shared_count& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 __r._M_pi = _M_pi;
 _M_pi = __tmp;
      }

      long
      _M_get_use_count() const noexcept
      { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }

      bool
      _M_unique() const noexcept
      { return this->_M_get_use_count() == 1; }

      void*
      _M_get_deleter(const std::type_info& __ti) const noexcept
      { return _M_pi ? _M_pi->_M_get_deleter(__ti) : nullptr; }

      bool
      _M_less(const __shared_count& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }

      bool
      _M_less(const __weak_count<_Lp>& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }


      friend inline bool
      operator==(const __shared_count& __a, const __shared_count& __b) noexcept
      { return __a._M_pi == __b._M_pi; }

    private:
      friend class __weak_count<_Lp>;

      _Sp_counted_base<_Lp>* _M_pi;
    };


  template<_Lock_policy _Lp>
    class __weak_count
    {
    public:
      constexpr __weak_count() noexcept : _M_pi(nullptr)
      { }

      __weak_count(const __shared_count<_Lp>& __r) noexcept
      : _M_pi(__r._M_pi)
      {
 if (_M_pi != nullptr)
   _M_pi->_M_weak_add_ref();
      }

      __weak_count(const __weak_count& __r) noexcept
      : _M_pi(__r._M_pi)
      {
 if (_M_pi != nullptr)
   _M_pi->_M_weak_add_ref();
      }

      __weak_count(__weak_count&& __r) noexcept
      : _M_pi(__r._M_pi)
      { __r._M_pi = nullptr; }

      ~__weak_count() noexcept
      {
 if (_M_pi != nullptr)
   _M_pi->_M_weak_release();
      }

      __weak_count&
      operator=(const __shared_count<_Lp>& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 if (__tmp != nullptr)
   __tmp->_M_weak_add_ref();
 if (_M_pi != nullptr)
   _M_pi->_M_weak_release();
 _M_pi = __tmp;
 return *this;
      }

      __weak_count&
      operator=(const __weak_count& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 if (__tmp != nullptr)
   __tmp->_M_weak_add_ref();
 if (_M_pi != nullptr)
   _M_pi->_M_weak_release();
 _M_pi = __tmp;
 return *this;
      }

      __weak_count&
      operator=(__weak_count&& __r) noexcept
      {
 if (_M_pi != nullptr)
   _M_pi->_M_weak_release();
 _M_pi = __r._M_pi;
        __r._M_pi = nullptr;
 return *this;
      }

      void
      _M_swap(__weak_count& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 __r._M_pi = _M_pi;
 _M_pi = __tmp;
      }

      long
      _M_get_use_count() const noexcept
      { return _M_pi != nullptr ? _M_pi->_M_get_use_count() : 0; }

      bool
      _M_less(const __weak_count& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }

      bool
      _M_less(const __shared_count<_Lp>& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }


      friend inline bool
      operator==(const __weak_count& __a, const __weak_count& __b) noexcept
      { return __a._M_pi == __b._M_pi; }

    private:
      friend class __shared_count<_Lp>;

      _Sp_counted_base<_Lp>* _M_pi;
    };


  template<_Lock_policy _Lp>
    inline
    __shared_count<_Lp>::__shared_count(const __weak_count<_Lp>& __r)
    : _M_pi(__r._M_pi)
    {
      if (_M_pi != nullptr)
 _M_pi->_M_add_ref_lock();
      else
 __throw_bad_weak_ptr();
    }


  template<_Lock_policy _Lp>
    inline
    __shared_count<_Lp>::
    __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t)
    : _M_pi(__r._M_pi)
    {
      if (_M_pi != nullptr)
 if (!_M_pi->_M_add_ref_lock_nothrow())
   _M_pi = nullptr;
    }







  template<typename _Yp_ptr, typename _Tp_ptr>
    struct __sp_compatible_with
    : false_type
    { };

  template<typename _Yp, typename _Tp>
    struct __sp_compatible_with<_Yp*, _Tp*>
    : is_convertible<_Yp*, _Tp*>::type
    { };

  template<typename _Up, size_t _Nm>
    struct __sp_compatible_with<_Up(*)[_Nm], _Up(*)[]>
    : true_type
    { };

  template<typename _Up, size_t _Nm>
    struct __sp_compatible_with<_Up(*)[_Nm], const _Up(*)[]>
    : true_type
    { };

  template<typename _Up, size_t _Nm>
    struct __sp_compatible_with<_Up(*)[_Nm], volatile _Up(*)[]>
    : true_type
    { };

  template<typename _Up, size_t _Nm>
    struct __sp_compatible_with<_Up(*)[_Nm], const volatile _Up(*)[]>
    : true_type
    { };


  template<typename _Up, size_t _Nm, typename _Yp, typename = void>
    struct __sp_is_constructible_arrN
    : false_type
    { };

  template<typename _Up, size_t _Nm, typename _Yp>
    struct __sp_is_constructible_arrN<_Up, _Nm, _Yp, __void_t<_Yp[_Nm]>>
    : is_convertible<_Yp(*)[_Nm], _Up(*)[_Nm]>::type
    { };


  template<typename _Up, typename _Yp, typename = void>
    struct __sp_is_constructible_arr
    : false_type
    { };

  template<typename _Up, typename _Yp>
    struct __sp_is_constructible_arr<_Up, _Yp, __void_t<_Yp[]>>
    : is_convertible<_Yp(*)[], _Up(*)[]>::type
    { };


  template<typename _Tp, typename _Yp>
    struct __sp_is_constructible;


  template<typename _Up, size_t _Nm, typename _Yp>
    struct __sp_is_constructible<_Up[_Nm], _Yp>
    : __sp_is_constructible_arrN<_Up, _Nm, _Yp>::type
    { };


  template<typename _Up, typename _Yp>
    struct __sp_is_constructible<_Up[], _Yp>
    : __sp_is_constructible_arr<_Up, _Yp>::type
    { };


  template<typename _Tp, typename _Yp>
    struct __sp_is_constructible
    : is_convertible<_Yp*, _Tp*>::type
    { };



  template<typename _Tp, _Lock_policy _Lp,
    bool = is_array<_Tp>::value, bool = is_void<_Tp>::value>
    class __shared_ptr_access
    {
    public:
      using element_type = _Tp;

      element_type&
      operator*() const noexcept
      {
 ;
 return *_M_get();
      }

      element_type*
      operator->() const noexcept
      {
 ;
 return _M_get();
      }

    private:
      element_type*
      _M_get() const noexcept
      { return static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get(); }
    };


  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr_access<_Tp, _Lp, false, true>
    {
    public:
      using element_type = _Tp;

      element_type*
      operator->() const noexcept
      {
 auto __ptr = static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get();
 ;
 return __ptr;
      }
    };


  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr_access<_Tp, _Lp, true, false>
    {
    public:
      using element_type = typename remove_extent<_Tp>::type;
# 1065 "/usr/local/include/c++/10.0.0/bits/shared_ptr_base.h" 3
      element_type&
      operator[](ptrdiff_t __i) const
      {
 ;
 ;
 return _M_get()[__i];
      }

    private:
      element_type*
      _M_get() const noexcept
      { return static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get(); }
    };

  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr
    : public __shared_ptr_access<_Tp, _Lp>
    {
    public:
      using element_type = typename remove_extent<_Tp>::type;

    private:

      template<typename _Yp>
 using _SafeConv
   = typename enable_if<__sp_is_constructible<_Tp, _Yp>::value>::type;


      template<typename _Yp, typename _Res = void>
 using _Compatible = typename
   enable_if<__sp_compatible_with<_Yp*, _Tp*>::value, _Res>::type;


      template<typename _Yp>
 using _Assignable = _Compatible<_Yp, __shared_ptr&>;


      template<typename _Yp, typename _Del, typename _Res = void,
        typename _Ptr = typename unique_ptr<_Yp, _Del>::pointer>
 using _UniqCompatible = typename enable_if<__and_<
   __sp_compatible_with<_Yp*, _Tp*>, is_convertible<_Ptr, element_type*>
   >::value, _Res>::type;


      template<typename _Yp, typename _Del>
 using _UniqAssignable = _UniqCompatible<_Yp, _Del, __shared_ptr&>;

    public:


      using weak_type = __weak_ptr<_Tp, _Lp>;


      constexpr __shared_ptr() noexcept
      : _M_ptr(0), _M_refcount()
      { }

      template<typename _Yp, typename = _SafeConv<_Yp>>
 explicit
 __shared_ptr(_Yp* __p)
 : _M_ptr(__p), _M_refcount(__p, typename is_array<_Tp>::type())
 {
   static_assert( !is_void<_Yp>::value, "incomplete type" );
   static_assert( sizeof(_Yp) > 0, "incomplete type" );
   _M_enable_shared_from_this_with(__p);
 }

      template<typename _Yp, typename _Deleter, typename = _SafeConv<_Yp>>
 __shared_ptr(_Yp* __p, _Deleter __d)
 : _M_ptr(__p), _M_refcount(__p, std::move(__d))
 {
   static_assert(__is_invocable<_Deleter&, _Yp*&>::value,
       "deleter expression d(p) is well-formed");
   _M_enable_shared_from_this_with(__p);
 }

      template<typename _Yp, typename _Deleter, typename _Alloc,
        typename = _SafeConv<_Yp>>
 __shared_ptr(_Yp* __p, _Deleter __d, _Alloc __a)
 : _M_ptr(__p), _M_refcount(__p, std::move(__d), std::move(__a))
 {
   static_assert(__is_invocable<_Deleter&, _Yp*&>::value,
       "deleter expression d(p) is well-formed");
   _M_enable_shared_from_this_with(__p);
 }

      template<typename _Deleter>
 __shared_ptr(nullptr_t __p, _Deleter __d)
 : _M_ptr(0), _M_refcount(__p, std::move(__d))
 { }

      template<typename _Deleter, typename _Alloc>
        __shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)
 : _M_ptr(0), _M_refcount(__p, std::move(__d), std::move(__a))
 { }


      template<typename _Yp>
 __shared_ptr(const __shared_ptr<_Yp, _Lp>& __r,
       element_type* __p) noexcept
 : _M_ptr(__p), _M_refcount(__r._M_refcount)
 { }


      template<typename _Yp>
 __shared_ptr(__shared_ptr<_Yp, _Lp>&& __r,
       element_type* __p) noexcept
 : _M_ptr(__p), _M_refcount()
 {
   _M_refcount._M_swap(__r._M_refcount);
   __r._M_ptr = 0;
 }

      __shared_ptr(const __shared_ptr&) noexcept = default;
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;

      template<typename _Yp, typename = _Compatible<_Yp>>
 __shared_ptr(const __shared_ptr<_Yp, _Lp>& __r) noexcept
 : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
 { }

      __shared_ptr(__shared_ptr&& __r) noexcept
      : _M_ptr(__r._M_ptr), _M_refcount()
      {
 _M_refcount._M_swap(__r._M_refcount);
 __r._M_ptr = 0;
      }

      template<typename _Yp, typename = _Compatible<_Yp>>
 __shared_ptr(__shared_ptr<_Yp, _Lp>&& __r) noexcept
 : _M_ptr(__r._M_ptr), _M_refcount()
 {
   _M_refcount._M_swap(__r._M_refcount);
   __r._M_ptr = 0;
 }

      template<typename _Yp, typename = _Compatible<_Yp>>
 explicit __shared_ptr(const __weak_ptr<_Yp, _Lp>& __r)
 : _M_refcount(__r._M_refcount)
 {


   _M_ptr = __r._M_ptr;
 }


      template<typename _Yp, typename _Del,
        typename = _UniqCompatible<_Yp, _Del>>
 __shared_ptr(unique_ptr<_Yp, _Del>&& __r)
 : _M_ptr(__r.get()), _M_refcount()
 {
   auto __raw = __to_address(__r.get());
   _M_refcount = __shared_count<_Lp>(std::move(__r));
   _M_enable_shared_from_this_with(__raw);
 }
# 1241 "/usr/local/include/c++/10.0.0/bits/shared_ptr_base.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

      template<typename _Yp, typename = _Compatible<_Yp>>
 __shared_ptr(auto_ptr<_Yp>&& __r);
#pragma GCC diagnostic pop


      constexpr __shared_ptr(nullptr_t) noexcept : __shared_ptr() { }

      template<typename _Yp>
 _Assignable<_Yp>
 operator=(const __shared_ptr<_Yp, _Lp>& __r) noexcept
 {
   _M_ptr = __r._M_ptr;
   _M_refcount = __r._M_refcount;
   return *this;
 }


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
      template<typename _Yp>
 _Assignable<_Yp>
 operator=(auto_ptr<_Yp>&& __r)
 {
   __shared_ptr(std::move(__r)).swap(*this);
   return *this;
 }
#pragma GCC diagnostic pop


      __shared_ptr&
      operator=(__shared_ptr&& __r) noexcept
      {
 __shared_ptr(std::move(__r)).swap(*this);
 return *this;
      }

      template<class _Yp>
 _Assignable<_Yp>
 operator=(__shared_ptr<_Yp, _Lp>&& __r) noexcept
 {
   __shared_ptr(std::move(__r)).swap(*this);
   return *this;
 }

      template<typename _Yp, typename _Del>
 _UniqAssignable<_Yp, _Del>
 operator=(unique_ptr<_Yp, _Del>&& __r)
 {
   __shared_ptr(std::move(__r)).swap(*this);
   return *this;
 }

      void
      reset() noexcept
      { __shared_ptr().swap(*this); }

      template<typename _Yp>
 _SafeConv<_Yp>
 reset(_Yp* __p)
 {

   ;
   __shared_ptr(__p).swap(*this);
 }

      template<typename _Yp, typename _Deleter>
 _SafeConv<_Yp>
 reset(_Yp* __p, _Deleter __d)
 { __shared_ptr(__p, std::move(__d)).swap(*this); }

      template<typename _Yp, typename _Deleter, typename _Alloc>
 _SafeConv<_Yp>
 reset(_Yp* __p, _Deleter __d, _Alloc __a)
        { __shared_ptr(__p, std::move(__d), std::move(__a)).swap(*this); }


      element_type*
      get() const noexcept
      { return _M_ptr; }


      explicit operator bool() const
      { return _M_ptr == 0 ? false : true; }


      bool
      unique() const noexcept
      { return _M_refcount._M_unique(); }


      long
      use_count() const noexcept
      { return _M_refcount._M_get_use_count(); }


      void
      swap(__shared_ptr<_Tp, _Lp>& __other) noexcept
      {
 std::swap(_M_ptr, __other._M_ptr);
 _M_refcount._M_swap(__other._M_refcount);
      }
# 1353 "/usr/local/include/c++/10.0.0/bits/shared_ptr_base.h" 3
      template<typename _Tp1>
 bool
 owner_before(__shared_ptr<_Tp1, _Lp> const& __rhs) const noexcept
 { return _M_refcount._M_less(__rhs._M_refcount); }

      template<typename _Tp1>
 bool
 owner_before(__weak_ptr<_Tp1, _Lp> const& __rhs) const noexcept
 { return _M_refcount._M_less(__rhs._M_refcount); }


    protected:

      template<typename _Alloc, typename... _Args>
 __shared_ptr(_Sp_alloc_shared_tag<_Alloc> __tag, _Args&&... __args)
 : _M_ptr(), _M_refcount(_M_ptr, __tag, std::forward<_Args>(__args)...)
 { _M_enable_shared_from_this_with(_M_ptr); }

      template<typename _Tp1, _Lock_policy _Lp1, typename _Alloc,
        typename... _Args>
 friend __shared_ptr<_Tp1, _Lp1>
 __allocate_shared(const _Alloc& __a, _Args&&... __args);



      __shared_ptr(const __weak_ptr<_Tp, _Lp>& __r, std::nothrow_t)
      : _M_refcount(__r._M_refcount, std::nothrow)
      {
 _M_ptr = _M_refcount._M_get_use_count() ? __r._M_ptr : nullptr;
      }

      friend class __weak_ptr<_Tp, _Lp>;

    private:

      template<typename _Yp>
 using __esft_base_t = decltype(__enable_shared_from_this_base(
       std::declval<const __shared_count<_Lp>&>(),
       std::declval<_Yp*>()));


      template<typename _Yp, typename = void>
 struct __has_esft_base
 : false_type { };

      template<typename _Yp>
 struct __has_esft_base<_Yp, __void_t<__esft_base_t<_Yp>>>
 : __not_<is_array<_Tp>> { };

      template<typename _Yp, typename _Yp2 = typename remove_cv<_Yp>::type>
 typename enable_if<__has_esft_base<_Yp2>::value>::type
 _M_enable_shared_from_this_with(_Yp* __p) noexcept
 {
   if (auto __base = __enable_shared_from_this_base(_M_refcount, __p))
     __base->_M_weak_assign(const_cast<_Yp2*>(__p), _M_refcount);
 }

      template<typename _Yp, typename _Yp2 = typename remove_cv<_Yp>::type>
 typename enable_if<!__has_esft_base<_Yp2>::value>::type
 _M_enable_shared_from_this_with(_Yp*) noexcept
 { }

      void*
      _M_get_deleter(const std::type_info& __ti) const noexcept
      { return _M_refcount._M_get_deleter(__ti); }

      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;
      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;

      template<typename _Del, typename _Tp1, _Lock_policy _Lp1>
 friend _Del* get_deleter(const __shared_ptr<_Tp1, _Lp1>&) noexcept;

      template<typename _Del, typename _Tp1>
 friend _Del* get_deleter(const shared_ptr<_Tp1>&) noexcept;

      element_type* _M_ptr;
      __shared_count<_Lp> _M_refcount;
    };



  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator==(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return __a.get() == __b.get(); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return !__a; }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return !__a; }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator!=(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return __a.get() != __b.get(); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator!=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return (bool)__a; }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator!=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return (bool)__a; }

  template<typename _Tp, typename _Up, _Lock_policy _Lp>
    inline bool
    operator<(const __shared_ptr<_Tp, _Lp>& __a,
       const __shared_ptr<_Up, _Lp>& __b) noexcept
    {
      using _Tp_elt = typename __shared_ptr<_Tp, _Lp>::element_type;
      using _Up_elt = typename __shared_ptr<_Up, _Lp>::element_type;
      using _Vp = typename common_type<_Tp_elt*, _Up_elt*>::type;
      return less<_Vp>()(__a.get(), __b.get());
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    {
      using _Tp_elt = typename __shared_ptr<_Tp, _Lp>::element_type;
      return less<_Tp_elt*>()(__a.get(), nullptr);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    {
      using _Tp_elt = typename __shared_ptr<_Tp, _Lp>::element_type;
      return less<_Tp_elt*>()(nullptr, __a.get());
    }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator<=(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return !(__b < __a); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return !(nullptr < __a); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return !(__a < nullptr); }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator>(const __shared_ptr<_Tp1, _Lp>& __a,
       const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return (__b < __a); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return nullptr < __a; }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return __a < nullptr; }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator>=(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return !(__a < __b); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return !(__a < nullptr); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return !(nullptr < __a); }


  template<typename _Tp, _Lock_policy _Lp>
    inline void
    swap(__shared_ptr<_Tp, _Lp>& __a, __shared_ptr<_Tp, _Lp>& __b) noexcept
    { __a.swap(__b); }
# 1554 "/usr/local/include/c++/10.0.0/bits/shared_ptr_base.h" 3
  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    static_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
    {
      using _Sp = __shared_ptr<_Tp, _Lp>;
      return _Sp(__r, static_cast<typename _Sp::element_type*>(__r.get()));
    }






  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    const_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
    {
      using _Sp = __shared_ptr<_Tp, _Lp>;
      return _Sp(__r, const_cast<typename _Sp::element_type*>(__r.get()));
    }






  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    dynamic_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
    {
      using _Sp = __shared_ptr<_Tp, _Lp>;
      if (auto* __p = dynamic_cast<typename _Sp::element_type*>(__r.get()))
 return _Sp(__r, __p);
      return _Sp();
    }


  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    reinterpret_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
    {
      using _Sp = __shared_ptr<_Tp, _Lp>;
      return _Sp(__r, reinterpret_cast<typename _Sp::element_type*>(__r.get()));
    }


  template<typename _Tp, _Lock_policy _Lp>
    class __weak_ptr
    {
      template<typename _Yp, typename _Res = void>
 using _Compatible = typename
   enable_if<__sp_compatible_with<_Yp*, _Tp*>::value, _Res>::type;


      template<typename _Yp>
 using _Assignable = _Compatible<_Yp, __weak_ptr&>;

    public:
      using element_type = typename remove_extent<_Tp>::type;

      constexpr __weak_ptr() noexcept
      : _M_ptr(nullptr), _M_refcount()
      { }

      __weak_ptr(const __weak_ptr&) noexcept = default;

      ~__weak_ptr() = default;
# 1636 "/usr/local/include/c++/10.0.0/bits/shared_ptr_base.h" 3
      template<typename _Yp, typename = _Compatible<_Yp>>
 __weak_ptr(const __weak_ptr<_Yp, _Lp>& __r) noexcept
 : _M_refcount(__r._M_refcount)
        { _M_ptr = __r.lock().get(); }

      template<typename _Yp, typename = _Compatible<_Yp>>
 __weak_ptr(const __shared_ptr<_Yp, _Lp>& __r) noexcept
 : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
 { }

      __weak_ptr(__weak_ptr&& __r) noexcept
      : _M_ptr(__r._M_ptr), _M_refcount(std::move(__r._M_refcount))
      { __r._M_ptr = nullptr; }

      template<typename _Yp, typename = _Compatible<_Yp>>
 __weak_ptr(__weak_ptr<_Yp, _Lp>&& __r) noexcept
 : _M_ptr(__r.lock().get()), _M_refcount(std::move(__r._M_refcount))
        { __r._M_ptr = nullptr; }

      __weak_ptr&
      operator=(const __weak_ptr& __r) noexcept = default;

      template<typename _Yp>
 _Assignable<_Yp>
 operator=(const __weak_ptr<_Yp, _Lp>& __r) noexcept
 {
   _M_ptr = __r.lock().get();
   _M_refcount = __r._M_refcount;
   return *this;
 }

      template<typename _Yp>
 _Assignable<_Yp>
 operator=(const __shared_ptr<_Yp, _Lp>& __r) noexcept
 {
   _M_ptr = __r._M_ptr;
   _M_refcount = __r._M_refcount;
   return *this;
 }

      __weak_ptr&
      operator=(__weak_ptr&& __r) noexcept
      {
 _M_ptr = __r._M_ptr;
 _M_refcount = std::move(__r._M_refcount);
 __r._M_ptr = nullptr;
 return *this;
      }

      template<typename _Yp>
 _Assignable<_Yp>
 operator=(__weak_ptr<_Yp, _Lp>&& __r) noexcept
 {
   _M_ptr = __r.lock().get();
   _M_refcount = std::move(__r._M_refcount);
   __r._M_ptr = nullptr;
   return *this;
 }

      __shared_ptr<_Tp, _Lp>
      lock() const noexcept
      { return __shared_ptr<element_type, _Lp>(*this, std::nothrow); }

      long
      use_count() const noexcept
      { return _M_refcount._M_get_use_count(); }

      bool
      expired() const noexcept
      { return _M_refcount._M_get_use_count() == 0; }

      template<typename _Tp1>
 bool
 owner_before(const __shared_ptr<_Tp1, _Lp>& __rhs) const noexcept
 { return _M_refcount._M_less(__rhs._M_refcount); }

      template<typename _Tp1>
 bool
 owner_before(const __weak_ptr<_Tp1, _Lp>& __rhs) const noexcept
 { return _M_refcount._M_less(__rhs._M_refcount); }

      void
      reset() noexcept
      { __weak_ptr().swap(*this); }

      void
      swap(__weak_ptr& __s) noexcept
      {
 std::swap(_M_ptr, __s._M_ptr);
 _M_refcount._M_swap(__s._M_refcount);
      }

    private:

      void
      _M_assign(_Tp* __ptr, const __shared_count<_Lp>& __refcount) noexcept
      {
 if (use_count() == 0)
   {
     _M_ptr = __ptr;
     _M_refcount = __refcount;
   }
      }

      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;
      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;
      friend class __enable_shared_from_this<_Tp, _Lp>;
      friend class enable_shared_from_this<_Tp>;

      element_type* _M_ptr;
      __weak_count<_Lp> _M_refcount;
    };


  template<typename _Tp, _Lock_policy _Lp>
    inline void
    swap(__weak_ptr<_Tp, _Lp>& __a, __weak_ptr<_Tp, _Lp>& __b) noexcept
    { __a.swap(__b); }

  template<typename _Tp, typename _Tp1>
    struct _Sp_owner_less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __lhs, const _Tp& __rhs) const noexcept
      { return __lhs.owner_before(__rhs); }

      bool
      operator()(const _Tp& __lhs, const _Tp1& __rhs) const noexcept
      { return __lhs.owner_before(__rhs); }

      bool
      operator()(const _Tp1& __lhs, const _Tp& __rhs) const noexcept
      { return __lhs.owner_before(__rhs); }
    };

  template<>
    struct _Sp_owner_less<void, void>
    {
      template<typename _Tp, typename _Up>
 auto
 operator()(const _Tp& __lhs, const _Up& __rhs) const noexcept
 -> decltype(__lhs.owner_before(__rhs))
 { return __lhs.owner_before(__rhs); }

      using is_transparent = void;
    };

  template<typename _Tp, _Lock_policy _Lp>
    struct owner_less<__shared_ptr<_Tp, _Lp>>
    : public _Sp_owner_less<__shared_ptr<_Tp, _Lp>, __weak_ptr<_Tp, _Lp>>
    { };

  template<typename _Tp, _Lock_policy _Lp>
    struct owner_less<__weak_ptr<_Tp, _Lp>>
    : public _Sp_owner_less<__weak_ptr<_Tp, _Lp>, __shared_ptr<_Tp, _Lp>>
    { };


  template<typename _Tp, _Lock_policy _Lp>
    class __enable_shared_from_this
    {
    protected:
      constexpr __enable_shared_from_this() noexcept { }

      __enable_shared_from_this(const __enable_shared_from_this&) noexcept { }

      __enable_shared_from_this&
      operator=(const __enable_shared_from_this&) noexcept
      { return *this; }

      ~__enable_shared_from_this() { }

    public:
      __shared_ptr<_Tp, _Lp>
      shared_from_this()
      { return __shared_ptr<_Tp, _Lp>(this->_M_weak_this); }

      __shared_ptr<const _Tp, _Lp>
      shared_from_this() const
      { return __shared_ptr<const _Tp, _Lp>(this->_M_weak_this); }


      __weak_ptr<_Tp, _Lp>
      weak_from_this() noexcept
      { return this->_M_weak_this; }

      __weak_ptr<const _Tp, _Lp>
      weak_from_this() const noexcept
      { return this->_M_weak_this; }


    private:
      template<typename _Tp1>
 void
 _M_weak_assign(_Tp1* __p, const __shared_count<_Lp>& __n) const noexcept
 { _M_weak_this._M_assign(__p, __n); }

      friend const __enable_shared_from_this*
      __enable_shared_from_this_base(const __shared_count<_Lp>&,
         const __enable_shared_from_this* __p)
      { return __p; }

      template<typename, _Lock_policy>
 friend class __shared_ptr;

      mutable __weak_ptr<_Tp, _Lp> _M_weak_this;
    };

  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy,
    typename _Alloc, typename... _Args>
    inline __shared_ptr<_Tp, _Lp>
    __allocate_shared(const _Alloc& __a, _Args&&... __args)
    {
      return __shared_ptr<_Tp, _Lp>(_Sp_alloc_shared_tag<_Alloc>{__a},
        std::forward<_Args>(__args)...);
    }

  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy,
    typename... _Args>
    inline __shared_ptr<_Tp, _Lp>
    __make_shared(_Args&&... __args)
    {
      typedef typename std::remove_const<_Tp>::type _Tp_nc;
      return std::__allocate_shared<_Tp, _Lp>(std::allocator<_Tp_nc>(),
           std::forward<_Args>(__args)...);
    }


  template<typename _Tp, _Lock_policy _Lp>
    struct hash<__shared_ptr<_Tp, _Lp>>
    : public __hash_base<size_t, __shared_ptr<_Tp, _Lp>>
    {
      size_t
      operator()(const __shared_ptr<_Tp, _Lp>& __s) const noexcept
      {
 return hash<typename __shared_ptr<_Tp, _Lp>::element_type*>()(
     __s.get());
      }
    };


}
# 53 "/usr/local/include/c++/10.0.0/bits/shared_ptr.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 67 "/usr/local/include/c++/10.0.0/bits/shared_ptr.h" 3
  template<typename _Ch, typename _Tr, typename _Tp, _Lock_policy _Lp>
    inline std::basic_ostream<_Ch, _Tr>&
    operator<<(std::basic_ostream<_Ch, _Tr>& __os,
        const __shared_ptr<_Tp, _Lp>& __p)
    {
      __os << __p.get();
      return __os;
    }

  template<typename _Del, typename _Tp, _Lock_policy _Lp>
    inline _Del*
    get_deleter(const __shared_ptr<_Tp, _Lp>& __p) noexcept
    {

      return static_cast<_Del*>(__p._M_get_deleter(typeid(_Del)));



    }





  template<typename _Del, typename _Tp>
    inline _Del*
    get_deleter(const shared_ptr<_Tp>& __p) noexcept
    {

      return static_cast<_Del*>(__p._M_get_deleter(typeid(_Del)));



    }
# 120 "/usr/local/include/c++/10.0.0/bits/shared_ptr.h" 3
  template<typename _Tp>
    class shared_ptr : public __shared_ptr<_Tp>
    {
      template<typename... _Args>
 using _Constructible = typename enable_if<
   is_constructible<__shared_ptr<_Tp>, _Args...>::value
 >::type;

      template<typename _Arg>
 using _Assignable = typename enable_if<
   is_assignable<__shared_ptr<_Tp>&, _Arg>::value, shared_ptr&
 >::type;

    public:


      using element_type = typename __shared_ptr<_Tp>::element_type;




      using weak_type = weak_ptr<_Tp>;





      constexpr shared_ptr() noexcept : __shared_ptr<_Tp>() { }

      shared_ptr(const shared_ptr&) noexcept = default;







      template<typename _Yp, typename = _Constructible<_Yp*>>
 explicit
 shared_ptr(_Yp* __p) : __shared_ptr<_Tp>(__p) { }
# 174 "/usr/local/include/c++/10.0.0/bits/shared_ptr.h" 3
      template<typename _Yp, typename _Deleter,
        typename = _Constructible<_Yp*, _Deleter>>
 shared_ptr(_Yp* __p, _Deleter __d)
        : __shared_ptr<_Tp>(__p, std::move(__d)) { }
# 192 "/usr/local/include/c++/10.0.0/bits/shared_ptr.h" 3
      template<typename _Deleter>
 shared_ptr(nullptr_t __p, _Deleter __d)
        : __shared_ptr<_Tp>(__p, std::move(__d)) { }
# 211 "/usr/local/include/c++/10.0.0/bits/shared_ptr.h" 3
      template<typename _Yp, typename _Deleter, typename _Alloc,
        typename = _Constructible<_Yp*, _Deleter, _Alloc>>
 shared_ptr(_Yp* __p, _Deleter __d, _Alloc __a)
 : __shared_ptr<_Tp>(__p, std::move(__d), std::move(__a)) { }
# 231 "/usr/local/include/c++/10.0.0/bits/shared_ptr.h" 3
      template<typename _Deleter, typename _Alloc>
 shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)
 : __shared_ptr<_Tp>(__p, std::move(__d), std::move(__a)) { }
# 255 "/usr/local/include/c++/10.0.0/bits/shared_ptr.h" 3
      template<typename _Yp>
 shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) noexcept
 : __shared_ptr<_Tp>(__r, __p) { }
# 282 "/usr/local/include/c++/10.0.0/bits/shared_ptr.h" 3
      template<typename _Yp>
 shared_ptr(shared_ptr<_Yp>&& __r, element_type* __p) noexcept
 : __shared_ptr<_Tp>(std::move(__r), __p) { }
# 293 "/usr/local/include/c++/10.0.0/bits/shared_ptr.h" 3
      template<typename _Yp,
        typename = _Constructible<const shared_ptr<_Yp>&>>
 shared_ptr(const shared_ptr<_Yp>& __r) noexcept
        : __shared_ptr<_Tp>(__r) { }






      shared_ptr(shared_ptr&& __r) noexcept
      : __shared_ptr<_Tp>(std::move(__r)) { }






      template<typename _Yp, typename = _Constructible<shared_ptr<_Yp>>>
 shared_ptr(shared_ptr<_Yp>&& __r) noexcept
 : __shared_ptr<_Tp>(std::move(__r)) { }
# 323 "/usr/local/include/c++/10.0.0/bits/shared_ptr.h" 3
      template<typename _Yp, typename = _Constructible<const weak_ptr<_Yp>&>>
 explicit shared_ptr(const weak_ptr<_Yp>& __r)
 : __shared_ptr<_Tp>(__r) { }


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
      template<typename _Yp, typename = _Constructible<auto_ptr<_Yp>>>
 shared_ptr(auto_ptr<_Yp>&& __r);
#pragma GCC diagnostic pop




      template<typename _Yp, typename _Del,
        typename = _Constructible<unique_ptr<_Yp, _Del>>>
 shared_ptr(unique_ptr<_Yp, _Del>&& __r)
 : __shared_ptr<_Tp>(std::move(__r)) { }
# 356 "/usr/local/include/c++/10.0.0/bits/shared_ptr.h" 3
      constexpr shared_ptr(nullptr_t) noexcept : shared_ptr() { }

      shared_ptr& operator=(const shared_ptr&) noexcept = default;

      template<typename _Yp>
 _Assignable<const shared_ptr<_Yp>&>
 operator=(const shared_ptr<_Yp>& __r) noexcept
 {
   this->__shared_ptr<_Tp>::operator=(__r);
   return *this;
 }


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
      template<typename _Yp>
 _Assignable<auto_ptr<_Yp>>
 operator=(auto_ptr<_Yp>&& __r)
 {
   this->__shared_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }
#pragma GCC diagnostic pop


      shared_ptr&
      operator=(shared_ptr&& __r) noexcept
      {
 this->__shared_ptr<_Tp>::operator=(std::move(__r));
 return *this;
      }

      template<class _Yp>
 _Assignable<shared_ptr<_Yp>>
 operator=(shared_ptr<_Yp>&& __r) noexcept
 {
   this->__shared_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }

      template<typename _Yp, typename _Del>
 _Assignable<unique_ptr<_Yp, _Del>>
 operator=(unique_ptr<_Yp, _Del>&& __r)
 {
   this->__shared_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }

    private:

      template<typename _Alloc, typename... _Args>
 shared_ptr(_Sp_alloc_shared_tag<_Alloc> __tag, _Args&&... __args)
 : __shared_ptr<_Tp>(__tag, std::forward<_Args>(__args)...)
 { }

      template<typename _Yp, typename _Alloc, typename... _Args>
 friend shared_ptr<_Yp>
 allocate_shared(const _Alloc& __a, _Args&&... __args);


      shared_ptr(const weak_ptr<_Tp>& __r, std::nothrow_t)
      : __shared_ptr<_Tp>(__r, std::nothrow) { }

      friend class weak_ptr<_Tp>;
    };


  template<typename _Tp>
    shared_ptr(weak_ptr<_Tp>) -> shared_ptr<_Tp>;
  template<typename _Tp, typename _Del>
    shared_ptr(unique_ptr<_Tp, _Del>) -> shared_ptr<_Tp>;







  template<typename _Tp, typename _Up>
    [[__nodiscard__]] inline bool
    operator==(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    { return __a.get() == __b.get(); }


  template<typename _Tp>
    [[__nodiscard__]] inline bool
    operator==(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return !__a; }


  template<typename _Tp>
    [[__nodiscard__]] inline bool
    operator==(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return !__a; }


  template<typename _Tp, typename _Up>
    [[__nodiscard__]] inline bool
    operator!=(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    { return __a.get() != __b.get(); }


  template<typename _Tp>
    [[__nodiscard__]] inline bool
    operator!=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return (bool)__a; }


  template<typename _Tp>
    [[__nodiscard__]] inline bool
    operator!=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return (bool)__a; }


  template<typename _Tp, typename _Up>
    [[__nodiscard__]] inline bool
    operator<(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    {
      using _Tp_elt = typename shared_ptr<_Tp>::element_type;
      using _Up_elt = typename shared_ptr<_Up>::element_type;
      using _Vp = typename common_type<_Tp_elt*, _Up_elt*>::type;
      return less<_Vp>()(__a.get(), __b.get());
    }


  template<typename _Tp>
    [[__nodiscard__]] inline bool
    operator<(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    {
      using _Tp_elt = typename shared_ptr<_Tp>::element_type;
      return less<_Tp_elt*>()(__a.get(), nullptr);
    }


  template<typename _Tp>
    [[__nodiscard__]] inline bool
    operator<(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    {
      using _Tp_elt = typename shared_ptr<_Tp>::element_type;
      return less<_Tp_elt*>()(nullptr, __a.get());
    }


  template<typename _Tp, typename _Up>
    [[__nodiscard__]] inline bool
    operator<=(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    { return !(__b < __a); }


  template<typename _Tp>
    [[__nodiscard__]] inline bool
    operator<=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return !(nullptr < __a); }


  template<typename _Tp>
    [[__nodiscard__]] inline bool
    operator<=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return !(__a < nullptr); }


  template<typename _Tp, typename _Up>
    [[__nodiscard__]] inline bool
    operator>(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    { return (__b < __a); }


  template<typename _Tp>
    [[__nodiscard__]] inline bool
    operator>(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return nullptr < __a; }


  template<typename _Tp>
    [[__nodiscard__]] inline bool
    operator>(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return __a < nullptr; }


  template<typename _Tp, typename _Up>
    [[__nodiscard__]] inline bool
    operator>=(const shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept
    { return !(__a < __b); }


  template<typename _Tp>
    [[__nodiscard__]] inline bool
    operator>=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return !(__a < nullptr); }


  template<typename _Tp>
    [[__nodiscard__]] inline bool
    operator>=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return !(nullptr < __a); }




  template<typename _Tp>
    inline void
    swap(shared_ptr<_Tp>& __a, shared_ptr<_Tp>& __b) noexcept
    { __a.swap(__b); }




  template<typename _Tp, typename _Up>
    inline shared_ptr<_Tp>
    static_pointer_cast(const shared_ptr<_Up>& __r) noexcept
    {
      using _Sp = shared_ptr<_Tp>;
      return _Sp(__r, static_cast<typename _Sp::element_type*>(__r.get()));
    }


  template<typename _Tp, typename _Up>
    inline shared_ptr<_Tp>
    const_pointer_cast(const shared_ptr<_Up>& __r) noexcept
    {
      using _Sp = shared_ptr<_Tp>;
      return _Sp(__r, const_cast<typename _Sp::element_type*>(__r.get()));
    }


  template<typename _Tp, typename _Up>
    inline shared_ptr<_Tp>
    dynamic_pointer_cast(const shared_ptr<_Up>& __r) noexcept
    {
      using _Sp = shared_ptr<_Tp>;
      if (auto* __p = dynamic_cast<typename _Sp::element_type*>(__r.get()))
 return _Sp(__r, __p);
      return _Sp();
    }



  template<typename _Tp, typename _Up>
    inline shared_ptr<_Tp>
    reinterpret_pointer_cast(const shared_ptr<_Up>& __r) noexcept
    {
      using _Sp = shared_ptr<_Tp>;
      return _Sp(__r, reinterpret_cast<typename _Sp::element_type*>(__r.get()));
    }






  template<typename _Tp, typename _Up>
    inline shared_ptr<_Tp>
    static_pointer_cast(shared_ptr<_Up>&& __r) noexcept
    {
      using _Sp = shared_ptr<_Tp>;
      return _Sp(std::move(__r),
   static_cast<typename _Sp::element_type*>(__r.get()));
    }


  template<typename _Tp, typename _Up>
    inline shared_ptr<_Tp>
    const_pointer_cast(shared_ptr<_Up>&& __r) noexcept
    {
      using _Sp = shared_ptr<_Tp>;
      return _Sp(std::move(__r),
   const_cast<typename _Sp::element_type*>(__r.get()));
    }


  template<typename _Tp, typename _Up>
    inline shared_ptr<_Tp>
    dynamic_pointer_cast(shared_ptr<_Up>&& __r) noexcept
    {
      using _Sp = shared_ptr<_Tp>;
      if (auto* __p = dynamic_cast<typename _Sp::element_type*>(__r.get()))
 return _Sp(std::move(__r), __p);
      return _Sp();
    }


  template<typename _Tp, typename _Up>
    inline shared_ptr<_Tp>
    reinterpret_pointer_cast(shared_ptr<_Up>&& __r) noexcept
    {
      using _Sp = shared_ptr<_Tp>;
      return _Sp(std::move(__r),
   reinterpret_cast<typename _Sp::element_type*>(__r.get()));
    }
# 668 "/usr/local/include/c++/10.0.0/bits/shared_ptr.h" 3
  template<typename _Tp>
    class weak_ptr : public __weak_ptr<_Tp>
    {
      template<typename _Arg>
 using _Constructible = typename enable_if<
   is_constructible<__weak_ptr<_Tp>, _Arg>::value
 >::type;

      template<typename _Arg>
 using _Assignable = typename enable_if<
   is_assignable<__weak_ptr<_Tp>&, _Arg>::value, weak_ptr&
 >::type;

    public:
      constexpr weak_ptr() noexcept = default;

      template<typename _Yp,
        typename = _Constructible<const shared_ptr<_Yp>&>>
 weak_ptr(const shared_ptr<_Yp>& __r) noexcept
 : __weak_ptr<_Tp>(__r) { }

      weak_ptr(const weak_ptr&) noexcept = default;

      template<typename _Yp, typename = _Constructible<const weak_ptr<_Yp>&>>
 weak_ptr(const weak_ptr<_Yp>& __r) noexcept
 : __weak_ptr<_Tp>(__r) { }

      weak_ptr(weak_ptr&&) noexcept = default;

      template<typename _Yp, typename = _Constructible<weak_ptr<_Yp>>>
 weak_ptr(weak_ptr<_Yp>&& __r) noexcept
 : __weak_ptr<_Tp>(std::move(__r)) { }

      weak_ptr&
      operator=(const weak_ptr& __r) noexcept = default;

      template<typename _Yp>
 _Assignable<const weak_ptr<_Yp>&>
 operator=(const weak_ptr<_Yp>& __r) noexcept
 {
   this->__weak_ptr<_Tp>::operator=(__r);
   return *this;
 }

      template<typename _Yp>
 _Assignable<const shared_ptr<_Yp>&>
 operator=(const shared_ptr<_Yp>& __r) noexcept
 {
   this->__weak_ptr<_Tp>::operator=(__r);
   return *this;
 }

      weak_ptr&
      operator=(weak_ptr&& __r) noexcept = default;

      template<typename _Yp>
 _Assignable<weak_ptr<_Yp>>
 operator=(weak_ptr<_Yp>&& __r) noexcept
 {
   this->__weak_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }

      shared_ptr<_Tp>
      lock() const noexcept
      { return shared_ptr<_Tp>(*this, std::nothrow); }
    };


  template<typename _Tp>
    weak_ptr(shared_ptr<_Tp>) -> weak_ptr<_Tp>;





  template<typename _Tp>
    inline void
    swap(weak_ptr<_Tp>& __a, weak_ptr<_Tp>& __b) noexcept
    { __a.swap(__b); }



  template<typename _Tp = void>
    struct owner_less;


  template<>
    struct owner_less<void> : _Sp_owner_less<void, void>
    { };


  template<typename _Tp>
    struct owner_less<shared_ptr<_Tp>>
    : public _Sp_owner_less<shared_ptr<_Tp>, weak_ptr<_Tp>>
    { };


  template<typename _Tp>
    struct owner_less<weak_ptr<_Tp>>
    : public _Sp_owner_less<weak_ptr<_Tp>, shared_ptr<_Tp>>
    { };




  template<typename _Tp>
    class enable_shared_from_this
    {
    protected:
      constexpr enable_shared_from_this() noexcept { }

      enable_shared_from_this(const enable_shared_from_this&) noexcept { }

      enable_shared_from_this&
      operator=(const enable_shared_from_this&) noexcept
      { return *this; }

      ~enable_shared_from_this() { }

    public:
      shared_ptr<_Tp>
      shared_from_this()
      { return shared_ptr<_Tp>(this->_M_weak_this); }

      shared_ptr<const _Tp>
      shared_from_this() const
      { return shared_ptr<const _Tp>(this->_M_weak_this); }



      weak_ptr<_Tp>
      weak_from_this() noexcept
      { return this->_M_weak_this; }

      weak_ptr<const _Tp>
      weak_from_this() const noexcept
      { return this->_M_weak_this; }


    private:
      template<typename _Tp1>
 void
 _M_weak_assign(_Tp1* __p, const __shared_count<>& __n) const noexcept
 { _M_weak_this._M_assign(__p, __n); }


      friend const enable_shared_from_this*
      __enable_shared_from_this_base(const __shared_count<>&,
         const enable_shared_from_this* __p)
      { return __p; }

      template<typename, _Lock_policy>
 friend class __shared_ptr;

      mutable weak_ptr<_Tp> _M_weak_this;
    };
# 839 "/usr/local/include/c++/10.0.0/bits/shared_ptr.h" 3
  template<typename _Tp, typename _Alloc, typename... _Args>
    inline shared_ptr<_Tp>
    allocate_shared(const _Alloc& __a, _Args&&... __args)
    {
      return shared_ptr<_Tp>(_Sp_alloc_shared_tag<_Alloc>{__a},
        std::forward<_Args>(__args)...);
    }
# 854 "/usr/local/include/c++/10.0.0/bits/shared_ptr.h" 3
  template<typename _Tp, typename... _Args>
    inline shared_ptr<_Tp>
    make_shared(_Args&&... __args)
    {
      typedef typename std::remove_cv<_Tp>::type _Tp_nc;
      return std::allocate_shared<_Tp>(std::allocator<_Tp_nc>(),
           std::forward<_Args>(__args)...);
    }


  template<typename _Tp>
    struct hash<shared_ptr<_Tp>>
    : public __hash_base<size_t, shared_ptr<_Tp>>
    {
      size_t
      operator()(const shared_ptr<_Tp>& __s) const noexcept
      {
 return std::hash<typename shared_ptr<_Tp>::element_type*>()(__s.get());
      }
    };





  namespace __detail::__variant
  {
    template<typename> struct _Never_valueless_alt;



    template<typename _Tp>
      struct _Never_valueless_alt<std::shared_ptr<_Tp>>
      : std::true_type
      { };



    template<typename _Tp>
      struct _Never_valueless_alt<std::weak_ptr<_Tp>>
      : std::true_type
      { };
  }



}
# 84 "/usr/local/include/c++/10.0.0/memory" 2 3
# 1 "/usr/local/include/c++/10.0.0/bits/shared_ptr_atomic.h" 1 3
# 33 "/usr/local/include/c++/10.0.0/bits/shared_ptr_atomic.h" 3
# 1 "/usr/local/include/c++/10.0.0/bits/atomic_base.h" 1 3
# 33 "/usr/local/include/c++/10.0.0/bits/atomic_base.h" 3
       
# 34 "/usr/local/include/c++/10.0.0/bits/atomic_base.h" 3



# 1 "/usr/local/include/c++/10.0.0/bits/atomic_lockfree_defines.h" 1 3
# 33 "/usr/local/include/c++/10.0.0/bits/atomic_lockfree_defines.h" 3
       
# 34 "/usr/local/include/c++/10.0.0/bits/atomic_lockfree_defines.h" 3
# 38 "/usr/local/include/c++/10.0.0/bits/atomic_base.h" 2 3






namespace std __attribute__ ((__visibility__ ("default")))
{

# 57 "/usr/local/include/c++/10.0.0/bits/atomic_base.h" 3
  enum class memory_order : int
    {
      relaxed,
      consume,
      acquire,
      release,
      acq_rel,
      seq_cst
    };

  inline constexpr memory_order memory_order_relaxed = memory_order::relaxed;
  inline constexpr memory_order memory_order_consume = memory_order::consume;
  inline constexpr memory_order memory_order_acquire = memory_order::acquire;
  inline constexpr memory_order memory_order_release = memory_order::release;
  inline constexpr memory_order memory_order_acq_rel = memory_order::acq_rel;
  inline constexpr memory_order memory_order_seq_cst = memory_order::seq_cst;
# 85 "/usr/local/include/c++/10.0.0/bits/atomic_base.h" 3
  enum __memory_order_modifier
    {
      __memory_order_mask = 0x0ffff,
      __memory_order_modifier_mask = 0xffff0000,
      __memory_order_hle_acquire = 0x10000,
      __memory_order_hle_release = 0x20000
    };

  constexpr memory_order
  operator|(memory_order __m, __memory_order_modifier __mod)
  {
    return memory_order(int(__m) | int(__mod));
  }

  constexpr memory_order
  operator&(memory_order __m, __memory_order_modifier __mod)
  {
    return memory_order(int(__m) & int(__mod));
  }


  constexpr memory_order
  __cmpexch_failure_order2(memory_order __m) noexcept
  {
    return __m == memory_order_acq_rel ? memory_order_acquire
      : __m == memory_order_release ? memory_order_relaxed : __m;
  }

  constexpr memory_order
  __cmpexch_failure_order(memory_order __m) noexcept
  {
    return memory_order(__cmpexch_failure_order2(__m & __memory_order_mask)
      | __memory_order_modifier(__m & __memory_order_modifier_mask));
  }

  inline __attribute__((__always_inline__)) void
  atomic_thread_fence(memory_order __m) noexcept
  { __atomic_thread_fence(int(__m)); }

  inline __attribute__((__always_inline__)) void
  atomic_signal_fence(memory_order __m) noexcept
  { __atomic_signal_fence(int(__m)); }


  template<typename _Tp>
    inline _Tp
    kill_dependency(_Tp __y) noexcept
    {
      _Tp __ret(__y);
      return __ret;
    }



  template<typename _IntTp>
    struct __atomic_base;




  template<typename _Tp>
    struct atomic;

  template<typename _Tp>
    struct atomic<_Tp*>;



    typedef bool __atomic_flag_data_type;
# 168 "/usr/local/include/c++/10.0.0/bits/atomic_base.h" 3
  extern "C" {

  struct __atomic_flag_base
  {
    __atomic_flag_data_type _M_i;
  };

  }




  struct atomic_flag : public __atomic_flag_base
  {
    atomic_flag() noexcept = default;
    ~atomic_flag() noexcept = default;
    atomic_flag(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) volatile = delete;


    constexpr atomic_flag(bool __i) noexcept
      : __atomic_flag_base{ _S_init(__i) }
    { }

    inline __attribute__((__always_inline__)) bool
    test_and_set(memory_order __m = memory_order_seq_cst) noexcept
    {
      return __atomic_test_and_set (&_M_i, int(__m));
    }

    inline __attribute__((__always_inline__)) bool
    test_and_set(memory_order __m = memory_order_seq_cst) volatile noexcept
    {
      return __atomic_test_and_set (&_M_i, int(__m));
    }

    inline __attribute__((__always_inline__)) void
    clear(memory_order __m = memory_order_seq_cst) noexcept
    {
      memory_order __b = __m & __memory_order_mask;
      ;
      ;
      ;

      __atomic_clear (&_M_i, int(__m));
    }

    inline __attribute__((__always_inline__)) void
    clear(memory_order __m = memory_order_seq_cst) volatile noexcept
    {
      memory_order __b = __m & __memory_order_mask;
      ;
      ;
      ;

      __atomic_clear (&_M_i, int(__m));
    }

  private:
    static constexpr __atomic_flag_data_type
    _S_init(bool __i)
    { return __i ? 1 : 0; }
  };
# 258 "/usr/local/include/c++/10.0.0/bits/atomic_base.h" 3
  template<typename _ITp>
    struct __atomic_base
    {
      using value_type = _ITp;
      using difference_type = value_type;

    private:
      typedef _ITp __int_type;

      static constexpr int _S_alignment =
 sizeof(_ITp) > alignof(_ITp) ? sizeof(_ITp) : alignof(_ITp);

      alignas(_S_alignment) __int_type _M_i;

    public:
      __atomic_base() noexcept = default;
      ~__atomic_base() noexcept = default;
      __atomic_base(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) volatile = delete;


      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }

      operator __int_type() const noexcept
      { return load(); }

      operator __int_type() const volatile noexcept
      { return load(); }

      __int_type
      operator=(__int_type __i) noexcept
      {
 store(__i);
 return __i;
      }

      __int_type
      operator=(__int_type __i) volatile noexcept
      {
 store(__i);
 return __i;
      }

      __int_type
      operator++(int) noexcept
      { return fetch_add(1); }

      __int_type
      operator++(int) volatile noexcept
      { return fetch_add(1); }

      __int_type
      operator--(int) noexcept
      { return fetch_sub(1); }

      __int_type
      operator--(int) volatile noexcept
      { return fetch_sub(1); }

      __int_type
      operator++() noexcept
      { return __atomic_add_fetch(&_M_i, 1, int(memory_order_seq_cst)); }

      __int_type
      operator++() volatile noexcept
      { return __atomic_add_fetch(&_M_i, 1, int(memory_order_seq_cst)); }

      __int_type
      operator--() noexcept
      { return __atomic_sub_fetch(&_M_i, 1, int(memory_order_seq_cst)); }

      __int_type
      operator--() volatile noexcept
      { return __atomic_sub_fetch(&_M_i, 1, int(memory_order_seq_cst)); }

      __int_type
      operator+=(__int_type __i) noexcept
      { return __atomic_add_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator+=(__int_type __i) volatile noexcept
      { return __atomic_add_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator-=(__int_type __i) noexcept
      { return __atomic_sub_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator-=(__int_type __i) volatile noexcept
      { return __atomic_sub_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator&=(__int_type __i) noexcept
      { return __atomic_and_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator&=(__int_type __i) volatile noexcept
      { return __atomic_and_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator|=(__int_type __i) noexcept
      { return __atomic_or_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator|=(__int_type __i) volatile noexcept
      { return __atomic_or_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator^=(__int_type __i) noexcept
      { return __atomic_xor_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      __int_type
      operator^=(__int_type __i) volatile noexcept
      { return __atomic_xor_fetch(&_M_i, __i, int(memory_order_seq_cst)); }

      bool
      is_lock_free() const noexcept
      {

 return __atomic_is_lock_free(sizeof(_M_i),
     reinterpret_cast<void *>(-_S_alignment));
      }

      bool
      is_lock_free() const volatile noexcept
      {

 return __atomic_is_lock_free(sizeof(_M_i),
     reinterpret_cast<void *>(-_S_alignment));
      }

      inline __attribute__((__always_inline__)) void
      store(__int_type __i, memory_order __m = memory_order_seq_cst) noexcept
      {
 memory_order __b = __m & __memory_order_mask;
 ;
 ;
 ;

 __atomic_store_n(&_M_i, __i, int(__m));
      }

      inline __attribute__((__always_inline__)) void
      store(__int_type __i,
     memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 memory_order __b = __m & __memory_order_mask;
 ;
 ;
 ;

 __atomic_store_n(&_M_i, __i, int(__m));
      }

      inline __attribute__((__always_inline__)) __int_type
      load(memory_order __m = memory_order_seq_cst) const noexcept
      {
 memory_order __b = __m & __memory_order_mask;
 ;
 ;

 return __atomic_load_n(&_M_i, int(__m));
      }

      inline __attribute__((__always_inline__)) __int_type
      load(memory_order __m = memory_order_seq_cst) const volatile noexcept
      {
 memory_order __b = __m & __memory_order_mask;
 ;
 ;

 return __atomic_load_n(&_M_i, int(__m));
      }

      inline __attribute__((__always_inline__)) __int_type
      exchange(__int_type __i,
        memory_order __m = memory_order_seq_cst) noexcept
      {
 return __atomic_exchange_n(&_M_i, __i, int(__m));
      }


      inline __attribute__((__always_inline__)) __int_type
      exchange(__int_type __i,
        memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 return __atomic_exchange_n(&_M_i, __i, int(__m));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_weak(__int_type& __i1, __int_type __i2,
       memory_order __m1, memory_order __m2) noexcept
      {
 memory_order __b2 = __m2 & __memory_order_mask;
 memory_order __b1 = __m1 & __memory_order_mask;
 ;
 ;
 ;

 return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1,
        int(__m1), int(__m2));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_weak(__int_type& __i1, __int_type __i2,
       memory_order __m1,
       memory_order __m2) volatile noexcept
      {
 memory_order __b2 = __m2 & __memory_order_mask;
 memory_order __b1 = __m1 & __memory_order_mask;
 ;
 ;
 ;

 return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1,
        int(__m1), int(__m2));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_weak(__int_type& __i1, __int_type __i2,
       memory_order __m = memory_order_seq_cst) noexcept
      {
 return compare_exchange_weak(__i1, __i2, __m,
         __cmpexch_failure_order(__m));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_weak(__int_type& __i1, __int_type __i2,
     memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 return compare_exchange_weak(__i1, __i2, __m,
         __cmpexch_failure_order(__m));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__int_type& __i1, __int_type __i2,
         memory_order __m1, memory_order __m2) noexcept
      {
 memory_order __b2 = __m2 & __memory_order_mask;
 memory_order __b1 = __m1 & __memory_order_mask;
 ;
 ;
 ;

 return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0,
        int(__m1), int(__m2));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__int_type& __i1, __int_type __i2,
         memory_order __m1,
         memory_order __m2) volatile noexcept
      {
 memory_order __b2 = __m2 & __memory_order_mask;
 memory_order __b1 = __m1 & __memory_order_mask;

 ;
 ;
 ;

 return __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0,
        int(__m1), int(__m2));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__int_type& __i1, __int_type __i2,
         memory_order __m = memory_order_seq_cst) noexcept
      {
 return compare_exchange_strong(__i1, __i2, __m,
           __cmpexch_failure_order(__m));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__int_type& __i1, __int_type __i2,
   memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 return compare_exchange_strong(__i1, __i2, __m,
           __cmpexch_failure_order(__m));
      }

      inline __attribute__((__always_inline__)) __int_type
      fetch_add(__int_type __i,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_add(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_add(__int_type __i,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_add(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_sub(__int_type __i,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_sub(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_sub(__int_type __i,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_sub(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_and(__int_type __i,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_and(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_and(__int_type __i,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_and(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_or(__int_type __i,
        memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_or(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_or(__int_type __i,
        memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_or(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_xor(__int_type __i,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_xor(&_M_i, __i, int(__m)); }

      inline __attribute__((__always_inline__)) __int_type
      fetch_xor(__int_type __i,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_xor(&_M_i, __i, int(__m)); }
    };



  template<typename _PTp>
    struct __atomic_base<_PTp*>
    {
    private:
      typedef _PTp* __pointer_type;

      __pointer_type _M_p;


      constexpr ptrdiff_t
      _M_type_size(ptrdiff_t __d) const { return __d * sizeof(_PTp); }

      constexpr ptrdiff_t
      _M_type_size(ptrdiff_t __d) const volatile { return __d * sizeof(_PTp); }

    public:
      __atomic_base() noexcept = default;
      ~__atomic_base() noexcept = default;
      __atomic_base(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) volatile = delete;


      constexpr __atomic_base(__pointer_type __p) noexcept : _M_p (__p) { }

      operator __pointer_type() const noexcept
      { return load(); }

      operator __pointer_type() const volatile noexcept
      { return load(); }

      __pointer_type
      operator=(__pointer_type __p) noexcept
      {
 store(__p);
 return __p;
      }

      __pointer_type
      operator=(__pointer_type __p) volatile noexcept
      {
 store(__p);
 return __p;
      }

      __pointer_type
      operator++(int) noexcept
      { return fetch_add(1); }

      __pointer_type
      operator++(int) volatile noexcept
      { return fetch_add(1); }

      __pointer_type
      operator--(int) noexcept
      { return fetch_sub(1); }

      __pointer_type
      operator--(int) volatile noexcept
      { return fetch_sub(1); }

      __pointer_type
      operator++() noexcept
      { return __atomic_add_fetch(&_M_p, _M_type_size(1),
      int(memory_order_seq_cst)); }

      __pointer_type
      operator++() volatile noexcept
      { return __atomic_add_fetch(&_M_p, _M_type_size(1),
      int(memory_order_seq_cst)); }

      __pointer_type
      operator--() noexcept
      { return __atomic_sub_fetch(&_M_p, _M_type_size(1),
      int(memory_order_seq_cst)); }

      __pointer_type
      operator--() volatile noexcept
      { return __atomic_sub_fetch(&_M_p, _M_type_size(1),
      int(memory_order_seq_cst)); }

      __pointer_type
      operator+=(ptrdiff_t __d) noexcept
      { return __atomic_add_fetch(&_M_p, _M_type_size(__d),
      int(memory_order_seq_cst)); }

      __pointer_type
      operator+=(ptrdiff_t __d) volatile noexcept
      { return __atomic_add_fetch(&_M_p, _M_type_size(__d),
      int(memory_order_seq_cst)); }

      __pointer_type
      operator-=(ptrdiff_t __d) noexcept
      { return __atomic_sub_fetch(&_M_p, _M_type_size(__d),
      int(memory_order_seq_cst)); }

      __pointer_type
      operator-=(ptrdiff_t __d) volatile noexcept
      { return __atomic_sub_fetch(&_M_p, _M_type_size(__d),
      int(memory_order_seq_cst)); }

      bool
      is_lock_free() const noexcept
      {

 return __atomic_is_lock_free(sizeof(_M_p),
     reinterpret_cast<void *>(-__alignof(_M_p)));
      }

      bool
      is_lock_free() const volatile noexcept
      {

 return __atomic_is_lock_free(sizeof(_M_p),
     reinterpret_cast<void *>(-__alignof(_M_p)));
      }

      inline __attribute__((__always_inline__)) void
      store(__pointer_type __p,
     memory_order __m = memory_order_seq_cst) noexcept
      {
        memory_order __b = __m & __memory_order_mask;

 ;
 ;
 ;

 __atomic_store_n(&_M_p, __p, int(__m));
      }

      inline __attribute__((__always_inline__)) void
      store(__pointer_type __p,
     memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 memory_order __b = __m & __memory_order_mask;
 ;
 ;
 ;

 __atomic_store_n(&_M_p, __p, int(__m));
      }

      inline __attribute__((__always_inline__)) __pointer_type
      load(memory_order __m = memory_order_seq_cst) const noexcept
      {
 memory_order __b = __m & __memory_order_mask;
 ;
 ;

 return __atomic_load_n(&_M_p, int(__m));
      }

      inline __attribute__((__always_inline__)) __pointer_type
      load(memory_order __m = memory_order_seq_cst) const volatile noexcept
      {
 memory_order __b = __m & __memory_order_mask;
 ;
 ;

 return __atomic_load_n(&_M_p, int(__m));
      }

      inline __attribute__((__always_inline__)) __pointer_type
      exchange(__pointer_type __p,
        memory_order __m = memory_order_seq_cst) noexcept
      {
 return __atomic_exchange_n(&_M_p, __p, int(__m));
      }


      inline __attribute__((__always_inline__)) __pointer_type
      exchange(__pointer_type __p,
        memory_order __m = memory_order_seq_cst) volatile noexcept
      {
 return __atomic_exchange_n(&_M_p, __p, int(__m));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
         memory_order __m1,
         memory_order __m2) noexcept
      {
 memory_order __b2 = __m2 & __memory_order_mask;
 memory_order __b1 = __m1 & __memory_order_mask;
 ;
 ;
 ;

 return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0,
        int(__m1), int(__m2));
      }

      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
         memory_order __m1,
         memory_order __m2) volatile noexcept
      {
 memory_order __b2 = __m2 & __memory_order_mask;
 memory_order __b1 = __m1 & __memory_order_mask;

 ;
 ;
 ;

 return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0,
        int(__m1), int(__m2));
      }

      inline __attribute__((__always_inline__)) __pointer_type
      fetch_add(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_add(&_M_p, _M_type_size(__d), int(__m)); }

      inline __attribute__((__always_inline__)) __pointer_type
      fetch_add(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_add(&_M_p, _M_type_size(__d), int(__m)); }

      inline __attribute__((__always_inline__)) __pointer_type
      fetch_sub(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_fetch_sub(&_M_p, _M_type_size(__d), int(__m)); }

      inline __attribute__((__always_inline__)) __pointer_type
      fetch_sub(ptrdiff_t __d,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_fetch_sub(&_M_p, _M_type_size(__d), int(__m)); }
    };



  namespace __atomic_impl
  {

    template<typename _Tp>
      using _Val = remove_volatile_t<_Tp>;


    template<typename _Tp>
      using _Diff = conditional_t<is_pointer_v<_Tp>, ptrdiff_t, _Val<_Tp>>;

    template<size_t _Size, size_t _Align>
      inline __attribute__((__always_inline__)) bool
      is_lock_free() noexcept
      {

 return __atomic_is_lock_free(_Size, reinterpret_cast<void *>(-_Align));
      }

    template<typename _Tp>
      inline __attribute__((__always_inline__)) void
      store(_Tp* __ptr, _Val<_Tp> __t, memory_order __m) noexcept
      { __atomic_store(__ptr, std::__addressof(__t), int(__m)); }

    template<typename _Tp>
      inline __attribute__((__always_inline__)) _Tp
      load(_Tp* __ptr, memory_order __m) noexcept
      {
 alignas(_Tp) unsigned char __buf[sizeof(_Tp)];
 _Tp* __dest = reinterpret_cast<_Tp*>(__buf);
 __atomic_load(__ptr, __dest, int(__m));
 return *__dest;
      }

    template<typename _Tp>
      inline __attribute__((__always_inline__)) _Tp
      exchange(_Tp* __ptr, _Val<_Tp> __desired, memory_order __m) noexcept
      {
        alignas(_Tp) unsigned char __buf[sizeof(_Tp)];
 _Tp* __dest = reinterpret_cast<_Tp*>(__buf);
 __atomic_exchange(__ptr, std::__addressof(__desired), __dest, int(__m));
 return *__dest;
      }

    template<typename _Tp>
      inline __attribute__((__always_inline__)) bool
      compare_exchange_weak(_Tp* __ptr, _Val<_Tp>& __expected,
       _Val<_Tp> __desired, memory_order __success,
       memory_order __failure) noexcept
      {
 return __atomic_compare_exchange(__ptr, std::__addressof(__expected),
      std::__addressof(__desired), true,
      int(__success), int(__failure));
      }

    template<typename _Tp>
      inline __attribute__((__always_inline__)) bool
      compare_exchange_strong(_Tp* __ptr, _Val<_Tp>& __expected,
         _Val<_Tp> __desired, memory_order __success,
         memory_order __failure) noexcept
      {
 return __atomic_compare_exchange(__ptr, std::__addressof(__expected),
      std::__addressof(__desired), false,
      int(__success), int(__failure));
      }

    template<typename _Tp>
      inline __attribute__((__always_inline__)) _Tp
      fetch_add(_Tp* __ptr, _Diff<_Tp> __i, memory_order __m) noexcept
      { return __atomic_fetch_add(__ptr, __i, int(__m)); }

    template<typename _Tp>
      inline __attribute__((__always_inline__)) _Tp
      fetch_sub(_Tp* __ptr, _Diff<_Tp> __i, memory_order __m) noexcept
      { return __atomic_fetch_sub(__ptr, __i, int(__m)); }

    template<typename _Tp>
      inline __attribute__((__always_inline__)) _Tp
      fetch_and(_Tp* __ptr, _Val<_Tp> __i, memory_order __m) noexcept
      { return __atomic_fetch_and(__ptr, __i, int(__m)); }

    template<typename _Tp>
      inline __attribute__((__always_inline__)) _Tp
      fetch_or(_Tp* __ptr, _Val<_Tp> __i, memory_order __m) noexcept
      { return __atomic_fetch_or(__ptr, __i, int(__m)); }

    template<typename _Tp>
      inline __attribute__((__always_inline__)) _Tp
      fetch_xor(_Tp* __ptr, _Val<_Tp> __i, memory_order __m) noexcept
      { return __atomic_fetch_xor(__ptr, __i, int(__m)); }

    template<typename _Tp>
      inline __attribute__((__always_inline__)) _Tp
      __add_fetch(_Tp* __ptr, _Diff<_Tp> __i) noexcept
      { return __atomic_add_fetch(__ptr, __i, 5); }

    template<typename _Tp>
      inline __attribute__((__always_inline__)) _Tp
      __sub_fetch(_Tp* __ptr, _Diff<_Tp> __i) noexcept
      { return __atomic_sub_fetch(__ptr, __i, 5); }

    template<typename _Tp>
      inline __attribute__((__always_inline__)) _Tp
      __and_fetch(_Tp* __ptr, _Val<_Tp> __i) noexcept
      { return __atomic_and_fetch(__ptr, __i, 5); }

    template<typename _Tp>
      inline __attribute__((__always_inline__)) _Tp
      __or_fetch(_Tp* __ptr, _Val<_Tp> __i) noexcept
      { return __atomic_or_fetch(__ptr, __i, 5); }

    template<typename _Tp>
      inline __attribute__((__always_inline__)) _Tp
      __xor_fetch(_Tp* __ptr, _Val<_Tp> __i) noexcept
      { return __atomic_xor_fetch(__ptr, __i, 5); }

    template<typename _Tp>
      _Tp
      __fetch_add_flt(_Tp* __ptr, _Val<_Tp> __i, memory_order __m) noexcept
      {
 _Val<_Tp> __oldval = load(__ptr, memory_order_relaxed);
 _Val<_Tp> __newval = __oldval + __i;
 while (!compare_exchange_weak(__ptr, __oldval, __newval, __m,
          memory_order_relaxed))
   __newval = __oldval + __i;
 return __oldval;
      }

    template<typename _Tp>
      _Tp
      __fetch_sub_flt(_Tp* __ptr, _Val<_Tp> __i, memory_order __m) noexcept
      {
 _Val<_Tp> __oldval = load(__ptr, memory_order_relaxed);
 _Val<_Tp> __newval = __oldval - __i;
 while (!compare_exchange_weak(__ptr, __oldval, __newval, __m,
          memory_order_relaxed))
   __newval = __oldval - __i;
 return __oldval;
      }

    template<typename _Tp>
      _Tp
      __add_fetch_flt(_Tp* __ptr, _Val<_Tp> __i) noexcept
      {
 _Val<_Tp> __oldval = load(__ptr, memory_order_relaxed);
 _Val<_Tp> __newval = __oldval + __i;
 while (!compare_exchange_weak(__ptr, __oldval, __newval,
          memory_order_seq_cst,
          memory_order_relaxed))
   __newval = __oldval + __i;
 return __newval;
      }

    template<typename _Tp>
      _Tp
      __sub_fetch_flt(_Tp* __ptr, _Val<_Tp> __i) noexcept
      {
 _Val<_Tp> __oldval = load(__ptr, memory_order_relaxed);
 _Val<_Tp> __newval = __oldval - __i;
 while (!compare_exchange_weak(__ptr, __oldval, __newval,
          memory_order_seq_cst,
          memory_order_relaxed))
   __newval = __oldval - __i;
 return __newval;
      }
  }


  template<typename _Fp>
    struct __atomic_float
    {
      static_assert(is_floating_point_v<_Fp>);

      static constexpr size_t _S_alignment = __alignof__(_Fp);

    public:
      using value_type = _Fp;
      using difference_type = value_type;

      static constexpr bool is_always_lock_free
 = __atomic_always_lock_free(sizeof(_Fp), 0);

      __atomic_float() = default;

      constexpr
      __atomic_float(_Fp __t) : _M_fp(__t)
      { }

      __atomic_float(const __atomic_float&) = delete;
      __atomic_float& operator=(const __atomic_float&) = delete;
      __atomic_float& operator=(const __atomic_float&) volatile = delete;

      _Fp
      operator=(_Fp __t) volatile noexcept
      {
 this->store(__t);
 return __t;
      }

      _Fp
      operator=(_Fp __t) noexcept
      {
 this->store(__t);
 return __t;
      }

      bool
      is_lock_free() const volatile noexcept
      { return __atomic_impl::is_lock_free<sizeof(_Fp), _S_alignment>(); }

      bool
      is_lock_free() const noexcept
      { return __atomic_impl::is_lock_free<sizeof(_Fp), _S_alignment>(); }

      void
      store(_Fp __t, memory_order __m = memory_order_seq_cst) volatile noexcept
      { __atomic_impl::store(&_M_fp, __t, __m); }

      void
      store(_Fp __t, memory_order __m = memory_order_seq_cst) noexcept
      { __atomic_impl::store(&_M_fp, __t, __m); }

      _Fp
      load(memory_order __m = memory_order_seq_cst) const volatile noexcept
      { return __atomic_impl::load(&_M_fp, __m); }

      _Fp
      load(memory_order __m = memory_order_seq_cst) const noexcept
      { return __atomic_impl::load(&_M_fp, __m); }

      operator _Fp() const volatile noexcept { return this->load(); }
      operator _Fp() const noexcept { return this->load(); }

      _Fp
      exchange(_Fp __desired,
        memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_impl::exchange(&_M_fp, __desired, __m); }

      _Fp
      exchange(_Fp __desired,
        memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_impl::exchange(&_M_fp, __desired, __m); }

      bool
      compare_exchange_weak(_Fp& __expected, _Fp __desired,
       memory_order __success,
       memory_order __failure) noexcept
      {
 return __atomic_impl::compare_exchange_weak(&_M_fp,
          __expected, __desired,
          __success, __failure);
      }

      bool
      compare_exchange_weak(_Fp& __expected, _Fp __desired,
       memory_order __success,
       memory_order __failure) volatile noexcept
      {
 return __atomic_impl::compare_exchange_weak(&_M_fp,
          __expected, __desired,
          __success, __failure);
      }

      bool
      compare_exchange_strong(_Fp& __expected, _Fp __desired,
         memory_order __success,
         memory_order __failure) noexcept
      {
 return __atomic_impl::compare_exchange_strong(&_M_fp,
            __expected, __desired,
            __success, __failure);
      }

      bool
      compare_exchange_strong(_Fp& __expected, _Fp __desired,
         memory_order __success,
         memory_order __failure) volatile noexcept
      {
 return __atomic_impl::compare_exchange_strong(&_M_fp,
            __expected, __desired,
            __success, __failure);
      }

      bool
      compare_exchange_weak(_Fp& __expected, _Fp __desired,
       memory_order __order = memory_order_seq_cst)
      noexcept
      {
 return compare_exchange_weak(__expected, __desired, __order,
                                     __cmpexch_failure_order(__order));
      }

      bool
      compare_exchange_weak(_Fp& __expected, _Fp __desired,
       memory_order __order = memory_order_seq_cst)
      volatile noexcept
      {
 return compare_exchange_weak(__expected, __desired, __order,
                                     __cmpexch_failure_order(__order));
      }

      bool
      compare_exchange_strong(_Fp& __expected, _Fp __desired,
         memory_order __order = memory_order_seq_cst)
      noexcept
      {
 return compare_exchange_strong(__expected, __desired, __order,
           __cmpexch_failure_order(__order));
      }

      bool
      compare_exchange_strong(_Fp& __expected, _Fp __desired,
         memory_order __order = memory_order_seq_cst)
      volatile noexcept
      {
 return compare_exchange_strong(__expected, __desired, __order,
           __cmpexch_failure_order(__order));
      }

      value_type
      fetch_add(value_type __i,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_impl::__fetch_add_flt(&_M_fp, __i, __m); }

      value_type
      fetch_add(value_type __i,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_impl::__fetch_add_flt(&_M_fp, __i, __m); }

      value_type
      fetch_sub(value_type __i,
  memory_order __m = memory_order_seq_cst) noexcept
      { return __atomic_impl::__fetch_sub_flt(&_M_fp, __i, __m); }

      value_type
      fetch_sub(value_type __i,
  memory_order __m = memory_order_seq_cst) volatile noexcept
      { return __atomic_impl::__fetch_sub_flt(&_M_fp, __i, __m); }

      value_type
      operator+=(value_type __i) noexcept
      { return __atomic_impl::__add_fetch_flt(&_M_fp, __i); }

      value_type
      operator+=(value_type __i) volatile noexcept
      { return __atomic_impl::__add_fetch_flt(&_M_fp, __i); }

      value_type
      operator-=(value_type __i) noexcept
      { return __atomic_impl::__sub_fetch_flt(&_M_fp, __i); }

      value_type
      operator-=(value_type __i) volatile noexcept
      { return __atomic_impl::__sub_fetch_flt(&_M_fp, __i); }

    private:
      alignas(_S_alignment) _Fp _M_fp;
    };

  template<typename _Tp,
    bool = is_integral_v<_Tp>, bool = is_floating_point_v<_Tp>>
    struct __atomic_ref;


  template<typename _Tp>
    struct __atomic_ref<_Tp, false, false>
    {
      static_assert(is_trivially_copyable_v<_Tp>);


      static constexpr int _S_min_alignment
 = (sizeof(_Tp) & (sizeof(_Tp) - 1)) || sizeof(_Tp) > 16
 ? 0 : sizeof(_Tp);

    public:
      using value_type = _Tp;

      static constexpr bool is_always_lock_free
 = __atomic_always_lock_free(sizeof(_Tp), 0);

      static constexpr size_t required_alignment
 = _S_min_alignment > alignof(_Tp) ? _S_min_alignment : alignof(_Tp);

      __atomic_ref& operator=(const __atomic_ref&) = delete;

      explicit
      __atomic_ref(_Tp& __t) : _M_ptr(std::__addressof(__t))
      { ; }

      __atomic_ref(const __atomic_ref&) noexcept = default;

      _Tp
      operator=(_Tp __t) const noexcept
      {
 this->store(__t);
 return __t;
      }

      operator _Tp() const noexcept { return this->load(); }

      bool
      is_lock_free() const noexcept
      { return __atomic_impl::is_lock_free<sizeof(_Tp), required_alignment>(); }

      void
      store(_Tp __t, memory_order __m = memory_order_seq_cst) const noexcept
      { __atomic_impl::store(_M_ptr, __t, __m); }

      _Tp
      load(memory_order __m = memory_order_seq_cst) const noexcept
      { return __atomic_impl::load(_M_ptr, __m); }

      _Tp
      exchange(_Tp __desired, memory_order __m = memory_order_seq_cst)
      const noexcept
      { return __atomic_impl::exchange(_M_ptr, __desired, __m); }

      bool
      compare_exchange_weak(_Tp& __expected, _Tp __desired,
       memory_order __success,
       memory_order __failure) const noexcept
      {
 return __atomic_impl::compare_exchange_weak(_M_ptr,
          __expected, __desired,
          __success, __failure);
      }

      bool
      compare_exchange_strong(_Tp& __expected, _Tp __desired,
       memory_order __success,
       memory_order __failure) const noexcept
      {
 return __atomic_impl::compare_exchange_strong(_M_ptr,
            __expected, __desired,
            __success, __failure);
      }

      bool
      compare_exchange_weak(_Tp& __expected, _Tp __desired,
       memory_order __order = memory_order_seq_cst)
      const noexcept
      {
 return compare_exchange_weak(__expected, __desired, __order,
                                     __cmpexch_failure_order(__order));
      }

      bool
      compare_exchange_strong(_Tp& __expected, _Tp __desired,
         memory_order __order = memory_order_seq_cst)
      const noexcept
      {
 return compare_exchange_strong(__expected, __desired, __order,
           __cmpexch_failure_order(__order));
      }

    private:
      _Tp* _M_ptr;
    };


  template<typename _Tp>
    struct __atomic_ref<_Tp, true, false>
    {
      static_assert(is_integral_v<_Tp>);

    public:
      using value_type = _Tp;
      using difference_type = value_type;

      static constexpr bool is_always_lock_free
 = __atomic_always_lock_free(sizeof(_Tp), 0);

      static constexpr size_t required_alignment
 = sizeof(_Tp) > alignof(_Tp) ? sizeof(_Tp) : alignof(_Tp);

      __atomic_ref() = delete;
      __atomic_ref& operator=(const __atomic_ref&) = delete;

      explicit
      __atomic_ref(_Tp& __t) : _M_ptr(&__t)
      { ; }

      __atomic_ref(const __atomic_ref&) noexcept = default;

      _Tp
      operator=(_Tp __t) const noexcept
      {
 this->store(__t);
 return __t;
      }

      operator _Tp() const noexcept { return this->load(); }

      bool
      is_lock_free() const noexcept
      {
 return __atomic_impl::is_lock_free<sizeof(_Tp), required_alignment>();
      }

      void
      store(_Tp __t, memory_order __m = memory_order_seq_cst) const noexcept
      { __atomic_impl::store(_M_ptr, __t, __m); }

      _Tp
      load(memory_order __m = memory_order_seq_cst) const noexcept
      { return __atomic_impl::load(_M_ptr, __m); }

      _Tp
      exchange(_Tp __desired,
        memory_order __m = memory_order_seq_cst) const noexcept
      { return __atomic_impl::exchange(_M_ptr, __desired, __m); }

      bool
      compare_exchange_weak(_Tp& __expected, _Tp __desired,
       memory_order __success,
       memory_order __failure) const noexcept
      {
 return __atomic_impl::compare_exchange_weak(_M_ptr,
          __expected, __desired,
          __success, __failure);
      }

      bool
      compare_exchange_strong(_Tp& __expected, _Tp __desired,
         memory_order __success,
         memory_order __failure) const noexcept
      {
 return __atomic_impl::compare_exchange_strong(_M_ptr,
            __expected, __desired,
            __success, __failure);
      }

      bool
      compare_exchange_weak(_Tp& __expected, _Tp __desired,
       memory_order __order = memory_order_seq_cst)
      const noexcept
      {
 return compare_exchange_weak(__expected, __desired, __order,
                                     __cmpexch_failure_order(__order));
      }

      bool
      compare_exchange_strong(_Tp& __expected, _Tp __desired,
         memory_order __order = memory_order_seq_cst)
      const noexcept
      {
 return compare_exchange_strong(__expected, __desired, __order,
           __cmpexch_failure_order(__order));
      }

      value_type
      fetch_add(value_type __i,
  memory_order __m = memory_order_seq_cst) const noexcept
      { return __atomic_impl::fetch_add(_M_ptr, __i, __m); }

      value_type
      fetch_sub(value_type __i,
  memory_order __m = memory_order_seq_cst) const noexcept
      { return __atomic_impl::fetch_sub(_M_ptr, __i, __m); }

      value_type
      fetch_and(value_type __i,
  memory_order __m = memory_order_seq_cst) const noexcept
      { return __atomic_impl::fetch_and(_M_ptr, __i, __m); }

      value_type
      fetch_or(value_type __i,
        memory_order __m = memory_order_seq_cst) const noexcept
      { return __atomic_impl::fetch_or(_M_ptr, __i, __m); }

      value_type
      fetch_xor(value_type __i,
  memory_order __m = memory_order_seq_cst) const noexcept
      { return __atomic_impl::fetch_xor(_M_ptr, __i, __m); }

      inline __attribute__((__always_inline__)) value_type
      operator++(int) const noexcept
      { return fetch_add(1); }

      inline __attribute__((__always_inline__)) value_type
      operator--(int) const noexcept
      { return fetch_sub(1); }

      value_type
      operator++() const noexcept
      { return __atomic_impl::__add_fetch(_M_ptr, value_type(1)); }

      value_type
      operator--() const noexcept
      { return __atomic_impl::__sub_fetch(_M_ptr, value_type(1)); }

      value_type
      operator+=(value_type __i) const noexcept
      { return __atomic_impl::__add_fetch(_M_ptr, __i); }

      value_type
      operator-=(value_type __i) const noexcept
      { return __atomic_impl::__sub_fetch(_M_ptr, __i); }

      value_type
      operator&=(value_type __i) const noexcept
      { return __atomic_impl::__and_fetch(_M_ptr, __i); }

      value_type
      operator|=(value_type __i) const noexcept
      { return __atomic_impl::__or_fetch(_M_ptr, __i); }

      value_type
      operator^=(value_type __i) const noexcept
      { return __atomic_impl::__xor_fetch(_M_ptr, __i); }

    private:
      _Tp* _M_ptr;
    };


  template<typename _Fp>
    struct __atomic_ref<_Fp, false, true>
    {
      static_assert(is_floating_point_v<_Fp>);

    public:
      using value_type = _Fp;
      using difference_type = value_type;

      static constexpr bool is_always_lock_free
 = __atomic_always_lock_free(sizeof(_Fp), 0);

      static constexpr size_t required_alignment = __alignof__(_Fp);

      __atomic_ref() = delete;
      __atomic_ref& operator=(const __atomic_ref&) = delete;

      explicit
      __atomic_ref(_Fp& __t) : _M_ptr(&__t)
      { ; }

      __atomic_ref(const __atomic_ref&) noexcept = default;

      _Fp
      operator=(_Fp __t) const noexcept
      {
 this->store(__t);
 return __t;
      }

      operator _Fp() const noexcept { return this->load(); }

      bool
      is_lock_free() const noexcept
      {
 return __atomic_impl::is_lock_free<sizeof(_Fp), required_alignment>();
      }

      void
      store(_Fp __t, memory_order __m = memory_order_seq_cst) const noexcept
      { __atomic_impl::store(_M_ptr, __t, __m); }

      _Fp
      load(memory_order __m = memory_order_seq_cst) const noexcept
      { return __atomic_impl::load(_M_ptr, __m); }

      _Fp
      exchange(_Fp __desired,
        memory_order __m = memory_order_seq_cst) const noexcept
      { return __atomic_impl::exchange(_M_ptr, __desired, __m); }

      bool
      compare_exchange_weak(_Fp& __expected, _Fp __desired,
       memory_order __success,
       memory_order __failure) const noexcept
      {
 return __atomic_impl::compare_exchange_weak(_M_ptr,
          __expected, __desired,
          __success, __failure);
      }

      bool
      compare_exchange_strong(_Fp& __expected, _Fp __desired,
       memory_order __success,
       memory_order __failure) const noexcept
      {
 return __atomic_impl::compare_exchange_strong(_M_ptr,
            __expected, __desired,
            __success, __failure);
      }

      bool
      compare_exchange_weak(_Fp& __expected, _Fp __desired,
       memory_order __order = memory_order_seq_cst)
      const noexcept
      {
 return compare_exchange_weak(__expected, __desired, __order,
                                     __cmpexch_failure_order(__order));
      }

      bool
      compare_exchange_strong(_Fp& __expected, _Fp __desired,
         memory_order __order = memory_order_seq_cst)
      const noexcept
      {
 return compare_exchange_strong(__expected, __desired, __order,
           __cmpexch_failure_order(__order));
      }

      value_type
      fetch_add(value_type __i,
  memory_order __m = memory_order_seq_cst) const noexcept
      { return __atomic_impl::__fetch_add_flt(_M_ptr, __i, __m); }

      value_type
      fetch_sub(value_type __i,
  memory_order __m = memory_order_seq_cst) const noexcept
      { return __atomic_impl::__fetch_sub_flt(_M_ptr, __i, __m); }

      value_type
      operator+=(value_type __i) const noexcept
      { return __atomic_impl::__add_fetch_flt(_M_ptr, __i); }

      value_type
      operator-=(value_type __i) const noexcept
      { return __atomic_impl::__sub_fetch_flt(_M_ptr, __i); }

    private:
      _Fp* _M_ptr;
    };


  template<typename _Tp>
    struct __atomic_ref<_Tp*, false, false>
    {
    public:
      using value_type = _Tp*;
      using difference_type = ptrdiff_t;

      static constexpr bool is_always_lock_free = 2 == 2;

      static constexpr size_t required_alignment = __alignof__(_Tp*);

      __atomic_ref() = delete;
      __atomic_ref& operator=(const __atomic_ref&) = delete;

      explicit
      __atomic_ref(_Tp*& __t) : _M_ptr(std::__addressof(__t))
      { ; }

      __atomic_ref(const __atomic_ref&) noexcept = default;

      _Tp*
      operator=(_Tp* __t) const noexcept
      {
 this->store(__t);
 return __t;
      }

      operator _Tp*() const noexcept { return this->load(); }

      bool
      is_lock_free() const noexcept
      {
 return __atomic_impl::is_lock_free<sizeof(_Tp*), required_alignment>();
      }

      void
      store(_Tp* __t, memory_order __m = memory_order_seq_cst) const noexcept
      { __atomic_impl::store(_M_ptr, __t, __m); }

      _Tp*
      load(memory_order __m = memory_order_seq_cst) const noexcept
      { return __atomic_impl::load(_M_ptr, __m); }

      _Tp*
      exchange(_Tp* __desired,
        memory_order __m = memory_order_seq_cst) const noexcept
      { return __atomic_impl::exchange(_M_ptr, __desired, __m); }

      bool
      compare_exchange_weak(_Tp*& __expected, _Tp* __desired,
       memory_order __success,
       memory_order __failure) const noexcept
      {
 return __atomic_impl::compare_exchange_weak(_M_ptr,
          __expected, __desired,
          __success, __failure);
      }

      bool
      compare_exchange_strong(_Tp*& __expected, _Tp* __desired,
       memory_order __success,
       memory_order __failure) const noexcept
      {
 return __atomic_impl::compare_exchange_strong(_M_ptr,
            __expected, __desired,
            __success, __failure);
      }

      bool
      compare_exchange_weak(_Tp*& __expected, _Tp* __desired,
       memory_order __order = memory_order_seq_cst)
      const noexcept
      {
 return compare_exchange_weak(__expected, __desired, __order,
                                     __cmpexch_failure_order(__order));
      }

      bool
      compare_exchange_strong(_Tp*& __expected, _Tp* __desired,
         memory_order __order = memory_order_seq_cst)
      const noexcept
      {
 return compare_exchange_strong(__expected, __desired, __order,
           __cmpexch_failure_order(__order));
      }

      inline __attribute__((__always_inline__)) value_type
      fetch_add(difference_type __d,
  memory_order __m = memory_order_seq_cst) const noexcept
      { return __atomic_impl::fetch_add(_M_ptr, _S_type_size(__d), __m); }

      inline __attribute__((__always_inline__)) value_type
      fetch_sub(difference_type __d,
  memory_order __m = memory_order_seq_cst) const noexcept
      { return __atomic_impl::fetch_sub(_M_ptr, _S_type_size(__d), __m); }

      value_type
      operator++(int) const noexcept
      { return fetch_add(1); }

      value_type
      operator--(int) const noexcept
      { return fetch_sub(1); }

      value_type
      operator++() const noexcept
      {
 return __atomic_impl::__add_fetch(_M_ptr, _S_type_size(1));
      }

      value_type
      operator--() const noexcept
      {
 return __atomic_impl::__sub_fetch(_M_ptr, _S_type_size(1));
      }

      value_type
      operator+=(difference_type __d) const noexcept
      {
 return __atomic_impl::__add_fetch(_M_ptr, _S_type_size(__d));
      }

      value_type
      operator-=(difference_type __d) const noexcept
      {
 return __atomic_impl::__sub_fetch(_M_ptr, _S_type_size(__d));
      }

    private:
      static constexpr ptrdiff_t
      _S_type_size(ptrdiff_t __d) noexcept
      {
 static_assert(is_object_v<_Tp>);
 return __d * sizeof(_Tp);
      }

      _Tp** _M_ptr;
    };






}
# 34 "/usr/local/include/c++/10.0.0/bits/shared_ptr_atomic.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 47 "/usr/local/include/c++/10.0.0/bits/shared_ptr_atomic.h" 3
  struct _Sp_locker
  {
    _Sp_locker(const _Sp_locker&) = delete;
    _Sp_locker& operator=(const _Sp_locker&) = delete;


    explicit
    _Sp_locker(const void*) noexcept;
    _Sp_locker(const void*, const void*) noexcept;
    ~_Sp_locker();

  private:
    unsigned char _M_key1;
    unsigned char _M_key2;



  };
# 74 "/usr/local/include/c++/10.0.0/bits/shared_ptr_atomic.h" 3
  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    atomic_is_lock_free(const __shared_ptr<_Tp, _Lp>* __p)
    {

      return __gthread_active_p() == 0;



    }

  template<typename _Tp>
    inline bool
    atomic_is_lock_free(const shared_ptr<_Tp>* __p)
    { return std::atomic_is_lock_free<_Tp, __default_lock_policy>(__p); }
# 101 "/usr/local/include/c++/10.0.0/bits/shared_ptr_atomic.h" 3
  template<typename _Tp>
    inline shared_ptr<_Tp>
    atomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)
    {
      _Sp_locker __lock{__p};
      return *__p;
    }

  template<typename _Tp>
    inline shared_ptr<_Tp>
    atomic_load(const shared_ptr<_Tp>* __p)
    { return std::atomic_load_explicit(__p, memory_order_seq_cst); }

  template<typename _Tp, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    atomic_load_explicit(const __shared_ptr<_Tp, _Lp>* __p, memory_order)
    {
      _Sp_locker __lock{__p};
      return *__p;
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    atomic_load(const __shared_ptr<_Tp, _Lp>* __p)
    { return std::atomic_load_explicit(__p, memory_order_seq_cst); }
# 137 "/usr/local/include/c++/10.0.0/bits/shared_ptr_atomic.h" 3
  template<typename _Tp>
    inline void
    atomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r,
     memory_order)
    {
      _Sp_locker __lock{__p};
      __p->swap(__r);
    }

  template<typename _Tp>
    inline void
    atomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)
    { std::atomic_store_explicit(__p, std::move(__r), memory_order_seq_cst); }

  template<typename _Tp, _Lock_policy _Lp>
    inline void
    atomic_store_explicit(__shared_ptr<_Tp, _Lp>* __p,
     __shared_ptr<_Tp, _Lp> __r,
     memory_order)
    {
      _Sp_locker __lock{__p};
      __p->swap(__r);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline void
    atomic_store(__shared_ptr<_Tp, _Lp>* __p, __shared_ptr<_Tp, _Lp> __r)
    { std::atomic_store_explicit(__p, std::move(__r), memory_order_seq_cst); }
# 174 "/usr/local/include/c++/10.0.0/bits/shared_ptr_atomic.h" 3
  template<typename _Tp>
    inline shared_ptr<_Tp>
    atomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r,
        memory_order)
    {
      _Sp_locker __lock{__p};
      __p->swap(__r);
      return __r;
    }

  template<typename _Tp>
    inline shared_ptr<_Tp>
    atomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)
    {
      return std::atomic_exchange_explicit(__p, std::move(__r),
        memory_order_seq_cst);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    atomic_exchange_explicit(__shared_ptr<_Tp, _Lp>* __p,
        __shared_ptr<_Tp, _Lp> __r,
        memory_order)
    {
      _Sp_locker __lock{__p};
      __p->swap(__r);
      return __r;
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    atomic_exchange(__shared_ptr<_Tp, _Lp>* __p, __shared_ptr<_Tp, _Lp> __r)
    {
      return std::atomic_exchange_explicit(__p, std::move(__r),
        memory_order_seq_cst);
    }
# 223 "/usr/local/include/c++/10.0.0/bits/shared_ptr_atomic.h" 3
  template<typename _Tp>
    bool
    atomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p,
         shared_ptr<_Tp>* __v,
         shared_ptr<_Tp> __w,
         memory_order,
         memory_order)
    {
      shared_ptr<_Tp> __x;
      _Sp_locker __lock{__p, __v};
      owner_less<shared_ptr<_Tp>> __less;
      if (*__p == *__v && !__less(*__p, *__v) && !__less(*__v, *__p))
 {
   __x = std::move(*__p);
   *__p = std::move(__w);
   return true;
 }
      __x = std::move(*__v);
      *__v = *__p;
      return false;
    }

  template<typename _Tp>
    inline bool
    atomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,
     shared_ptr<_Tp> __w)
    {
      return std::atomic_compare_exchange_strong_explicit(__p, __v,
   std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
    }

  template<typename _Tp>
    inline bool
    atomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p,
       shared_ptr<_Tp>* __v,
       shared_ptr<_Tp> __w,
       memory_order __success,
       memory_order __failure)
    {
      return std::atomic_compare_exchange_strong_explicit(__p, __v,
   std::move(__w), __success, __failure);
    }

  template<typename _Tp>
    inline bool
    atomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,
     shared_ptr<_Tp> __w)
    {
      return std::atomic_compare_exchange_weak_explicit(__p, __v,
   std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
    }

  template<typename _Tp, _Lock_policy _Lp>
    bool
    atomic_compare_exchange_strong_explicit(__shared_ptr<_Tp, _Lp>* __p,
         __shared_ptr<_Tp, _Lp>* __v,
         __shared_ptr<_Tp, _Lp> __w,
         memory_order,
         memory_order)
    {
      __shared_ptr<_Tp, _Lp> __x;
      _Sp_locker __lock{__p, __v};
      owner_less<__shared_ptr<_Tp, _Lp>> __less;
      if (*__p == *__v && !__less(*__p, *__v) && !__less(*__v, *__p))
 {
   __x = std::move(*__p);
   *__p = std::move(__w);
   return true;
 }
      __x = std::move(*__v);
      *__v = *__p;
      return false;
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    atomic_compare_exchange_strong(__shared_ptr<_Tp, _Lp>* __p,
       __shared_ptr<_Tp, _Lp>* __v,
       __shared_ptr<_Tp, _Lp> __w)
    {
      return std::atomic_compare_exchange_strong_explicit(__p, __v,
   std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    atomic_compare_exchange_weak_explicit(__shared_ptr<_Tp, _Lp>* __p,
       __shared_ptr<_Tp, _Lp>* __v,
       __shared_ptr<_Tp, _Lp> __w,
       memory_order __success,
       memory_order __failure)
    {
      return std::atomic_compare_exchange_strong_explicit(__p, __v,
   std::move(__w), __success, __failure);
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    atomic_compare_exchange_weak(__shared_ptr<_Tp, _Lp>* __p,
     __shared_ptr<_Tp, _Lp>* __v,
     __shared_ptr<_Tp, _Lp> __w)
    {
      return std::atomic_compare_exchange_weak_explicit(__p, __v,
   std::move(__w), memory_order_seq_cst, memory_order_seq_cst);
    }






}
# 85 "/usr/local/include/c++/10.0.0/memory" 2 3

# 1 "/usr/local/include/c++/10.0.0/backward/auto_ptr.h" 1 3
# 36 "/usr/local/include/c++/10.0.0/backward/auto_ptr.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 47 "/usr/local/include/c++/10.0.0/backward/auto_ptr.h" 3
  template<typename _Tp1>
    struct auto_ptr_ref
    {
      _Tp1* _M_ptr;

      explicit
      auto_ptr_ref(_Tp1* __p): _M_ptr(__p) { }
    } __attribute__ ((__deprecated__));

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
# 88 "/usr/local/include/c++/10.0.0/backward/auto_ptr.h" 3
  template<typename _Tp>
    class auto_ptr
    {
    private:
      _Tp* _M_ptr;

    public:

      typedef _Tp element_type;







      explicit
      auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }
# 114 "/usr/local/include/c++/10.0.0/backward/auto_ptr.h" 3
      auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) { }
# 126 "/usr/local/include/c++/10.0.0/backward/auto_ptr.h" 3
      template<typename _Tp1>
        auto_ptr(auto_ptr<_Tp1>& __a) throw() : _M_ptr(__a.release()) { }
# 137 "/usr/local/include/c++/10.0.0/backward/auto_ptr.h" 3
      auto_ptr&
      operator=(auto_ptr& __a) throw()
      {
 reset(__a.release());
 return *this;
      }
# 154 "/usr/local/include/c++/10.0.0/backward/auto_ptr.h" 3
      template<typename _Tp1>
        auto_ptr&
        operator=(auto_ptr<_Tp1>& __a) throw()
        {
   reset(__a.release());
   return *this;
 }
# 172 "/usr/local/include/c++/10.0.0/backward/auto_ptr.h" 3
      ~auto_ptr() { delete _M_ptr; }
# 182 "/usr/local/include/c++/10.0.0/backward/auto_ptr.h" 3
      element_type&
      operator*() const throw()
      {
 ;
 return *_M_ptr;
      }







      element_type*
      operator->() const throw()
      {
 ;
 return _M_ptr;
      }
# 212 "/usr/local/include/c++/10.0.0/backward/auto_ptr.h" 3
      element_type*
      get() const throw() { return _M_ptr; }
# 226 "/usr/local/include/c++/10.0.0/backward/auto_ptr.h" 3
      element_type*
      release() throw()
      {
 element_type* __tmp = _M_ptr;
 _M_ptr = 0;
 return __tmp;
      }
# 241 "/usr/local/include/c++/10.0.0/backward/auto_ptr.h" 3
      void
      reset(element_type* __p = 0) throw()
      {
 if (__p != _M_ptr)
   {
     delete _M_ptr;
     _M_ptr = __p;
   }
      }
# 266 "/usr/local/include/c++/10.0.0/backward/auto_ptr.h" 3
      auto_ptr(auto_ptr_ref<element_type> __ref) throw()
      : _M_ptr(__ref._M_ptr) { }

      auto_ptr&
      operator=(auto_ptr_ref<element_type> __ref) throw()
      {
 if (__ref._M_ptr != this->get())
   {
     delete _M_ptr;
     _M_ptr = __ref._M_ptr;
   }
 return *this;
      }

      template<typename _Tp1>
        operator auto_ptr_ref<_Tp1>() throw()
        { return auto_ptr_ref<_Tp1>(this->release()); }

      template<typename _Tp1>
        operator auto_ptr<_Tp1>() throw()
        { return auto_ptr<_Tp1>(this->release()); }
    } __attribute__ ((__deprecated__));



  template<>
    class auto_ptr<void>
    {
    public:
      typedef void element_type;
    } __attribute__ ((__deprecated__));


  template<_Lock_policy _Lp>
  template<typename _Tp>
    inline
    __shared_count<_Lp>::__shared_count(std::auto_ptr<_Tp>&& __r)
    : _M_pi(new _Sp_counted_ptr<_Tp*, _Lp>(__r.get()))
    { __r.release(); }

  template<typename _Tp, _Lock_policy _Lp>
  template<typename _Tp1, typename>
    inline
    __shared_ptr<_Tp, _Lp>::__shared_ptr(std::auto_ptr<_Tp1>&& __r)
    : _M_ptr(__r.get()), _M_refcount()
    {
     
      static_assert( sizeof(_Tp1) > 0, "incomplete type" );
      _Tp1* __tmp = __r.get();
      _M_refcount = __shared_count<_Lp>(std::move(__r));
      _M_enable_shared_from_this_with(__tmp);
    }

  template<typename _Tp>
  template<typename _Tp1, typename>
    inline
    shared_ptr<_Tp>::shared_ptr(std::auto_ptr<_Tp1>&& __r)
    : __shared_ptr<_Tp>(std::move(__r)) { }

  template<typename _Tp, typename _Dp>
  template<typename _Up, typename>
    inline
    unique_ptr<_Tp, _Dp>::unique_ptr(auto_ptr<_Up>&& __u) noexcept
    : _M_t(__u.release(), deleter_type()) { }


#pragma GCC diagnostic pop


}
# 87 "/usr/local/include/c++/10.0.0/memory" 2 3
# 95 "/usr/local/include/c++/10.0.0/memory" 3
# 1 "/usr/local/include/c++/10.0.0/bit" 1 3
# 32 "/usr/local/include/c++/10.0.0/bit" 3
       
# 33 "/usr/local/include/c++/10.0.0/bit" 3






namespace std __attribute__ ((__visibility__ ("default")))
{

# 54 "/usr/local/include/c++/10.0.0/bit" 3
  template<typename _Tp>
    constexpr _Tp
    __rotl(_Tp __x, int __s) noexcept
    {
      constexpr auto _Nd = numeric_limits<_Tp>::digits;
      const int __r = __s % _Nd;
      if (__r == 0)
 return __x;
      else if (__r > 0)
 return (__x << __r) | (__x >> ((_Nd - __r) % _Nd));
      else
 return (__x >> -__r) | (__x << ((_Nd + __r) % _Nd));
    }

  template<typename _Tp>
    constexpr _Tp
    __rotr(_Tp __x, int __s) noexcept
    {
      constexpr auto _Nd = numeric_limits<_Tp>::digits;
      const int __r = __s % _Nd;
      if (__r == 0)
 return __x;
      else if (__r > 0)
 return (__x >> __r) | (__x << ((_Nd - __r) % _Nd));
      else
 return (__x << -__r) | (__x >> ((_Nd + __r) % _Nd));
    }

  template<typename _Tp>
    constexpr int
    __countl_zero(_Tp __x) noexcept
    {
      constexpr auto _Nd = numeric_limits<_Tp>::digits;

      if (__x == 0)
        return _Nd;

      constexpr auto _Nd_ull = numeric_limits<unsigned long long>::digits;
      constexpr auto _Nd_ul = numeric_limits<unsigned long>::digits;
      constexpr auto _Nd_u = numeric_limits<unsigned>::digits;

      if constexpr (_Nd <= _Nd_u)
 {
   constexpr int __diff = _Nd_u - _Nd;
   return __builtin_clz(__x) - __diff;
 }
      else if constexpr (_Nd <= _Nd_ul)
 {
   constexpr int __diff = _Nd_ul - _Nd;
   return __builtin_clzl(__x) - __diff;
 }
      else if constexpr (_Nd <= _Nd_ull)
 {
   constexpr int __diff = _Nd_ull - _Nd;
   return __builtin_clzll(__x) - __diff;
 }
      else
 {
   static_assert(_Nd <= (2 * _Nd_ull),
   "Maximum supported integer size is 128-bit");

   unsigned long long __high = __x >> _Nd_ull;
   if (__high != 0)
     {
       constexpr int __diff = (2 * _Nd_ull) - _Nd;
       return __builtin_clzll(__high) - __diff;
     }
   constexpr auto __max_ull = numeric_limits<unsigned long long>::max();
   unsigned long long __low = __x & __max_ull;
   return (_Nd - _Nd_ull) + __builtin_clzll(__low);
 }
    }

  template<typename _Tp>
    constexpr int
    __countl_one(_Tp __x) noexcept
    {
      if (__x == numeric_limits<_Tp>::max())
        return numeric_limits<_Tp>::digits;
      return std::__countl_zero<_Tp>((_Tp)~__x);
    }

  template<typename _Tp>
    constexpr int
    __countr_zero(_Tp __x) noexcept
    {
      constexpr auto _Nd = numeric_limits<_Tp>::digits;

      if (__x == 0)
        return _Nd;

      constexpr auto _Nd_ull = numeric_limits<unsigned long long>::digits;
      constexpr auto _Nd_ul = numeric_limits<unsigned long>::digits;
      constexpr auto _Nd_u = numeric_limits<unsigned>::digits;

      if constexpr (_Nd <= _Nd_u)
 return __builtin_ctz(__x);
      else if constexpr (_Nd <= _Nd_ul)
 return __builtin_ctzl(__x);
      else if constexpr (_Nd <= _Nd_ull)
 return __builtin_ctzll(__x);
      else
 {
   static_assert(_Nd <= (2 * _Nd_ull),
   "Maximum supported integer size is 128-bit");

   constexpr auto __max_ull = numeric_limits<unsigned long long>::max();
   unsigned long long __low = __x & __max_ull;
   if (__low != 0)
     return __builtin_ctzll(__low);
   unsigned long long __high = __x >> _Nd_ull;
   return __builtin_ctzll(__high) + _Nd_ull;
 }
    }

  template<typename _Tp>
    constexpr int
    __countr_one(_Tp __x) noexcept
    {
      if (__x == numeric_limits<_Tp>::max())
        return numeric_limits<_Tp>::digits;
      return std::__countr_zero((_Tp)~__x);
    }

  template<typename _Tp>
    constexpr int
    __popcount(_Tp __x) noexcept
    {
      constexpr auto _Nd = numeric_limits<_Tp>::digits;

      if (__x == 0)
        return 0;

      constexpr auto _Nd_ull = numeric_limits<unsigned long long>::digits;
      constexpr auto _Nd_ul = numeric_limits<unsigned long>::digits;
      constexpr auto _Nd_u = numeric_limits<unsigned>::digits;

      if constexpr (_Nd <= _Nd_u)
 return __builtin_popcount(__x);
      else if constexpr (_Nd <= _Nd_ul)
 return __builtin_popcountl(__x);
      else if constexpr (_Nd <= _Nd_ull)
 return __builtin_popcountll(__x);
      else
 {
   static_assert(_Nd <= (2 * _Nd_ull),
   "Maximum supported integer size is 128-bit");

   constexpr auto __max_ull = numeric_limits<unsigned long long>::max();
   unsigned long long __low = __x & __max_ull;
   unsigned long long __high = __x >> _Nd_ull;
   return __builtin_popcountll(__low) + __builtin_popcountll(__high);
 }
    }

  template<typename _Tp>
    constexpr bool
    __ispow2(_Tp __x) noexcept
    { return std::__popcount(__x) == 1; }

  template<typename _Tp>
    constexpr _Tp
    __ceil2(_Tp __x) noexcept
    {
      constexpr auto _Nd = numeric_limits<_Tp>::digits;
      if (__x == 0 || __x == 1)
        return 1;
      auto __shift_exponent = _Nd - std::__countl_zero((_Tp)(__x - 1u));





      if (!__builtin_is_constant_evaluated())
 {
   ;
 }

      using __promoted_type = decltype(__x << 1);
      if constexpr (!is_same<__promoted_type, _Tp>::value)
 {





   const int __extra_exp = sizeof(__promoted_type) / sizeof(_Tp) / 2;
   __shift_exponent |= (__shift_exponent & _Nd) << __extra_exp;
 }
      return (_Tp)1u << __shift_exponent;
    }

  template<typename _Tp>
    constexpr _Tp
    __floor2(_Tp __x) noexcept
    {
      constexpr auto _Nd = numeric_limits<_Tp>::digits;
      if (__x == 0)
        return 0;
      return (_Tp)1u << (_Nd - std::__countl_zero((_Tp)(__x >> 1)));
    }

  template<typename _Tp>
    constexpr _Tp
    __log2p1(_Tp __x) noexcept
    {
      constexpr auto _Nd = numeric_limits<_Tp>::digits;
      return _Nd - std::__countl_zero(__x);
    }
# 271 "/usr/local/include/c++/10.0.0/bit" 3
  template<typename _Tp, typename _Up = _Tp>
    using _If_is_unsigned_integer
      = enable_if_t<__is_unsigned_integer<_Tp>::value, _Up>;





  template<typename _Tp>
    [[nodiscard]] constexpr _If_is_unsigned_integer<_Tp>
    rotl(_Tp __x, int __s) noexcept
    { return std::__rotl(__x, __s); }


  template<typename _Tp>
    [[nodiscard]] constexpr _If_is_unsigned_integer<_Tp>
    rotr(_Tp __x, int __s) noexcept
    { return std::__rotr(__x, __s); }




  template<typename _Tp>
    constexpr _If_is_unsigned_integer<_Tp, int>
    countl_zero(_Tp __x) noexcept
    { return std::__countl_zero(__x); }


  template<typename _Tp>
    constexpr _If_is_unsigned_integer<_Tp, int>
    countl_one(_Tp __x) noexcept
    { return std::__countl_one(__x); }


  template<typename _Tp>
    constexpr _If_is_unsigned_integer<_Tp, int>
    countr_zero(_Tp __x) noexcept
    { return std::__countr_zero(__x); }


  template<typename _Tp>
    constexpr _If_is_unsigned_integer<_Tp, int>
    countr_one(_Tp __x) noexcept
    { return std::__countr_one(__x); }


  template<typename _Tp>
    constexpr _If_is_unsigned_integer<_Tp, int>
    popcount(_Tp __x) noexcept
    { return std::__popcount(__x); }




  template<typename _Tp>
    constexpr _If_is_unsigned_integer<_Tp, bool>
    ispow2(_Tp __x) noexcept
    { return std::__ispow2(__x); }


  template<typename _Tp>
    constexpr _If_is_unsigned_integer<_Tp>
    ceil2(_Tp __x) noexcept
    { return std::__ceil2(__x); }


  template<typename _Tp>
    constexpr _If_is_unsigned_integer<_Tp>
    floor2(_Tp __x) noexcept
    { return std::__floor2(__x); }


  template<typename _Tp>
    constexpr _If_is_unsigned_integer<_Tp>
    log2p1(_Tp __x) noexcept
    { return std::__log2p1(__x); }




  enum class endian
  {
    little = 1234,
    big = 4321,
    native = 1234
  };





}
# 96 "/usr/local/include/c++/10.0.0/memory" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{

# 121 "/usr/local/include/c++/10.0.0/memory" 3
inline void*
align(size_t __align, size_t __size, void*& __ptr, size_t& __space) noexcept
{

  const auto __intptr = reinterpret_cast<uintptr_t>(__ptr);






  const auto __aligned = (__intptr - 1u + __align) & -__align;
  const auto __diff = __aligned - __intptr;
  if ((__size + __diff) > __space)
    return nullptr;
  else
    {
      __space -= __diff;
      return __ptr = reinterpret_cast<void*>(__aligned);
    }
}
# 157 "/usr/local/include/c++/10.0.0/memory" 3
enum class pointer_safety { relaxed, preferred, strict };


inline void
declare_reachable(void*) { }


template <typename _Tp>
  inline _Tp*
  undeclare_reachable(_Tp* __p) { return __p; }


inline void
declare_no_pointers(char*, size_t) { }


inline void
undeclare_no_pointers(char*, size_t) { }


inline pointer_safety
get_pointer_safety() noexcept { return pointer_safety::relaxed; }
# 189 "/usr/local/include/c++/10.0.0/memory" 3
  template<size_t _Align, class _Tp>
    [[nodiscard,__gnu__::__always_inline__]]
    constexpr _Tp* assume_aligned(_Tp* __ptr)
    {
      static_assert(std::ispow2(_Align));
      ;
      return static_cast<_Tp*>(__builtin_assume_aligned(__ptr, _Align));
    }



  template<typename _Tp>
    struct __is_pair : false_type { };
  template<typename _Tp, typename _Up>
    struct __is_pair<pair<_Tp, _Up>> : true_type { };
  template<typename _Tp, typename _Up>
    struct __is_pair<const pair<_Tp, _Up>> : true_type { };




  template<typename _Tp, typename __ = _Require<__not_<__is_pair<_Tp>>>,
    typename _Alloc, typename... _Args>
    constexpr auto
    __uses_alloc_args(const _Alloc& __a, _Args&&... __args) noexcept
    {
      if constexpr (uses_allocator_v<remove_cv_t<_Tp>, _Alloc>)
 {
   if constexpr (is_constructible_v<_Tp, allocator_arg_t,
        const _Alloc&, _Args...>)
     {
       return tuple<allocator_arg_t, const _Alloc&, _Args&&...>(
    allocator_arg, __a, std::forward<_Args>(__args)...);
     }
   else
     {
       static_assert(is_constructible_v<_Tp, _Args..., const _Alloc&>,
    "construction with an allocator must be possible"
    " if uses_allocator is true");

       return tuple<_Args&&..., const _Alloc&>(
    std::forward<_Args>(__args)..., __a);
     }
 }
      else
 {
   static_assert(is_constructible_v<_Tp, _Args...>);

   return tuple<_Args&&...>(std::forward<_Args>(__args)...);
 }
    }


  template<typename _Tp>
    concept _Std_pair = __is_pair<_Tp>::value;
# 256 "/usr/local/include/c++/10.0.0/memory" 3
  template<typename _Tp,



    typename _Alloc, typename... _Args>
    constexpr auto
    uses_allocator_construction_args(const _Alloc& __a,
         _Args&&... __args) noexcept

    requires (! _Std_pair<_Tp>)

    {
      return std::__uses_alloc_args<_Tp>(__a, std::forward<_Args>(__args)...);
    }

  template<_Std_pair _Tp, typename _Alloc,
    typename _Tuple1, typename _Tuple2>
    constexpr auto
    uses_allocator_construction_args(const _Alloc& __a, piecewise_construct_t,
         _Tuple1&& __x, _Tuple2&& __y) noexcept;

  template<_Std_pair _Tp, typename _Alloc>
    constexpr auto
    uses_allocator_construction_args(const _Alloc&) noexcept;

  template<_Std_pair _Tp, typename _Alloc,
    typename _Up, typename _Vp>
    constexpr auto
    uses_allocator_construction_args(const _Alloc&, _Up&&, _Vp&&) noexcept;

  template<_Std_pair _Tp, typename _Alloc,
    typename _Up, typename _Vp>
    constexpr auto
    uses_allocator_construction_args(const _Alloc&,
         const pair<_Up, _Vp>&) noexcept;

  template<_Std_pair _Tp, typename _Alloc,
    typename _Up, typename _Vp>
    constexpr auto
    uses_allocator_construction_args(const _Alloc&, pair<_Up, _Vp>&&) noexcept;

  template<_Std_pair _Tp, typename _Alloc,
    typename _Tuple1, typename _Tuple2>
    constexpr auto
    uses_allocator_construction_args(const _Alloc& __a, piecewise_construct_t,
         _Tuple1&& __x, _Tuple2&& __y) noexcept
    {
      using _Tp1 = typename _Tp::first_type;
      using _Tp2 = typename _Tp::second_type;

      return std::make_tuple(piecewise_construct,
   std::apply([&__a](auto&&... __args1) {
       return std::uses_allocator_construction_args<_Tp1>(
    __a, std::forward<decltype(__args1)>(__args1)...);
   }, std::forward<_Tuple1>(__x)),
   std::apply([&__a](auto&&... __args2) {
       return std::uses_allocator_construction_args<_Tp2>(
    __a, std::forward<decltype(__args2)>(__args2)...);
   }, std::forward<_Tuple2>(__y)));
    }

  template<_Std_pair _Tp, typename _Alloc>
    constexpr auto
    uses_allocator_construction_args(const _Alloc& __a) noexcept
    {
      using _Tp1 = typename _Tp::first_type;
      using _Tp2 = typename _Tp::second_type;

      return std::make_tuple(piecewise_construct,
   std::uses_allocator_construction_args<_Tp1>(__a),
   std::uses_allocator_construction_args<_Tp2>(__a));
    }

  template<_Std_pair _Tp, typename _Alloc,
    typename _Up, typename _Vp>
    constexpr auto
    uses_allocator_construction_args(const _Alloc& __a, _Up&& __u, _Vp&& __v)
      noexcept
    {
      using _Tp1 = typename _Tp::first_type;
      using _Tp2 = typename _Tp::second_type;

      return std::make_tuple(piecewise_construct,
   std::uses_allocator_construction_args<_Tp1>(__a,
     std::forward<_Up>(__u)),
   std::uses_allocator_construction_args<_Tp2>(__a,
     std::forward<_Vp>(__v)));
    }

  template<_Std_pair _Tp, typename _Alloc,
    typename _Up, typename _Vp>
    constexpr auto
    uses_allocator_construction_args(const _Alloc& __a,
         const pair<_Up, _Vp>& __pr) noexcept
    {
      using _Tp1 = typename _Tp::first_type;
      using _Tp2 = typename _Tp::second_type;

      return std::make_tuple(piecewise_construct,
   std::uses_allocator_construction_args<_Tp1>(__a, __pr.first),
   std::uses_allocator_construction_args<_Tp2>(__a, __pr.second));
    }

  template<_Std_pair _Tp, typename _Alloc,
    typename _Up, typename _Vp>
    constexpr auto
    uses_allocator_construction_args(const _Alloc& __a,
         pair<_Up, _Vp>&& __pr) noexcept
    {
      using _Tp1 = typename _Tp::first_type;
      using _Tp2 = typename _Tp::second_type;

      return std::make_tuple(piecewise_construct,
   std::uses_allocator_construction_args<_Tp1>(__a,
     std::move(__pr).first),
   std::uses_allocator_construction_args<_Tp2>(__a,
     std::move(__pr).second));
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    inline _Tp
    make_obj_using_allocator(const _Alloc& __a, _Args&&... __args)
    {
      return std::make_from_tuple<_Tp>(
   std::uses_allocator_construction_args<_Tp>(__a,
     std::forward<_Args>(__args)...));
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    inline _Tp*
    uninitialized_construct_using_allocator(_Tp* __p, const _Alloc& __a,
         _Args&&... __args)
    {
      void* __vp = const_cast<void*>(static_cast<const volatile void*>(__p));
      return ::new(__vp) _Tp(std::make_obj_using_allocator<_Tp>(__a,
     std::forward<_Args>(__args)...));
    }





}
# 408 "/usr/local/include/c++/10.0.0/memory" 3
# 1 "/usr/local/include/c++/10.0.0/pstl/glue_memory_defs.h" 1 3
# 13 "/usr/local/include/c++/10.0.0/pstl/glue_memory_defs.h" 3
# 1 "/usr/local/include/c++/10.0.0/pstl/execution_defs.h" 1 3
# 15 "/usr/local/include/c++/10.0.0/pstl/execution_defs.h" 3
namespace __pstl
{
namespace execution
{
inline namespace v1
{


class sequenced_policy
{
  public:

    static constexpr std::false_type
    __allow_unsequenced()
    {
        return std::false_type{};
    }
    static constexpr std::false_type
    __allow_vector()
    {
        return std::false_type{};
    }
    static constexpr std::false_type
    __allow_parallel()
    {
        return std::false_type{};
    }
};


class parallel_policy
{
  public:

    static constexpr std::false_type
    __allow_unsequenced()
    {
        return std::false_type{};
    }
    static constexpr std::false_type
    __allow_vector()
    {
        return std::false_type{};
    }
    static constexpr std::true_type
    __allow_parallel()
    {
        return std::true_type{};
    }
};


class parallel_unsequenced_policy
{
  public:

    static constexpr std::true_type
    __allow_unsequenced()
    {
        return std::true_type{};
    }
    static constexpr std::true_type
    __allow_vector()
    {
        return std::true_type{};
    }
    static constexpr std::true_type
    __allow_parallel()
    {
        return std::true_type{};
    }
};

class unsequenced_policy
{
  public:

    static constexpr std::true_type
    __allow_unsequenced()
    {
        return std::true_type{};
    }
    static constexpr std::true_type
    __allow_vector()
    {
        return std::true_type{};
    }
    static constexpr std::false_type
    __allow_parallel()
    {
        return std::false_type{};
    }
};


constexpr sequenced_policy seq{};
constexpr parallel_policy par{};
constexpr parallel_unsequenced_policy par_unseq{};
constexpr unsequenced_policy unseq{};


template <class _Tp>
struct is_execution_policy : std::false_type
{
};

template <>
struct is_execution_policy<__pstl::execution::sequenced_policy> : std::true_type
{
};
template <>
struct is_execution_policy<__pstl::execution::parallel_policy> : std::true_type
{
};
template <>
struct is_execution_policy<__pstl::execution::parallel_unsequenced_policy> : std::true_type
{
};
template <>
struct is_execution_policy<__pstl::execution::unsequenced_policy> : std::true_type
{
};


template <class _Tp>
constexpr bool is_execution_policy_v = __pstl::execution::is_execution_policy<_Tp>::value;


}
}

namespace __internal
{
template <class _ExecPolicy, class _Tp>

using __enable_if_execution_policy =
    typename std::enable_if<__pstl::execution::is_execution_policy<std::__remove_cvref_t<_ExecPolicy>>::value,
                            _Tp>::type;





}

}
# 14 "/usr/local/include/c++/10.0.0/pstl/glue_memory_defs.h" 2 3

namespace std
{



template <class _ExecutionPolicy, class _InputIterator, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
uninitialized_copy(_ExecutionPolicy&& __exec, _InputIterator __first, _InputIterator __last, _ForwardIterator __result);

template <class _ExecutionPolicy, class _InputIterator, class _Size, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
uninitialized_copy_n(_ExecutionPolicy&& __exec, _InputIterator __first, _Size __n, _ForwardIterator __result);



template <class _ExecutionPolicy, class _InputIterator, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
uninitialized_move(_ExecutionPolicy&& __exec, _InputIterator __first, _InputIterator __last, _ForwardIterator __result);

template <class _ExecutionPolicy, class _InputIterator, class _Size, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
uninitialized_move_n(_ExecutionPolicy&& __exec, _InputIterator __first, _Size __n, _ForwardIterator __result);



template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
uninitialized_fill(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __value);

template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
uninitialized_fill_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Size __n, const _Tp& __value);



template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
destroy(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator, class _Size>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
destroy_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Size __n);



template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
uninitialized_default_construct(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator, class _Size>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
uninitialized_default_construct_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Size __n);



template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
uninitialized_value_construct(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator, class _Size>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
uninitialized_value_construct_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Size __n);

}
# 409 "/usr/local/include/c++/10.0.0/memory" 2 3
# 21 "fast_io/fast_io_core.h" 2

# 1 "/usr/local/include/c++/10.0.0/string_view" 1 3
# 36 "/usr/local/include/c++/10.0.0/string_view" 3
       
# 37 "/usr/local/include/c++/10.0.0/string_view" 3





# 1 "/usr/local/include/c++/10.0.0/bits/char_traits.h" 1 3
# 37 "/usr/local/include/c++/10.0.0/bits/char_traits.h" 3
       
# 38 "/usr/local/include/c++/10.0.0/bits/char_traits.h" 3



# 1 "/usr/local/include/c++/10.0.0/cwchar" 1 3
# 39 "/usr/local/include/c++/10.0.0/cwchar" 3
       
# 40 "/usr/local/include/c++/10.0.0/cwchar" 3
# 42 "/usr/local/include/c++/10.0.0/bits/char_traits.h" 2 3





namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 61 "/usr/local/include/c++/10.0.0/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 86 "/usr/local/include/c++/10.0.0/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static constexpr void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static constexpr int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static constexpr std::size_t
      length(const char_type* __s);

      static constexpr const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static constexpr char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static constexpr int_type
      eof()
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    constexpr int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    constexpr std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    constexpr const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      if (__n == 0)
 return __s1;
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{

# 229 "/usr/local/include/c++/10.0.0/bits/char_traits.h" 3
  template<typename _CharT>
    static inline __attribute__((__always_inline__)) constexpr bool
    __constant_string_p(const _CharT* __s)
    {

      (void) __s;

      return __builtin_is_constant_evaluated();





    }
# 252 "/usr/local/include/c++/10.0.0/bits/char_traits.h" 3
  template<typename _CharT>
    static inline __attribute__((__always_inline__)) constexpr bool
    __constant_char_array_p(const _CharT* __a, size_t __n)
    {

      (void) __a;
      (void) __n;

      return __builtin_is_constant_evaluated();






    }
# 283 "/usr/local/include/c++/10.0.0/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static constexpr void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      {

 return (static_cast<unsigned char>(__c1)
  < static_cast<unsigned char>(__c2));
      }

      static constexpr int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return 0;

 if (__builtin_constant_p(__n)
     && __constant_char_array_p(__s1, __n)
     && __constant_char_array_p(__s2, __n))
   return __gnu_cxx::char_traits<char_type>::compare(__s1, __s2, __n);

 return __builtin_memcmp(__s1, __s2, __n);
      }

      static constexpr size_t
      length(const char_type* __s)
      {

 if (__constant_string_p(__s))
   return __gnu_cxx::char_traits<char_type>::length(__s);

 return __builtin_strlen(__s);
      }

      static constexpr const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 if (__n == 0)
   return 0;

 if (__builtin_constant_p(__n)
     && __builtin_constant_p(__a)
     && __constant_char_array_p(__s, __n))
   return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);

 return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n));
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;
 return static_cast<char_type*>(__builtin_memset(__s, __a, __n));
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return static_cast<char_type>(__c); }



      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static constexpr void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static constexpr int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return 0;

 if (__builtin_constant_p(__n)
     && __constant_char_array_p(__s1, __n)
     && __constant_char_array_p(__s2, __n))
   return __gnu_cxx::char_traits<char_type>::compare(__s1, __s2, __n);

 return wmemcmp(__s1, __s2, __n);
      }

      static constexpr size_t
      length(const char_type* __s)
      {

 if (__constant_string_p(__s))
   return __gnu_cxx::char_traits<char_type>::length(__s);

 return wcslen(__s);
      }

      static constexpr const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 if (__n == 0)
   return 0;

 if (__builtin_constant_p(__n)
     && __builtin_constant_p(__a)
     && __constant_char_array_p(__s, __n))
   return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);

 return wmemchr(__s, __a, __n);
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return wmemmove(__s1, __s2, __n);
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return wmemcpy(__s1, __s2, __n);
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;
 return wmemset(__s, __a, __n);
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>((0xffffffffu)); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };



  template<>
    struct char_traits<char8_t>
    {
      typedef char8_t char_type;
      typedef unsigned int int_type;
      typedef u8streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static constexpr void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static constexpr int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return 0;

 if (__builtin_constant_p(__n)
     && __constant_char_array_p(__s1, __n)
     && __constant_char_array_p(__s2, __n))
   return __gnu_cxx::char_traits<char_type>::compare(__s1, __s2, __n);

 return __builtin_memcmp(__s1, __s2, __n);
      }

      static constexpr size_t
      length(const char_type* __s)
      {

 if (__constant_string_p(__s))
   return __gnu_cxx::char_traits<char_type>::length(__s);

 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static constexpr const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 if (__n == 0)
   return 0;

 if (__builtin_constant_p(__n)
     && __builtin_constant_p(__a)
     && __constant_char_array_p(__s, __n))
   return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);

 return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n));
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;
 return static_cast<char_type*>(__builtin_memset(__s, __a, __n));
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };



}





namespace std __attribute__ ((__visibility__ ("default")))
{


  template<>
    struct char_traits<char16_t>
    {
      typedef char16_t char_type;

      typedef uint_least16_t int_type;





      typedef streamoff off_type;
      typedef u16streampos pos_type;
      typedef mbstate_t state_type;

      static constexpr void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static constexpr int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static constexpr size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static constexpr const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return __c == eof() ? int_type(0xfffd) : int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };

  template<>
    struct char_traits<char32_t>
    {
      typedef char32_t char_type;

      typedef uint_least32_t int_type;





      typedef streamoff off_type;
      typedef u32streampos pos_type;
      typedef mbstate_t state_type;

      static constexpr void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static constexpr int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static constexpr size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static constexpr const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };


}
# 43 "/usr/local/include/c++/10.0.0/string_view" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{





  constexpr size_t
  __sv_check(size_t __size, size_t __pos, const char* __s)
  {
    if (__pos > __size)
      __throw_out_of_range_fmt(("%s: __pos (which is %zu) > __size " "(which is %zu)")
                        , __s, __pos, __size);
    return __pos;
  }



  constexpr size_t
  __sv_limit(size_t __size, size_t __pos, size_t __off) noexcept
  {
   const bool __testoff = __off < __size - __pos;
   return __testoff ? __off : __size - __pos;
  }
# 89 "/usr/local/include/c++/10.0.0/string_view" 3
  template<typename _CharT, typename _Traits = std::char_traits<_CharT>>
    class basic_string_view
    {
      static_assert(!is_array_v<_CharT>);
      static_assert(is_trivial_v<_CharT> && is_standard_layout_v<_CharT>);
      static_assert(is_same_v<_CharT, typename _Traits::char_type>);

    public:


      using traits_type = _Traits;
      using value_type = _CharT;
      using pointer = value_type*;
      using const_pointer = const value_type*;
      using reference = value_type&;
      using const_reference = const value_type&;
      using const_iterator = const value_type*;
      using iterator = const_iterator;
      using const_reverse_iterator = std::reverse_iterator<const_iterator>;
      using reverse_iterator = const_reverse_iterator;
      using size_type = size_t;
      using difference_type = ptrdiff_t;
      static constexpr size_type npos = size_type(-1);



      constexpr
      basic_string_view() noexcept
      : _M_len{0}, _M_str{nullptr}
      { }

      constexpr basic_string_view(const basic_string_view&) noexcept = default;

      __attribute__((__nonnull__)) constexpr
      basic_string_view(const _CharT* __str) noexcept
      : _M_len{traits_type::length(__str)},
 _M_str{__str}
      { }

      constexpr
      basic_string_view(const _CharT* __str, size_type __len) noexcept
      : _M_len{__len}, _M_str{__str}
      { }


      template<contiguous_iterator _It, sized_sentinel_for<_It> _End>
 requires same_as<iter_value_t<_It>, _CharT>
   && (!convertible_to<_End, size_type>)
 constexpr
 basic_string_view(_It __first, _End __last)
 : _M_len(__last - __first), _M_str(std::to_address(__first))
 { }


      constexpr basic_string_view&
      operator=(const basic_string_view&) noexcept = default;



      constexpr const_iterator
      begin() const noexcept
      { return this->_M_str; }

      constexpr const_iterator
      end() const noexcept
      { return this->_M_str + this->_M_len; }

      constexpr const_iterator
      cbegin() const noexcept
      { return this->_M_str; }

      constexpr const_iterator
      cend() const noexcept
      { return this->_M_str + this->_M_len; }

      constexpr const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(this->end()); }

      constexpr const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(this->begin()); }

      constexpr const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->end()); }

      constexpr const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->begin()); }



      constexpr size_type
      size() const noexcept
      { return this->_M_len; }

      constexpr size_type
      length() const noexcept
      { return _M_len; }

      constexpr size_type
      max_size() const noexcept
      {
 return (npos - sizeof(size_type) - sizeof(void*))
  / sizeof(value_type) / 4;
      }

      [[nodiscard]] constexpr bool
      empty() const noexcept
      { return this->_M_len == 0; }



      constexpr const_reference
      operator[](size_type __pos) const noexcept
      {


 return *(this->_M_str + __pos);
      }

      constexpr const_reference
      at(size_type __pos) const
      {
 if (__pos >= _M_len)
   __throw_out_of_range_fmt(("basic_string_view::at: __pos " "(which is %zu) >= this->size() " "(which is %zu)")

                            , __pos, this->size());
 return *(this->_M_str + __pos);
      }

      constexpr const_reference
      front() const noexcept
      {


 return *this->_M_str;
      }

      constexpr const_reference
      back() const noexcept
      {


 return *(this->_M_str + this->_M_len - 1);
      }

      constexpr const_pointer
      data() const noexcept
      { return this->_M_str; }



      constexpr void
      remove_prefix(size_type __n) noexcept
      {
 ;
 this->_M_str += __n;
 this->_M_len -= __n;
      }

      constexpr void
      remove_suffix(size_type __n) noexcept
      { this->_M_len -= __n; }

      constexpr void
      swap(basic_string_view& __sv) noexcept
      {
 auto __tmp = *this;
 *this = __sv;
 __sv = __tmp;
      }



      size_type
      copy(_CharT* __str, size_type __n, size_type __pos = 0) const
      {
 ;
 __pos = std::__sv_check(size(), __pos, "basic_string_view::copy");
 const size_type __rlen = std::min(__n, _M_len - __pos);


 traits_type::copy(__str, data() + __pos, __rlen);
 return __rlen;
      }

      constexpr basic_string_view
      substr(size_type __pos = 0, size_type __n = npos) const noexcept(false)
      {
 __pos = std::__sv_check(size(), __pos, "basic_string_view::substr");
 const size_type __rlen = std::min(__n, _M_len - __pos);
 return basic_string_view{_M_str + __pos, __rlen};
      }

      constexpr int
      compare(basic_string_view __str) const noexcept
      {
 const size_type __rlen = std::min(this->_M_len, __str._M_len);
 int __ret = traits_type::compare(this->_M_str, __str._M_str, __rlen);
 if (__ret == 0)
   __ret = _S_compare(this->_M_len, __str._M_len);
 return __ret;
      }

      constexpr int
      compare(size_type __pos1, size_type __n1, basic_string_view __str) const
      { return this->substr(__pos1, __n1).compare(__str); }

      constexpr int
      compare(size_type __pos1, size_type __n1,
       basic_string_view __str, size_type __pos2, size_type __n2) const
      {
 return this->substr(__pos1, __n1).compare(__str.substr(__pos2, __n2));
      }

      __attribute__((__nonnull__)) constexpr int
      compare(const _CharT* __str) const noexcept
      { return this->compare(basic_string_view{__str}); }

      __attribute__((__nonnull__)) constexpr int
      compare(size_type __pos1, size_type __n1, const _CharT* __str) const
      { return this->substr(__pos1, __n1).compare(basic_string_view{__str}); }

      constexpr int
      compare(size_type __pos1, size_type __n1,
       const _CharT* __str, size_type __n2) const noexcept(false)
      {
 return this->substr(__pos1, __n1)
     .compare(basic_string_view(__str, __n2));
      }


      constexpr bool
      starts_with(basic_string_view __x) const noexcept
      { return this->substr(0, __x.size()) == __x; }

      constexpr bool
      starts_with(_CharT __x) const noexcept
      { return !this->empty() && traits_type::eq(this->front(), __x); }

      constexpr bool
      starts_with(const _CharT* __x) const noexcept
      { return this->starts_with(basic_string_view(__x)); }

      constexpr bool
      ends_with(basic_string_view __x) const noexcept
      {
 return this->size() >= __x.size()
     && this->compare(this->size() - __x.size(), npos, __x) == 0;
      }

      constexpr bool
      ends_with(_CharT __x) const noexcept
      { return !this->empty() && traits_type::eq(this->back(), __x); }

      constexpr bool
      ends_with(const _CharT* __x) const noexcept
      { return this->ends_with(basic_string_view(__x)); }




      constexpr size_type
      find(basic_string_view __str, size_type __pos = 0) const noexcept
      { return this->find(__str._M_str, __pos, __str._M_len); }

      constexpr size_type
      find(_CharT __c, size_type __pos = 0) const noexcept;

      constexpr size_type
      find(const _CharT* __str, size_type __pos, size_type __n) const noexcept;

      __attribute__((__nonnull__)) constexpr size_type
      find(const _CharT* __str, size_type __pos = 0) const noexcept
      { return this->find(__str, __pos, traits_type::length(__str)); }

      constexpr size_type
      rfind(basic_string_view __str, size_type __pos = npos) const noexcept
      { return this->rfind(__str._M_str, __pos, __str._M_len); }

      constexpr size_type
      rfind(_CharT __c, size_type __pos = npos) const noexcept;

      constexpr size_type
      rfind(const _CharT* __str, size_type __pos, size_type __n) const noexcept;

      __attribute__((__nonnull__)) constexpr size_type
      rfind(const _CharT* __str, size_type __pos = npos) const noexcept
      { return this->rfind(__str, __pos, traits_type::length(__str)); }

      constexpr size_type
      find_first_of(basic_string_view __str, size_type __pos = 0) const noexcept
      { return this->find_first_of(__str._M_str, __pos, __str._M_len); }

      constexpr size_type
      find_first_of(_CharT __c, size_type __pos = 0) const noexcept
      { return this->find(__c, __pos); }

      constexpr size_type
      find_first_of(const _CharT* __str, size_type __pos,
      size_type __n) const noexcept;

      __attribute__((__nonnull__)) constexpr size_type
      find_first_of(const _CharT* __str, size_type __pos = 0) const noexcept
      { return this->find_first_of(__str, __pos, traits_type::length(__str)); }

      constexpr size_type
      find_last_of(basic_string_view __str,
     size_type __pos = npos) const noexcept
      { return this->find_last_of(__str._M_str, __pos, __str._M_len); }

      constexpr size_type
      find_last_of(_CharT __c, size_type __pos=npos) const noexcept
      { return this->rfind(__c, __pos); }

      constexpr size_type
      find_last_of(const _CharT* __str, size_type __pos,
     size_type __n) const noexcept;

      __attribute__((__nonnull__)) constexpr size_type
      find_last_of(const _CharT* __str, size_type __pos = npos) const noexcept
      { return this->find_last_of(__str, __pos, traits_type::length(__str)); }

      constexpr size_type
      find_first_not_of(basic_string_view __str,
   size_type __pos = 0) const noexcept
      { return this->find_first_not_of(__str._M_str, __pos, __str._M_len); }

      constexpr size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const noexcept;

      constexpr size_type
      find_first_not_of(const _CharT* __str,
   size_type __pos, size_type __n) const noexcept;

      __attribute__((__nonnull__)) constexpr size_type
      find_first_not_of(const _CharT* __str, size_type __pos = 0) const noexcept
      {
 return this->find_first_not_of(__str, __pos,
           traits_type::length(__str));
      }

      constexpr size_type
      find_last_not_of(basic_string_view __str,
         size_type __pos = npos) const noexcept
      { return this->find_last_not_of(__str._M_str, __pos, __str._M_len); }

      constexpr size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const noexcept;

      constexpr size_type
      find_last_not_of(const _CharT* __str,
         size_type __pos, size_type __n) const noexcept;

      __attribute__((__nonnull__)) constexpr size_type
      find_last_not_of(const _CharT* __str,
         size_type __pos = npos) const noexcept
      {
 return this->find_last_not_of(__str, __pos,
          traits_type::length(__str));
      }

    private:

      static constexpr int
      _S_compare(size_type __n1, size_type __n2) noexcept
      {
 const difference_type __diff = __n1 - __n2;
 if (__diff > std::numeric_limits<int>::max())
   return std::numeric_limits<int>::max();
 if (__diff < std::numeric_limits<int>::min())
   return std::numeric_limits<int>::min();
 return static_cast<int>(__diff);
      }

      size_t _M_len;
      const _CharT* _M_str;
    };


  template<contiguous_iterator _It, sized_sentinel_for<_It> _End>
    basic_string_view(_It, _End) -> basic_string_view<iter_value_t<_It>>;
# 482 "/usr/local/include/c++/10.0.0/string_view" 3
  template<typename _CharT, typename _Traits>
    constexpr bool
    operator==(basic_string_view<_CharT, _Traits> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return __x.size() == __y.size() && __x.compare(__y) == 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator==(basic_string_view<_CharT, _Traits> __x,
               __type_identity_t<basic_string_view<_CharT, _Traits>> __y)
    noexcept
    { return __x.size() == __y.size() && __x.compare(__y) == 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator==(__type_identity_t<basic_string_view<_CharT, _Traits>> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return __x.size() == __y.size() && __x.compare(__y) == 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator!=(basic_string_view<_CharT, _Traits> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return !(__x == __y); }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator!=(basic_string_view<_CharT, _Traits> __x,
               __type_identity_t<basic_string_view<_CharT, _Traits>> __y)
    noexcept
    { return !(__x == __y); }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator!=(__type_identity_t<basic_string_view<_CharT, _Traits>> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return !(__x == __y); }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator< (basic_string_view<_CharT, _Traits> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return __x.compare(__y) < 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator< (basic_string_view<_CharT, _Traits> __x,
               __type_identity_t<basic_string_view<_CharT, _Traits>> __y)
    noexcept
    { return __x.compare(__y) < 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator< (__type_identity_t<basic_string_view<_CharT, _Traits>> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return __x.compare(__y) < 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator> (basic_string_view<_CharT, _Traits> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return __x.compare(__y) > 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator> (basic_string_view<_CharT, _Traits> __x,
               __type_identity_t<basic_string_view<_CharT, _Traits>> __y)
    noexcept
    { return __x.compare(__y) > 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator> (__type_identity_t<basic_string_view<_CharT, _Traits>> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return __x.compare(__y) > 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator<=(basic_string_view<_CharT, _Traits> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return __x.compare(__y) <= 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator<=(basic_string_view<_CharT, _Traits> __x,
               __type_identity_t<basic_string_view<_CharT, _Traits>> __y)
    noexcept
    { return __x.compare(__y) <= 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator<=(__type_identity_t<basic_string_view<_CharT, _Traits>> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return __x.compare(__y) <= 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator>=(basic_string_view<_CharT, _Traits> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return __x.compare(__y) >= 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator>=(basic_string_view<_CharT, _Traits> __x,
               __type_identity_t<basic_string_view<_CharT, _Traits>> __y)
    noexcept
    { return __x.compare(__y) >= 0; }

  template<typename _CharT, typename _Traits>
    constexpr bool
    operator>=(__type_identity_t<basic_string_view<_CharT, _Traits>> __x,
               basic_string_view<_CharT, _Traits> __y) noexcept
    { return __x.compare(__y) >= 0; }


  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        basic_string_view<_CharT,_Traits> __str)
    { return __ostream_insert(__os, __str.data(), __str.size()); }




  using string_view = basic_string_view<char>;

  using wstring_view = basic_string_view<wchar_t>;


  using u8string_view = basic_string_view<char8_t>;

  using u16string_view = basic_string_view<char16_t>;
  using u32string_view = basic_string_view<char32_t>;



  template<typename _Tp>
    struct hash;

  template<>
    struct hash<string_view>
    : public __hash_base<size_t, string_view>
    {
      size_t
      operator()(const string_view& __str) const noexcept
      { return std::_Hash_impl::hash(__str.data(), __str.length()); }
    };

  template<>
    struct __is_fast_hash<hash<string_view>> : std::false_type
    { };


  template<>
    struct hash<wstring_view>
    : public __hash_base<size_t, wstring_view>
    {
      size_t
      operator()(const wstring_view& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(wchar_t)); }
    };

  template<>
    struct __is_fast_hash<hash<wstring_view>> : std::false_type
    { };



  template<>
    struct hash<u8string_view>
    : public __hash_base<size_t, u8string_view>
    {
      size_t
      operator()(const u8string_view& __str) const noexcept
      { return std::_Hash_impl::hash(__str.data(), __str.length()); }
    };

  template<>
    struct __is_fast_hash<hash<u8string_view>> : std::false_type
    { };


  template<>
    struct hash<u16string_view>
    : public __hash_base<size_t, u16string_view>
    {
      size_t
      operator()(const u16string_view& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char16_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u16string_view>> : std::false_type
    { };

  template<>
    struct hash<u32string_view>
    : public __hash_base<size_t, u32string_view>
    {
      size_t
      operator()(const u32string_view& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char32_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u32string_view>> : std::false_type
    { };

  inline namespace literals
  {
  inline namespace string_view_literals
  {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wliteral-suffix"
    inline constexpr basic_string_view<char>
    operator""sv(const char* __str, size_t __len) noexcept
    { return basic_string_view<char>{__str, __len}; }


    inline constexpr basic_string_view<wchar_t>
    operator""sv(const wchar_t* __str, size_t __len) noexcept
    { return basic_string_view<wchar_t>{__str, __len}; }



    inline constexpr basic_string_view<char8_t>
    operator""sv(const char8_t* __str, size_t __len) noexcept
    { return basic_string_view<char8_t>{__str, __len}; }


    inline constexpr basic_string_view<char16_t>
    operator""sv(const char16_t* __str, size_t __len) noexcept
    { return basic_string_view<char16_t>{__str, __len}; }

    inline constexpr basic_string_view<char32_t>
    operator""sv(const char32_t* __str, size_t __len) noexcept
    { return basic_string_view<char32_t>{__str, __len}; }

#pragma GCC diagnostic pop
  }
  }


  namespace ranges
  {
    template<typename> extern inline const bool enable_safe_range;

    template<typename _CharT, typename _Traits>
      inline constexpr bool
 enable_safe_range<basic_string_view<_CharT, _Traits>> = true;
  }


}

# 1 "/usr/local/include/c++/10.0.0/bits/string_view.tcc" 1 3
# 37 "/usr/local/include/c++/10.0.0/bits/string_view.tcc" 3
       
# 38 "/usr/local/include/c++/10.0.0/bits/string_view.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    find(const _CharT* __str, size_type __pos, size_type __n) const noexcept
    {
      ;

      if (__n == 0)
 return __pos <= this->_M_len ? __pos : npos;

      if (__n <= this->_M_len)
 {
   for (; __pos <= this->_M_len - __n; ++__pos)
     if (traits_type::eq(this->_M_str[__pos], __str[0])
  && traits_type::compare(this->_M_str + __pos + 1,
     __str + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    find(_CharT __c, size_type __pos) const noexcept
    {
      size_type __ret = npos;
      if (__pos < this->_M_len)
 {
   const size_type __n = this->_M_len - __pos;
   const _CharT* __p = traits_type::find(this->_M_str + __pos, __n, __c);
   if (__p)
     __ret = __p - this->_M_str;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    rfind(const _CharT* __str, size_type __pos, size_type __n) const noexcept
    {
      ;

      if (__n <= this->_M_len)
 {
   __pos = std::min(size_type(this->_M_len - __n), __pos);
   do
     {
       if (traits_type::compare(this->_M_str + __pos, __str, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    rfind(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->_M_len;
      if (__size > 0)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(this->_M_str[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    find_first_of(const _CharT* __str, size_type __pos,
    size_type __n) const noexcept
    {
      ;
      for (; __n && __pos < this->_M_len; ++__pos)
 {
   const _CharT* __p = traits_type::find(__str, __n,
      this->_M_str[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    find_last_of(const _CharT* __str, size_type __pos,
   size_type __n) const noexcept
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__str, __n, this->_M_str[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    find_first_not_of(const _CharT* __str, size_type __pos,
        size_type __n) const noexcept
    {
      ;
      for (; __pos < this->_M_len; ++__pos)
 if (!traits_type::find(__str, __n, this->_M_str[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    find_first_not_of(_CharT __c, size_type __pos) const noexcept
    {
      for (; __pos < this->_M_len; ++__pos)
 if (!traits_type::eq(this->_M_str[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    find_last_not_of(const _CharT* __str, size_type __pos,
       size_type __n) const noexcept
    {
      ;
      size_type __size = this->_M_len;
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__str, __n, this->_M_str[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits>
    constexpr typename basic_string_view<_CharT, _Traits>::size_type
    basic_string_view<_CharT, _Traits>::
    find_last_not_of(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->_M_len;
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(this->_M_str[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }


}
# 741 "/usr/local/include/c++/10.0.0/string_view" 2 3
# 23 "fast_io/fast_io_core.h" 2
# 1 "/usr/local/include/c++/10.0.0/iterator" 1 3
# 58 "/usr/local/include/c++/10.0.0/iterator" 3
       
# 59 "/usr/local/include/c++/10.0.0/iterator" 3






# 1 "/usr/local/include/c++/10.0.0/bits/stream_iterator.h" 1 3
# 33 "/usr/local/include/c++/10.0.0/bits/stream_iterator.h" 3
       
# 34 "/usr/local/include/c++/10.0.0/bits/stream_iterator.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{








  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT>, typename _Dist = ptrdiff_t>
    class istream_iterator
    : public iterator<input_iterator_tag, _Tp, _Dist, const _Tp*, const _Tp&>
    {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_istream<_CharT, _Traits> istream_type;

    private:
      istream_type* _M_stream;
      _Tp _M_value;



      bool _M_ok;

    public:

      constexpr istream_iterator()
      : _M_stream(0), _M_value(), _M_ok(false) {}


      istream_iterator(istream_type& __s)
      : _M_stream(std::__addressof(__s)), _M_ok(true)
      { _M_read(); }

      istream_iterator(const istream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_value(__obj._M_value),
        _M_ok(__obj._M_ok)
      { }


      istream_iterator& operator=(const istream_iterator&) = default;
      ~istream_iterator() = default;


      const _Tp&
      operator*() const
      {


                        ;
 return _M_value;
      }

      const _Tp*
      operator->() const { return std::__addressof((operator*())); }

      istream_iterator&
      operator++()
      {


                        ;
 _M_read();
 return *this;
      }

      istream_iterator
      operator++(int)
      {


                        ;
 istream_iterator __tmp = *this;
 _M_read();
 return __tmp;
      }

    private:
      bool
      _M_equal(const istream_iterator& __x) const
      {


 return (_M_ok == __x._M_ok) && (!_M_ok || _M_stream == __x._M_stream);
      }

      void
      _M_read()
      {
        if (_M_stream && !(*_M_stream >> _M_value))
          {
            _M_stream = 0;
            _M_ok = false;
          }
      }



      friend bool
      operator==(const istream_iterator& __x, const istream_iterator& __y)
      { return __x._M_equal(__y); }



      friend bool
      operator!=(const istream_iterator& __x, const istream_iterator& __y)
      { return !__x._M_equal(__y); }
    };
# 161 "/usr/local/include/c++/10.0.0/bits/stream_iterator.h" 3
  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT> >
    class ostream_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:


      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


    private:
      ostream_type* _M_stream;
      const _CharT* _M_string;

    public:

      constexpr ostream_iterator() noexcept
      : _M_stream(nullptr), _M_string(nullptr) { }



      ostream_iterator(ostream_type& __s)
      : _M_stream(std::__addressof(__s)), _M_string(0) {}
# 198 "/usr/local/include/c++/10.0.0/bits/stream_iterator.h" 3
      ostream_iterator(ostream_type& __s, const _CharT* __c)
      : _M_stream(std::__addressof(__s)), _M_string(__c) { }


      ostream_iterator(const ostream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_string(__obj._M_string) { }


      ostream_iterator& operator=(const ostream_iterator&) = default;




      ostream_iterator&
      operator=(const _Tp& __value)
      {


                        ;
 *_M_stream << __value;
 if (_M_string)
          *_M_stream << _M_string;
 return *this;
      }

      ostream_iterator&
      operator*()
      { return *this; }

      ostream_iterator&
      operator++()
      { return *this; }

      ostream_iterator&
      operator++(int)
      { return *this; }
    };




}
# 66 "/usr/local/include/c++/10.0.0/iterator" 2 3
# 1 "/usr/local/include/c++/10.0.0/bits/streambuf_iterator.h" 1 3
# 33 "/usr/local/include/c++/10.0.0/bits/streambuf_iterator.h" 3
       
# 34 "/usr/local/include/c++/10.0.0/bits/streambuf_iterator.h" 3

# 1 "/usr/local/include/c++/10.0.0/streambuf" 1 3
# 36 "/usr/local/include/c++/10.0.0/streambuf" 3
       
# 37 "/usr/local/include/c++/10.0.0/streambuf" 3



# 1 "/usr/local/include/c++/10.0.0/bits/localefwd.h" 1 3
# 37 "/usr/local/include/c++/10.0.0/bits/localefwd.h" 3
       
# 38 "/usr/local/include/c++/10.0.0/bits/localefwd.h" 3


# 1 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/c++locale.h" 1 3
# 39 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/c++locale.h" 3
       
# 40 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/c++locale.h" 3

# 1 "/usr/local/include/c++/10.0.0/clocale" 1 3
# 39 "/usr/local/include/c++/10.0.0/clocale" 3
       
# 40 "/usr/local/include/c++/10.0.0/clocale" 3


# 1 "/usr/include/locale.h" 1 3 4
# 28 "/usr/include/locale.h" 3 4
# 1 "/usr/local/lib/gcc/x86_64-pc-linux-gnu/10.0.0/include/stddef.h" 1 3 4
# 29 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/locale.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4

extern "C" {
# 51 "/usr/include/locale.h" 3 4
struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 118 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, const char *__locale) throw ();


extern struct lconv *localeconv (void) throw ();
# 141 "/usr/include/locale.h" 3 4
extern locale_t newlocale (int __category_mask, const char *__locale,
      locale_t __base) throw ();
# 176 "/usr/include/locale.h" 3 4
extern locale_t duplocale (locale_t __dataset) throw ();



extern void freelocale (locale_t __dataset) throw ();






extern locale_t uselocale (locale_t __dataset) throw ();







}
# 43 "/usr/local/include/c++/10.0.0/clocale" 2 3
# 51 "/usr/local/include/c++/10.0.0/clocale" 3
namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
# 42 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/c++locale.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  extern "C" __typeof(uselocale) __uselocale;


}


namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef __locale_t __c_locale;





  inline int
  __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),
     char* __out,
     const int __size __attribute__ ((__unused__)),
     const char* __fmt, ...)
  {

    __c_locale __old = __gnu_cxx::__uselocale(__cloc);
# 88 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/c++locale.h" 3
    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);


    __gnu_cxx::__uselocale(__old);







    return __ret;
  }


}
# 41 "/usr/local/include/c++/10.0.0/bits/localefwd.h" 2 3

# 1 "/usr/local/include/c++/10.0.0/cctype" 1 3
# 39 "/usr/local/include/c++/10.0.0/cctype" 3
       
# 40 "/usr/local/include/c++/10.0.0/cctype" 3


# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4
extern "C" {
# 46 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     throw () __attribute__ ((__const__));
# 108 "/usr/include/ctype.h" 3 4
extern int isalnum (int) throw ();
extern int isalpha (int) throw ();
extern int iscntrl (int) throw ();
extern int isdigit (int) throw ();
extern int islower (int) throw ();
extern int isgraph (int) throw ();
extern int isprint (int) throw ();
extern int ispunct (int) throw ();
extern int isspace (int) throw ();
extern int isupper (int) throw ();
extern int isxdigit (int) throw ();



extern int tolower (int __c) throw ();


extern int toupper (int __c) throw ();




extern int isblank (int) throw ();




extern int isctype (int __c, int __mask) throw ();






extern int isascii (int __c) throw ();



extern int toascii (int __c) throw ();



extern int _toupper (int) throw ();
extern int _tolower (int) throw ();
# 251 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, locale_t) throw ();
extern int isalpha_l (int, locale_t) throw ();
extern int iscntrl_l (int, locale_t) throw ();
extern int isdigit_l (int, locale_t) throw ();
extern int islower_l (int, locale_t) throw ();
extern int isgraph_l (int, locale_t) throw ();
extern int isprint_l (int, locale_t) throw ();
extern int ispunct_l (int, locale_t) throw ();
extern int isspace_l (int, locale_t) throw ();
extern int isupper_l (int, locale_t) throw ();
extern int isxdigit_l (int, locale_t) throw ();

extern int isblank_l (int, locale_t) throw ();



extern int __tolower_l (int __c, locale_t __l) throw ();
extern int tolower_l (int __c, locale_t __l) throw ();


extern int __toupper_l (int __c, locale_t __l) throw ();
extern int toupper_l (int __c, locale_t __l) throw ();
# 327 "/usr/include/ctype.h" 3 4
}
# 43 "/usr/local/include/c++/10.0.0/cctype" 2 3
# 62 "/usr/local/include/c++/10.0.0/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}







namespace std
{
  using ::isblank;
}
# 43 "/usr/local/include/c++/10.0.0/bits/localefwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 55 "/usr/local/include/c++/10.0.0/bits/localefwd.h" 3
  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);


  template<typename _CharT>
    bool
    isblank(_CharT, const locale&);


  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;


  template<> class codecvt<char16_t, char, mbstate_t>;
  template<> class codecvt<char32_t, char, mbstate_t>;

  template<> class codecvt<char16_t, char8_t, mbstate_t>;
  template<> class codecvt<char32_t, char8_t, mbstate_t>;


  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

namespace __cxx11 {
  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;
}

namespace __cxx11 {

  template<typename _CharT>
    class collate;
  template<typename _CharT>
    class collate_byname;
}


  class time_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
}
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;
}
namespace __cxx11 {
  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;
}


  class messages_base;
namespace __cxx11 {
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;
}


}
# 41 "/usr/local/include/c++/10.0.0/streambuf" 2 3
# 1 "/usr/local/include/c++/10.0.0/bits/ios_base.h" 1 3
# 37 "/usr/local/include/c++/10.0.0/bits/ios_base.h" 3
       
# 38 "/usr/local/include/c++/10.0.0/bits/ios_base.h" 3



# 1 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 1 3
# 37 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 3
       
# 38 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 3


# 1 "/usr/local/include/c++/10.0.0/string" 1 3
# 36 "/usr/local/include/c++/10.0.0/string" 3
       
# 37 "/usr/local/include/c++/10.0.0/string" 3







# 1 "/usr/local/include/c++/10.0.0/bits/ostream_insert.h" 1 3
# 33 "/usr/local/include/c++/10.0.0/bits/ostream_insert.h" 3
       
# 34 "/usr/local/include/c++/10.0.0/bits/ostream_insert.h" 3


# 1 "/usr/local/include/c++/10.0.0/bits/cxxabi_forced.h" 1 3
# 34 "/usr/local/include/c++/10.0.0/bits/cxxabi_forced.h" 3
       
# 35 "/usr/local/include/c++/10.0.0/bits/cxxabi_forced.h" 3

#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();


    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
# 37 "/usr/local/include/c++/10.0.0/bits/ostream_insert.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }




  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);




}
# 45 "/usr/local/include/c++/10.0.0/string" 2 3







# 1 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 1 3
# 59 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
# 1 "/usr/local/include/c++/10.0.0/cstdlib" 1 3
# 39 "/usr/local/include/c++/10.0.0/cstdlib" 3
       
# 40 "/usr/local/include/c++/10.0.0/cstdlib" 3
# 75 "/usr/local/include/c++/10.0.0/cstdlib" 3
# 1 "/usr/include/stdlib.h" 1 3 4
# 25 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 26 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/local/lib/gcc/x86_64-pc-linux-gnu/10.0.0/include/stddef.h" 1 3 4
# 32 "/usr/include/stdlib.h" 2 3 4

extern "C" {





# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 40 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 58 "/usr/include/stdlib.h" 3 4
typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 97 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) throw () ;



extern double atof (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));
# 140 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float64 strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float128 strtof128 (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float32x strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));



extern _Float64x strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));
# 176 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     throw () __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     throw () __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     throw () __attribute__ ((__nonnull__ (3)));
# 232 "/usr/include/stdlib.h" 3 4
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         _Float32 __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         _Float64 __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf128 (char *__dest, size_t __size, const char * __format,
   _Float128 __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   _Float32x __f)
     throw () __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   _Float64x __f)
     throw () __attribute__ ((__nonnull__ (3)));
# 274 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));
# 316 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float64 strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float128 strtof128_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float32x strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern _Float64x strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));
# 360 "/usr/include/stdlib.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) atoi (const char *__nptr) throw ()
{
  return (int) strtol (__nptr, (char **) __null, 10);
}
extern __inline __attribute__ ((__gnu_inline__)) long int
__attribute__ ((__leaf__)) atol (const char *__nptr) throw ()
{
  return strtol (__nptr, (char **) __null, 10);
}


__extension__ extern __inline __attribute__ ((__gnu_inline__)) long long int
__attribute__ ((__leaf__)) atoll (const char *__nptr) throw ()
{
  return strtoll (__nptr, (char **) __null, 10);
}
# 385 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw () ;


extern long int a64l (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;
# 104 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 135 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/local/lib/gcc/x86_64-pc-linux-gnu/10.0.0/include/stddef.h" 1 3 4
# 146 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 178 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 197 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 49 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern "C" {
# 101 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 113 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 126 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
}
# 198 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 1 3 4
# 41 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sysmacros.h" 1 3 4
# 42 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 2 3 4
# 71 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
extern "C" {

extern unsigned int gnu_dev_major (__dev_t __dev) throw () __attribute__ ((__const__));
extern unsigned int gnu_dev_minor (__dev_t __dev) throw () __attribute__ ((__const__));
extern __dev_t gnu_dev_makedev (unsigned int __major, unsigned int __minor) throw () __attribute__ ((__const__));



__extension__ extern __inline __attribute__ ((__gnu_inline__)) __attribute__ ((__const__)) unsigned int __attribute__ ((__leaf__)) gnu_dev_major (__dev_t __dev) throw () { unsigned int __major; __major = ((__dev & (__dev_t) 0x00000000000fff00u) >> 8); __major |= ((__dev & (__dev_t) 0xfffff00000000000u) >> 32); return __major; }
__extension__ extern __inline __attribute__ ((__gnu_inline__)) __attribute__ ((__const__)) unsigned int __attribute__ ((__leaf__)) gnu_dev_minor (__dev_t __dev) throw () { unsigned int __minor; __minor = ((__dev & (__dev_t) 0x00000000000000ffu) >> 0); __minor |= ((__dev & (__dev_t) 0x00000ffffff00000u) >> 12); return __minor; }
__extension__ extern __inline __attribute__ ((__gnu_inline__)) __attribute__ ((__const__)) __dev_t __attribute__ ((__leaf__)) gnu_dev_makedev (unsigned int __major, unsigned int __minor) throw () { __dev_t __dev; __dev = (((__dev_t) (__major & 0x00000fffu)) << 8); __dev |= (((__dev_t) (__major & 0xfffff000u)) << 32); __dev |= (((__dev_t) (__minor & 0x000000ffu)) << 0); __dev |= (((__dev_t) (__minor & 0xffffff00u)) << 12); return __dev; }



}
# 206 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4






typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 246 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;
# 257 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
}
# 395 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();



extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) ;






extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));



extern void free (void *__ptr) throw ();


# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/local/lib/gcc/x86_64-pc-linux-gnu/10.0.0/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();





}
# 567 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) ;



extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));




extern "C++" int at_quick_exit (void (*__func) (void))
     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));
# 607 "/usr/include/stdlib.h" 3 4
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) throw () __attribute__ ((__noreturn__));





extern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));





extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;




extern char *secure_getenv (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) throw () __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) throw ();
# 672 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1)));
# 685 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 695 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 707 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 717 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 728 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 739 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 749 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 759 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 771 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 781 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;





extern char *canonicalize_file_name (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 797 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) throw () ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;


# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) void *
bsearch (const void *__key, const void *__base, size_t __nmemb, size_t __size,
  __compar_fn_t __compar)
{
  size_t __l, __u, __idx;
  const void *__p;
  int __comparison;

  __l = 0;
  __u = __nmemb;
  while (__l < __u)
    {
      __idx = (__l + __u) / 2;
      __p = (void *) (((const char *) __base) + (__idx * __size));
      __comparison = (*__compar) (__key, __p);
      if (__comparison < 0)
 __u = __idx;
      else if (__comparison > 0)
 __l = __idx + 1;
      else
 return (void *) __p;
    }

  return __null;
}
# 823 "/usr/include/stdlib.h" 2 3 4




extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) throw () __attribute__ ((__const__)) ;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) ;
# 869 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) throw ();


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) throw ();


extern int wctomb (char *__s, wchar_t __wchar) throw ();



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     throw ();







extern int rpmatch (const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
# 954 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (const char *__key) throw () __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));
# 1016 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) double
__attribute__ ((__leaf__)) atof (const char *__nptr) throw ()
{
  return strtod (__nptr, (char **) __null);
}
# 1017 "/usr/include/stdlib.h" 2 3 4
# 1026 "/usr/include/stdlib.h" 3 4
}
# 76 "/usr/local/include/c++/10.0.0/cstdlib" 2 3

# 1 "/usr/local/include/c++/10.0.0/bits/std_abs.h" 1 3
# 33 "/usr/local/include/c++/10.0.0/bits/std_abs.h" 3
       
# 34 "/usr/local/include/c++/10.0.0/bits/std_abs.h" 3
# 46 "/usr/local/include/c++/10.0.0/bits/std_abs.h" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::abs;


  inline long
  abs(long __i) { return __builtin_labs(__i); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }
# 70 "/usr/local/include/c++/10.0.0/bits/std_abs.h" 3
  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }
# 107 "/usr/local/include/c++/10.0.0/bits/std_abs.h" 3

}
}
# 78 "/usr/local/include/c++/10.0.0/cstdlib" 2 3
# 121 "/usr/local/include/c++/10.0.0/cstdlib" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;

  using ::aligned_alloc;

  using ::atexit;


  using ::at_quick_exit;


  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;


  using ::quick_exit;


  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }




}
# 195 "/usr/local/include/c++/10.0.0/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 227 "/usr/local/include/c++/10.0.0/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}



}
# 60 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 2 3
# 1 "/usr/local/include/c++/10.0.0/bits/algorithmfwd.h" 1 3
# 33 "/usr/local/include/c++/10.0.0/bits/algorithmfwd.h" 3
       
# 34 "/usr/local/include/c++/10.0.0/bits/algorithmfwd.h" 3
# 42 "/usr/local/include/c++/10.0.0/bits/algorithmfwd.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 199 "/usr/local/include/c++/10.0.0/bits/algorithmfwd.h" 3
  template<typename _IIter, typename _Predicate>
    constexpr
    bool
    all_of(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Predicate>
    constexpr
    bool
    any_of(_IIter, _IIter, _Predicate);


  template<typename _FIter, typename _Tp>
    constexpr
    bool
    binary_search(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    constexpr
    bool
    binary_search(_FIter, _FIter, const _Tp&, _Compare);


  template<typename _Tp>
    constexpr
    const _Tp&
    clamp(const _Tp&, const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    const _Tp&
    clamp(const _Tp&, const _Tp&, const _Tp&, _Compare);


  template<typename _IIter, typename _OIter>
    constexpr
    _OIter
    copy(_IIter, _IIter, _OIter);

  template<typename _BIter1, typename _BIter2>
    constexpr
    _BIter2
    copy_backward(_BIter1, _BIter1, _BIter2);


  template<typename _IIter, typename _OIter, typename _Predicate>
    constexpr
    _OIter
    copy_if(_IIter, _IIter, _OIter, _Predicate);

  template<typename _IIter, typename _Size, typename _OIter>
    constexpr
    _OIter
    copy_n(_IIter, _Size, _OIter);





  template<typename _FIter, typename _Tp>
    constexpr
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    constexpr
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _FIter, typename _Tp>
    constexpr
    void
    fill(_FIter, _FIter, const _Tp&);

  template<typename _OIter, typename _Size, typename _Tp>
    constexpr
    _OIter
    fill_n(_OIter, _Size, const _Tp&);



  template<typename _FIter1, typename _FIter2>
    constexpr
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    constexpr
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);





  template<typename _IIter, typename _Predicate>
    constexpr
    _IIter
    find_if_not(_IIter, _IIter, _Predicate);






  template<typename _IIter1, typename _IIter2>
    constexpr
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    constexpr
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _BIter>
    void
    inplace_merge(_BIter, _BIter, _BIter);

  template<typename _BIter, typename _Compare>
    void
    inplace_merge(_BIter, _BIter, _BIter, _Compare);


  template<typename _RAIter>
    constexpr
    bool
    is_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    constexpr
    bool
    is_heap(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    constexpr
    _RAIter
    is_heap_until(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    constexpr
    _RAIter
    is_heap_until(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _Predicate>
    constexpr
    bool
    is_partitioned(_IIter, _IIter, _Predicate);

  template<typename _FIter1, typename _FIter2>
    constexpr
    bool
    is_permutation(_FIter1, _FIter1, _FIter2);

  template<typename _FIter1, typename _FIter2,
    typename _BinaryPredicate>
    constexpr
    bool
    is_permutation(_FIter1, _FIter1, _FIter2, _BinaryPredicate);

  template<typename _FIter>
    constexpr
    bool
    is_sorted(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    bool
    is_sorted(_FIter, _FIter, _Compare);

  template<typename _FIter>
    constexpr
    _FIter
    is_sorted_until(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    _FIter
    is_sorted_until(_FIter, _FIter, _Compare);


  template<typename _FIter1, typename _FIter2>
    constexpr
    void
    iter_swap(_FIter1, _FIter2);

  template<typename _FIter, typename _Tp>
    constexpr
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    constexpr
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _RAIter>
    constexpr
    void
    make_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    constexpr
    void
    make_heap(_RAIter, _RAIter, _Compare);

  template<typename _Tp>
    constexpr
    const _Tp&
    max(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    const _Tp&
    max(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    constexpr
    const _Tp&
    min(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    const _Tp&
    min(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    constexpr
    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&, _Compare);

  template<typename _FIter>
    constexpr
    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter, _Compare);

  template<typename _Tp>
    constexpr
    _Tp
    min(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    constexpr
    _Tp
    min(initializer_list<_Tp>, _Compare);

  template<typename _Tp>
    constexpr
    _Tp
    max(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    constexpr
    _Tp
    max(initializer_list<_Tp>, _Compare);

  template<typename _Tp>
    constexpr
    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    constexpr
    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>, _Compare);




  template<typename _BIter>
    constexpr
    bool
    next_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    constexpr
    bool
    next_permutation(_BIter, _BIter, _Compare);


  template<typename _IIter, typename _Predicate>
    constexpr
    bool
    none_of(_IIter, _IIter, _Predicate);





  template<typename _IIter, typename _RAIter>
    constexpr
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter);

  template<typename _IIter, typename _RAIter, typename _Compare>
    constexpr
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter, _Compare);




  template<typename _IIter, typename _OIter1,
    typename _OIter2, typename _Predicate>
    constexpr
    pair<_OIter1, _OIter2>
    partition_copy(_IIter, _IIter, _OIter1, _OIter2, _Predicate);

  template<typename _FIter, typename _Predicate>
    constexpr
    _FIter
    partition_point(_FIter, _FIter, _Predicate);


  template<typename _RAIter>
    constexpr
    void
    pop_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    constexpr
    void
    pop_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter>
    constexpr
    bool
    prev_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    constexpr
    bool
    prev_permutation(_BIter, _BIter, _Compare);

  template<typename _RAIter>
    constexpr
    void
    push_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    constexpr
    void
    push_heap(_RAIter, _RAIter, _Compare);



  template<typename _FIter, typename _Tp>
    constexpr
    _FIter
    remove(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Predicate>
    constexpr
    _FIter
    remove_if(_FIter, _FIter, _Predicate);

  template<typename _IIter, typename _OIter, typename _Tp>
    constexpr
    _OIter
    remove_copy(_IIter, _IIter, _OIter, const _Tp&);

  template<typename _IIter, typename _OIter, typename _Predicate>
    constexpr
    _OIter
    remove_copy_if(_IIter, _IIter, _OIter, _Predicate);



  template<typename _IIter, typename _OIter, typename _Tp>
    constexpr
    _OIter
    replace_copy(_IIter, _IIter, _OIter, const _Tp&, const _Tp&);

  template<typename _Iter, typename _OIter, typename _Predicate, typename _Tp>
    constexpr
    _OIter
    replace_copy_if(_Iter, _Iter, _OIter, _Predicate, const _Tp&);



  template<typename _BIter>
    constexpr
    void
    reverse(_BIter, _BIter);

  template<typename _BIter, typename _OIter>
    constexpr
    _OIter
    reverse_copy(_BIter, _BIter, _OIter);

  inline namespace _V2
  {
    template<typename _FIter>
      constexpr
      _FIter
      rotate(_FIter, _FIter, _FIter);
  }

  template<typename _FIter, typename _OIter>
    constexpr
    _OIter
    rotate_copy(_FIter, _FIter, _FIter, _OIter);
# 625 "/usr/local/include/c++/10.0.0/bits/algorithmfwd.h" 3
  template<typename _RAIter, typename _UGenerator>
    void
    shuffle(_RAIter, _RAIter, _UGenerator&&);


  template<typename _RAIter>
    constexpr
    void
    sort_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    constexpr
    void
    sort_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    stable_partition(_BIter, _BIter, _Predicate);
# 658 "/usr/local/include/c++/10.0.0/bits/algorithmfwd.h" 3
  template<typename _FIter1, typename _FIter2>
    constexpr
    _FIter2
    swap_ranges(_FIter1, _FIter1, _FIter2);



  template<typename _FIter>
    constexpr
    _FIter
    unique(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    constexpr
    _FIter
    unique(_FIter, _FIter, _BinaryPredicate);



  template<typename _FIter, typename _Tp>
    constexpr
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    constexpr
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&, _Compare);



  template<typename _FIter>
    constexpr
    _FIter
    adjacent_find(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    constexpr
    _FIter
    adjacent_find(_FIter, _FIter, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    constexpr
    typename iterator_traits<_IIter>::difference_type
    count(_IIter, _IIter, const _Tp&);

  template<typename _IIter, typename _Predicate>
    constexpr
    typename iterator_traits<_IIter>::difference_type
    count_if(_IIter, _IIter, _Predicate);

  template<typename _IIter1, typename _IIter2>
    constexpr
    bool
    equal(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    constexpr
    bool
    equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    constexpr
    _IIter
    find(_IIter, _IIter, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    constexpr
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    constexpr
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _IIter, typename _Predicate>
    constexpr
    _IIter
    find_if(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Funct>
    constexpr
    _Funct
    for_each(_IIter, _IIter, _Funct);

  template<typename _FIter, typename _Generator>
    constexpr
    void
    generate(_FIter, _FIter, _Generator);

  template<typename _OIter, typename _Size, typename _Generator>
    constexpr
    _OIter
    generate_n(_OIter, _Size, _Generator);

  template<typename _IIter1, typename _IIter2>
    constexpr
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    constexpr
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _FIter>
    constexpr
    _FIter
    max_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    _FIter
    max_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    constexpr
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    constexpr
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _FIter>
    constexpr
    _FIter
    min_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    _FIter
    min_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2>
    constexpr
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    constexpr
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _RAIter>
    constexpr
    void
    nth_element(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    constexpr
    void
    nth_element(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    constexpr
    void
    partial_sort(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    constexpr
    void
    partial_sort(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    constexpr
    _BIter
    partition(_BIter, _BIter, _Predicate);

  template<typename _RAIter>
    void
    random_shuffle(_RAIter, _RAIter);

  template<typename _RAIter, typename _Generator>
    void
    random_shuffle(_RAIter, _RAIter,

     _Generator&&);




  template<typename _FIter, typename _Tp>
    constexpr
    void
    replace(_FIter, _FIter, const _Tp&, const _Tp&);

  template<typename _FIter, typename _Predicate, typename _Tp>
    constexpr
    void
    replace_if(_FIter, _FIter, _Predicate, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    constexpr
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    constexpr
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _FIter, typename _Size, typename _Tp>
    constexpr
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&);

  template<typename _FIter, typename _Size, typename _Tp,
    typename _BinaryPredicate>
    constexpr
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&, _BinaryPredicate);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    constexpr
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    constexpr
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    constexpr
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    constexpr
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    constexpr
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    constexpr
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2,
        _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    constexpr
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    constexpr
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _RAIter>
    constexpr
    void
    sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    constexpr
    void
    sort(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    stable_sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    stable_sort(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _OIter, typename _UnaryOperation>
    constexpr
    _OIter
    transform(_IIter, _IIter, _OIter, _UnaryOperation);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _BinaryOperation>
    constexpr
    _OIter
    transform(_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation);

  template<typename _IIter, typename _OIter>
    constexpr
    _OIter
    unique_copy(_IIter, _IIter, _OIter);

  template<typename _IIter, typename _OIter, typename _BinaryPredicate>
    constexpr
    _OIter
    unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate);



}
# 61 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 2 3
# 1 "/usr/local/include/c++/10.0.0/bits/stl_heap.h" 1 3
# 62 "/usr/local/include/c++/10.0.0/bits/stl_heap.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    constexpr
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n,
      _Compare& __comp)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__comp(__first + __parent, __first + __child))
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }



  template<typename _RandomAccessIterator, typename _Distance>
    constexpr
    inline bool
    __is_heap(_RandomAccessIterator __first, _Distance __n)
    {
      __gnu_cxx::__ops::_Iter_less_iter __comp;
      return std::__is_heap_until(__first, __n, __comp) == __n;
    }

  template<typename _RandomAccessIterator, typename _Compare,
    typename _Distance>
    constexpr
    inline bool
    __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)
    {
      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      return std::__is_heap_until(__first, __n, __cmp) == __n;
    }

  template<typename _RandomAccessIterator>
    constexpr
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::__is_heap(__first, std::distance(__first, __last)); }

  template<typename _RandomAccessIterator, typename _Compare>
    constexpr
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      return std::__is_heap(__first, std::move(__comp),
       std::distance(__first, __last));
    }




  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
    typename _Compare>
    constexpr
    void
    __push_heap(_RandomAccessIterator __first,
  _Distance __holeIndex, _Distance __topIndex, _Tp __value,
  _Compare& __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && __comp(__first + __parent, __value))
 {
   *(__first + __holeIndex) = std::move(*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = std::move(__value);
    }
# 158 "/usr/local/include/c++/10.0.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    constexpr
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

     
      ;
      ;
      ;

      __gnu_cxx::__ops::_Iter_less_val __comp;
      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value), __comp);
    }
# 194 "/usr/local/include/c++/10.0.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    constexpr
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

      ;
      ;
      ;

      __decltype(__gnu_cxx::__ops::__iter_comp_val(std::move(__comp)))
 __cmp(std::move(__comp));
      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value), __cmp);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Tp, typename _Compare>
    constexpr
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value, _Compare __comp)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (__comp(__first + __secondChild,
       __first + (__secondChild - 1)))
     __secondChild--;
   *(__first + __holeIndex) = std::move(*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = std::move(*(__first + (__secondChild - 1)))
                                  ;
   __holeIndex = __secondChild - 1;
 }
      __decltype(__gnu_cxx::__ops::__iter_comp_val(std::move(__comp)))
 __cmp(std::move(__comp));
      std::__push_heap(__first, __holeIndex, __topIndex,
         std::move(__value), __cmp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    constexpr
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Compare& __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      _ValueType __value = std::move(*__result);
      *__result = std::move(*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    std::move(__value), __comp);
    }
# 279 "/usr/local/include/c++/10.0.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    constexpr
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;
      ;
      ;

      if (__last - __first > 1)
 {
   --__last;
   __gnu_cxx::__ops::_Iter_less_iter __comp;
   std::__pop_heap(__first, __last, __last, __comp);
 }
    }
# 313 "/usr/local/include/c++/10.0.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    constexpr
    inline void
    pop_heap(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {

     

      ;
      ;
      ;
      ;

      if (__last - __first > 1)
 {
   typedef __decltype(__comp) _Cmp;
   __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
   --__last;
   std::__pop_heap(__first, __last, __last, __cmp);
 }
    }

  template<typename _RandomAccessIterator, typename _Compare>
    constexpr
    void
    __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare& __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = std::move(*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, std::move(__value),
        __comp);
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 371 "/usr/local/include/c++/10.0.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    constexpr
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      __gnu_cxx::__ops::_Iter_less_iter __comp;
      std::__make_heap(__first, __last, __comp);
    }
# 398 "/usr/local/include/c++/10.0.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    constexpr
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {

     

      ;
      ;

      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      std::__make_heap(__first, __last, __cmp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    constexpr
    void
    __sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare& __comp)
    {
      while (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last, __comp);
 }
    }
# 436 "/usr/local/include/c++/10.0.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    constexpr
    inline void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;
      ;

      __gnu_cxx::__ops::_Iter_less_iter __comp;
      std::__sort_heap(__first, __last, __comp);
    }
# 464 "/usr/local/include/c++/10.0.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    constexpr
    inline void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {

     

      ;
      ;
      ;

      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      std::__sort_heap(__first, __last, __cmp);
    }
# 493 "/usr/local/include/c++/10.0.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    constexpr
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      __gnu_cxx::__ops::_Iter_less_iter __comp;
      return __first +
 std::__is_heap_until(__first, std::distance(__first, __last), __comp);
    }
# 522 "/usr/local/include/c++/10.0.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    constexpr
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {

     

      ;
      ;

      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      return __first
 + std::__is_heap_until(__first, std::distance(__first, __last), __cmp);
    }
# 547 "/usr/local/include/c++/10.0.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    constexpr
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::is_heap_until(__first, __last) == __last; }
# 561 "/usr/local/include/c++/10.0.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    constexpr
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _Compare __comp)
    {

     

      ;
      ;

      const auto __dist = std::distance(__first, __last);
      typedef __decltype(__comp) _Cmp;
      __gnu_cxx::__ops::_Iter_comp_iter<_Cmp> __cmp(std::move(__comp));
      return std::__is_heap_until(__first, __dist, __cmp) == __dist;
    }



}
# 62 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 2 3




# 1 "/usr/local/include/c++/10.0.0/bits/uniform_int_dist.h" 1 3
# 37 "/usr/local/include/c++/10.0.0/bits/uniform_int_dist.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  namespace __detail
  {

    template<typename _Tp>
      inline bool
      _Power_of_2(_Tp __x)
      {
 return ((__x - 1) & __x) == 0;
      }
  }






  template<typename _IntType = int>
    class uniform_int_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument must be an integral type");

    public:

      typedef _IntType result_type;

      struct param_type
      {
 typedef uniform_int_distribution<_IntType> distribution_type;

 param_type() : param_type(0) { }

 explicit
 param_type(_IntType __a,
     _IntType __b = numeric_limits<_IntType>::max())
 : _M_a(__a), _M_b(__b)
 {
   ;
 }

 result_type
 a() const
 { return _M_a; }

 result_type
 b() const
 { return _M_b; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }

 friend bool
 operator!=(const param_type& __p1, const param_type& __p2)
 { return !(__p1 == __p2); }

      private:
 _IntType _M_a;
 _IntType _M_b;
      };

    public:



      uniform_int_distribution() : uniform_int_distribution(0) { }




      explicit
      uniform_int_distribution(_IntType __a,
          _IntType __b = numeric_limits<_IntType>::max())
      : _M_param(__a, __b)
      { }

      explicit
      uniform_int_distribution(const param_type& __p)
      : _M_param(__p)
      { }






      void
      reset() { }

      result_type
      a() const
      { return _M_param.a(); }

      result_type
      b() const
      { return _M_param.b(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return this->a(); }




      result_type
      max() const
      { return this->b(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
        { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }





      friend bool
      operator==(const uniform_int_distribution& __d1,
   const uniform_int_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;
    };

  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename uniform_int_distribution<_IntType>::result_type
      uniform_int_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 typedef typename _UniformRandomNumberGenerator::result_type
   _Gresult_type;
 typedef typename std::make_unsigned<result_type>::type __utype;
 typedef typename std::common_type<_Gresult_type, __utype>::type
   __uctype;

 const __uctype __urngmin = __urng.min();
 const __uctype __urngmax = __urng.max();
 const __uctype __urngrange = __urngmax - __urngmin;
 const __uctype __urange
   = __uctype(__param.b()) - __uctype(__param.a());

 __uctype __ret;

 if (__urngrange > __urange)
   {

     const __uctype __uerange = __urange + 1;
     const __uctype __scaling = __urngrange / __uerange;
     const __uctype __past = __uerange * __scaling;
     do
       __ret = __uctype(__urng()) - __urngmin;
     while (__ret >= __past);
     __ret /= __scaling;
   }
 else if (__urngrange < __urange)
   {
# 271 "/usr/local/include/c++/10.0.0/bits/uniform_int_dist.h" 3
     __uctype __tmp;
     do
       {
  const __uctype __uerngrange = __urngrange + 1;
  __tmp = (__uerngrange * operator()
    (__urng, param_type(0, __urange / __uerngrange)));
  __ret = __tmp + (__uctype(__urng()) - __urngmin);
       }
     while (__ret > __urange || __ret < __tmp);
   }
 else
   __ret = __uctype(__urng()) - __urngmin;

 return __ret + __param.a();
      }


  template<typename _IntType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      uniform_int_distribution<_IntType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __param)
      {

 typedef typename _UniformRandomNumberGenerator::result_type
   _Gresult_type;
 typedef typename std::make_unsigned<result_type>::type __utype;
 typedef typename std::common_type<_Gresult_type, __utype>::type
   __uctype;

 const __uctype __urngmin = __urng.min();
 const __uctype __urngmax = __urng.max();
 const __uctype __urngrange = __urngmax - __urngmin;
 const __uctype __urange
   = __uctype(__param.b()) - __uctype(__param.a());

 __uctype __ret;

 if (__urngrange > __urange)
   {
     if (__detail::_Power_of_2(__urngrange + 1)
  && __detail::_Power_of_2(__urange + 1))
       {
  while (__f != __t)
    {
      __ret = __uctype(__urng()) - __urngmin;
      *__f++ = (__ret & __urange) + __param.a();
    }
       }
     else
       {

  const __uctype __uerange = __urange + 1;
  const __uctype __scaling = __urngrange / __uerange;
  const __uctype __past = __uerange * __scaling;
  while (__f != __t)
    {
      do
        __ret = __uctype(__urng()) - __urngmin;
      while (__ret >= __past);
      *__f++ = __ret / __scaling + __param.a();
    }
       }
   }
 else if (__urngrange < __urange)
   {
# 355 "/usr/local/include/c++/10.0.0/bits/uniform_int_dist.h" 3
     __uctype __tmp;
     while (__f != __t)
       {
  do
    {
      const __uctype __uerngrange = __urngrange + 1;
      __tmp = (__uerngrange * operator()
        (__urng, param_type(0, __urange / __uerngrange)));
      __ret = __tmp + (__uctype(__urng()) - __urngmin);
    }
  while (__ret > __urange || __ret < __tmp);
  *__f++ = __ret;
       }
   }
 else
   while (__f != __t)
     *__f++ = __uctype(__urng()) - __urngmin + __param.a();
      }




}
# 67 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Iterator, typename _Compare>
    constexpr
    void
    __move_median_to_first(_Iterator __result,_Iterator __a, _Iterator __b,
      _Iterator __c, _Compare __comp)
    {
      if (__comp(__a, __b))
 {
   if (__comp(__b, __c))
     std::iter_swap(__result, __b);
   else if (__comp(__a, __c))
     std::iter_swap(__result, __c);
   else
     std::iter_swap(__result, __a);
 }
      else if (__comp(__a, __c))
 std::iter_swap(__result, __a);
      else if (__comp(__b, __c))
 std::iter_swap(__result, __c);
      else
 std::iter_swap(__result, __b);
    }


  template<typename _InputIterator, typename _Predicate>
    constexpr
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !__pred(__first))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Predicate>
    constexpr
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(__first))
     return __first;
   ++__first;
 case 2:
   if (__pred(__first))
     return __first;
   ++__first;
 case 1:
   if (__pred(__first))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }

  template<typename _Iterator, typename _Predicate>
    constexpr
    inline _Iterator
    __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)
    {
      return __find_if(__first, __last, __pred,
         std::__iterator_category(__first));
    }


  template<typename _InputIterator, typename _Predicate>
    constexpr
    inline _InputIterator
    __find_if_not(_InputIterator __first, _InputIterator __last,
    _Predicate __pred)
    {
      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__negate(__pred),
       std::__iterator_category(__first));
    }




  template<typename _InputIterator, typename _Predicate, typename _Distance>
    constexpr
    _InputIterator
    __find_if_not_n(_InputIterator __first, _Distance& __len, _Predicate __pred)
    {
      for (; __len; --__len, (void) ++__first)
 if (!__pred(__first))
   break;
      return __first;
    }
# 208 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    constexpr
    _ForwardIterator1
    __search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __predicate)
    {

      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 return std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));


      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   __first1 =
     std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));

   if (__first1 == __last1)
     return __last1;

   _ForwardIterator2 __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(__current, __p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }






  template<typename _ForwardIterator, typename _Integer,
    typename _UnaryPredicate>
    constexpr
    _ForwardIterator
    __search_n_aux(_ForwardIterator __first, _ForwardIterator __last,
     _Integer __count, _UnaryPredicate __unary_pred,
     std::forward_iterator_tag)
    {
      __first = std::__find_if(__first, __last, __unary_pred);
      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && __unary_pred(__i))
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = std::__find_if(++__i, __last, __unary_pred);
 }
      return __last;
    }





  template<typename _RandomAccessIter, typename _Integer,
    typename _UnaryPredicate>
    constexpr
    _RandomAccessIter
    __search_n_aux(_RandomAccessIter __first, _RandomAccessIter __last,
     _Integer __count, _UnaryPredicate __unary_pred,
     std::random_access_iterator_tag)
    {
      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      _DistanceType __remainder = __count;

      while (__remainder <= __tailSize)
 {
   __first += __remainder;
   __tailSize -= __remainder;


   _RandomAccessIter __backTrack = __first;
   while (__unary_pred(--__backTrack))
     {
       if (--__remainder == 0)
  return (__first - __count);
     }
   __remainder = __count + 1 - (__first - __backTrack);
 }
      return __last;
    }

  template<typename _ForwardIterator, typename _Integer,
    typename _UnaryPredicate>
    constexpr
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count,
        _UnaryPredicate __unary_pred)
    {
      if (__count <= 0)
 return __first;

      if (__count == 1)
 return std::__find_if(__first, __last, __unary_pred);

      return std::__search_n_aux(__first, __last, __count, __unary_pred,
     std::__iterator_category(__first));
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    constexpr
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag,
        _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
 return __last1;

      _ForwardIterator1 __result = __last1;
      while (1)
 {
   _ForwardIterator1 __new_result
     = std::__search(__first1, __last1, __first2, __last2, __comp);
   if (__new_result == __last1)
     return __result;
   else
     {
       __result = __new_result;
       __first1 = __new_result;
       ++__first1;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BinaryPredicate>
    constexpr
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag,
        _BinaryPredicate __comp)
    {

     

     


      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::__search(_RevIterator1(__last1), __rlast1,
           _RevIterator2(__last2), __rlast2,
           __comp);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
# 434 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    constexpr
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 483 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    constexpr
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp)
    {

     
     
     


      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 519 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    constexpr
    inline bool
    all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if_not(__first, __last, __pred); }
# 537 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    constexpr
    inline bool
    none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if(__first, __last, __pred); }
# 556 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    constexpr
    inline bool
    any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return !std::none_of(__first, __last, __pred); }
# 572 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    constexpr
    inline _InputIterator
    find_if_not(_InputIterator __first, _InputIterator __last,
  _Predicate __pred)
    {

     
     

      ;
      return std::__find_if_not(__first, __last,
    __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 597 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    constexpr
    inline bool
    is_partitioned(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {
      __first = std::find_if_not(__first, __last, __pred);
      if (__first == __last)
 return true;
      ++__first;
      return std::none_of(__first, __last, __pred);
    }
# 619 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    constexpr
    _ForwardIterator
    partition_point(_ForwardIterator __first, _ForwardIterator __last,
      _Predicate __pred)
    {

     
     



      ;

      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__pred(*__middle))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }


  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    constexpr
    _OutputIterator
    __remove_copy_if(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _Predicate __pred)
    {
      for (; __first != __last; ++__first)
 if (!__pred(__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 686 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    constexpr
    inline _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, const _Tp& __value)
    {

     
     

     

      ;

      return std::__remove_copy_if(__first, __last, __result,
 __gnu_cxx::__ops::__iter_equals_val(__value));
    }
# 719 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    constexpr
    inline _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {

     
     

     

      ;

      return std::__remove_copy_if(__first, __last, __result,
       __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 754 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    constexpr
    _OutputIterator
    copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {

     
     

     

      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }

  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    constexpr
    _OutputIterator
    __copy_n_a(_InputIterator __first, _Size __n, _OutputIterator __result)
    {
      if (__n > 0)
 {
   while (true)
     {
       *__result = *__first;
       ++__result;
       if (--__n > 0)
  ++__first;
       else
  break;
     }
 }
      return __result;
    }

  template<typename _CharT, typename _Size>
    __enable_if_t<__is_char<_CharT>::__value, _CharT*>
    __copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT>>,
        _Size, _CharT*);

  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    constexpr
    _OutputIterator
    __copy_n(_InputIterator __first, _Size __n,
      _OutputIterator __result, input_iterator_tag)
    {
      return std::__niter_wrap(__result,
          __copy_n_a(__first, __n,
       std::__niter_base(__result)));
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _OutputIterator>
    constexpr
    inline _OutputIterator
    __copy_n(_RandomAccessIterator __first, _Size __n,
      _OutputIterator __result, random_access_iterator_tag)
    { return std::copy(__first, __first + __n, __result); }
# 835 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    constexpr
    inline _OutputIterator
    copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
    {

     
     

      ;
      ;

      return std::__copy_n(__first, __n, __result,
      std::__iterator_category(__first));
    }
# 866 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator1,
    typename _OutputIterator2, typename _Predicate>
    constexpr
    pair<_OutputIterator1, _OutputIterator2>
    partition_copy(_InputIterator __first, _InputIterator __last,
     _OutputIterator1 __out_true, _OutputIterator2 __out_false,
     _Predicate __pred)
    {

     
     

     

     

      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__out_true = *__first;
     ++__out_true;
   }
 else
   {
     *__out_false = *__first;
     ++__out_false;
   }

      return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
    }


  template<typename _ForwardIterator, typename _Predicate>
    constexpr
    _ForwardIterator
    __remove_if(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred)
    {
      __first = std::__find_if(__first, __last, __pred);
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for (; __first != __last; ++__first)
 if (!__pred(__first))
   {
     *__result = std::move(*__first);
     ++__result;
   }
      return __result;
    }
# 937 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    constexpr
    inline _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __value)
    {

     

     

      ;

      return std::__remove_if(__first, __last,
  __gnu_cxx::__ops::__iter_equals_val(__value));
    }
# 971 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    constexpr
    inline _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      return std::__remove_if(__first, __last,
         __gnu_cxx::__ops::__pred_iter(__pred));
    }

  template<typename _ForwardIterator, typename _BinaryPredicate>
    constexpr
    _ForwardIterator
    __adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
      _BinaryPredicate __binary_pred)
    {
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while (++__next != __last)
 {
   if (__binary_pred(__first, __next))
     return __first;
   __first = __next;
 }
      return __last;
    }

  template<typename _ForwardIterator, typename _BinaryPredicate>
    constexpr
    _ForwardIterator
    __unique(_ForwardIterator __first, _ForwardIterator __last,
      _BinaryPredicate __binary_pred)
    {

      __first = std::__adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!__binary_pred(__dest, __first))
   *++__dest = std::move(*__first);
      return ++__dest;
    }
# 1040 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    inline _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {

     

     

      ;

      return std::__unique(__first, __last,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1071 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    constexpr
    inline _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {

     

     


      ;

      return std::__unique(__first, __last,
      __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }







  template<typename _ForwardIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    constexpr
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    forward_iterator_tag, output_iterator_tag)
    {

     



      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!__binary_pred(__first, __next))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    constexpr
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, output_iterator_tag)
    {

     



      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      __decltype(__gnu_cxx::__ops::__iter_comp_val(__binary_pred))
 __rebound_pred
 = __gnu_cxx::__ops::__iter_comp_val(__binary_pred);
      *__result = __value;
      while (++__first != __last)
 if (!__rebound_pred(__first, __value))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    constexpr
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, forward_iterator_tag)
    {

     


      *__result = *__first;
      while (++__first != __last)
 if (!__binary_pred(__result, __first))
   *++__result = *__first;
      return ++__result;
    }






  template<typename _BidirectionalIterator>
    constexpr
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {
      while (true)
 if (__first == __last || __first == --__last)
   return;
 else
   {
     std::iter_swap(__first, __last);
     ++__first;
   }
    }






  template<typename _RandomAccessIterator>
    constexpr
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
       random_access_iterator_tag)
    {
      if (__first == __last)
 return;
      --__last;
      while (__first < __last)
 {
   std::iter_swap(__first, __last);
   ++__first;
   --__last;
 }
    }
# 1232 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    constexpr
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {

     

      ;
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }
# 1260 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _OutputIterator>
    constexpr
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
   _OutputIterator __result)
    {

     

     

      ;

      while (__first != __last)
 {
   --__last;
   *__result = *__last;
   ++__result;
 }
      return __result;
    }





  template<typename _EuclideanRingElement>
    constexpr
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
 {
   _EuclideanRingElement __t = __m % __n;
   __m = __n;
   __n = __t;
 }
      return __m;
    }

  inline namespace _V2
  {


  template<typename _ForwardIterator>
    constexpr
    _ForwardIterator
    __rotate(_ForwardIterator __first,
      _ForwardIterator __middle,
      _ForwardIterator __last,
      forward_iterator_tag)
    {
      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      _ForwardIterator __first2 = __middle;
      do
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
 }
      while (__first2 != __last);

      _ForwardIterator __ret = __first;

      __first2 = __middle;

      while (__first2 != __last)
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
   else if (__first2 == __last)
     __first2 = __middle;
 }
      return __ret;
    }


  template<typename _BidirectionalIterator>
    constexpr
    _BidirectionalIterator
    __rotate(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {

     


      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      std::__reverse(__first, __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last, bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
 {
   std::iter_swap(__first, --__last);
   ++__first;
 }

      if (__first == __middle)
 {
   std::__reverse(__middle, __last, bidirectional_iterator_tag());
   return __last;
 }
      else
 {
   std::__reverse(__first, __middle, bidirectional_iterator_tag());
   return __first;
 }
    }


  template<typename _RandomAccessIterator>
    constexpr
    _RandomAccessIterator
    __rotate(_RandomAccessIterator __first,
      _RandomAccessIterator __middle,
      _RandomAccessIterator __last,
      random_access_iterator_tag)
    {

     


      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      _Distance __n = __last - __first;
      _Distance __k = __middle - __first;

      if (__k == __n - __k)
 {
   std::swap_ranges(__first, __middle, __middle);
   return __middle;
 }

      _RandomAccessIterator __p = __first;
      _RandomAccessIterator __ret = __first + (__last - __middle);

      for (;;)
 {
   if (__k < __n - __k)
     {
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = std::move(*__p);
    std::move(__p + 1, __p + __n, __p);
    *(__p + __n - 1) = std::move(__t);
    return __ret;
  }
       _RandomAccessIterator __q = __p + __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    std::iter_swap(__p, __q);
    ++__p;
    ++__q;
  }
       __n %= __k;
       if (__n == 0)
  return __ret;
       std::swap(__n, __k);
       __k = __n - __k;
     }
   else
     {
       __k = __n - __k;
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = std::move(*(__p + __n - 1));
    std::move_backward(__p, __p + __n - 1, __p + __n);
    *__p = std::move(__t);
    return __ret;
  }
       _RandomAccessIterator __q = __p + __n;
       __p = __q - __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    --__p;
    --__q;
    std::iter_swap(__p, __q);
  }
       __n %= __k;
       if (__n == 0)
  return __ret;
       std::swap(__n, __k);
     }
 }
    }
# 1492 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    inline _ForwardIterator
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
    _ForwardIterator __last)
    {

     

      ;
      ;

      return std::__rotate(__first, __middle, __last,
      std::__iterator_category(__first));
    }

  }
# 1530 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator>
    constexpr
    inline _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
  _ForwardIterator __last, _OutputIterator __result)
    {

     
     

      ;
      ;

      return std::copy(__first, __middle,
         std::copy(__middle, __last, __result));
    }


  template<typename _ForwardIterator, typename _Predicate>
    constexpr
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred, forward_iterator_tag)
    {
      if (__first == __last)
 return __first;

      while (__pred(*__first))
 if (++__first == __last)
   return __first;

      _ForwardIterator __next = __first;

      while (++__next != __last)
 if (__pred(*__next))
   {
     std::iter_swap(__first, __next);
     ++__first;
   }

      return __first;
    }


  template<typename _BidirectionalIterator, typename _Predicate>
    constexpr
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
  _Predicate __pred, bidirectional_iterator_tag)
    {
      while (true)
 {
   while (true)
     if (__first == __last)
       return __first;
     else if (__pred(*__first))
       ++__first;
     else
       break;
   --__last;
   while (true)
     if (__first == __last)
       return __first;
     else if (!bool(__pred(*__last)))
       --__last;
     else
       break;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }
# 1610 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
    typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred, _Distance __len,
    _Pointer __buffer,
    _Distance __buffer_size)
    {
      if (__len == 1)
 return __first;

      if (__len <= __buffer_size)
 {
   _ForwardIterator __result1 = __first;
   _Pointer __result2 = __buffer;




   *__result2 = std::move(*__first);
   ++__result2;
   ++__first;
   for (; __first != __last; ++__first)
     if (__pred(__first))
       {
  *__result1 = std::move(*__first);
  ++__result1;
       }
     else
       {
  *__result2 = std::move(*__first);
  ++__result2;
       }

   std::move(__buffer, __result2, __result1);
   return __result1;
 }

      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __left_split =
 std::__stable_partition_adaptive(__first, __middle, __pred,
      __len / 2, __buffer,
      __buffer_size);



      _Distance __right_len = __len - __len / 2;
      _ForwardIterator __right_split =
 std::__find_if_not_n(__middle, __right_len, __pred);

      if (__right_len)
 __right_split =
   std::__stable_partition_adaptive(__right_split, __last, __pred,
        __right_len,
        __buffer, __buffer_size);

      return std::rotate(__left_split, __middle, __right_split);
    }

  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __stable_partition(_ForwardIterator __first, _ForwardIterator __last,
         _Predicate __pred)
    {
      __first = std::__find_if_not(__first, __last, __pred);

      if (__first == __last)
 return __first;

      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _Temporary_buffer<_ForwardIterator, _ValueType>
 __buf(__first, std::distance(__first, __last));
      return
 std::__stable_partition_adaptive(__first, __last, __pred,
      _DistanceType(__buf.requested_size()),
      __buf.begin(),
      _DistanceType(__buf.size()));
    }
# 1712 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      return std::__stable_partition(__first, __last,
         __gnu_cxx::__ops::__pred_iter(__pred));
    }


  template<typename _RandomAccessIterator, typename _Compare>
    constexpr
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last, _Compare __comp)
    {
      std::__make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (__comp(__i, __first))
   std::__pop_heap(__first, __middle, __i, __comp);
    }



  template<typename _InputIterator, typename _RandomAccessIterator,
    typename _Compare>
    constexpr
    _RandomAccessIterator
    __partial_sort_copy(_InputIterator __first, _InputIterator __last,
   _RandomAccessIterator __result_first,
   _RandomAccessIterator __result_last,
   _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef iterator_traits<_RandomAccessIterator> _RItTraits;
      typedef typename _RItTraits::difference_type _DistanceType;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while (__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }

      std::__make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
 {
   if (__comp(__first, __result_first))
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first), __comp);
   ++__first;
 }
      std::__sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }
# 1800 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator>
    constexpr
    inline _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last)
    {
# 1815 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
     
     

     

     
      ;
      ;
      ;

      return std::__partial_sort_copy(__first, __last,
          __result_first, __result_last,
          __gnu_cxx::__ops::__iter_less_iter());
    }
# 1850 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator,
    typename _Compare>
    constexpr
    inline _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last,
        _Compare __comp)
    {
# 1867 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
     
     

     

     

     

      ;
      ;
      ;

      return std::__partial_sort_copy(__first, __last,
          __result_first, __result_last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }


  template<typename _RandomAccessIterator, typename _Compare>
    constexpr
    void
    __unguarded_linear_insert(_RandomAccessIterator __last,
         _Compare __comp)
    {
      typename iterator_traits<_RandomAccessIterator>::value_type
 __val = std::move(*__last);
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, __next))
 {
   *__last = std::move(*__next);
   __last = __next;
   --__next;
 }
      *__last = std::move(__val);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    constexpr
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   if (__comp(__i, __first))
     {
       typename iterator_traits<_RandomAccessIterator>::value_type
  __val = std::move(*__i);
       std::move_backward(__first, __i, __i + 1);
       *__first = std::move(__val);
     }
   else
     std::__unguarded_linear_insert(__i,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    constexpr
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
    {
      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }





  enum { _S_threshold = 16 };


  template<typename _RandomAccessIterator, typename _Compare>
    constexpr
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
       __comp);
 }
      else
 std::__insertion_sort(__first, __last, __comp);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    constexpr
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last,
     _RandomAccessIterator __pivot, _Compare __comp)
    {
      while (true)
 {
   while (__comp(__first, __pivot))
     ++__first;
   --__last;
   while (__comp(__pivot, __last))
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    constexpr
    inline _RandomAccessIterator
    __unguarded_partition_pivot(_RandomAccessIterator __first,
    _RandomAccessIterator __last, _Compare __comp)
    {
      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
      std::__move_median_to_first(__first, __first + 1, __mid, __last - 1,
      __comp);
      return std::__unguarded_partition(__first + 1, __last, __first, __comp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    constexpr
    inline void
    __partial_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __middle,
     _RandomAccessIterator __last,
     _Compare __comp)
    {
      std::__heap_select(__first, __middle, __last, __comp);
      std::__sort_heap(__first, __middle, __comp);
    }


  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    constexpr
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit, _Compare __comp)
    {
      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::__partial_sort(__first, __last, __last, __comp);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   std::__introsort_loop(__cut, __last, __depth_limit, __comp);
   __last = __cut;
 }
    }



  template<typename _RandomAccessIterator, typename _Compare>
    constexpr
    inline void
    __sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {
      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2,
    __comp);
   std::__final_insertion_sort(__first, __last, __comp);
 }
    }

  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    constexpr
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit,
    _Compare __comp)
    {
      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last, __comp);

       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
# 2098 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    constexpr
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {

     
     

     
                    ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_comp_val(__comp));
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    constexpr
    _ForwardIterator
    __upper_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__val, __middle))
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 2154 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    constexpr
    inline _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

      ;

      return std::__upper_bound(__first, __last, __val,
    __gnu_cxx::__ops::__val_less_iter());
    }
# 2185 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    constexpr
    inline _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {

     
     

     
                    ;

      return std::__upper_bound(__first, __last, __val,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Tp,
    typename _CompareItTp, typename _CompareTpIt>
    constexpr
    pair<_ForwardIterator, _ForwardIterator>
    __equal_range(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val,
    _CompareItTp __comp_it_val, _CompareTpIt __comp_val_it)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp_it_val(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__comp_val_it(__val, __middle))
     __len = __half;
   else
     {
       _ForwardIterator __left
  = std::__lower_bound(__first, __middle, __val, __comp_it_val);
       std::advance(__first, __len);
       _ForwardIterator __right
  = std::__upper_bound(++__middle, __first, __val, __comp_val_it);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 2258 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    constexpr
    inline pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

     

      ;
      ;

      return std::__equal_range(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val(),
    __gnu_cxx::__ops::__val_less_iter());
    }
# 2295 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    constexpr
    inline pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {

     
     

     

     
                    ;
     
                    ;

      return std::__equal_range(__first, __last, __val,
    __gnu_cxx::__ops::__iter_comp_val(__comp),
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }
# 2329 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    constexpr
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val)
    {

     
     

      ;
      ;

      _ForwardIterator __i
 = std::__lower_bound(__first, __last, __val,
        __gnu_cxx::__ops::__iter_less_val());
      return __i != __last && !(__val < *__i);
    }
# 2363 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    constexpr
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {

     
     

     
                    ;
     
                    ;

      _ForwardIterator __i
 = std::__lower_bound(__first, __last, __val,
        __gnu_cxx::__ops::__iter_comp_val(__comp));
      return __i != __last && !bool(__comp(__val, *__i));
    }




  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    void
    __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      if (__first1 != __last1)
 std::move(__first1, __last1, __result);
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare>
    void
    __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result,
       _Compare __comp)
    {
      if (__first1 == __last1)
 {
   std::move_backward(__first2, __last2, __result);
   return;
 }
      else if (__first2 == __last2)
 return;

      --__last1;
      --__last2;
      while (true)
 {
   if (__comp(__last2, __last1))
     {
       *--__result = std::move(*__last1);
       if (__first1 == __last1)
  {
    std::move_backward(__first2, ++__last2, __result);
    return;
  }
       --__last1;
     }
   else
     {
       *--__result = std::move(*__last2);
       if (__first2 == __last2)
  return;
       --__last2;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
        _BidirectionalIterator1 __middle,
        _BidirectionalIterator1 __last,
        _Distance __len1, _Distance __len2,
        _BidirectionalIterator2 __buffer,
        _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
 {
   if (__len2)
     {
       __buffer_end = std::move(__middle, __last, __buffer);
       std::move_backward(__first, __middle, __last);
       return std::move(__buffer, __buffer_end, __first);
     }
   else
     return __first;
 }
      else if (__len1 <= __buffer_size)
 {
   if (__len1)
     {
       __buffer_end = std::move(__first, __middle, __buffer);
       std::move(__middle, __last, __first);
       return std::move_backward(__buffer, __buffer_end, __last);
     }
   else
     return __last;
 }
      else
 return std::rotate(__first, __middle, __last);
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer, typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
       _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size,
       _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__first, __middle, __buffer);
   std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
         __first, __comp);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__middle, __last, __buffer);
   std::__move_merge_adaptive_backward(__first, __middle, __buffer,
           __buffer_end, __last, __comp);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut
  = std::__lower_bound(__middle, __last, *__first_cut,
         __gnu_cxx::__ops::__iter_comp_val(__comp));
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut
  = std::__upper_bound(__first, __middle, *__second_cut,
         __gnu_cxx::__ops::__val_comp_iter(__comp));
       __len11 = std::distance(__first, __first_cut);
     }

   _BidirectionalIterator __new_middle
     = std::__rotate_adaptive(__first_cut, __middle, __second_cut,
         __len1 - __len11, __len22, __buffer,
         __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size, __comp);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer,
    __buffer_size, __comp);
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2,
      _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
 return;

      if (__len1 + __len2 == 2)
 {
   if (__comp(__middle, __first))
     std::iter_swap(__first, __middle);
   return;
 }

      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut
     = std::__lower_bound(__middle, __last, *__first_cut,
     __gnu_cxx::__ops::__iter_comp_val(__comp));
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut
     = std::__upper_bound(__first, __middle, *__second_cut,
     __gnu_cxx::__ops::__val_comp_iter(__comp));
   __len11 = std::distance(__first, __first_cut);
 }

      _BidirectionalIterator __new_middle
 = std::rotate(__first_cut, __middle, __second_cut);
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22, __comp);
    }

  template<typename _BidirectionalIterator, typename _Compare>
    void
    __inplace_merge(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
   _DistanceType;

      if (__first == __middle || __middle == __last)
 return;

      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);

      typedef _Temporary_buffer<_BidirectionalIterator, _ValueType> _TmpBuf;
      _TmpBuf __buf(__first, __len1 + __len2);

      if (__buf.begin() == 0)
 std::__merge_without_buffer
   (__first, __middle, __last, __len1, __len2, __comp);
      else
 std::__merge_adaptive
   (__first, __middle, __last, __len1, __len2, __buf.begin(),
    _DistanceType(__buf.size()), __comp);
    }
# 2653 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last)
    {

     

     

      ;
      ;
      ;

      std::__inplace_merge(__first, __middle, __last,
      __gnu_cxx::__ops::__iter_less_iter());
    }
# 2694 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    inline void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp)
    {

     

     


      ;
      ;
      ;

      std::__inplace_merge(__first, __middle, __last,
      __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }



  template<typename _InputIterator, typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __move_merge(_InputIterator __first1, _InputIterator __last1,
   _InputIterator __first2, _InputIterator __last2,
   _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      return std::move(__first2, __last2, std::move(__first1, __last1, __result))

                  ;
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result, _Distance __step_size,
        _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::__move_merge(__first, __first + __step_size,
           __first + __step_size,
           __first + __two_step,
           __result, __comp);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);

      std::__move_merge(__first, __first + __step_size,
   __first + __step_size, __last, __result, __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    constexpr
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size, __comp);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last, __comp);
    }

  enum { _S_chunk_size = 7 };

  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
        _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer,
     __step_size, __comp);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first,
     __step_size, __comp);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Pointer __buffer, _Distance __buffer_size,
      _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle, __buffer,
          __buffer_size, __comp);
   std::__stable_sort_adaptive(__middle, __last, __buffer,
          __buffer_size, __comp);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
   std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size,
       __comp);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last, __comp);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle,
      __comp);
    }
# 2867 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    constexpr
    bool
    __includes(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first2, __first1))
   return false;
 else if (__comp(__first1, __first2))
   ++__first1;
 else
   {
     ++__first1;
     ++__first2;
   }

      return __first2 == __last2;
    }
# 2907 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    constexpr
    inline bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     


     


      ;
      ;
      ;
      ;

      return std::__includes(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 2952 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    constexpr
    inline bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _Compare __comp)
    {

     
     
     


     


      ;
      ;
      ;
      ;

      return std::__includes(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 2988 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    constexpr
    bool
    __next_permutation(_BidirectionalIterator __first,
         _BidirectionalIterator __last, _Compare __comp)
    {
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(__i, __ii))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(__i, --__j))
  {}
       std::iter_swap(__i, __j);
       std::__reverse(__ii, __last,
        std::__iterator_category(__first));
       return true;
     }
   if (__i == __first)
     {
       std::__reverse(__first, __last,
        std::__iterator_category(__first));
       return false;
     }
 }
    }
# 3038 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    constexpr
    inline bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {

     

     

      ;
      ;

      return std::__next_permutation
 (__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }
# 3071 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    constexpr
    inline bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {

     

     


      ;
      ;

      return std::__next_permutation
 (__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _BidirectionalIterator, typename _Compare>
    constexpr
    bool
    __prev_permutation(_BidirectionalIterator __first,
         _BidirectionalIterator __last, _Compare __comp)
    {
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(__ii, __i))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(--__j, __i))
  {}
       std::iter_swap(__i, __j);
       std::__reverse(__ii, __last,
        std::__iterator_category(__first));
       return true;
     }
   if (__i == __first)
     {
       std::__reverse(__first, __last,
        std::__iterator_category(__first));
       return false;
     }
 }
    }
# 3141 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    constexpr
    inline bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {

     

     

      ;
      ;

      return std::__prev_permutation(__first, __last,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 3174 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    constexpr
    inline bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {

     

     


      ;
      ;

      return std::__prev_permutation(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }




  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    constexpr
    _OutputIterator
    __replace_copy_if(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result,
        _Predicate __pred, const _Tp& __new_value)
    {
      for (; __first != __last; ++__first, (void)++__result)
 if (__pred(__first))
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 3226 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    constexpr
    inline _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result,
   const _Tp& __old_value, const _Tp& __new_value)
    {

     
     

     

      ;

      return std::__replace_copy_if(__first, __last, __result,
   __gnu_cxx::__ops::__iter_equals_val(__old_value),
           __new_value);
    }
# 3261 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    constexpr
    inline _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result,
      _Predicate __pred, const _Tp& __new_value)
    {

     
     

     

      ;

      return std::__replace_copy_if(__first, __last, __result,
    __gnu_cxx::__ops::__pred_iter(__pred),
           __new_value);
    }

  template<typename _InputIterator, typename _Predicate>
    constexpr
    typename iterator_traits<_InputIterator>::difference_type
    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(__first))
   ++__n;
      return __n;
    }
# 3302 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last)
    { return std::is_sorted_until(__first, __last) == __last; }
# 3317 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last,
       _Compare __comp)
    { return std::is_sorted_until(__first, __last, __comp) == __last; }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    _ForwardIterator
    __is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
        _Compare __comp)
    {
      if (__first == __last)
 return __last;

      _ForwardIterator __next = __first;
      for (++__next; __next != __last; __first = __next, (void)++__next)
 if (__comp(__next, __first))
   return __next;
      return __next;
    }
# 3348 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    inline _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      ;

      return std::__is_sorted_until(__first, __last,
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 3373 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
      _Compare __comp)
    {

     
     


      ;
      ;

      return std::__is_sorted_until(__first, __last,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 3399 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _Tp>
    constexpr
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b)
    {

     

      return __b < __a ? pair<const _Tp&, const _Tp&>(__b, __a)
         : pair<const _Tp&, const _Tp&>(__a, __b);
    }
# 3420 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {
      return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a)
         : pair<const _Tp&, const _Tp&>(__a, __b);
    }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    pair<_ForwardIterator, _ForwardIterator>
    __minmax_element(_ForwardIterator __first, _ForwardIterator __last,
       _Compare __comp)
    {
      _ForwardIterator __next = __first;
      if (__first == __last
   || ++__next == __last)
 return std::make_pair(__first, __first);

      _ForwardIterator __min{}, __max{};
      if (__comp(__next, __first))
 {
   __min = __next;
   __max = __first;
 }
      else
 {
   __min = __first;
   __max = __next;
 }

      __first = __next;
      ++__first;

      while (__first != __last)
 {
   __next = __first;
   if (++__next == __last)
     {
       if (__comp(__first, __min))
  __min = __first;
       else if (!__comp(__first, __max))
  __max = __first;
       break;
     }

   if (__comp(__next, __first))
     {
       if (__comp(__next, __min))
  __min = __next;
       if (!__comp(__first, __max))
  __max = __first;
     }
   else
     {
       if (__comp(__first, __min))
  __min = __first;
       if (!__comp(__next, __max))
  __max = __next;
     }

   __first = __next;
   ++__first;
 }

      return std::make_pair(__min, __max);
    }
# 3500 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    inline pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      ;

      return std::__minmax_element(__first, __last,
       __gnu_cxx::__ops::__iter_less_iter());
    }
# 3528 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last,
     _Compare __comp)
    {

     
     


      ;
      ;

      return std::__minmax_element(__first, __last,
       __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }


  template<typename _Tp>
    constexpr
    inline _Tp
    min(initializer_list<_Tp> __l)
    { return *std::min_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>
    constexpr
    inline _Tp
    min(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::min_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>
    constexpr
    inline _Tp
    max(initializer_list<_Tp> __l)
    { return *std::max_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>
    constexpr
    inline _Tp
    max(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::max_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>
    constexpr
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end());
      return std::make_pair(*__p.first, *__p.second);
    }

  template<typename _Tp, typename _Compare>
    constexpr
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l, _Compare __comp)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end(), __comp);
      return std::make_pair(*__p.first, *__p.second);
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    constexpr
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {


      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__first1 == __last1)
 return true;



      _ForwardIterator2 __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));
      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
     __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches
     = std::__count_if(__first2, __last2,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches ||
       std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
# 3641 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    constexpr
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2)
    {

     
     
     


      ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 3673 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    constexpr
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {

     
     
     


      ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_comp_iter(__pred));
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    constexpr
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2,
       _BinaryPredicate __pred)
    {
      using _Cat1
 = typename iterator_traits<_ForwardIterator1>::iterator_category;
      using _Cat2
 = typename iterator_traits<_ForwardIterator2>::iterator_category;
      using _It1_is_RA = is_same<_Cat1, random_access_iterator_tag>;
      using _It2_is_RA = is_same<_Cat2, random_access_iterator_tag>;
      constexpr bool __ra_iters = _It1_is_RA() && _It2_is_RA();
      if (__ra_iters)
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
 }



      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__ra_iters)
 {
   if (__first1 == __last1)
     return true;
 }
      else
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 == 0 && __d2 == 0)
     return true;
   if (__d1 != __d2)
     return false;
 }

      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches = std::__count_if(__first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches
       || std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
# 3768 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    constexpr
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {
      ;
      ;

      return
 std::__is_permutation(__first1, __last1, __first2, __last2,
         __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 3796 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    constexpr
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
     _BinaryPredicate __pred)
    {
      ;
      ;

      return std::__is_permutation(__first1, __last1, __first2, __last2,
       __gnu_cxx::__ops::__iter_comp_iter(__pred));
    }
# 3823 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _Tp>
    constexpr const _Tp&
    clamp(const _Tp& __val, const _Tp& __lo, const _Tp& __hi)
    {
      ;
      return (__val < __lo) ? __lo : (__hi < __val) ? __hi : __val;
    }
# 3841 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _Tp, typename _Compare>
    constexpr const _Tp&
    clamp(const _Tp& __val, const _Tp& __lo, const _Tp& __hi, _Compare __comp)
    {
      ;
      return __comp(__val, __lo) ? __lo : __comp(__hi, __val) ? __hi : __val;
    }
# 3873 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _IntType, typename _UniformRandomBitGenerator>
    pair<_IntType, _IntType>
    __gen_two_uniform_ints(_IntType __b0, _IntType __b1,
      _UniformRandomBitGenerator&& __g)
    {
      _IntType __x
 = uniform_int_distribution<_IntType>{0, (__b0 * __b1) - 1}(__g);
      return std::make_pair(__x / __b1, __x % __b1);
    }
# 3895 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator,
    typename _UniformRandomNumberGenerator>
    void
    shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _UniformRandomNumberGenerator&& __g)
    {

     

      ;

      if (__first == __last)
 return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      typedef typename std::make_unsigned<_DistanceType>::type __ud_type;
      typedef typename std::uniform_int_distribution<__ud_type> __distr_type;
      typedef typename __distr_type::param_type __p_type;

      typedef typename remove_reference<_UniformRandomNumberGenerator>::type
 _Gen;
      typedef typename common_type<typename _Gen::result_type, __ud_type>::type
 __uc_type;

      const __uc_type __urngrange = __g.max() - __g.min();
      const __uc_type __urange = __uc_type(__last - __first);

      if (__urngrange / __urange >= __urange)

      {
 _RandomAccessIterator __i = __first + 1;





 if ((__urange % 2) == 0)
 {
   __distr_type __d{0, 1};
   std::iter_swap(__i++, __first + __d(__g));
 }





 while (__i != __last)
 {
   const __uc_type __swap_range = __uc_type(__i - __first) + 1;

   const pair<__uc_type, __uc_type> __pospos =
     __gen_two_uniform_ints(__swap_range, __swap_range + 1, __g);

   std::iter_swap(__i++, __first + __pospos.first);
   std::iter_swap(__i++, __first + __pospos.second);
 }

 return;
      }

      __distr_type __d;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __d(__g, __p_type(0, __i - __first)));
    }





# 3980 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Function>
    constexpr
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {

     
      ;
      for (; __first != __last; ++__first)
 __f(*__first);
      return __f;
    }
# 4006 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Size, typename _Function>
    _InputIterator
    for_each_n(_InputIterator __first, _Size __n, _Function __f)
    {
      auto __n2 = std::__size_to_integer(__n);
      using _Cat = typename iterator_traits<_InputIterator>::iterator_category;
      if constexpr (is_base_of_v<random_access_iterator_tag, _Cat>)
 {
   if (__n2 <= 0)
     return __first;
   auto __last = __first + __n2;
   std::for_each(__first, __last, std::move(__f));
   return __last;
 }
      else
 {
   while (__n2-->0)
     {
       __f(*__first);
       ++__first;
     }
   return __first;
 }
    }
# 4041 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    constexpr
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val)
    {

     
     

      ;
      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__iter_equals_val(__val));
    }
# 4066 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    constexpr
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {

     
     

      ;

      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 4098 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    constexpr
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2)
    {

     
     
     


      ;
      ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (*__first1 == *__iter)
     return __first1;
      return __last1;
    }
# 4139 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    constexpr
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2,
    _BinaryPredicate __comp)
    {

     
     
     


      ;
      ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (__comp(*__first1, *__iter))
     return __first1;
      return __last1;
    }
# 4172 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    inline _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;

      return std::__adjacent_find(__first, __last,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 4198 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    constexpr
    inline _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {

     
     


      ;

      return std::__adjacent_find(__first, __last,
   __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }
# 4224 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    constexpr
    inline typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {

     
     

      ;

      return std::__count_if(__first, __last,
        __gnu_cxx::__ops::__iter_equals_val(__value));
    }
# 4248 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    constexpr
    inline typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {

     
     

      ;

      return std::__count_if(__first, __last,
        __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 4289 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    constexpr
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__search(__first1, __last1, __first2, __last2,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 4329 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    constexpr
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {

     
     
     


      ;
      ;

      return std::__search(__first1, __last1, __first2, __last2,
      __gnu_cxx::__ops::__iter_comp_iter(__predicate));
    }
# 4365 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    constexpr
    inline _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val)
    {

     
     

      ;

      return std::__search_n(__first, __last, __count,
        __gnu_cxx::__ops::__iter_equals_val(__val));
    }
# 4399 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
    typename _BinaryPredicate>
    constexpr
    inline _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val,
      _BinaryPredicate __binary_pred)
    {

     
     

      ;

      return std::__search_n(__first, __last, __count,
  __gnu_cxx::__ops::__iter_comp_val(__binary_pred, __val));
    }
# 4425 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Searcher>
    inline _ForwardIterator
    search(_ForwardIterator __first, _ForwardIterator __last,
    const _Searcher& __searcher)
    { return __searcher(__first, __last).first; }
# 4448 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>
    constexpr
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _UnaryOperation __unary_op)
    {

     
     


      ;

      for (; __first != __last; ++__first, (void)++__result)
 *__result = __unary_op(*__first);
      return __result;
    }
# 4486 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _BinaryOperation>
    constexpr
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _OutputIterator __result,
       _BinaryOperation __binary_op)
    {

     
     
     


      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2, ++__result)
 *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
# 4520 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    constexpr
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
     const _Tp& __old_value, const _Tp& __new_value)
    {

     

     

     

      ;

      for (; __first != __last; ++__first)
 if (*__first == __old_value)
   *__first = __new_value;
    }
# 4553 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
    constexpr
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
        _Predicate __pred, const _Tp& __new_value)
    {

     

     

     

      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   *__first = __new_value;
    }
# 4586 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Generator>
    constexpr
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
      _Generator __gen)
    {

     
     

      ;

      for (; __first != __last; ++__first)
 *__first = __gen();
    }
# 4620 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _OutputIterator, typename _Size, typename _Generator>
    constexpr
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {

     



      typedef __decltype(std::__size_to_integer(__n)) _IntSize;
      for (_IntSize __niter = std::__size_to_integer(__n);
    __niter > 0; --__niter, (void) ++__first)
 *__first = __gen();
      return __first;
    }
# 4658 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    constexpr
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {

     
     

     

      ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
    __gnu_cxx::__ops::__iter_equal_to_iter(),
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4699 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    constexpr
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result,
  _BinaryPredicate __binary_pred)
    {

     
     

      ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
   __gnu_cxx::__ops::__iter_comp_iter(__binary_pred),
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4733 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

      ;

      if (__first != __last)
 for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
   {

     _RandomAccessIterator __j = __first
     + std::rand() % ((__i - __first) + 1);
     if (__i != __j)
       std::iter_swap(__i, __j);
   }
    }
# 4768 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,

     _RandomNumberGenerator&& __rand)



    {

     

      ;

      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   _RandomAccessIterator __j = __first + __rand((__i - __first) + 1);
   if (__i != __j)
     std::iter_swap(__i, __j);
 }
    }
# 4808 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    constexpr
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      return std::__partition(__first, __last, __pred,
         std::__iterator_category(__first));
    }
# 4842 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    constexpr
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last)
    {

     

     

      ;
      ;
      ;

      std::__partial_sort(__first, __middle, __last,
     __gnu_cxx::__ops::__iter_less_iter());
    }
# 4881 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    constexpr
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last,
   _Compare __comp)
    {

     

     


      ;
      ;
      ;

      std::__partial_sort(__first, __middle, __last,
     __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 4918 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    constexpr
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last)
    {

     

     

      ;
      ;
      ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 4958 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    constexpr
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last, _Compare __comp)
    {

     

     


      ;
      ;
      ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 4996 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    constexpr
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }
# 5027 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    constexpr
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {

     

     


      ;
      ;

      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    constexpr
    _OutputIterator
    __merge(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 5090 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    constexpr
    inline _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {

     
     
     

     

     


      ;
      ;
      ;
      ;

      return std::__merge(__first1, __last1,
         __first2, __last2, __result,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 5141 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    constexpr
    inline _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {

     
     
     

     

     


      ;
      ;
      ;
      ;

      return std::__merge(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      typedef _Temporary_buffer<_RandomAccessIterator, _ValueType> _TmpBuf;
      _TmpBuf __buf(__first, std::distance(__first, __last));

      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last, __comp);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()), __comp);
    }
# 5206 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      std::__stable_sort(__first, __last,
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 5240 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {

     

     


      ;
      ;

      std::__stable_sort(__first, __last,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    constexpr
    _OutputIterator
    __set_union(_InputIterator1 __first1, _InputIterator1 __last1,
  _InputIterator2 __first2, _InputIterator2 __last2,
  _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first1, __first2))
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (__comp(__first2, __first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 5310 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    constexpr
    inline _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {

     
     
     

     

     


     


      ;
      ;
      ;
      ;

      return std::__set_union(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 5361 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    constexpr
    inline _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {

     
     
     

     

     


     


      ;
      ;
      ;
      ;

      return std::__set_union(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    constexpr
    _OutputIterator
    __set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _InputIterator2 __last2,
         _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   ++__first1;
 else if (__comp(__first2, __first1))
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 5434 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    constexpr
    inline _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {

     
     
     

     


     


      ;
      ;
      ;
      ;

      return std::__set_intersection(__first1, __last1,
         __first2, __last2, __result,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 5484 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    constexpr
    inline _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {

     
     
     

     


     


      ;
      ;
      ;
      ;

      return std::__set_intersection(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    constexpr
    _OutputIterator
    __set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(__first2, __first1))
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 5559 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    constexpr
    inline _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {

     
     
     

     


     


      ;
      ;
      ;
      ;

      return std::__set_difference(__first1, __last1,
       __first2, __last2, __result,
       __gnu_cxx::__ops::__iter_less_iter());
    }
# 5611 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    constexpr
    inline _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {

     
     
     

     


     


      ;
      ;
      ;
      ;

      return std::__set_difference(__first1, __last1,
       __first2, __last2, __result,
       __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    constexpr
    _OutputIterator
    __set_symmetric_difference(_InputIterator1 __first1,
          _InputIterator1 __last1,
          _InputIterator2 __first2,
          _InputIterator2 __last2,
          _OutputIterator __result,
          _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(__first2, __first1))
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 5692 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    constexpr
    inline _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result)
    {

     
     
     

     

     


     


      ;
      ;
      ;
      ;

      return std::__set_symmetric_difference(__first1, __last1,
     __first2, __last2, __result,
     __gnu_cxx::__ops::__iter_less_iter());
    }
# 5744 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    constexpr
    inline _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result,
        _Compare __comp)
    {

     
     
     

     

     


     


      ;
      ;
      ;
      ;

      return std::__set_symmetric_difference(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    _ForwardIterator
    __min_element(_ForwardIterator __first, _ForwardIterator __last,
    _Compare __comp)
    {
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(__first, __result))
   __result = __first;
      return __result;
    }
# 5798 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    _ForwardIterator
    inline min_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      ;

      return std::__min_element(__first, __last,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 5823 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {

     
     


      ;
      ;

      return std::__min_element(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    _ForwardIterator
    __max_element(_ForwardIterator __first, _ForwardIterator __last,
    _Compare __comp)
    {
      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(__result, __first))
   __result = __first;
      return __result;
    }
# 5862 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    inline _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      ;

      return std::__max_element(__first, __last,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 5887 "/usr/local/include/c++/10.0.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {

     
     


      ;
      ;

      return std::__max_element(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }



  template<typename _InputIterator, typename _RandomAccessIterator,
           typename _Size, typename _UniformRandomBitGenerator>
    _RandomAccessIterator
    __sample(_InputIterator __first, _InputIterator __last, input_iterator_tag,
      _RandomAccessIterator __out, random_access_iterator_tag,
      _Size __n, _UniformRandomBitGenerator&& __g)
    {
      using __distrib_type = uniform_int_distribution<_Size>;
      using __param_type = typename __distrib_type::param_type;
      __distrib_type __d{};
      _Size __sample_sz = 0;
      while (__first != __last && __sample_sz != __n)
 {
   __out[__sample_sz++] = *__first;
   ++__first;
 }
      for (auto __pop_sz = __sample_sz; __first != __last;
   ++__first, (void) ++__pop_sz)
 {
   const auto __k = __d(__g, __param_type{0, __pop_sz});
   if (__k < __n)
     __out[__k] = *__first;
 }
      return __out + __sample_sz;
    }


  template<typename _ForwardIterator, typename _OutputIterator, typename _Cat,
           typename _Size, typename _UniformRandomBitGenerator>
    _OutputIterator
    __sample(_ForwardIterator __first, _ForwardIterator __last,
      forward_iterator_tag,
      _OutputIterator __out, _Cat,
      _Size __n, _UniformRandomBitGenerator&& __g)
    {
      using __distrib_type = uniform_int_distribution<_Size>;
      using __param_type = typename __distrib_type::param_type;
      using _USize = make_unsigned_t<_Size>;
      using _Gen = remove_reference_t<_UniformRandomBitGenerator>;
      using __uc_type = common_type_t<typename _Gen::result_type, _USize>;

      __distrib_type __d{};
      _Size __unsampled_sz = std::distance(__first, __last);
      __n = std::min(__n, __unsampled_sz);




      const __uc_type __urngrange = __g.max() - __g.min();
      if (__urngrange / __uc_type(__unsampled_sz) >= __uc_type(__unsampled_sz))


        {
   while (__n != 0 && __unsampled_sz >= 2)
     {
       const pair<_Size, _Size> __p =
  __gen_two_uniform_ints(__unsampled_sz, __unsampled_sz - 1, __g);

       --__unsampled_sz;
       if (__p.first < __n)
  {
    *__out++ = *__first;
    --__n;
  }

       ++__first;

       if (__n == 0) break;

       --__unsampled_sz;
       if (__p.second < __n)
  {
    *__out++ = *__first;
    --__n;
  }

       ++__first;
     }
        }



      for (; __n != 0; ++__first)
 if (__d(__g, __param_type{0, --__unsampled_sz}) < __n)
   {
     *__out++ = *__first;
     --__n;
   }
      return __out;
    }




  template<typename _PopulationIterator, typename _SampleIterator,
           typename _Distance, typename _UniformRandomBitGenerator>
    _SampleIterator
    sample(_PopulationIterator __first, _PopulationIterator __last,
    _SampleIterator __out, _Distance __n,
    _UniformRandomBitGenerator&& __g)
    {
      using __pop_cat = typename
 std::iterator_traits<_PopulationIterator>::iterator_category;
      using __samp_cat = typename
 std::iterator_traits<_SampleIterator>::iterator_category;

      static_assert(
   __or_<is_convertible<__pop_cat, forward_iterator_tag>,
  is_convertible<__samp_cat, random_access_iterator_tag>>::value,
   "output range must use a RandomAccessIterator when input range"
   " does not meet the ForwardIterator requirements");

      static_assert(is_integral<_Distance>::value,
      "sample size must be an integer type");

      typename iterator_traits<_PopulationIterator>::difference_type __d = __n;
      return std::
 __sample(__first, __last, __pop_cat{}, __out, __samp_cat{}, __d,
   std::forward<_UniformRandomBitGenerator>(__g));
    }





}
# 53 "/usr/local/include/c++/10.0.0/string" 2 3


# 1 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 1 3
# 37 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
       
# 38 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
# 52 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



namespace __cxx11 {
# 76 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_CharT>::other _Char_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Char_alloc_type allocator_type;
      typedef typename _Alloc_traits::size_type size_type;
      typedef typename _Alloc_traits::difference_type difference_type;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
       const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;


      static const size_type npos = static_cast<size_type>(-1);

    protected:




      typedef const_iterator __const_iterator;


    private:


      typedef basic_string_view<_CharT, _Traits> __sv_type;

      template<typename _Tp, typename _Res>
 using _If_sv = enable_if_t<
   __and_<is_convertible<const _Tp&, __sv_type>,
   __not_<is_convertible<const _Tp*, const basic_string*>>,
   __not_<is_convertible<const _Tp&, const _CharT*>>>::value,
   _Res>;


      static __sv_type
      _S_to_string_view(__sv_type __svt) noexcept
      { return __svt; }





      struct __sv_wrapper
      {
 explicit __sv_wrapper(__sv_type __sv) noexcept : _M_sv(__sv) { }
 __sv_type _M_sv;
      };







      explicit
      basic_string(__sv_wrapper __svw, const _Alloc& __a)
      : basic_string(__svw._M_sv.data(), __svw._M_sv.size(), __a) { }



      struct _Alloc_hider : allocator_type
      {




 _Alloc_hider(pointer __dat, const _Alloc& __a)
 : allocator_type(__a), _M_p(__dat) { }

 _Alloc_hider(pointer __dat, _Alloc&& __a = _Alloc())
 : allocator_type(std::move(__a)), _M_p(__dat) { }


 pointer _M_p;
      };

      _Alloc_hider _M_dataplus;
      size_type _M_string_length;

      enum { _S_local_capacity = 15 / sizeof(_CharT) };

      union
      {
 _CharT _M_local_buf[_S_local_capacity + 1];
 size_type _M_allocated_capacity;
      };

      void
      _M_data(pointer __p)
      { _M_dataplus._M_p = __p; }

      void
      _M_length(size_type __length)
      { _M_string_length = __length; }

      pointer
      _M_data() const
      { return _M_dataplus._M_p; }

      pointer
      _M_local_data()
      {

 return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);



      }

      const_pointer
      _M_local_data() const
      {

 return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);



      }

      void
      _M_capacity(size_type __capacity)
      { _M_allocated_capacity = __capacity; }

      void
      _M_set_length(size_type __n)
      {
 _M_length(__n);
 traits_type::assign(_M_data()[__n], _CharT());
      }

      bool
      _M_is_local() const
      { return _M_data() == _M_local_data(); }


      pointer
      _M_create(size_type&, size_type);

      void
      _M_dispose()
      {
 if (!_M_is_local())
   _M_destroy(_M_allocated_capacity);
      }

      void
      _M_destroy(size_type __size) throw()
      { _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1); }



      template<typename _InIterator>
        void
        _M_construct_aux(_InIterator __beg, _InIterator __end,
    std::__false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          _M_construct(__beg, __end, _Tag());
 }



      template<typename _Integer>
        void
        _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type)
 { _M_construct_aux_2(static_cast<size_type>(__beg), __end); }

      void
      _M_construct_aux_2(size_type __req, _CharT __c)
      { _M_construct(__req, __c); }

      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   _M_construct_aux(__beg, __end, _Integral());
        }


      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end,
       std::input_iterator_tag);



      template<typename _FwdIterator>
        void
        _M_construct(_FwdIterator __beg, _FwdIterator __end,
       std::forward_iterator_tag);

      void
      _M_construct(size_type __req, _CharT __c);

      allocator_type&
      _M_get_allocator()
      { return _M_dataplus; }

      const allocator_type&
      _M_get_allocator() const
      { return _M_dataplus; }

    private:
# 309 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range_fmt(("%s: __pos (which is %zu) > " "this->size() (which is %zu)")
                                         ,
       __s, __pos, this->size());
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }



      size_type
      _M_limit(size_type __pos, size_type __off) const noexcept
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const noexcept
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _S_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _S_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _S_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, (void)++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) noexcept
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_assign(const basic_string&);

      void
      _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
  size_type __len2);

      void
      _M_erase(size_type __pos, size_type __n);

    public:







      basic_string()
      noexcept(is_nothrow_default_constructible<_Alloc>::value)
      : _M_dataplus(_M_local_data())
      { _M_set_length(0); }




      explicit
      basic_string(const _Alloc& __a) noexcept
      : _M_dataplus(_M_local_data(), __a)
      { _M_set_length(0); }





      basic_string(const basic_string& __str)
      : _M_dataplus(_M_local_data(),
      _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))
      { _M_construct(__str._M_data(), __str._M_data() + __str.length()); }
# 461 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,
     const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      {
 const _CharT* __start = __str._M_data()
   + __str._M_check(__pos, "basic_string::basic_string");
 _M_construct(__start, __start + __str._M_limit(__pos, npos));
      }







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n)
      : _M_dataplus(_M_local_data())
      {
 const _CharT* __start = __str._M_data()
   + __str._M_check(__pos, "basic_string::basic_string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
# 492 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      {
 const _CharT* __start
   = __str._M_data() + __str._M_check(__pos, "string::string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
# 510 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s + __n); }
# 523 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      template<typename = _RequireAllocator<_Alloc>>

      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s ? __s + traits_type::length(__s) : __s+npos); }
# 538 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      template<typename = _RequireAllocator<_Alloc>>

      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__n, __c); }
# 552 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      basic_string(basic_string&& __str) noexcept
      : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))
      {
 if (__str._M_is_local())
   {
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         _S_local_capacity + 1);
   }
 else
   {
     _M_data(__str._M_data());
     _M_capacity(__str._M_allocated_capacity);
   }




 _M_length(__str.length());
 __str._M_data(__str._M_local_data());
 __str._M_set_length(0);
      }






      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__l.begin(), __l.end()); }

      basic_string(const basic_string& __str, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__str.begin(), __str.end()); }

      basic_string(basic_string&& __str, const _Alloc& __a)
      noexcept(_Alloc_traits::_S_always_equal())
      : _M_dataplus(_M_local_data(), __a)
      {
 if (__str._M_is_local())
   {
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         _S_local_capacity + 1);
     _M_length(__str.length());
     __str._M_set_length(0);
   }
 else if (_Alloc_traits::_S_always_equal()
     || __str.get_allocator() == __a)
   {
     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     __str._M_data(__str._M_local_buf);
     __str._M_set_length(0);
   }
 else
   _M_construct(__str.begin(), __str.end());
      }
# 620 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc())
 : _M_dataplus(_M_local_data(), __a)
 { _M_construct(__beg, __end); }
# 638 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      template<typename _Tp, typename = _If_sv<_Tp, void>>
 basic_string(const _Tp& __t, size_type __pos, size_type __n,
       const _Alloc& __a = _Alloc())
 : basic_string(_S_to_string_view(__t).substr(__pos, __n), __a) { }






      template<typename _Tp, typename = _If_sv<_Tp, void>>
 explicit
 basic_string(const _Tp& __t, const _Alloc& __a = _Alloc())
 : basic_string(__sv_wrapper(_S_to_string_view(__t)), __a) { }





      ~basic_string()
      { _M_dispose(); }





      basic_string&
      operator=(const basic_string& __str)
      {
 return this->assign(__str);
      }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 685 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
# 702 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      basic_string&
      operator=(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {
 if (!_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign()
     && !_Alloc_traits::_S_always_equal()
     && _M_get_allocator() != __str._M_get_allocator())
   {

     _M_destroy(_M_allocated_capacity);
     _M_data(_M_local_data());
     _M_set_length(0);
   }

 std::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());

 if (__str._M_is_local())
   {

     if (__str.size())
       this->_S_copy(_M_data(), __str._M_data(), __str.size());
     _M_set_length(__str.size());
   }
 else if (_Alloc_traits::_S_propagate_on_move_assign()
     || _Alloc_traits::_S_always_equal()
     || _M_get_allocator() == __str._M_get_allocator())
   {

     pointer __data = nullptr;
     size_type __capacity;
     if (!_M_is_local())
       {
  if (_Alloc_traits::_S_always_equal())
    {

      __data = _M_data();
      __capacity = _M_allocated_capacity;
    }
  else
    _M_destroy(_M_allocated_capacity);
       }

     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     if (__data)
       {
  __str._M_data(__data);
  __str._M_capacity(__capacity);
       }
     else
       __str._M_data(__str._M_local_buf);
   }
 else
   assign(__str);
 __str.clear();
 return *this;
      }





      basic_string&
      operator=(initializer_list<_CharT> __l)
      {
 this->assign(__l.begin(), __l.size());
 return *this;
      }







     template<typename _Tp>
       _If_sv<_Tp, basic_string&>
       operator=(const _Tp& __svt)
       { return this->assign(__svt); }





      operator __sv_type() const noexcept
      { return __sv_type(data(), size()); }







      iterator
      begin() noexcept
      { return iterator(_M_data()); }





      const_iterator
      begin() const noexcept
      { return const_iterator(_M_data()); }





      iterator
      end() noexcept
      { return iterator(_M_data() + this->size()); }





      const_iterator
      end() const noexcept
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(this->begin()); }






      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_data()); }





      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_data() + this->size()); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->begin()); }


    public:



      size_type
      size() const noexcept
      { return _M_string_length; }



      size_type
      length() const noexcept
      { return _M_string_length; }


      size_type
      max_size() const noexcept
      { return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2; }
# 925 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 938 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }



      void
      shrink_to_fit() noexcept
      {

 if (capacity() > size())
   {
     try
       { reserve(0); }
     catch(...)
       { }
   }

      }






      size_type
      capacity() const noexcept
      {
 return _M_is_local() ? size_type(_S_local_capacity)
                      : _M_allocated_capacity;
      }
# 987 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear() noexcept
      { _M_set_length(0); }





      [[__nodiscard__]] bool
      empty() const noexcept
      { return this->size() == 0; }
# 1016 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const noexcept
      {
 ;
 return _M_data()[__pos];
      }
# 1033 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {


 ;

 ;
 return _M_data()[__pos];
      }
# 1054 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
 return _M_data()[__n];
      }
# 1075 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
 return _M_data()[__n];
      }






      reference
      front() noexcept
      {
 ;
 return operator[](0);
      }





      const_reference
      front() const noexcept
      {
 ;
 return operator[](0);
      }





      reference
      back() noexcept
      {
 ;
 return operator[](this->size() - 1);
      }





      const_reference
      back() const noexcept
      {
 ;
 return operator[](this->size() - 1);
      }
# 1138 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }







      basic_string&
      operator+=(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1180 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, basic_string&>
 operator+=(const _Tp& __svt)
 { return this->append(__svt); }







      basic_string&
      append(const basic_string& __str)
      { return _M_append(__str._M_data(), __str.size()); }
# 1208 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n = npos)
      { return _M_append(__str._M_data()
    + __str._M_check(__pos, "basic_string::append"),
    __str._M_limit(__pos, __n)); }







      basic_string&
      append(const _CharT* __s, size_type __n)
      {
 ;
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }






      basic_string&
      append(const _CharT* __s)
      {
 ;
 const size_type __n = traits_type::length(__s);
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }
# 1250 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c)
      { return _M_replace_aux(this->size(), size_type(0), __n, __c); }







      basic_string&
      append(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1274 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(end(), end(), __first, __last); }







      template<typename _Tp>
        _If_sv<_Tp, basic_string&>
        append(const _Tp& __svt)
        {
          __sv_type __sv = __svt;
          return this->append(__sv.data(), __sv.size());
        }
# 1304 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      template<typename _Tp>
        _If_sv<_Tp, basic_string&>
 append(const _Tp& __svt, size_type __pos, size_type __n = npos)
 {
   __sv_type __sv = __svt;
   return _M_append(__sv.data()
       + std::__sv_check(__sv.size(), __pos, "basic_string::append"),
       std::__sv_limit(__sv.size(), __pos, __n));
 }






      void
      push_back(_CharT __c)
      {
 const size_type __size = this->size();
 if (__size + 1 > this->capacity())
   this->_M_mutate(__size, size_type(0), 0, size_type(1));
 traits_type::assign(this->_M_data()[__size], __c);
 this->_M_set_length(__size + 1);
      }






      basic_string&
      assign(const basic_string& __str)
      {

 if (_Alloc_traits::_S_propagate_on_copy_assign())
   {
     if (!_Alloc_traits::_S_always_equal() && !_M_is_local()
  && _M_get_allocator() != __str._M_get_allocator())
       {


  if (__str.size() <= _S_local_capacity)
    {
      _M_destroy(_M_allocated_capacity);
      _M_data(_M_local_data());
      _M_set_length(0);
    }
  else
    {
      const auto __len = __str.size();
      auto __alloc = __str._M_get_allocator();

      auto __ptr = _Alloc_traits::allocate(__alloc, __len + 1);
      _M_destroy(_M_allocated_capacity);
      _M_data(__ptr);
      _M_capacity(__len);
      _M_set_length(__len);
    }
       }
     std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator());
   }

 this->_M_assign(__str);
 return *this;
      }
# 1379 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      basic_string&
      assign(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {


 return *this = std::move(__str);
      }
# 1402 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n = npos)
      { return _M_replace(size_type(0), this->size(), __str._M_data()
     + __str._M_check(__pos, "basic_string::assign"),
     __str._M_limit(__pos, __n)); }
# 1418 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n)
      {
 ;
 return _M_replace(size_type(0), this->size(), __s, __n);
      }
# 1434 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return _M_replace(size_type(0), this->size(), __s,
     traits_type::length(__s));
      }
# 1451 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 1464 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(begin(), end(), __first, __last); }







      basic_string&
      assign(initializer_list<_CharT> __l)
      { return this->assign(__l.begin(), __l.size()); }
# 1490 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, basic_string&>
 assign(const _Tp& __svt)
 {
   __sv_type __sv = __svt;
   return this->assign(__sv.data(), __sv.size());
 }
# 1505 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, basic_string&>
 assign(const _Tp& __svt, size_type __pos, size_type __n = npos)
 {
   __sv_type __sv = __svt;
   return _M_replace(size_type(0), this->size(),
       __sv.data()
       + std::__sv_check(__sv.size(), __pos, "basic_string::assign"),
       std::__sv_limit(__sv.size(), __pos, __n));
 }
# 1533 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      iterator
      insert(const_iterator __p, size_type __n, _CharT __c)
      {
 ;
 const size_type __pos = __p - begin();
 this->replace(__p, __p, __n, __c);
 return iterator(this->_M_data() + __pos);
      }
# 1575 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
        insert(const_iterator __p, _InputIterator __beg, _InputIterator __end)
        {
   ;
   const size_type __pos = __p - begin();
   this->replace(__p, __p, __beg, __end);
   return iterator(this->_M_data() + __pos);
 }
# 1611 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      iterator
      insert(const_iterator __p, initializer_list<_CharT> __l)
      { return this->insert(__p, __l.begin(), __l.end()); }
# 1638 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->replace(__pos1, size_type(0),
        __str._M_data(), __str.size()); }
# 1661 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n = npos)
      { return this->replace(__pos1, size_type(0), __str._M_data()
        + __str._M_check(__pos2, "basic_string::insert"),
        __str._M_limit(__pos2, __n)); }
# 1684 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n)
      { return this->replace(__pos, size_type(0), __s, __n); }
# 1703 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->replace(__pos, size_type(0), __s,
        traits_type::length(__s));
      }
# 1727 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1745 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      iterator
      insert(__const_iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - begin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 return iterator(_M_data() + __pos);
      }
# 1761 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, basic_string&>
 insert(size_type __pos, const _Tp& __svt)
 {
   __sv_type __sv = __svt;
   return this->insert(__pos, __sv.data(), __sv.size());
 }
# 1777 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, basic_string&>
 insert(size_type __pos1, const _Tp& __svt,
        size_type __pos2, size_type __n = npos)
 {
   __sv_type __sv = __svt;
   return this->replace(__pos1, size_type(0),
       __sv.data()
       + std::__sv_check(__sv.size(), __pos2, "basic_string::insert"),
       std::__sv_limit(__sv.size(), __pos2, __n));
 }
# 1805 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_check(__pos, "basic_string::erase");
 if (__n == npos)
   this->_M_set_length(__pos);
 else if (__n != 0)
   this->_M_erase(__pos, _M_limit(__pos, __n));
 return *this;
      }
# 1824 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      iterator
      erase(__const_iterator __position)
      {

                           ;
 const size_type __pos = __position - begin();
 this->_M_erase(__pos, size_type(1));
 return iterator(_M_data() + __pos);
      }
# 1843 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      iterator
      erase(__const_iterator __first, __const_iterator __last)
      {

                        ;
        const size_type __pos = __first - begin();
 if (__last == end())
   this->_M_set_length(__pos);
 else
   this->_M_erase(__pos, __last - __first);
 return iterator(this->_M_data() + __pos);
      }







      void
      pop_back() noexcept
      {
 ;
 _M_erase(size() - 1, 1);
      }
# 1887 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1909 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2 = npos)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1934 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2)
      {
 ;
 return _M_replace(_M_check(__pos, "basic_string::replace"),
     _M_limit(__pos, __n1), __s, __n2);
      }
# 1959 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1983 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 2001 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 2021 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __s, size_type __n)
      {

                      ;
 return this->replace(__i1 - begin(), __i2 - __i1, __s, __n);
      }
# 2043 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 2064 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, size_type __n,
       _CharT __c)
      {

                      ;
 return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);
      }
# 2089 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        basic_string&
        replace(const_iterator __i1, const_iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {
  
                        ;
   ;
   return this->_M_replace_dispatch(__i1, __i2, __k1, __k2,
        std::__false_type());
 }
# 2121 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       _CharT* __k1, _CharT* __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       iterator __k1, iterator __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
# 2180 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      basic_string& replace(const_iterator __i1, const_iterator __i2,
       initializer_list<_CharT> __l)
      { return this->replace(__i1, __i2, __l.begin(), __l.size()); }
# 2193 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, basic_string&>
 replace(size_type __pos, size_type __n, const _Tp& __svt)
 {
   __sv_type __sv = __svt;
   return this->replace(__pos, __n, __sv.data(), __sv.size());
 }
# 2210 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, basic_string&>
 replace(size_type __pos1, size_type __n1, const _Tp& __svt,
  size_type __pos2, size_type __n2 = npos)
 {
   __sv_type __sv = __svt;
   return this->replace(__pos1, __n1,
       __sv.data()
       + std::__sv_check(__sv.size(), __pos2, "basic_string::replace"),
       std::__sv_limit(__sv.size(), __pos2, __n2));
 }
# 2231 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, basic_string&>
 replace(const_iterator __i1, const_iterator __i2, const _Tp& __svt)
 {
   __sv_type __sv = __svt;
   return this->replace(__i1 - begin(), __i2 - __i1, __sv);
 }


    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _Integer __n, _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _InputIterator __k1, _InputIterator __k2,
       __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
   const size_type __len2);

      basic_string&
      _M_append(const _CharT* __s, size_type __n);

    public:
# 2278 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 2288 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      void
      swap(basic_string& __s) noexcept;
# 2298 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      const _CharT*
      c_str() const noexcept
      { return _M_data(); }
# 2310 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      const _CharT*
      data() const noexcept
      { return _M_data(); }
# 2321 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      _CharT*
      data() noexcept
      { return _M_data(); }





      allocator_type
      get_allocator() const noexcept
      { return _M_get_allocator(); }
# 2345 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2359 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find(__str.data(), __pos, __str.size()); }
# 2371 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, size_type>
 find(const _Tp& __svt, size_type __pos = 0) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   return this->find(__sv.data(), __pos, __sv.size());
 }
# 2391 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const noexcept
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 2408 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const noexcept;
# 2421 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 2433 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, size_type>
 rfind(const _Tp& __svt, size_type __pos = npos) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   return this->rfind(__sv.data(), __pos, __sv.size());
 }
# 2455 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2469 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 2486 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const noexcept;
# 2500 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 2513 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, size_type>
 find_first_of(const _Tp& __svt, size_type __pos = 0) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   return this->find_first_of(__sv.data(), __pos, __sv.size());
 }
# 2535 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2549 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      noexcept
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 2569 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const noexcept
      { return this->find(__c, __pos); }
# 2584 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 2597 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, size_type>
 find_last_of(const _Tp& __svt, size_type __pos = npos) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   return this->find_last_of(__sv.data(), __pos, __sv.size());
 }
# 2619 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2633 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      noexcept
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 2653 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const noexcept
      { return this->rfind(__c, __pos); }
# 2667 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 2680 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, size_type>
 find_first_not_of(const _Tp& __svt, size_type __pos = 0) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   return this->find_first_not_of(__sv.data(), __pos, __sv.size());
 }
# 2702 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const noexcept;
# 2716 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      noexcept
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 2734 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const
      noexcept;
# 2749 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 2762 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, size_type>
 find_last_not_of(const _Tp& __svt, size_type __pos = npos) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   return this->find_last_not_of(__sv.data(), __pos, __sv.size());
 }
# 2784 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const noexcept;
# 2798 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      noexcept
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 2816 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const
      noexcept;
# 2832 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 2851 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }







      template<typename _Tp>
 _If_sv<_Tp, int>
 compare(const _Tp& __svt) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   const size_type __size = this->size();
   const size_type __osize = __sv.size();
   const size_type __len = std::min(__size, __osize);

   int __r = traits_type::compare(_M_data(), __sv.data(), __len);
   if (!__r)
     __r = _S_compare(__size, __osize);
   return __r;
 }
# 2894 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, int>
 compare(size_type __pos, size_type __n, const _Tp& __svt) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   return __sv_type(*this).substr(__pos, __n).compare(__sv);
 }
# 2913 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      template<typename _Tp>
 _If_sv<_Tp, int>
 compare(size_type __pos1, size_type __n1, const _Tp& __svt,
  size_type __pos2, size_type __n2 = npos) const
 noexcept(is_same<_Tp, __sv_type>::value)
 {
   __sv_type __sv = __svt;
   return __sv_type(*this)
     .substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
 }
# 2944 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 2970 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2 = npos) const;
# 2988 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const noexcept;
# 3012 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 3039 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;


      bool
      starts_with(basic_string_view<_CharT, _Traits> __x) const noexcept
      { return __sv_type(this->data(), this->size()).starts_with(__x); }

      bool
      starts_with(_CharT __x) const noexcept
      { return __sv_type(this->data(), this->size()).starts_with(__x); }

      bool
      starts_with(const _CharT* __x) const noexcept
      { return __sv_type(this->data(), this->size()).starts_with(__x); }

      bool
      ends_with(basic_string_view<_CharT, _Traits> __x) const noexcept
      { return __sv_type(this->data(), this->size()).ends_with(__x); }

      bool
      ends_with(_CharT __x) const noexcept
      { return __sv_type(this->data(), this->size()).ends_with(__x); }

      bool
      ends_with(const _CharT* __x) const noexcept
      { return __sv_type(this->data(), this->size()).ends_with(__x); }



      template<typename, typename, typename> friend class basic_stringbuf;
    };
}
# 5985 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
namespace __cxx11 {
  template<typename _InputIterator, typename _CharT
      = typename iterator_traits<_InputIterator>::value_type,
    typename _Allocator = allocator<_CharT>,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireAllocator<_Allocator>>
    basic_string(_InputIterator, _InputIterator, _Allocator = _Allocator())
      -> basic_string<_CharT, char_traits<_CharT>, _Allocator>;



  template<typename _CharT, typename _Traits,
    typename _Allocator = allocator<_CharT>,
    typename = _RequireAllocator<_Allocator>>
    basic_string(basic_string_view<_CharT, _Traits>, const _Allocator& = _Allocator())
      -> basic_string<_CharT, _Traits, _Allocator>;

  template<typename _CharT, typename _Traits,
    typename _Allocator = allocator<_CharT>,
    typename = _RequireAllocator<_Allocator>>
    basic_string(basic_string_view<_CharT, _Traits>,
   typename basic_string<_CharT, _Traits, _Allocator>::size_type,
   typename basic_string<_CharT, _Traits, _Allocator>::size_type,
   const _Allocator& = _Allocator())
      -> basic_string<_CharT, _Traits, _Allocator>;
}
# 6020 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    {

      using _Alloc_traits = allocator_traits<_Alloc>;
      bool __use_rhs = false;
      if constexpr (typename _Alloc_traits::is_always_equal{})
 __use_rhs = true;
      else if (__lhs.get_allocator() == __rhs.get_allocator())
 __use_rhs = true;
      if (__use_rhs)

 {
   const auto __size = __lhs.size() + __rhs.size();
   if (__size > __lhs.capacity() && __size <= __rhs.capacity())
     return std::move(__rhs.insert(0, __lhs));
 }
      return std::move(__lhs.append(__rhs));
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, 1, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const _CharT* __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       _CharT __rhs)
    { return std::move(__lhs.append(1, __rhs)); }
# 6151 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs) noexcept
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 6198 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
# 6236 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 6274 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 6312 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 6350 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 6388 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept(noexcept(__lhs.swap(__rhs)))
    { __lhs.swap(__rhs); }
# 6408 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 6426 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 6449 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 6466 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str, __is.widen('\n')); }



  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    { return std::getline(__is, __str, __delim); }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str); }


  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);



}



# 1 "/usr/local/include/c++/10.0.0/ext/string_conversions.h" 1 3
# 32 "/usr/local/include/c++/10.0.0/ext/string_conversions.h" 3
       
# 33 "/usr/local/include/c++/10.0.0/ext/string_conversions.h" 3
# 41 "/usr/local/include/c++/10.0.0/ext/string_conversions.h" 3
# 1 "/usr/local/include/c++/10.0.0/cstdlib" 1 3
# 39 "/usr/local/include/c++/10.0.0/cstdlib" 3
       
# 40 "/usr/local/include/c++/10.0.0/cstdlib" 3
# 42 "/usr/local/include/c++/10.0.0/ext/string_conversions.h" 2 3
# 1 "/usr/local/include/c++/10.0.0/cwchar" 1 3
# 39 "/usr/local/include/c++/10.0.0/cwchar" 3
       
# 40 "/usr/local/include/c++/10.0.0/cwchar" 3
# 43 "/usr/local/include/c++/10.0.0/ext/string_conversions.h" 2 3
# 1 "/usr/local/include/c++/10.0.0/cstdio" 1 3
# 39 "/usr/local/include/c++/10.0.0/cstdio" 3
       
# 40 "/usr/local/include/c++/10.0.0/cstdio" 3


# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/stdio.h" 2 3 4

extern "C" {



# 1 "/usr/local/lib/gcc/x86_64-pc-linux-gnu/10.0.0/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/libio.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/_G_config.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/_G_config.h" 3 4
# 1 "/usr/local/lib/gcc/x86_64-pc-linux-gnu/10.0.0/include/stddef.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/_G_config.h" 2 3 4






typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 36 "/usr/include/x86_64-linux-gnu/bits/libio.h" 2 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
# 1 "/usr/local/lib/gcc/x86_64-pc-linux-gnu/10.0.0/include/stdarg.h" 1 3 4
# 54 "/usr/include/x86_64-linux-gnu/bits/libio.h" 2 3 4
# 149 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;




typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 177 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 245 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 293 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
  __off64_t _offset;







  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;

  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};





struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 337 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);




extern "C" {


extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 433 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) throw ();
extern int _IO_ferror (_IO_FILE *__fp) throw ();

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) throw ();
extern void _IO_funlockfile (_IO_FILE *) throw ();
extern int _IO_ftrylockfile (_IO_FILE *) throw ();
# 462 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) throw ();
# 524 "/usr/include/x86_64-linux-gnu/bits/libio.h" 3 4
}
# 42 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 78 "/usr/include/stdio.h" 3 4
typedef _G_fpos_t fpos_t;




typedef _G_fpos64_t fpos64_t;
# 131 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 132 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;






extern int remove (const char *__filename) throw ();

extern int rename (const char *__old, const char *__new) throw ();



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) throw ();







extern FILE *tmpfile (void) ;
# 169 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) throw () ;




extern char *tmpnam_r (char *__s) throw () ;
# 190 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     throw () __attribute__ ((__malloc__)) ;







extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 213 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 223 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 232 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 256 "/usr/include/stdio.h" 3 4
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) throw () ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) throw () ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  throw () ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;





extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) throw ();



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) throw ();
# 420 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));
# 477 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);
# 495 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 506 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 517 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 537 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 587 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 603 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 662 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 673 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 707 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 731 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 750 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);



extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () ;

extern int ferror (FILE *__stream) throw () ;



extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;







extern void perror (const char *__s);





# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 782 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) throw () ;




extern int fileno_unlocked (FILE *__stream) throw () ;
# 800 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () ;


extern void funlockfile (FILE *__stream) throw ();
# 859 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
vprintf (const char *__restrict __fmt, __gnuc_va_list __arg)
{
  return vfprintf (stdout, __fmt, __arg);
}



extern __inline __attribute__ ((__gnu_inline__)) int
getchar (void)
{
  return _IO_getc (stdin);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fgetc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}





extern __inline __attribute__ ((__gnu_inline__)) int
getc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}


extern __inline __attribute__ ((__gnu_inline__)) int
getchar_unlocked (void)
{
  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
}




extern __inline __attribute__ ((__gnu_inline__)) int
putchar (int __c)
{
  return _IO_putc (__c, stdout);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fputc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) int
putc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}


extern __inline __attribute__ ((__gnu_inline__)) int
putchar_unlocked (int __c)
{
  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) __ssize_t
getline (char **__lineptr, size_t *__n, FILE *__stream)
{
  return __getdelim (__lineptr, __n, '\n', __stream);
}





extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) feof_unlocked (FILE *__stream) throw ()
{
  return (((__stream)->_flags & 0x10) != 0);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) ferror_unlocked (FILE *__stream) throw ()
{
  return (((__stream)->_flags & 0x20) != 0);
}
# 860 "/usr/include/stdio.h" 2 3 4
# 868 "/usr/include/stdio.h" 3 4
}
# 43 "/usr/local/include/c++/10.0.0/cstdio" 2 3
# 96 "/usr/local/include/c++/10.0.0/cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;




  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;

  using ::tmpnam;

  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
# 157 "/usr/local/include/c++/10.0.0/cstdio" 3
namespace __gnu_cxx
{
# 175 "/usr/local/include/c++/10.0.0/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}
# 44 "/usr/local/include/c++/10.0.0/ext/string_conversions.h" 2 3
# 1 "/usr/local/include/c++/10.0.0/cerrno" 1 3
# 39 "/usr/local/include/c++/10.0.0/cerrno" 3
       
# 40 "/usr/local/include/c++/10.0.0/cerrno" 3


# 1 "/usr/include/errno.h" 1 3 4
# 28 "/usr/include/errno.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4




# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 6 "/usr/include/asm-generic/errno.h" 2 3 4
# 2 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
# 2 "/usr/include/linux/errno.h" 2 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4
# 29 "/usr/include/errno.h" 2 3 4





extern "C" {


extern int *__errno_location (void) throw () __attribute__ ((__const__));







extern char *program_invocation_name;
extern char *program_invocation_short_name;





typedef int error_t;




}
# 43 "/usr/local/include/c++/10.0.0/cerrno" 2 3
# 45 "/usr/local/include/c++/10.0.0/ext/string_conversions.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<typename _TRet, typename _Ret = _TRet, typename _CharT,
    typename... _Base>
    _Ret
    __stoa(_TRet (*__convf) (const _CharT*, _CharT**, _Base...),
    const char* __name, const _CharT* __str, std::size_t* __idx,
    _Base... __base)
    {
      _Ret __ret;

      _CharT* __endptr;

      struct _Save_errno {
 _Save_errno() : _M_errno((*__errno_location ())) { (*__errno_location ()) = 0; }
 ~_Save_errno() { if ((*__errno_location ()) == 0) (*__errno_location ()) = _M_errno; }
 int _M_errno;
      } const __save_errno;

      struct _Range_chk {
   static bool
   _S_chk(_TRet, std::false_type) { return false; }

   static bool
   _S_chk(_TRet __val, std::true_type)
   {
     return __val < _TRet(__numeric_traits<int>::__min)
       || __val > _TRet(__numeric_traits<int>::__max);
   }
      };

      const _TRet __tmp = __convf(__str, &__endptr, __base...);

      if (__endptr == __str)
 std::__throw_invalid_argument(__name);
      else if ((*__errno_location ()) == 34
   || _Range_chk::_S_chk(__tmp, std::is_same<_Ret, int>{}))
 std::__throw_out_of_range(__name);
      else
 __ret = __tmp;

      if (__idx)
 *__idx = __endptr - __str;

      return __ret;
    }


  template<typename _String, typename _CharT = typename _String::value_type>
    _String
    __to_xstring(int (*__convf) (_CharT*, std::size_t, const _CharT*,
     __builtin_va_list), std::size_t __n,
   const _CharT* __fmt, ...)
    {


      _CharT* __s = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
         * __n));

      __builtin_va_list __args;
      __builtin_va_start(__args, __fmt);

      const int __len = __convf(__s, __n, __fmt, __args);

      __builtin_va_end(__args);

      return _String(__s, __s + __len);
    }


}
# 6506 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 2 3
# 1 "/usr/local/include/c++/10.0.0/bits/charconv.h" 1 3
# 33 "/usr/local/include/c++/10.0.0/bits/charconv.h" 3
       
# 34 "/usr/local/include/c++/10.0.0/bits/charconv.h" 3





namespace std __attribute__ ((__visibility__ ("default")))
{

namespace __detail
{

  template<typename _Tp>
    constexpr unsigned
    __to_chars_len(_Tp __value, int __base = 10) noexcept
    {
      static_assert(is_integral<_Tp>::value, "implementation bug");
      static_assert(is_unsigned<_Tp>::value, "implementation bug");

      unsigned __n = 1;
      const unsigned __b2 = __base * __base;
      const unsigned __b3 = __b2 * __base;
      const unsigned long __b4 = __b3 * __base;
      for (;;)
 {
   if (__value < (unsigned)__base) return __n;
   if (__value < __b2) return __n + 1;
   if (__value < __b3) return __n + 2;
   if (__value < __b4) return __n + 3;
   __value /= __b4;
   __n += 4;
 }
    }




  template<typename _Tp>
    void
    __to_chars_10_impl(char* __first, unsigned __len, _Tp __val) noexcept
    {
      static_assert(is_integral<_Tp>::value, "implementation bug");
      static_assert(is_unsigned<_Tp>::value, "implementation bug");

      static constexpr char __digits[201] =
 "0001020304050607080910111213141516171819"
 "2021222324252627282930313233343536373839"
 "4041424344454647484950515253545556575859"
 "6061626364656667686970717273747576777879"
 "8081828384858687888990919293949596979899";
      unsigned __pos = __len - 1;
      while (__val >= 100)
 {
   auto const __num = (__val % 100) * 2;
   __val /= 100;
   __first[__pos] = __digits[__num + 1];
   __first[__pos - 1] = __digits[__num];
   __pos -= 2;
 }
      if (__val >= 10)
 {
   auto const __num = __val * 2;
   __first[1] = __digits[__num + 1];
   __first[0] = __digits[__num];
 }
      else
 __first[0] = '0' + __val;
    }

}

}
# 6507 "/usr/local/include/c++/10.0.0/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

namespace __cxx11 {



  inline int
  stoi(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }




  inline string
  to_string(int __val)
  {
    const bool __neg = __val < 0;
    const unsigned __uval = __neg ? (unsigned)~__val + 1u : __val;
    const auto __len = __detail::__to_chars_len(__uval);
    string __str(__neg + __len, '-');
    __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
    return __str;
  }

  inline string
  to_string(unsigned __val)
  {
    string __str(__detail::__to_chars_len(__val), '\0');
    __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
    return __str;
  }

  inline string
  to_string(long __val)
  {
    const bool __neg = __val < 0;
    const unsigned long __uval = __neg ? (unsigned long)~__val + 1ul : __val;
    const auto __len = __detail::__to_chars_len(__uval);
    string __str(__neg + __len, '-');
    __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
    return __str;
  }

  inline string
  to_string(unsigned long __val)
  {
    string __str(__detail::__to_chars_len(__val), '\0');
    __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
    return __str;
  }

  inline string
  to_string(long long __val)
  {
    const bool __neg = __val < 0;
    const unsigned long long __uval
      = __neg ? (unsigned long long)~__val + 1ull : __val;
    const auto __len = __detail::__to_chars_len(__uval);
    string __str(__neg + __len, '-');
    __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
    return __str;
  }

  inline string
  to_string(unsigned long long __val)
  {
    string __str(__detail::__to_chars_len(__val), '\0');
    __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
    return __str;
  }




  inline string
  to_string(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%Lf", __val);
  }



  inline int
  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); }



  inline wstring
  to_wstring(int __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),
         L"%d", __val); }

  inline wstring
  to_wstring(unsigned __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned),
         L"%u", __val); }

  inline wstring
  to_wstring(long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),
         L"%ld", __val); }

  inline wstring
  to_wstring(unsigned long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long),
         L"%lu", __val); }

  inline wstring
  to_wstring(long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(long long),
         L"%lld", __val); }

  inline wstring
  to_wstring(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long long),
         L"%llu", __val); }

  inline wstring
  to_wstring(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%Lf", __val);
  }



}

}







namespace std __attribute__ ((__visibility__ ("default")))
{






  template<>
    struct hash<string>
    : public __hash_base<size_t, string>
    {
      size_t
      operator()(const string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(), __s.length()); }
    };

  template<>
    struct __is_fast_hash<hash<string>> : std::false_type
    { };



  template<>
    struct hash<wstring>
    : public __hash_base<size_t, wstring>
    {
      size_t
      operator()(const wstring& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(wchar_t)); }
    };

  template<>
    struct __is_fast_hash<hash<wstring>> : std::false_type
    { };





  template<>
    struct hash<u8string>
    : public __hash_base<size_t, u8string>
    {
      size_t
      operator()(const u8string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char8_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u8string>> : std::false_type
    { };



  template<>
    struct hash<u16string>
    : public __hash_base<size_t, u16string>
    {
      size_t
      operator()(const u16string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char16_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u16string>> : std::false_type
    { };


  template<>
    struct hash<u32string>
    : public __hash_base<size_t, u32string>
    {
      size_t
      operator()(const u32string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char32_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u32string>> : std::false_type
    { };





  inline namespace literals
  {
  inline namespace string_literals
  {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wliteral-suffix"
    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char>
    operator""s(const char* __str, size_t __len)
    { return basic_string<char>{__str, __len}; }


    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<wchar_t>
    operator""s(const wchar_t* __str, size_t __len)
    { return basic_string<wchar_t>{__str, __len}; }



    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char8_t>
    operator""s(const char8_t* __str, size_t __len)
    { return basic_string<char8_t>{__str, __len}; }


    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char16_t>
    operator""s(const char16_t* __str, size_t __len)
    { return basic_string<char16_t>{__str, __len}; }

    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char32_t>
    operator""s(const char32_t* __str, size_t __len)
    { return basic_string<char32_t>{__str, __len}; }

#pragma GCC diagnostic pop
  }
  }


  namespace __detail::__variant
  {
    template<typename> struct _Never_valueless_alt;



    template<typename _Tp, typename _Traits, typename _Alloc>
      struct _Never_valueless_alt<std::basic_string<_Tp, _Traits, _Alloc>>
      : __and_<
 is_nothrow_move_constructible<std::basic_string<_Tp, _Traits, _Alloc>>,
 is_nothrow_move_assignable<std::basic_string<_Tp, _Traits, _Alloc>>
 >::type
      { };
  }




}
# 56 "/usr/local/include/c++/10.0.0/string" 2 3
# 1 "/usr/local/include/c++/10.0.0/bits/basic_string.tcc" 1 3
# 42 "/usr/local/include/c++/10.0.0/bits/basic_string.tcc" 3
       
# 43 "/usr/local/include/c++/10.0.0/bits/basic_string.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s) noexcept
    {
      if (this == &__s)
 return;

      _Alloc_traits::_S_on_swap(_M_get_allocator(), __s._M_get_allocator());

      if (_M_is_local())
 if (__s._M_is_local())
   {
     if (length() && __s.length())
       {
  _CharT __tmp_data[_S_local_capacity + 1];
  traits_type::copy(__tmp_data, __s._M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(_M_local_buf, __tmp_data,
      _S_local_capacity + 1);
       }
     else if (__s.length())
       {
  traits_type::copy(_M_local_buf, __s._M_local_buf,
      _S_local_capacity + 1);
  _M_length(__s.length());
  __s._M_set_length(0);
  return;
       }
     else if (length())
       {
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  __s._M_length(length());
  _M_set_length(0);
  return;
       }
   }
 else
   {
     const size_type __tmp_capacity = __s._M_allocated_capacity;
     traits_type::copy(__s._M_local_buf, _M_local_buf,
         _S_local_capacity + 1);
     _M_data(__s._M_data());
     __s._M_data(__s._M_local_buf);
     _M_capacity(__tmp_capacity);
   }
      else
 {
   const size_type __tmp_capacity = _M_allocated_capacity;
   if (__s._M_is_local())
     {
       traits_type::copy(_M_local_buf, __s._M_local_buf,
    _S_local_capacity + 1);
       __s._M_data(_M_data());
       _M_data(_M_local_buf);
     }
   else
     {
       pointer __tmp_ptr = _M_data();
       _M_data(__s._M_data());
       __s._M_data(__tmp_ptr);
       _M_capacity(__s._M_allocated_capacity);
     }
   __s._M_capacity(__tmp_capacity);
 }

      const size_type __tmp_length = length();
      _M_length(__s.length());
      __s._M_length(__tmp_length);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::pointer
    basic_string<_CharT, _Traits, _Alloc>::
    _M_create(size_type& __capacity, size_type __old_capacity)
    {


      if (__capacity > max_size())
 std::__throw_length_error(("basic_string::_M_create"));




      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 {
   __capacity = 2 * __old_capacity;

   if (__capacity > max_size())
     __capacity = max_size();
 }



      return _Alloc_traits::allocate(_M_get_allocator(), __capacity + 1);
    }





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::input_iterator_tag)
      {
 size_type __len = 0;
 size_type __capacity = size_type(_S_local_capacity);

 while (__beg != __end && __len < __capacity)
   {
     _M_data()[__len++] = *__beg;
     ++__beg;
   }

 try
   {
     while (__beg != __end)
       {
  if (__len == __capacity)
    {

      __capacity = __len + 1;
      pointer __another = _M_create(__capacity, __len);
      this->_S_copy(__another, _M_data(), __len);
      _M_dispose();
      _M_data(__another);
      _M_capacity(__capacity);
    }
  _M_data()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     _M_dispose();
     throw;
   }

 _M_set_length(__len);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::forward_iterator_tag)
      {

 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   std::__throw_logic_error(("basic_string::" "_M_construct null not valid")
                                         );

 size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));

 if (__dnew > size_type(_S_local_capacity))
   {
     _M_data(_M_create(__dnew, size_type(0)));
     _M_capacity(__dnew);
   }


 try
   { this->_S_copy_chars(_M_data(), __beg, __end); }
 catch(...)
   {
     _M_dispose();
     throw;
   }

 _M_set_length(__dnew);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_construct(size_type __n, _CharT __c)
    {
      if (__n > size_type(_S_local_capacity))
 {
   _M_data(_M_create(__n, size_type(0)));
   _M_capacity(__n);
 }

      if (__n)
 this->_S_assign(_M_data(), __n, __c);

      _M_set_length(__n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_assign(const basic_string& __str)
    {
      if (this != &__str)
 {
   const size_type __rsize = __str.length();
   const size_type __capacity = capacity();

   if (__rsize > __capacity)
     {
       size_type __new_capacity = __rsize;
       pointer __tmp = _M_create(__new_capacity, __capacity);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__new_capacity);
     }

   if (__rsize)
     this->_S_copy(_M_data(), __str._M_data(), __rsize);

   _M_set_length(__rsize);
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {

      if (__res < length())
 __res = length();

      const size_type __capacity = capacity();
      if (__res != __capacity)
 {
   if (__res > __capacity
       || __res > size_type(_S_local_capacity))
     {
       pointer __tmp = _M_create(__res, __capacity);
       this->_S_copy(__tmp, _M_data(), length() + 1);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__res);
     }
   else if (!_M_is_local())
     {
       this->_S_copy(_M_local_data(), _M_data(), length() + 1);
       _M_destroy(__capacity);
       _M_data(_M_local_data());
     }
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
       size_type __len2)
    {
      const size_type __how_much = length() - __pos - __len1;

      size_type __new_capacity = length() + __len2 - __len1;
      pointer __r = _M_create(__new_capacity, capacity());

      if (__pos)
 this->_S_copy(__r, _M_data(), __pos);
      if (__s && __len2)
 this->_S_copy(__r + __pos, __s, __len2);
      if (__how_much)
 this->_S_copy(__r + __pos + __len2,
        _M_data() + __pos + __len1, __how_much);

      _M_dispose();
      _M_data(__r);
      _M_capacity(__new_capacity);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_erase(size_type __pos, size_type __n)
    {
      const size_type __how_much = length() - __pos - __n;

      if (__how_much && __n)
 this->_S_move(_M_data() + __pos, _M_data() + __pos + __n, __how_much);

      _M_set_length(length() - __n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->_M_set_length(__n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_append(const _CharT* __s, size_type __n)
    {
      const size_type __len = __n + this->size();

      if (__len <= this->capacity())
 {
   if (__n)
     this->_S_copy(this->_M_data() + this->size(), __s, __n);
 }
      else
 this->_M_mutate(this->size(), size_type(0), __s, __n);

      this->_M_set_length(__len);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
     _InputIterator __k1, _InputIterator __k2,
     std::__false_type)
      {


 const basic_string __s(__k1, __k2, this->get_allocator());
 const size_type __n1 = __i2 - __i1;
 return _M_replace(__i1 - begin(), __n1, __s._M_data(),
     __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __n2 - __n1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos1;

   const size_type __how_much = __old_size - __pos1 - __n1;
   if (__how_much && __n1 != __n2)
     this->_S_move(__p + __n2, __p + __n1, __how_much);
 }
      else
 this->_M_mutate(__pos1, __n1, 0, __n2);

      if (__n2)
 this->_S_assign(this->_M_data() + __pos1, __n2, __c);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
        const size_type __len2)
    {
      _M_check_length(__len1, __len2, "basic_string::_M_replace");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos;

   const size_type __how_much = __old_size - __pos - __len1;
   if (_M_disjunct(__s))
     {
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2)
  this->_S_copy(__p, __s, __len2);
     }
   else
     {

       if (__len2 && __len2 <= __len1)
  this->_S_move(__p, __s, __len2);
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2 > __len1)
  {
    if (__s + __len2 <= __p + __len1)
      this->_S_move(__p, __s, __len2);
    else if (__s >= __p + __len1)
      this->_S_copy(__p, __s + __len2 - __len1, __len2);
    else
      {
        const size_type __nleft = (__p + __len1) - __s;
        this->_S_move(__p, __s, __nleft);
        this->_S_copy(__p + __nleft, __p + __len2,
        __len2 - __nleft);
      }
  }
     }
 }
      else
 this->_M_mutate(__pos, __len1, __s, __len2);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _S_copy(__s, _M_data() + __pos, __n);

      return __n;
    }
# 1158 "/usr/local/include/c++/10.0.0/bits/basic_string.tcc" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_CharT>::other _Char_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str(_Alloc_traits::_S_select_on_copy(
          __rhs.get_allocator()));
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_CharT>::other _Char_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
      __string_type __str(_Alloc_traits::_S_select_on_copy(
          __rhs.get_allocator()));
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      const size_type __size = this->size();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;
      if (__pos >= __size)
 return npos;

      const _CharT __elem0 = __s[0];
      const _CharT* const __data = data();
      const _CharT* __first = __data + __pos;
      const _CharT* const __last = __data + __size;
      size_type __len = __size - __pos;

      while (__len >= __n)
 {

   __first = traits_type::find(__first, __len - __n + 1, __elem0);
   if (!__first)
     return npos;



   if (traits_type::compare(__first, __s, __n) == 0)
     return __first - __data;
   __len = __last - ++__first;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const noexcept
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const noexcept
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const noexcept
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }
# 1626 "/usr/local/include/c++/10.0.0/bits/basic_string.tcc" 3
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);
# 1647 "/usr/local/include/c++/10.0.0/bits/basic_string.tcc" 3
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);




}
# 57 "/usr/local/include/c++/10.0.0/string" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

  namespace pmr {
    template<typename _Tp> class polymorphic_allocator;
    template<typename _CharT, typename _Traits = char_traits<_CharT>>
      using basic_string = std::basic_string<_CharT, _Traits,
          polymorphic_allocator<_CharT>>;
    using string = basic_string<char>;

    using u8string = basic_string<char8_t>;

    using u16string = basic_string<char16_t>;
    using u32string = basic_string<char32_t>;

    using wstring = basic_string<wchar_t>;

  }

  template<typename _Str>
    struct __hash_string_base
    : public __hash_base<size_t, _Str>
    {
      size_t
      operator()(const _Str& __s) const noexcept
      { return hash<basic_string_view<typename _Str::value_type>>{}(__s); }
    };

  template<>
    struct hash<pmr::string>
    : public __hash_string_base<pmr::string>
    { };

  template<>
    struct hash<pmr::u8string>
    : public __hash_string_base<pmr::u8string>
    { };

  template<>
    struct hash<pmr::u16string>
    : public __hash_string_base<pmr::u16string>
    { };
  template<>
    struct hash<pmr::u32string>
    : public __hash_string_base<pmr::u32string>
    { };

  template<>
    struct hash<pmr::wstring>
    : public __hash_string_base<pmr::wstring>
    { };



}



namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _CharT, typename _Traits, typename _Alloc,
    typename _Predicate>
    inline typename basic_string<_CharT, _Traits, _Alloc>::size_type
    erase_if(basic_string<_CharT, _Traits, _Alloc>& __cont, _Predicate __pred)
    {
      const auto __osz = __cont.size();
      __cont.erase(std::remove_if(__cont.begin(), __cont.end(), __pred),
     __cont.end());
      return __osz - __cont.size();
    }

  template<typename _CharT, typename _Traits, typename _Alloc, typename _Up>
    inline typename basic_string<_CharT, _Traits, _Alloc>::size_type
    erase(basic_string<_CharT, _Traits, _Alloc>& __cont, const _Up& __value)
    {
      const auto __osz = __cont.size();
      __cont.erase(std::remove(__cont.begin(), __cont.end(), __value),
     __cont.end());
      return __osz - __cont.size();
    }

}
# 41 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

# 62 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
# 98 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
# 117 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 3
    locale() throw();
# 126 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
# 136 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
# 151 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
# 162 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 3
    explicit
    locale(const std::string& __s) : locale(__s.c_str()) { }
# 177 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 3
    locale(const locale& __base, const std::string& __s, category __cat)
    : locale(__base, __s.c_str(), __cat) { }
# 192 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
# 205 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
# 219 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
# 234 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    __attribute ((__abi_tag__ ("cxx11")))
    string
    name() const;
# 254 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw();







    bool
    operator!=(const locale& __other) const throw()
    { return !(this->operator==(__other)); }
# 282 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
# 298 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 3
    static locale
    global(const locale& __loc);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
# 333 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 6 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once() throw();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);


    static const id* const _S_twinned_facets[];

  };
# 371 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
# 402 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc) throw();

    static void
    _S_destroy_c_locale(__c_locale& __cloc);

    static __c_locale
    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);



    static __c_locale
    _S_get_c_locale();

    __attribute__ ((__const__)) static const char*
    _S_get_c_name() throw();
# 438 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 3
    facet(const facet&) = delete;

    facet&
    operator=(const facet&) = delete;


  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    const facet* _M_sso_shim(const id*) const;
    const facet* _M_cow_shim(const id*) const;

  protected:
    class __shim;
  };
# 483 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const throw();
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    template<typename _Facet>
      void
      _M_init_facet_unchecked(_Facet* __facet)
      {
 __facet->_M_add_reference();
 _M_facets[_Facet::id._M_id()] = __facet;
      }

    void
    _M_install_cache(const facet*, size_t);

    void _M_init_extra(facet**);
    void _M_init_extra(void*, void*, const char*, const char*);
  };
# 641 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 3
  template<typename _CharT>
    class __cxx11:: collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
# 668 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
# 682 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
# 699 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
# 718 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
# 732 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const throw();

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const throw();

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
# 761 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
# 775 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
# 788 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const throw();

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const throw();


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const throw();

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();



  template<typename _CharT>
    class __cxx11:: collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }


      explicit
      collate_byname(const string& __s, size_t __refs = 0)
      : collate_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~collate_byname() { }
    };


}

# 1 "/usr/local/include/c++/10.0.0/bits/locale_classes.tcc" 1 3
# 37 "/usr/local/include/c++/10.0.0/bits/locale_classes.tcc" 3
       
# 38 "/usr/local/include/c++/10.0.0/bits/locale_classes.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }
# 102 "/usr/local/include/c++/10.0.0/bits/locale_classes.tcc" 3
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size

       && dynamic_cast<const _Facet*>(__facets[__i]));



    }
# 130 "/usr/local/include/c++/10.0.0/bits/locale_classes.tcc" 3
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();

      return dynamic_cast<const _Facet&>(*__facets[__i]);



    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const throw ()
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const throw ()
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      try
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      catch(...)
 {
   delete [] __c;
   throw;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }




  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);


  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);




}
# 852 "/usr/local/include/c++/10.0.0/bits/locale_classes.h" 2 3
# 42 "/usr/local/include/c++/10.0.0/bits/ios_base.h" 2 3




# 1 "/usr/local/include/c++/10.0.0/system_error" 1 3
# 32 "/usr/local/include/c++/10.0.0/system_error" 3
       
# 33 "/usr/local/include/c++/10.0.0/system_error" 3






# 1 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/error_constants.h" 1 3
# 34 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/error_constants.h" 3
# 1 "/usr/local/include/c++/10.0.0/cerrno" 1 3
# 39 "/usr/local/include/c++/10.0.0/cerrno" 3
       
# 40 "/usr/local/include/c++/10.0.0/cerrno" 3
# 35 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/error_constants.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  enum class errc
    {
      address_family_not_supported = 97,
      address_in_use = 98,
      address_not_available = 99,
      already_connected = 106,
      argument_list_too_long = 7,
      argument_out_of_domain = 33,
      bad_address = 14,
      bad_file_descriptor = 9,


      bad_message = 74,


      broken_pipe = 32,
      connection_aborted = 103,
      connection_already_in_progress = 114,
      connection_refused = 111,
      connection_reset = 104,
      cross_device_link = 18,
      destination_address_required = 89,
      device_or_resource_busy = 16,
      directory_not_empty = 39,
      executable_format_error = 8,
      file_exists = 17,
      file_too_large = 27,
      filename_too_long = 36,
      function_not_supported = 38,
      host_unreachable = 113,


      identifier_removed = 43,


      illegal_byte_sequence = 84,
      inappropriate_io_control_operation = 25,
      interrupted = 4,
      invalid_argument = 22,
      invalid_seek = 29,
      io_error = 5,
      is_a_directory = 21,
      message_size = 90,
      network_down = 100,
      network_reset = 102,
      network_unreachable = 101,
      no_buffer_space = 105,
      no_child_process = 10,


      no_link = 67,


      no_lock_available = 37,


      no_message_available = 61,


      no_message = 42,
      no_protocol_option = 92,
      no_space_on_device = 28,


      no_stream_resources = 63,


      no_such_device_or_address = 6,
      no_such_device = 19,
      no_such_file_or_directory = 2,
      no_such_process = 3,
      not_a_directory = 20,
      not_a_socket = 88,


      not_a_stream = 60,


      not_connected = 107,
      not_enough_memory = 12,


      not_supported = 95,



      operation_canceled = 125,


      operation_in_progress = 115,
      operation_not_permitted = 1,
      operation_not_supported = 95,
      operation_would_block = 11,


      owner_dead = 130,


      permission_denied = 13,


      protocol_error = 71,


      protocol_not_supported = 93,
      read_only_file_system = 30,
      resource_deadlock_would_occur = 35,
      resource_unavailable_try_again = 11,
      result_out_of_range = 34,


      state_not_recoverable = 131,



      stream_timeout = 62,



      text_file_busy = 26,


      timed_out = 110,
      too_many_files_open_in_system = 23,
      too_many_files_open = 24,
      too_many_links = 31,
      too_many_symbolic_link_levels = 40,


      value_too_large = 75,


      wrong_protocol_type = 91
    };


}
# 40 "/usr/local/include/c++/10.0.0/system_error" 2 3

# 1 "/usr/local/include/c++/10.0.0/stdexcept" 1 3
# 36 "/usr/local/include/c++/10.0.0/stdexcept" 3
       
# 37 "/usr/local/include/c++/10.0.0/stdexcept" 3




namespace std __attribute__ ((__visibility__ ("default")))
{





  struct __cow_string
  {
    union {
      const char* _M_p;
      char _M_bytes[sizeof(const char*)];
    };

    __cow_string();
    __cow_string(const std::string&);
    __cow_string(const char*, size_t);
    __cow_string(const __cow_string&) noexcept;
    __cow_string& operator=(const __cow_string&) noexcept;
    ~__cow_string();

    __cow_string(__cow_string&&) noexcept;
    __cow_string& operator=(__cow_string&&) noexcept;

  };

  typedef basic_string<char> __sso_string;
# 113 "/usr/local/include/c++/10.0.0/stdexcept" 3
  class logic_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    logic_error(const string& __arg) ;


    explicit
    logic_error(const char*) ;

    logic_error(logic_error&&) noexcept;
    logic_error& operator=(logic_error&&) noexcept;



    logic_error(const logic_error&) noexcept;
    logic_error& operator=(const logic_error&) noexcept;





    virtual ~logic_error() noexcept;



    virtual const char*
    what() const noexcept;





  };



  class domain_error : public logic_error
  {
  public:
    explicit domain_error(const string& __arg) ;

    explicit domain_error(const char*) ;
    domain_error(const domain_error&) = default;
    domain_error& operator=(const domain_error&) = default;
    domain_error(domain_error&&) = default;
    domain_error& operator=(domain_error&&) = default;

    virtual ~domain_error() noexcept;
  };


  class invalid_argument : public logic_error
  {
  public:
    explicit invalid_argument(const string& __arg) ;

    explicit invalid_argument(const char*) ;
    invalid_argument(const invalid_argument&) = default;
    invalid_argument& operator=(const invalid_argument&) = default;
    invalid_argument(invalid_argument&&) = default;
    invalid_argument& operator=(invalid_argument&&) = default;

    virtual ~invalid_argument() noexcept;
  };



  class length_error : public logic_error
  {
  public:
    explicit length_error(const string& __arg) ;

    explicit length_error(const char*) ;
    length_error(const length_error&) = default;
    length_error& operator=(const length_error&) = default;
    length_error(length_error&&) = default;
    length_error& operator=(length_error&&) = default;

    virtual ~length_error() noexcept;
  };



  class out_of_range : public logic_error
  {
  public:
    explicit out_of_range(const string& __arg) ;

    explicit out_of_range(const char*) ;
    out_of_range(const out_of_range&) = default;
    out_of_range& operator=(const out_of_range&) = default;
    out_of_range(out_of_range&&) = default;
    out_of_range& operator=(out_of_range&&) = default;

    virtual ~out_of_range() noexcept;
  };






  class runtime_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    runtime_error(const string& __arg) ;


    explicit
    runtime_error(const char*) ;

    runtime_error(runtime_error&&) noexcept;
    runtime_error& operator=(runtime_error&&) noexcept;



    runtime_error(const runtime_error&) noexcept;
    runtime_error& operator=(const runtime_error&) noexcept;





    virtual ~runtime_error() noexcept;



    virtual const char*
    what() const noexcept;





  };


  class range_error : public runtime_error
  {
  public:
    explicit range_error(const string& __arg) ;

    explicit range_error(const char*) ;
    range_error(const range_error&) = default;
    range_error& operator=(const range_error&) = default;
    range_error(range_error&&) = default;
    range_error& operator=(range_error&&) = default;

    virtual ~range_error() noexcept;
  };


  class overflow_error : public runtime_error
  {
  public:
    explicit overflow_error(const string& __arg) ;

    explicit overflow_error(const char*) ;
    overflow_error(const overflow_error&) = default;
    overflow_error& operator=(const overflow_error&) = default;
    overflow_error(overflow_error&&) = default;
    overflow_error& operator=(overflow_error&&) = default;

    virtual ~overflow_error() noexcept;
  };


  class underflow_error : public runtime_error
  {
  public:
    explicit underflow_error(const string& __arg) ;

    explicit underflow_error(const char*) ;
    underflow_error(const underflow_error&) = default;
    underflow_error& operator=(const underflow_error&) = default;
    underflow_error(underflow_error&&) = default;
    underflow_error& operator=(underflow_error&&) = default;

    virtual ~underflow_error() noexcept;
  };




}
# 42 "/usr/local/include/c++/10.0.0/system_error" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{






  class error_code;
  class error_condition;
  class system_error;


  template<typename _Tp>
    struct is_error_code_enum : public false_type { };


  template<typename _Tp>
    struct is_error_condition_enum : public false_type { };

  template<>
    struct is_error_condition_enum<errc>
    : public true_type { };


  template <typename _Tp>
    inline constexpr bool is_error_code_enum_v =
      is_error_code_enum<_Tp>::value;
  template <typename _Tp>
    inline constexpr bool is_error_condition_enum_v =
      is_error_condition_enum<_Tp>::value;

  inline namespace _V2 {
# 86 "/usr/local/include/c++/10.0.0/system_error" 3
  class error_category
  {
  public:
    constexpr error_category() noexcept = default;

    virtual ~error_category();

    error_category(const error_category&) = delete;
    error_category& operator=(const error_category&) = delete;

    virtual const char*
    name() const noexcept = 0;






  private:
    __attribute ((__abi_tag__ ("cxx11")))
    virtual __cow_string
    _M_message(int) const;

  public:
    __attribute ((__abi_tag__ ("cxx11")))
    virtual string
    message(int) const = 0;
# 122 "/usr/local/include/c++/10.0.0/system_error" 3
  public:
    virtual error_condition
    default_error_condition(int __i) const noexcept;

    virtual bool
    equivalent(int __i, const error_condition& __cond) const noexcept;

    virtual bool
    equivalent(const error_code& __code, int __i) const noexcept;

    bool
    operator<(const error_category& __other) const noexcept
    { return less<const error_category*>()(this, &__other); }

    bool
    operator==(const error_category& __other) const noexcept
    { return this == &__other; }

    bool
    operator!=(const error_category& __other) const noexcept
    { return this != &__other; }
  };




  __attribute__ ((__const__)) const error_category& generic_category() noexcept;


  __attribute__ ((__const__)) const error_category& system_category() noexcept;

  }

  error_code make_error_code(errc) noexcept;
# 171 "/usr/local/include/c++/10.0.0/system_error" 3
  struct error_code
  {
    error_code() noexcept
    : _M_value(0), _M_cat(&system_category()) { }

    error_code(int __v, const error_category& __cat) noexcept
    : _M_value(__v), _M_cat(&__cat) { }

    template<typename _ErrorCodeEnum, typename = typename
      enable_if<is_error_code_enum<_ErrorCodeEnum>::value>::type>
      error_code(_ErrorCodeEnum __e) noexcept
      { *this = make_error_code(__e); }

    void
    assign(int __v, const error_category& __cat) noexcept
    {
      _M_value = __v;
      _M_cat = &__cat;
    }

    void
    clear() noexcept
    { assign(0, system_category()); }


    template<typename _ErrorCodeEnum>
      typename enable_if<is_error_code_enum<_ErrorCodeEnum>::value,
    error_code&>::type
      operator=(_ErrorCodeEnum __e) noexcept
      { return *this = make_error_code(__e); }

    int
    value() const noexcept { return _M_value; }

    const error_category&
    category() const noexcept { return *_M_cat; }

    error_condition
    default_error_condition() const noexcept;

    __attribute ((__abi_tag__ ("cxx11")))
    string
    message() const
    { return category().message(value()); }

    explicit operator bool() const noexcept
    { return _M_value != 0; }


  private:
    int _M_value;
    const error_category* _M_cat;
  };





  inline error_code
  make_error_code(errc __e) noexcept
  { return error_code(static_cast<int>(__e), generic_category()); }

  inline bool
  operator<(const error_code& __lhs, const error_code& __rhs) noexcept
  {
    return (__lhs.category() < __rhs.category()
     || (__lhs.category() == __rhs.category()
  && __lhs.value() < __rhs.value()));
  }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __e)
    { return (__os << __e.category().name() << ':' << __e.value()); }



  error_condition make_error_condition(errc) noexcept;
# 259 "/usr/local/include/c++/10.0.0/system_error" 3
  struct error_condition
  {
    error_condition() noexcept
    : _M_value(0), _M_cat(&generic_category()) { }

    error_condition(int __v, const error_category& __cat) noexcept
    : _M_value(__v), _M_cat(&__cat) { }

    template<typename _ErrorConditionEnum, typename = typename
  enable_if<is_error_condition_enum<_ErrorConditionEnum>::value>::type>
      error_condition(_ErrorConditionEnum __e) noexcept
      { *this = make_error_condition(__e); }

    void
    assign(int __v, const error_category& __cat) noexcept
    {
      _M_value = __v;
      _M_cat = &__cat;
    }


    template<typename _ErrorConditionEnum>
      typename enable_if<is_error_condition_enum
    <_ErrorConditionEnum>::value, error_condition&>::type
      operator=(_ErrorConditionEnum __e) noexcept
      { return *this = make_error_condition(__e); }

    void
    clear() noexcept
    { assign(0, generic_category()); }


    int
    value() const noexcept { return _M_value; }

    const error_category&
    category() const noexcept { return *_M_cat; }

    __attribute ((__abi_tag__ ("cxx11")))
    string
    message() const
    { return category().message(value()); }

    explicit operator bool() const noexcept
    { return _M_value != 0; }


  private:
    int _M_value;
    const error_category* _M_cat;
  };





  inline error_condition
  make_error_condition(errc __e) noexcept
  { return error_condition(static_cast<int>(__e), generic_category()); }



  inline bool
  operator<(const error_condition& __lhs,
     const error_condition& __rhs) noexcept
  {
    return (__lhs.category() < __rhs.category()
     || (__lhs.category() == __rhs.category()
  && __lhs.value() < __rhs.value()));
  }




  inline bool
  operator==(const error_code& __lhs, const error_code& __rhs) noexcept
  { return (__lhs.category() == __rhs.category()
     && __lhs.value() == __rhs.value()); }



  inline bool
  operator==(const error_code& __lhs, const error_condition& __rhs) noexcept
  {
    return (__lhs.category().equivalent(__lhs.value(), __rhs)
     || __rhs.category().equivalent(__lhs, __rhs.value()));
  }



  inline bool
  operator==(const error_condition& __lhs, const error_code& __rhs) noexcept
  {
    return (__rhs.category().equivalent(__rhs.value(), __lhs)
     || __lhs.category().equivalent(__rhs, __lhs.value()));
  }


  inline bool
  operator==(const error_condition& __lhs,
      const error_condition& __rhs) noexcept
  {
    return (__lhs.category() == __rhs.category()
     && __lhs.value() == __rhs.value());
  }


  inline bool
  operator!=(const error_code& __lhs, const error_code& __rhs) noexcept
  { return !(__lhs == __rhs); }



  inline bool
  operator!=(const error_code& __lhs, const error_condition& __rhs) noexcept
  { return !(__lhs == __rhs); }



  inline bool
  operator!=(const error_condition& __lhs, const error_code& __rhs) noexcept
  { return !(__lhs == __rhs); }


  inline bool
  operator!=(const error_condition& __lhs,
      const error_condition& __rhs) noexcept
  { return !(__lhs == __rhs); }
# 397 "/usr/local/include/c++/10.0.0/system_error" 3
  class system_error : public std::runtime_error
  {
  private:
    error_code _M_code;

  public:
    system_error(error_code __ec = error_code())
    : runtime_error(__ec.message()), _M_code(__ec) { }

    system_error(error_code __ec, const string& __what)
    : runtime_error(__what + ": " + __ec.message()), _M_code(__ec) { }

    system_error(error_code __ec, const char* __what)
    : runtime_error(__what + (": " + __ec.message())), _M_code(__ec) { }

    system_error(int __v, const error_category& __ecat, const char* __what)
    : system_error(error_code(__v, __ecat), __what) { }

    system_error(int __v, const error_category& __ecat)
    : runtime_error(error_code(__v, __ecat).message()),
      _M_code(__v, __ecat) { }

    system_error(int __v, const error_category& __ecat, const string& __what)
    : runtime_error(__what + ": " + error_code(__v, __ecat).message()),
      _M_code(__v, __ecat) { }


    system_error (const system_error &) = default;
    system_error &operator= (const system_error &) = default;


    virtual ~system_error() noexcept;

    const error_code&
    code() const noexcept { return _M_code; }
  };


}



namespace std __attribute__ ((__visibility__ ("default")))
{






  template<>
    struct hash<error_code>
    : public __hash_base<size_t, error_code>
    {
      size_t
      operator()(const error_code& __e) const noexcept
      {
 const size_t __tmp = std::_Hash_impl::hash(__e.value());
 return std::_Hash_impl::__hash_combine(&__e.category(), __tmp);
      }
    };






  template<>
    struct hash<error_condition>
    : public __hash_base<size_t, error_condition>
    {
      size_t
      operator()(const error_condition& __e) const noexcept
      {
 const size_t __tmp = std::_Hash_impl::hash(__e.value());
 return std::_Hash_impl::__hash_combine(&__e.category(), __tmp);
      }
    };



}
# 47 "/usr/local/include/c++/10.0.0/bits/ios_base.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{






  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16,
      _S_ios_fmtflags_max = 0x7fffffff,
      _S_ios_fmtflags_min = ~0x7fffffff
    };

  inline constexpr _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }

  inline const _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline const _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline const _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16,
      _S_ios_openmode_max = 0x7fffffff,
      _S_ios_openmode_min = ~0x7fffffff
    };

  inline constexpr _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }

  inline const _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline const _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline const _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16,
      _S_ios_iostate_max = 0x7fffffff,
      _S_ios_iostate_min = ~0x7fffffff
    };

  inline constexpr _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  inline const _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline const _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline const _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }


  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };



  enum class io_errc { stream = 1 };

  template <> struct is_error_code_enum<io_errc> : public true_type { };

  const error_category& iostream_category() noexcept;

  inline error_code
  make_error_code(io_errc __e) noexcept
  { return error_code(static_cast<int>(__e), iostream_category()); }

  inline error_condition
  make_error_condition(io_errc __e) noexcept
  { return error_condition(static_cast<int>(__e), iostream_category()); }
# 228 "/usr/local/include/c++/10.0.0/bits/ios_base.h" 3
  class ios_base
  {
# 246 "/usr/local/include/c++/10.0.0/bits/ios_base.h" 3
  public:
# 255 "/usr/local/include/c++/10.0.0/bits/ios_base.h" 3
    class __attribute ((__abi_tag__ ("cxx11"))) failure : public system_error
    {
    public:
      explicit
      failure(const string& __str);


      explicit
      failure(const string&, const error_code&);

      explicit
      failure(const char*, const error_code& = io_errc::stream);


      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();
    };
# 323 "/usr/local/include/c++/10.0.0/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags internal = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
# 398 "/usr/local/include/c++/10.0.0/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
# 429 "/usr/local/include/c++/10.0.0/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;




    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;
# 461 "/usr/local/include/c++/10.0.0/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;
# 489 "/usr/local/include/c++/10.0.0/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
# 506 "/usr/local/include/c++/10.0.0/bits/ios_base.h" 3
    typedef void (*event_callback) (event __e, ios_base& __b, int __i);
# 518 "/usr/local/include/c++/10.0.0/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;



    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      {

        ;
        int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);
        if (__res == 0)
          {
            ;
          }
        return __res;
      }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void) throw();


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init() throw();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();


      Init(const Init&) = default;
      Init& operator=(const Init&) = default;


    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    fmtflags
    flags() const
    { return _M_flags; }
# 636 "/usr/local/include/c++/10.0.0/bits/ios_base.h" 3
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 652 "/usr/local/include/c++/10.0.0/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 669 "/usr/local/include/c++/10.0.0/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
# 695 "/usr/local/include/c++/10.0.0/bits/ios_base.h" 3
    streamsize
    precision() const
    { return _M_precision; }






    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    streamsize
    width() const
    { return _M_width; }






    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 746 "/usr/local/include/c++/10.0.0/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 758 "/usr/local/include/c++/10.0.0/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc) throw();
# 769 "/usr/local/include/c++/10.0.0/bits/ios_base.h" 3
    locale
    getloc() const
    { return _M_ios_locale; }
# 780 "/usr/local/include/c++/10.0.0/bits/ios_base.h" 3
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
# 799 "/usr/local/include/c++/10.0.0/bits/ios_base.h" 3
    static int
    xalloc() throw();
# 815 "/usr/local/include/c++/10.0.0/bits/ios_base.h" 3
    long&
    iword(int __ix)
    {
      _Words& __word = ((unsigned)__ix < (unsigned)_M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 836 "/usr/local/include/c++/10.0.0/bits/ios_base.h" 3
    void*&
    pword(int __ix)
    {
      _Words& __word = ((unsigned)__ix < (unsigned)_M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 853 "/usr/local/include/c++/10.0.0/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base() throw ();
# 867 "/usr/local/include/c++/10.0.0/bits/ios_base.h" 3
  public:
    ios_base(const ios_base&) = delete;

    ios_base&
    operator=(const ios_base&) = delete;

  protected:
    void
    _M_move(ios_base&) noexcept;

    void
    _M_swap(ios_base& __rhs) noexcept;

  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }






  inline ios_base&
  hexfloat(ios_base& __base)
  {
    __base.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  defaultfloat(ios_base& __base)
  {
    __base.unsetf(ios_base::floatfield);
    return __base;
  }



}
# 42 "/usr/local/include/c++/10.0.0/streambuf" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
# 121 "/usr/local/include/c++/10.0.0/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;




      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(basic_streambuf*, basic_streambuf*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Distance>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            void>::__type
        advance(istreambuf_iterator<_CharT2>&, _Distance);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:







      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;


      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
# 215 "/usr/local/include/c++/10.0.0/streambuf" 3
      locale
      pubimbue(const locale& __loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
# 232 "/usr/local/include/c++/10.0.0/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 245 "/usr/local/include/c++/10.0.0/streambuf" 3
      basic_streambuf*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }
# 257 "/usr/local/include/c++/10.0.0/streambuf" 3
      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }
# 269 "/usr/local/include/c++/10.0.0/streambuf" 3
      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }




      int
      pubsync() { return this->sync(); }
# 290 "/usr/local/include/c++/10.0.0/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
# 304 "/usr/local/include/c++/10.0.0/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
# 322 "/usr/local/include/c++/10.0.0/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
# 344 "/usr/local/include/c++/10.0.0/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
# 363 "/usr/local/include/c++/10.0.0/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 378 "/usr/local/include/c++/10.0.0/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
# 403 "/usr/local/include/c++/10.0.0/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
# 430 "/usr/local/include/c++/10.0.0/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
# 456 "/usr/local/include/c++/10.0.0/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 470 "/usr/local/include/c++/10.0.0/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
# 488 "/usr/local/include/c++/10.0.0/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 504 "/usr/local/include/c++/10.0.0/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 515 "/usr/local/include/c++/10.0.0/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
# 535 "/usr/local/include/c++/10.0.0/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 551 "/usr/local/include/c++/10.0.0/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 561 "/usr/local/include/c++/10.0.0/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
# 582 "/usr/local/include/c++/10.0.0/streambuf" 3
      virtual void
      imbue(const locale& __loc __attribute__ ((__unused__)))
      { }
# 597 "/usr/local/include/c++/10.0.0/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 608 "/usr/local/include/c++/10.0.0/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 620 "/usr/local/include/c++/10.0.0/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 633 "/usr/local/include/c++/10.0.0/streambuf" 3
      virtual int
      sync() { return 0; }
# 655 "/usr/local/include/c++/10.0.0/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 671 "/usr/local/include/c++/10.0.0/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 693 "/usr/local/include/c++/10.0.0/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 706 "/usr/local/include/c++/10.0.0/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
# 730 "/usr/local/include/c++/10.0.0/streambuf" 3
      virtual int_type
      pbackfail(int_type __c __attribute__ ((__unused__)) = traits_type::eof())
      { return traits_type::eof(); }
# 748 "/usr/local/include/c++/10.0.0/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 774 "/usr/local/include/c++/10.0.0/streambuf" 3
      virtual int_type
      overflow(int_type __c __attribute__ ((__unused__)) = traits_type::eof())
      { return traits_type::eof(); }
# 803 "/usr/local/include/c++/10.0.0/streambuf" 3
      void
      __safe_gbump(streamsize __n) { _M_in_cur += __n; }

      void
      __safe_pbump(streamsize __n) { _M_out_cur += __n; }




    protected:

      basic_streambuf(const basic_streambuf&);

      basic_streambuf&
      operator=(const basic_streambuf&);


      void
      swap(basic_streambuf& __sb)
      {
 std::swap(_M_in_beg, __sb._M_in_beg);
 std::swap(_M_in_cur, __sb._M_in_cur);
 std::swap(_M_in_end, __sb._M_in_end);
 std::swap(_M_out_beg, __sb._M_out_beg);
 std::swap(_M_out_cur, __sb._M_out_cur);
 std::swap(_M_out_end, __sb._M_out_end);
 std::swap(_M_buf_locale, __sb._M_buf_locale);
      }

    };


  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>::
    basic_streambuf(const basic_streambuf&) = default;

  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>&
    std::basic_streambuf<_CharT, _Traits>::
    operator=(const basic_streambuf&) = default;



  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);





}

# 1 "/usr/local/include/c++/10.0.0/bits/streambuf.tcc" 1 3
# 37 "/usr/local/include/c++/10.0.0/bits/streambuf.tcc" 3
       
# 38 "/usr/local/include/c++/10.0.0/bits/streambuf.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->__safe_gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->__safe_pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }




  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);




}
# 863 "/usr/local/include/c++/10.0.0/streambuf" 2 3
# 36 "/usr/local/include/c++/10.0.0/bits/streambuf_iterator.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

# 49 "/usr/local/include/c++/10.0.0/bits/streambuf_iterator.h" 3
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
        _CharT*,


        _CharT>



    {
    public:






      using pointer = void;

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
        ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);


      template<typename _CharT2, typename _Size>
 friend __enable_if_t<__is_char<_CharT2>::__value, _CharT2*>
 __copy_n_a(istreambuf_iterator<_CharT2>, _Size, _CharT2*);


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
        istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Distance>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            void>::__type
 advance(istreambuf_iterator<_CharT2>&, _Distance);

    private:







      mutable streambuf_type* _M_sbuf;
      int_type _M_c;

    public:

      constexpr istreambuf_iterator() noexcept
      : _M_sbuf(0), _M_c(traits_type::eof()) { }


      istreambuf_iterator(const istreambuf_iterator&) noexcept = default;

      ~istreambuf_iterator() = default;



      istreambuf_iterator(istream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }


      istreambuf_iterator&
      operator=(const istreambuf_iterator&) noexcept = default;





      char_type
      operator*() const
      {
 int_type __c = _M_get();
# 155 "/usr/local/include/c++/10.0.0/bits/streambuf_iterator.h" 3
 return traits_type::to_char_type(__c);
      }


      istreambuf_iterator&
      operator++()
      {



                        ;

 _M_sbuf->sbumpc();
 _M_c = traits_type::eof();
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {



                        ;

 istreambuf_iterator __old = *this;
 __old._M_c = _M_sbuf->sbumpc();
 _M_c = traits_type::eof();
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
 int_type __ret = _M_c;
 if (_M_sbuf && _S_is_eof(__ret) && _S_is_eof(__ret = _M_sbuf->sgetc()))
   _M_sbuf = 0;
 return __ret;
      }

      bool
      _M_at_eof() const
      { return _S_is_eof(_M_get()); }

      static bool
      _S_is_eof(int_type __c)
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(__c, __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:




      using difference_type = ptrdiff_t;

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
        ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:


      constexpr
      ostreambuf_iterator() noexcept
      : _M_sbuf(nullptr), _M_failed(true) { }



      ostreambuf_iterator(ostream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const noexcept
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->__safe_gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }


  template<typename _CharT, typename _Size>
    __enable_if_t<__is_char<_CharT>::__value, _CharT*>
    __copy_n_a(istreambuf_iterator<_CharT> __it, _Size __n, _CharT* __result)
    {
      if (__n == 0)
 return __result;

     

                            ;
      _CharT* __beg = __result;
      __result += __it._M_sbuf->sgetn(__beg, __n);
     

                            ;
      return __result;
    }


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;
      const int_type __eof = traits_type::eof();

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, __eof)
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->__safe_gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   __first._M_c = __eof;
 }

      return __first;
    }

  template<typename _CharT, typename _Distance>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        void>::__type
    advance(istreambuf_iterator<_CharT>& __i, _Distance __n)
    {
      if (__n == 0)
 return;

      ;
     

                           ;

      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;
      const int_type __eof = traits_type::eof();

      streambuf_type* __sb = __i._M_sbuf;
      while (__n > 0)
 {
   streamsize __size = __sb->egptr() - __sb->gptr();
   if (__size > __n)
     {
       __sb->__safe_gbump(__n);
       break;
     }

   __sb->__safe_gbump(__size);
   __n -= __size;
   if (traits_type::eq_int_type(__sb->underflow(), __eof))
     {
      

                      ;
       break;
     }
 }

      __i._M_c = __eof;
    }




}
# 67 "/usr/local/include/c++/10.0.0/iterator" 2 3
# 24 "fast_io/fast_io_core.h" 2
# 1 "/usr/local/include/c++/10.0.0/ranges" 1 3
# 35 "/usr/local/include/c++/10.0.0/ranges" 3
       
# 36 "/usr/local/include/c++/10.0.0/ranges" 3
# 45 "/usr/local/include/c++/10.0.0/ranges" 3
# 1 "/usr/local/include/c++/10.0.0/optional" 1 3
# 32 "/usr/local/include/c++/10.0.0/optional" 3
       
# 33 "/usr/local/include/c++/10.0.0/optional" 3
# 43 "/usr/local/include/c++/10.0.0/optional" 3
# 1 "/usr/local/include/c++/10.0.0/bits/enable_special_members.h" 1 3
# 33 "/usr/local/include/c++/10.0.0/bits/enable_special_members.h" 3
       
# 34 "/usr/local/include/c++/10.0.0/bits/enable_special_members.h" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct _Enable_default_constructor_tag
  {
    explicit constexpr _Enable_default_constructor_tag() = default;
  };






template<bool _Switch, typename _Tag = void>
  struct _Enable_default_constructor
  {
    constexpr _Enable_default_constructor() noexcept = default;
    constexpr _Enable_default_constructor(_Enable_default_constructor const&)
      noexcept = default;
    constexpr _Enable_default_constructor(_Enable_default_constructor&&)
      noexcept = default;
    _Enable_default_constructor&
    operator=(_Enable_default_constructor const&) noexcept = default;
    _Enable_default_constructor&
    operator=(_Enable_default_constructor&&) noexcept = default;


    constexpr explicit
    _Enable_default_constructor(_Enable_default_constructor_tag) { }
  };







template<bool _Switch, typename _Tag = void>
  struct _Enable_destructor { };






template<bool _Copy, bool _CopyAssignment,
         bool _Move, bool _MoveAssignment,
         typename _Tag = void>
  struct _Enable_copy_move { };
# 93 "/usr/local/include/c++/10.0.0/bits/enable_special_members.h" 3
template<bool _Default, bool _Destructor,
         bool _Copy, bool _CopyAssignment,
         bool _Move, bool _MoveAssignment,
         typename _Tag = void>
  struct _Enable_special_members
  : private _Enable_default_constructor<_Default, _Tag>,
    private _Enable_destructor<_Destructor, _Tag>,
    private _Enable_copy_move<_Copy, _CopyAssignment,
                              _Move, _MoveAssignment,
                              _Tag>
  { };



template<typename _Tag>
  struct _Enable_default_constructor<false, _Tag>
  {
    constexpr _Enable_default_constructor() noexcept = delete;
    constexpr _Enable_default_constructor(_Enable_default_constructor const&)
      noexcept = default;
    constexpr _Enable_default_constructor(_Enable_default_constructor&&)
      noexcept = default;
    _Enable_default_constructor&
    operator=(_Enable_default_constructor const&) noexcept = default;
    _Enable_default_constructor&
    operator=(_Enable_default_constructor&&) noexcept = default;


    constexpr explicit
    _Enable_default_constructor(_Enable_default_constructor_tag) { }
  };

template<typename _Tag>
  struct _Enable_destructor<false, _Tag>
  { ~_Enable_destructor() noexcept = delete; };

template<typename _Tag>
  struct _Enable_copy_move<false, true, true, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, false, true, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, false, true, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, true, false, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, true, false, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, false, false, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, false, false, true, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = default;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, true, true, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, true, true, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, false, true, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, false, true, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, true, false, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, true, false, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = default;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<true, false, false, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };

template<typename _Tag>
  struct _Enable_copy_move<false, false, false, false, _Tag>
  {
    constexpr _Enable_copy_move() noexcept = default;
    constexpr _Enable_copy_move(_Enable_copy_move const&) noexcept = delete;
    constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move const&) noexcept = delete;
    _Enable_copy_move&
    operator=(_Enable_copy_move&&) noexcept = delete;
  };


}
# 44 "/usr/local/include/c++/10.0.0/optional" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 56 "/usr/local/include/c++/10.0.0/optional" 3
  template<typename _Tp>
    class optional;


  struct nullopt_t
  {





    enum class _Construct { _Token };


    explicit constexpr nullopt_t(_Construct) { }
  };


  inline constexpr nullopt_t nullopt { nullopt_t::_Construct::_Token };






  class bad_optional_access : public exception
  {
  public:
    bad_optional_access() { }

    virtual const char* what() const noexcept override
    { return "bad optional access"; }

    virtual ~bad_optional_access() noexcept = default;
  };

  void
  __throw_bad_optional_access()
  __attribute__((__noreturn__));


  inline void
  __throw_bad_optional_access()
  { (throw (bad_optional_access())); }



  template <typename _Tp>
    struct _Optional_payload_base
    {
      using _Stored_type = remove_const_t<_Tp>;

      _Optional_payload_base() = default;
      ~_Optional_payload_base() = default;

      template<typename... _Args>
 constexpr
 _Optional_payload_base(in_place_t __tag, _Args&&... __args)
 : _M_payload(__tag, std::forward<_Args>(__args)...),
   _M_engaged(true)
 { }

      template<typename _Up, typename... _Args>
 constexpr
 _Optional_payload_base(std::initializer_list<_Up> __il,
          _Args&&... __args)
 : _M_payload(__il, std::forward<_Args>(__args)...),
   _M_engaged(true)
 { }



      constexpr
      _Optional_payload_base(bool __engaged,
        const _Optional_payload_base& __other)
      {
 if (__other._M_engaged)
   this->_M_construct(__other._M_get());
      }



      constexpr
      _Optional_payload_base(bool __engaged,
        _Optional_payload_base&& __other)
      {
 if (__other._M_engaged)
   this->_M_construct(std::move(__other._M_get()));
      }



      _Optional_payload_base(const _Optional_payload_base&) = default;



      _Optional_payload_base(_Optional_payload_base&&) = default;

      _Optional_payload_base&
      operator=(const _Optional_payload_base&) = default;

      _Optional_payload_base&
      operator=(_Optional_payload_base&&) = default;


      constexpr void
      _M_copy_assign(const _Optional_payload_base& __other)
      {
        if (this->_M_engaged && __other._M_engaged)
          this->_M_get() = __other._M_get();
        else
   {
     if (__other._M_engaged)
       this->_M_construct(__other._M_get());
     else
       this->_M_reset();
   }
      }


      constexpr void
      _M_move_assign(_Optional_payload_base&& __other)
      noexcept(__and_v<is_nothrow_move_constructible<_Tp>,
         is_nothrow_move_assignable<_Tp>>)
      {
 if (this->_M_engaged && __other._M_engaged)
   this->_M_get() = std::move(__other._M_get());
 else
   {
     if (__other._M_engaged)
       this->_M_construct(std::move(__other._M_get()));
     else
       this->_M_reset();
   }
      }

      struct _Empty_byte { };

      template<typename _Up, bool = is_trivially_destructible_v<_Up>>
 union _Storage
 {
   constexpr _Storage() noexcept : _M_empty() { }

   template<typename... _Args>
     constexpr
     _Storage(in_place_t, _Args&&... __args)
     : _M_value(std::forward<_Args>(__args)...)
     { }

   template<typename _Vp, typename... _Args>
     constexpr
     _Storage(std::initializer_list<_Vp> __il, _Args&&... __args)
     : _M_value(__il, std::forward<_Args>(__args)...)
     { }

   _Empty_byte _M_empty;
          _Up _M_value;
 };

      template<typename _Up>
 union _Storage<_Up, false>
 {
   constexpr _Storage() noexcept : _M_empty() { }

   template<typename... _Args>
     constexpr
     _Storage(in_place_t, _Args&&... __args)
     : _M_value(std::forward<_Args>(__args)...)
     { }

   template<typename _Vp, typename... _Args>
     constexpr
     _Storage(std::initializer_list<_Vp> __il, _Args&&... __args)
     : _M_value(__il, std::forward<_Args>(__args)...)
     { }


   ~_Storage() { }

   _Empty_byte _M_empty;
          _Up _M_value;
 };

      _Storage<_Stored_type> _M_payload;

      bool _M_engaged = false;

      template<typename... _Args>
        void
        _M_construct(_Args&&... __args)
        noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)
        {
          ::new ((void *) std::__addressof(this->_M_payload))
            _Stored_type(std::forward<_Args>(__args)...);
          this->_M_engaged = true;
        }

      constexpr void
      _M_destroy() noexcept
      {
 _M_engaged = false;
 _M_payload._M_value.~_Stored_type();
      }





      constexpr _Tp&
      _M_get() noexcept
      { return this->_M_payload._M_value; }

      constexpr const _Tp&
      _M_get() const noexcept
      { return this->_M_payload._M_value; }


      constexpr void
      _M_reset() noexcept
      {
 if (this->_M_engaged)
   _M_destroy();
      }
    };


  template <typename _Tp,
     bool =
       is_trivially_destructible_v<_Tp>,
     bool =
       is_trivially_copy_assignable_v<_Tp>
       && is_trivially_copy_constructible_v<_Tp>,
     bool =
       is_trivially_move_assignable_v<_Tp>
       && is_trivially_move_constructible_v<_Tp>>
    struct _Optional_payload;


  template <typename _Tp>
    struct _Optional_payload<_Tp, true, true, true>
    : _Optional_payload_base<_Tp>
    {
      using _Optional_payload_base<_Tp>::_Optional_payload_base;

      _Optional_payload() = default;
    };


  template <typename _Tp>
    struct _Optional_payload<_Tp, true, false, true>
    : _Optional_payload_base<_Tp>
    {
      using _Optional_payload_base<_Tp>::_Optional_payload_base;

      _Optional_payload() = default;
      ~_Optional_payload() = default;
      _Optional_payload(const _Optional_payload&) = default;
      _Optional_payload(_Optional_payload&&) = default;
      _Optional_payload& operator=(_Optional_payload&&) = default;


      constexpr
      _Optional_payload&
      operator=(const _Optional_payload& __other)
      {
 this->_M_copy_assign(__other);
 return *this;
      }
    };


  template <typename _Tp>
    struct _Optional_payload<_Tp, true, true, false>
    : _Optional_payload_base<_Tp>
    {
      using _Optional_payload_base<_Tp>::_Optional_payload_base;

      _Optional_payload() = default;
      ~_Optional_payload() = default;
      _Optional_payload(const _Optional_payload&) = default;
      _Optional_payload(_Optional_payload&&) = default;
      _Optional_payload& operator=(const _Optional_payload&) = default;


      constexpr
      _Optional_payload&
      operator=(_Optional_payload&& __other)
      noexcept(__and_v<is_nothrow_move_constructible<_Tp>,
         is_nothrow_move_assignable<_Tp>>)
      {
 this->_M_move_assign(std::move(__other));
 return *this;
      }
    };


  template <typename _Tp>
    struct _Optional_payload<_Tp, true, false, false>
    : _Optional_payload_base<_Tp>
    {
      using _Optional_payload_base<_Tp>::_Optional_payload_base;

      _Optional_payload() = default;
      ~_Optional_payload() = default;
      _Optional_payload(const _Optional_payload&) = default;
      _Optional_payload(_Optional_payload&&) = default;


      constexpr
      _Optional_payload&
      operator=(const _Optional_payload& __other)
      {
 this->_M_copy_assign(__other);
 return *this;
      }


      constexpr
      _Optional_payload&
      operator=(_Optional_payload&& __other)
      noexcept(__and_v<is_nothrow_move_constructible<_Tp>,
         is_nothrow_move_assignable<_Tp>>)
      {
 this->_M_move_assign(std::move(__other));
 return *this;
      }
    };


  template <typename _Tp, bool _Copy, bool _Move>
    struct _Optional_payload<_Tp, false, _Copy, _Move>
    : _Optional_payload<_Tp, true, false, false>
    {

      using _Optional_payload<_Tp, true, false, false>::_Optional_payload;
      _Optional_payload() = default;
      _Optional_payload(const _Optional_payload&) = default;
      _Optional_payload(_Optional_payload&&) = default;
      _Optional_payload& operator=(const _Optional_payload&) = default;
      _Optional_payload& operator=(_Optional_payload&&) = default;


      ~_Optional_payload() { this->_M_reset(); }
    };



  template<typename _Tp, typename _Dp>
    class _Optional_base_impl
    {
    protected:
      using _Stored_type = remove_const_t<_Tp>;



      template<typename... _Args>
 void
 _M_construct(_Args&&... __args)
 noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)
 {
   ::new
     (std::__addressof(static_cast<_Dp*>(this)->_M_payload._M_payload))
     _Stored_type(std::forward<_Args>(__args)...);
   static_cast<_Dp*>(this)->_M_payload._M_engaged = true;
 }

      void
      _M_destruct() noexcept
      { static_cast<_Dp*>(this)->_M_payload._M_destroy(); }


      constexpr void
      _M_reset() noexcept
      { static_cast<_Dp*>(this)->_M_payload._M_reset(); }

      constexpr bool _M_is_engaged() const noexcept
      { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }


      constexpr _Tp&
      _M_get() noexcept
      {
 ;
 return static_cast<_Dp*>(this)->_M_payload._M_get();
      }

      constexpr const _Tp&
      _M_get() const noexcept
      {
 ;
 return static_cast<const _Dp*>(this)->_M_payload._M_get();
      }
    };
# 468 "/usr/local/include/c++/10.0.0/optional" 3
  template<typename _Tp,
    bool = is_trivially_copy_constructible_v<_Tp>,
    bool = is_trivially_move_constructible_v<_Tp>>
    struct _Optional_base
      : _Optional_base_impl<_Tp, _Optional_base<_Tp>>
    {

      constexpr _Optional_base() = default;


      template<typename... _Args,
        enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>
        constexpr explicit _Optional_base(in_place_t, _Args&&... __args)
        : _M_payload(in_place,
       std::forward<_Args>(__args)...) { }

      template<typename _Up, typename... _Args,
               enable_if_t<is_constructible_v<_Tp,
           initializer_list<_Up>&,
           _Args&&...>, bool> = false>
        constexpr explicit _Optional_base(in_place_t,
                                          initializer_list<_Up> __il,
                                          _Args&&... __args)
        : _M_payload(in_place,
       __il, std::forward<_Args>(__args)...)
        { }


      constexpr _Optional_base(const _Optional_base& __other)
 : _M_payload(__other._M_payload._M_engaged,
       __other._M_payload)
      { }

      constexpr _Optional_base(_Optional_base&& __other)
      noexcept(is_nothrow_move_constructible_v<_Tp>)
 : _M_payload(__other._M_payload._M_engaged,
       std::move(__other._M_payload))
      { }


      _Optional_base& operator=(const _Optional_base&) = default;
      _Optional_base& operator=(_Optional_base&&) = default;

      _Optional_payload<_Tp> _M_payload;
    };

  template<typename _Tp>
    struct _Optional_base<_Tp, false, true>
      : _Optional_base_impl<_Tp, _Optional_base<_Tp>>
    {

      constexpr _Optional_base() = default;


      template<typename... _Args,
        enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>
        constexpr explicit _Optional_base(in_place_t, _Args&&... __args)
        : _M_payload(in_place,
       std::forward<_Args>(__args)...) { }

      template<typename _Up, typename... _Args,
               enable_if_t<is_constructible_v<_Tp,
           initializer_list<_Up>&,
           _Args&&...>, bool> = false>
        constexpr explicit _Optional_base(in_place_t,
                                          initializer_list<_Up> __il,
                                          _Args&&... __args)
        : _M_payload(in_place,
       __il, std::forward<_Args>(__args)...)
        { }


      constexpr _Optional_base(const _Optional_base& __other)
 : _M_payload(__other._M_payload._M_engaged,
       __other._M_payload)
      { }

      constexpr _Optional_base(_Optional_base&& __other) = default;


      _Optional_base& operator=(const _Optional_base&) = default;
      _Optional_base& operator=(_Optional_base&&) = default;

      _Optional_payload<_Tp> _M_payload;
    };

  template<typename _Tp>
    struct _Optional_base<_Tp, true, false>
      : _Optional_base_impl<_Tp, _Optional_base<_Tp>>
    {

      constexpr _Optional_base() = default;


      template<typename... _Args,
        enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>
        constexpr explicit _Optional_base(in_place_t, _Args&&... __args)
        : _M_payload(in_place,
       std::forward<_Args>(__args)...) { }

      template<typename _Up, typename... _Args,
               enable_if_t<is_constructible_v<_Tp,
           initializer_list<_Up>&,
           _Args&&...>, bool> = false>
        constexpr explicit _Optional_base(in_place_t,
                                          initializer_list<_Up> __il,
                                          _Args&&... __args)
        : _M_payload(in_place,
       __il, std::forward<_Args>(__args)...)
        { }


      constexpr _Optional_base(const _Optional_base& __other) = default;

      constexpr _Optional_base(_Optional_base&& __other)
      noexcept(is_nothrow_move_constructible_v<_Tp>)
 : _M_payload(__other._M_payload._M_engaged,
       std::move(__other._M_payload))
      { }


      _Optional_base& operator=(const _Optional_base&) = default;
      _Optional_base& operator=(_Optional_base&&) = default;

      _Optional_payload<_Tp> _M_payload;
    };

  template<typename _Tp>
    struct _Optional_base<_Tp, true, true>
      : _Optional_base_impl<_Tp, _Optional_base<_Tp>>
    {

      constexpr _Optional_base() = default;


      template<typename... _Args,
        enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>
        constexpr explicit _Optional_base(in_place_t, _Args&&... __args)
        : _M_payload(in_place,
       std::forward<_Args>(__args)...) { }

      template<typename _Up, typename... _Args,
               enable_if_t<is_constructible_v<_Tp,
           initializer_list<_Up>&,
           _Args&&...>, bool> = false>
        constexpr explicit _Optional_base(in_place_t,
                                          initializer_list<_Up> __il,
                                          _Args&&... __args)
        : _M_payload(in_place,
       __il, std::forward<_Args>(__args)...)
        { }


      constexpr _Optional_base(const _Optional_base& __other) = default;
      constexpr _Optional_base(_Optional_base&& __other) = default;


      _Optional_base& operator=(const _Optional_base&) = default;
      _Optional_base& operator=(_Optional_base&&) = default;

      _Optional_payload<_Tp> _M_payload;
    };

  template<typename _Tp>
  class optional;

  template<typename _Tp, typename _Up>
    using __converts_from_optional =
      __or_<is_constructible<_Tp, const optional<_Up>&>,
     is_constructible<_Tp, optional<_Up>&>,
     is_constructible<_Tp, const optional<_Up>&&>,
     is_constructible<_Tp, optional<_Up>&&>,
     is_convertible<const optional<_Up>&, _Tp>,
     is_convertible<optional<_Up>&, _Tp>,
     is_convertible<const optional<_Up>&&, _Tp>,
     is_convertible<optional<_Up>&&, _Tp>>;

  template<typename _Tp, typename _Up>
    using __assigns_from_optional =
      __or_<is_assignable<_Tp&, const optional<_Up>&>,
     is_assignable<_Tp&, optional<_Up>&>,
     is_assignable<_Tp&, const optional<_Up>&&>,
     is_assignable<_Tp&, optional<_Up>&&>>;




  template<typename _Tp>
    class optional
    : private _Optional_base<_Tp>,
      private _Enable_copy_move<

 is_copy_constructible_v<_Tp>,

 __and_v<is_copy_constructible<_Tp>, is_copy_assignable<_Tp>>,

 is_move_constructible_v<_Tp>,

 __and_v<is_move_constructible<_Tp>, is_move_assignable<_Tp>>,

 optional<_Tp>>
    {
      static_assert(!is_same_v<remove_cv_t<_Tp>, nullopt_t>);
      static_assert(!is_same_v<remove_cv_t<_Tp>, in_place_t>);
      static_assert(!is_reference_v<_Tp>);

    private:
      using _Base = _Optional_base<_Tp>;


      template<typename _Up>
 using __not_self = __not_<is_same<optional, __remove_cvref_t<_Up>>>;
      template<typename _Up>
 using __not_tag = __not_<is_same<in_place_t, __remove_cvref_t<_Up>>>;
      template<typename... _Cond>
 using _Requires = enable_if_t<__and_v<_Cond...>, bool>;

    public:
      using value_type = _Tp;

      constexpr optional() = default;

      constexpr optional(nullopt_t) noexcept { }


      template<typename _Up = _Tp,
        _Requires<__not_self<_Up>, __not_tag<_Up>,
    is_constructible<_Tp, _Up&&>,
    is_convertible<_Up&&, _Tp>> = true>
 constexpr
 optional(_Up&& __t)
 : _Base(std::in_place, std::forward<_Up>(__t)) { }

      template<typename _Up = _Tp,
        _Requires<__not_self<_Up>, __not_tag<_Up>,
    is_constructible<_Tp, _Up&&>,
    __not_<is_convertible<_Up&&, _Tp>>> = false>
 explicit constexpr
 optional(_Up&& __t)
        : _Base(std::in_place, std::forward<_Up>(__t)) { }

      template<typename _Up,
        _Requires<__not_<is_same<_Tp, _Up>>,
    is_constructible<_Tp, const _Up&>,
    is_convertible<const _Up&, _Tp>,
    __not_<__converts_from_optional<_Tp, _Up>>> = true>
 constexpr
 optional(const optional<_Up>& __t)
 {
   if (__t)
     emplace(*__t);
 }

      template<typename _Up,
        _Requires<__not_<is_same<_Tp, _Up>>,
    is_constructible<_Tp, const _Up&>,
    __not_<is_convertible<const _Up&, _Tp>>,
    __not_<__converts_from_optional<_Tp, _Up>>> = false>
 explicit constexpr
 optional(const optional<_Up>& __t)
 {
   if (__t)
     emplace(*__t);
 }

      template <typename _Up,
  _Requires<__not_<is_same<_Tp, _Up>>,
     is_constructible<_Tp, _Up&&>,
     is_convertible<_Up&&, _Tp>,
     __not_<__converts_from_optional<_Tp, _Up>>> = true>
 constexpr
 optional(optional<_Up>&& __t)
 {
   if (__t)
     emplace(std::move(*__t));
 }

      template <typename _Up,
  _Requires<__not_<is_same<_Tp, _Up>>,
     is_constructible<_Tp, _Up&&>,
     __not_<is_convertible<_Up&&, _Tp>>,
     __not_<__converts_from_optional<_Tp, _Up>>> = false>
 explicit constexpr
 optional(optional<_Up>&& __t)
 {
   if (__t)
     emplace(std::move(*__t));
 }

      template<typename... _Args,
        _Requires<is_constructible<_Tp, _Args&&...>> = false>
 explicit constexpr
 optional(in_place_t, _Args&&... __args)
 : _Base(std::in_place, std::forward<_Args>(__args)...) { }

      template<typename _Up, typename... _Args,
        _Requires<is_constructible<_Tp,
       initializer_list<_Up>&,
       _Args&&...>> = false>
 explicit constexpr
 optional(in_place_t, initializer_list<_Up> __il, _Args&&... __args)
 : _Base(std::in_place, __il, std::forward<_Args>(__args)...) { }


      optional&
      operator=(nullopt_t) noexcept
      {
 this->_M_reset();
 return *this;
      }

      template<typename _Up = _Tp>
 enable_if_t<__and_v<__not_self<_Up>,
       __not_<__and_<is_scalar<_Tp>,
       is_same<_Tp, decay_t<_Up>>>>,
       is_constructible<_Tp, _Up>,
       is_assignable<_Tp&, _Up>>,
      optional&>
 operator=(_Up&& __u)
 {
   if (this->_M_is_engaged())
     this->_M_get() = std::forward<_Up>(__u);
   else
     this->_M_construct(std::forward<_Up>(__u));

   return *this;
 }

      template<typename _Up>
 enable_if_t<__and_v<__not_<is_same<_Tp, _Up>>,
       is_constructible<_Tp, const _Up&>,
       is_assignable<_Tp&, _Up>,
       __not_<__converts_from_optional<_Tp, _Up>>,
       __not_<__assigns_from_optional<_Tp, _Up>>>,
      optional&>
 operator=(const optional<_Up>& __u)
 {
   if (__u)
     {
       if (this->_M_is_engaged())
  this->_M_get() = *__u;
       else
  this->_M_construct(*__u);
     }
   else
     {
       this->_M_reset();
     }
   return *this;
 }

      template<typename _Up>
        enable_if_t<__and_v<__not_<is_same<_Tp, _Up>>,
       is_constructible<_Tp, _Up>,
       is_assignable<_Tp&, _Up>,
       __not_<__converts_from_optional<_Tp, _Up>>,
       __not_<__assigns_from_optional<_Tp, _Up>>>,
      optional&>
 operator=(optional<_Up>&& __u)
 {
   if (__u)
     {
       if (this->_M_is_engaged())
  this->_M_get() = std::move(*__u);
       else
  this->_M_construct(std::move(*__u));
     }
   else
     {
       this->_M_reset();
     }

   return *this;
 }

      template<typename... _Args>
 enable_if_t<is_constructible_v<_Tp, _Args&&...>, _Tp&>
 emplace(_Args&&... __args)
 {
   this->_M_reset();
   this->_M_construct(std::forward<_Args>(__args)...);
   return this->_M_get();
 }

      template<typename _Up, typename... _Args>
 enable_if_t<is_constructible_v<_Tp, initializer_list<_Up>&,
           _Args&&...>, _Tp&>
 emplace(initializer_list<_Up> __il, _Args&&... __args)
 {
   this->_M_reset();
   this->_M_construct(__il, std::forward<_Args>(__args)...);
   return this->_M_get();
 }




      void
      swap(optional& __other)
      noexcept(is_nothrow_move_constructible_v<_Tp>
        && is_nothrow_swappable_v<_Tp>)
      {
 using std::swap;

 if (this->_M_is_engaged() && __other._M_is_engaged())
   swap(this->_M_get(), __other._M_get());
 else if (this->_M_is_engaged())
   {
     __other._M_construct(std::move(this->_M_get()));
     this->_M_destruct();
   }
 else if (__other._M_is_engaged())
   {
     this->_M_construct(std::move(__other._M_get()));
     __other._M_destruct();
   }
      }


      constexpr const _Tp*
      operator->() const
      { return std::__addressof(this->_M_get()); }

      constexpr _Tp*
      operator->()
      { return std::__addressof(this->_M_get()); }

      constexpr const _Tp&
      operator*() const&
      { return this->_M_get(); }

      constexpr _Tp&
      operator*()&
      { return this->_M_get(); }

      constexpr _Tp&&
      operator*()&&
      { return std::move(this->_M_get()); }

      constexpr const _Tp&&
      operator*() const&&
      { return std::move(this->_M_get()); }

      constexpr explicit operator bool() const noexcept
      { return this->_M_is_engaged(); }

      constexpr bool has_value() const noexcept
      { return this->_M_is_engaged(); }

      constexpr const _Tp&
      value() const&
      {
 return this->_M_is_engaged()
   ? this->_M_get()
   : (__throw_bad_optional_access(), this->_M_get());
      }

      constexpr _Tp&
      value()&
      {
 return this->_M_is_engaged()
   ? this->_M_get()
   : (__throw_bad_optional_access(), this->_M_get());
      }

      constexpr _Tp&&
      value()&&
      {
 return this->_M_is_engaged()
   ? std::move(this->_M_get())
   : (__throw_bad_optional_access(), std::move(this->_M_get()));
      }

      constexpr const _Tp&&
      value() const&&
      {
 return this->_M_is_engaged()
   ? std::move(this->_M_get())
   : (__throw_bad_optional_access(), std::move(this->_M_get()));
      }

      template<typename _Up>
 constexpr _Tp
 value_or(_Up&& __u) const&
 {
   static_assert(is_copy_constructible_v<_Tp>);
   static_assert(is_convertible_v<_Up&&, _Tp>);

   return this->_M_is_engaged()
     ? this->_M_get() : static_cast<_Tp>(std::forward<_Up>(__u));
 }

      template<typename _Up>
 constexpr _Tp
 value_or(_Up&& __u) &&
 {
   static_assert(is_move_constructible_v<_Tp>);
   static_assert(is_convertible_v<_Up&&, _Tp>);

   return this->_M_is_engaged()
     ? std::move(this->_M_get())
     : static_cast<_Tp>(std::forward<_Up>(__u));
 }

      void reset() noexcept { this->_M_reset(); }
    };

  template<typename _Tp>
    using __optional_relop_t =
      enable_if_t<is_convertible<_Tp, bool>::value, bool>;


  template<typename _Tp, typename _Up>
    constexpr auto
    operator==(const optional<_Tp>& __lhs, const optional<_Up>& __rhs)
    -> __optional_relop_t<decltype(declval<_Tp>() == declval<_Up>())>
    {
      return static_cast<bool>(__lhs) == static_cast<bool>(__rhs)
      && (!__lhs || *__lhs == *__rhs);
    }

  template<typename _Tp, typename _Up>
    constexpr auto
    operator!=(const optional<_Tp>& __lhs, const optional<_Up>& __rhs)
    -> __optional_relop_t<decltype(declval<_Tp>() != declval<_Up>())>
    {
      return static_cast<bool>(__lhs) != static_cast<bool>(__rhs)
 || (static_cast<bool>(__lhs) && *__lhs != *__rhs);
    }

  template<typename _Tp, typename _Up>
    constexpr auto
    operator<(const optional<_Tp>& __lhs, const optional<_Up>& __rhs)
    -> __optional_relop_t<decltype(declval<_Tp>() < declval<_Up>())>
    {
      return static_cast<bool>(__rhs) && (!__lhs || *__lhs < *__rhs);
    }

  template<typename _Tp, typename _Up>
    constexpr auto
    operator>(const optional<_Tp>& __lhs, const optional<_Up>& __rhs)
    -> __optional_relop_t<decltype(declval<_Tp>() > declval<_Up>())>
    {
      return static_cast<bool>(__lhs) && (!__rhs || *__lhs > *__rhs);
    }

  template<typename _Tp, typename _Up>
    constexpr auto
    operator<=(const optional<_Tp>& __lhs, const optional<_Up>& __rhs)
    -> __optional_relop_t<decltype(declval<_Tp>() <= declval<_Up>())>
    {
      return !__lhs || (static_cast<bool>(__rhs) && *__lhs <= *__rhs);
    }

  template<typename _Tp, typename _Up>
    constexpr auto
    operator>=(const optional<_Tp>& __lhs, const optional<_Up>& __rhs)
    -> __optional_relop_t<decltype(declval<_Tp>() >= declval<_Up>())>
    {
      return !__rhs || (static_cast<bool>(__lhs) && *__lhs >= *__rhs);
    }


  template<typename _Tp>
    constexpr bool
    operator==(const optional<_Tp>& __lhs, nullopt_t) noexcept
    { return !__lhs; }

  template<typename _Tp>
    constexpr bool
    operator==(nullopt_t, const optional<_Tp>& __rhs) noexcept
    { return !__rhs; }

  template<typename _Tp>
    constexpr bool
    operator!=(const optional<_Tp>& __lhs, nullopt_t) noexcept
    { return static_cast<bool>(__lhs); }

  template<typename _Tp>
    constexpr bool
    operator!=(nullopt_t, const optional<_Tp>& __rhs) noexcept
    { return static_cast<bool>(__rhs); }

  template<typename _Tp>
    constexpr bool
    operator<(const optional<_Tp>& , nullopt_t) noexcept
    { return false; }

  template<typename _Tp>
    constexpr bool
    operator<(nullopt_t, const optional<_Tp>& __rhs) noexcept
    { return static_cast<bool>(__rhs); }

  template<typename _Tp>
    constexpr bool
    operator>(const optional<_Tp>& __lhs, nullopt_t) noexcept
    { return static_cast<bool>(__lhs); }

  template<typename _Tp>
    constexpr bool
    operator>(nullopt_t, const optional<_Tp>& ) noexcept
    { return false; }

  template<typename _Tp>
    constexpr bool
    operator<=(const optional<_Tp>& __lhs, nullopt_t) noexcept
    { return !__lhs; }

  template<typename _Tp>
    constexpr bool
    operator<=(nullopt_t, const optional<_Tp>& ) noexcept
    { return true; }

  template<typename _Tp>
    constexpr bool
    operator>=(const optional<_Tp>& , nullopt_t) noexcept
    { return true; }

  template<typename _Tp>
    constexpr bool
    operator>=(nullopt_t, const optional<_Tp>& __rhs) noexcept
    { return !__rhs; }


  template<typename _Tp, typename _Up>
    constexpr auto
    operator==(const optional<_Tp>& __lhs, const _Up& __rhs)
    -> __optional_relop_t<decltype(declval<_Tp>() == declval<_Up>())>
    { return __lhs && *__lhs == __rhs; }

  template<typename _Tp, typename _Up>
    constexpr auto
    operator==(const _Up& __lhs, const optional<_Tp>& __rhs)
    -> __optional_relop_t<decltype(declval<_Up>() == declval<_Tp>())>
    { return __rhs && __lhs == *__rhs; }

  template<typename _Tp, typename _Up>
    constexpr auto
    operator!=(const optional<_Tp>& __lhs, const _Up& __rhs)
    -> __optional_relop_t<decltype(declval<_Tp>() != declval<_Up>())>
    { return !__lhs || *__lhs != __rhs; }

  template<typename _Tp, typename _Up>
    constexpr auto
    operator!=(const _Up& __lhs, const optional<_Tp>& __rhs)
    -> __optional_relop_t<decltype(declval<_Up>() != declval<_Tp>())>
    { return !__rhs || __lhs != *__rhs; }

  template<typename _Tp, typename _Up>
    constexpr auto
    operator<(const optional<_Tp>& __lhs, const _Up& __rhs)
    -> __optional_relop_t<decltype(declval<_Tp>() < declval<_Up>())>
    { return !__lhs || *__lhs < __rhs; }

  template<typename _Tp, typename _Up>
    constexpr auto
    operator<(const _Up& __lhs, const optional<_Tp>& __rhs)
    -> __optional_relop_t<decltype(declval<_Up>() < declval<_Tp>())>
    { return __rhs && __lhs < *__rhs; }

  template<typename _Tp, typename _Up>
    constexpr auto
    operator>(const optional<_Tp>& __lhs, const _Up& __rhs)
    -> __optional_relop_t<decltype(declval<_Tp>() > declval<_Up>())>
    { return __lhs && *__lhs > __rhs; }

  template<typename _Tp, typename _Up>
    constexpr auto
    operator>(const _Up& __lhs, const optional<_Tp>& __rhs)
    -> __optional_relop_t<decltype(declval<_Up>() > declval<_Tp>())>
    { return !__rhs || __lhs > *__rhs; }

  template<typename _Tp, typename _Up>
    constexpr auto
    operator<=(const optional<_Tp>& __lhs, const _Up& __rhs)
    -> __optional_relop_t<decltype(declval<_Tp>() <= declval<_Up>())>
    { return !__lhs || *__lhs <= __rhs; }

  template<typename _Tp, typename _Up>
    constexpr auto
    operator<=(const _Up& __lhs, const optional<_Tp>& __rhs)
    -> __optional_relop_t<decltype(declval<_Up>() <= declval<_Tp>())>
    { return __rhs && __lhs <= *__rhs; }

  template<typename _Tp, typename _Up>
    constexpr auto
    operator>=(const optional<_Tp>& __lhs, const _Up& __rhs)
    -> __optional_relop_t<decltype(declval<_Tp>() >= declval<_Up>())>
    { return __lhs && *__lhs >= __rhs; }

  template<typename _Tp, typename _Up>
    constexpr auto
    operator>=(const _Up& __lhs, const optional<_Tp>& __rhs)
    -> __optional_relop_t<decltype(declval<_Up>() >= declval<_Tp>())>
    { return !__rhs || __lhs >= *__rhs; }





  template<typename _Tp>
    inline enable_if_t<is_move_constructible_v<_Tp> && is_swappable_v<_Tp>>
    swap(optional<_Tp>& __lhs, optional<_Tp>& __rhs)
    noexcept(noexcept(__lhs.swap(__rhs)))
    { __lhs.swap(__rhs); }

  template<typename _Tp>
    enable_if_t<!(is_move_constructible_v<_Tp> && is_swappable_v<_Tp>)>
    swap(optional<_Tp>&, optional<_Tp>&) = delete;

  template<typename _Tp>
    constexpr optional<decay_t<_Tp>>
    make_optional(_Tp&& __t)
    { return optional<decay_t<_Tp>> { std::forward<_Tp>(__t) }; }

  template<typename _Tp, typename ..._Args>
    constexpr optional<_Tp>
    make_optional(_Args&&... __args)
    { return optional<_Tp> { in_place, std::forward<_Args>(__args)... }; }

  template<typename _Tp, typename _Up, typename ..._Args>
    constexpr optional<_Tp>
    make_optional(initializer_list<_Up> __il, _Args&&... __args)
    { return optional<_Tp> { in_place, __il, std::forward<_Args>(__args)... }; }



  template<typename _Tp, typename _Up = remove_const_t<_Tp>,
           bool = __poison_hash<_Up>::__enable_hash_call>
    struct __optional_hash_call_base
    {
      size_t
      operator()(const optional<_Tp>& __t) const
      noexcept(noexcept(hash<_Up>{}(*__t)))
      {


        constexpr size_t __magic_disengaged_hash = static_cast<size_t>(-3333);
        return __t ? hash<_Up>{}(*__t) : __magic_disengaged_hash;
      }
    };

  template<typename _Tp, typename _Up>
    struct __optional_hash_call_base<_Tp, _Up, false> {};

  template<typename _Tp>
    struct hash<optional<_Tp>>
    : private __poison_hash<remove_const_t<_Tp>>,
      public __optional_hash_call_base<_Tp>
    {
      using result_type [[__deprecated__]] = size_t;
      using argument_type [[__deprecated__]] = optional<_Tp>;
    };

  template<typename _Tp>
    struct __is_fast_hash<hash<optional<_Tp>>> : __is_fast_hash<hash<_Tp>>
    { };




  template <typename _Tp> optional(_Tp) -> optional<_Tp>;



}
# 46 "/usr/local/include/c++/10.0.0/ranges" 2 3







namespace std __attribute__ ((__visibility__ ("default")))
{

namespace ranges
{







  struct view_base { };

  namespace __detail
  {
    template<typename _Tp>
      concept __deep_const_range = range<_Tp> && range<const _Tp>
 && same_as<range_reference_t<_Tp>, range_reference_t<const _Tp>>;

    template<typename _Tp>
      inline constexpr bool __enable_view_impl
 = derived_from<_Tp, view_base> || (!__deep_const_range<_Tp>);

    template<typename _Tp>
      inline constexpr bool __enable_view_impl<std::initializer_list<_Tp>>
 = false;

  }

  template<typename _Tp>
    inline constexpr bool enable_view
      = __detail::__enable_view_impl<remove_cv_t<_Tp>>;

  template<typename _Tp>
    concept view
      = range<_Tp> && movable<_Tp> && default_initializable<_Tp>
 && enable_view<_Tp>;


  template<typename _Tp>
    concept viewable_range = range<_Tp>
      && (safe_range<_Tp> || view<decay_t<_Tp>>);

  namespace __detail
  {
    template<typename _Range>
      concept __simple_view = view<_Range> && range<const _Range>
 && same_as<iterator_t<_Range>, iterator_t<const _Range>>
 && same_as<sentinel_t<_Range>, sentinel_t<const _Range>>;

    template<typename _It>
      concept __has_arrow = input_iterator<_It>
 && (is_pointer_v<_It> || requires(_It __it) { __it.operator->(); });

    template<typename _Tp, typename _Up>
      concept __not_same_as
 = !same_as<remove_cvref_t<_Tp>, remove_cvref_t<_Up>>;
  }

  template<typename _Derived>
    requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>
    class view_interface : public view_base
    {
    private:
      constexpr _Derived& _M_derived() noexcept
      {
 static_assert(derived_from<_Derived, view_interface<_Derived>>);
 static_assert(view<_Derived>);
 return static_cast<_Derived&>(*this);
      }

      constexpr const _Derived& _M_derived() const noexcept
      {
 static_assert(derived_from<_Derived, view_interface<_Derived>>);
 static_assert(view<_Derived>);
 return static_cast<const _Derived&>(*this);
      }

    public:
      constexpr bool
      empty() requires forward_range<_Derived>
      { return ranges::begin(_M_derived()) == ranges::end(_M_derived()); }

      constexpr bool
      empty() const requires forward_range<const _Derived>
      { return ranges::begin(_M_derived()) == ranges::end(_M_derived()); }

      constexpr explicit
      operator bool() requires requires { ranges::empty(_M_derived()); }
      { return !ranges::empty(_M_derived()); }

      constexpr explicit
      operator bool() const requires requires { ranges::empty(_M_derived()); }
      { return !ranges::empty(_M_derived()); }

      constexpr auto
      data() requires contiguous_iterator<iterator_t<_Derived>>
      { return to_address(ranges::begin(_M_derived())); }

      constexpr auto
      data() const
      requires range<const _Derived>
 && contiguous_iterator<iterator_t<const _Derived>>
      { return to_address(ranges::begin(_M_derived())); }

      constexpr auto
      size()
      requires forward_range<_Derived>
 && sized_sentinel_for<sentinel_t<_Derived>, iterator_t<_Derived>>
      { return ranges::end(_M_derived()) - ranges::begin(_M_derived()); }

      constexpr auto
      size() const
      requires forward_range<const _Derived>
 && sized_sentinel_for<sentinel_t<const _Derived>,
         iterator_t<const _Derived>>
      { return ranges::end(_M_derived()) - ranges::begin(_M_derived()); }

      constexpr decltype(auto)
      front() requires forward_range<_Derived>
      {
 ;
 return *ranges::begin(_M_derived());
      }

      constexpr decltype(auto)
      front() const requires forward_range<const _Derived>
      {
 ;
 return *ranges::begin(_M_derived());
      }

      constexpr decltype(auto)
      back()
      requires bidirectional_range<_Derived> && common_range<_Derived>
      {
 ;
 return *ranges::prev(ranges::end(_M_derived()));
      }

      constexpr decltype(auto)
      back() const
      requires bidirectional_range<const _Derived>
 && common_range<const _Derived>
      {
 ;
 return *ranges::prev(ranges::end(_M_derived()));
      }

      template<random_access_range _Range = _Derived>
 constexpr decltype(auto)
 operator[](range_difference_t<_Range> __n)
 { return ranges::begin(_M_derived())[__n]; }

      template<random_access_range _Range = const _Derived>
 constexpr decltype(auto)
 operator[](range_difference_t<_Range> __n) const
 { return ranges::begin(_M_derived())[__n]; }
    };

  namespace __detail
  {
    template<typename _Tp>
      concept __pair_like
 = !is_reference_v<_Tp> && requires(_Tp __t)
 {
   typename tuple_size<_Tp>::type;
   requires derived_from<tuple_size<_Tp>, integral_constant<size_t, 2>>;
   typename tuple_element_t<0, remove_const_t<_Tp>>;
   typename tuple_element_t<1, remove_const_t<_Tp>>;
   { get<0>(__t) } -> convertible_to<const tuple_element_t<0, _Tp>&>;
   { get<1>(__t) } -> convertible_to<const tuple_element_t<1, _Tp>&>;
 };

    template<typename _Tp, typename _Up, typename _Vp>
      concept __pair_like_convertible_to
 = !range<_Tp> && __pair_like<remove_reference_t<_Tp>>
 && requires(_Tp&& __t)
 {
   { get<0>(std::forward<_Tp>(__t)) } -> convertible_to<_Up>;
   { get<1>(std::forward<_Tp>(__t)) } -> convertible_to<_Vp>;
 };

    template<typename _Tp, typename _Up, typename _Vp>
      concept __pair_like_convertible_from
 = !range<_Tp> && __pair_like<_Tp>
 && constructible_from<_Tp, _Up, _Vp>;

    template<typename _Tp>
      concept __iterator_sentinel_pair
 = !range<_Tp> && __pair_like<_Tp>
 && sentinel_for<tuple_element_t<1, _Tp>, tuple_element_t<0, _Tp>>;

    template<typename _Tp, bool _MaxDiff = same_as<_Tp, __max_diff_type>>
      using __make_unsigned_like_t
 = conditional_t<_MaxDiff, __max_size_type, make_unsigned_t<_Tp>>;

  }

  enum class subrange_kind : bool { unsized, sized };

  template<input_or_output_iterator _It, sentinel_for<_It> _Sent = _It,
    subrange_kind _Kind = sized_sentinel_for<_Sent, _It>
      ? subrange_kind::sized : subrange_kind::unsized>
    requires (_Kind == subrange_kind::sized || !sized_sentinel_for<_Sent, _It>)
    class subrange : public view_interface<subrange<_It, _Sent, _Kind>>
    {
    private:
      static constexpr bool _S_store_size
 = _Kind == subrange_kind::sized && !sized_sentinel_for<_Sent, _It>;

      _It _M_begin = _It();
      _Sent _M_end = _Sent();

      template<typename, bool = _S_store_size>
 struct _Size
 { };

      template<typename _Tp>
 struct _Size<_Tp, true>
 { __detail::__make_unsigned_like_t<_Tp> _M_size; };

      [[no_unique_address]] _Size<iter_difference_t<_It>> _M_size = {};

    public:
      subrange() = default;

      constexpr
      subrange(_It __i, _Sent __s) requires (!_S_store_size)
      : _M_begin(std::move(__i)), _M_end(__s)
      { }

      constexpr
      subrange(_It __i, _Sent __s,
        __detail::__make_unsigned_like_t<iter_difference_t<_It>> __n)
 requires (_Kind == subrange_kind::sized)
      : _M_begin(std::move(__i)), _M_end(__s)
      {
 using __detail::__to_unsigned_like;
 ;
 if constexpr (_S_store_size)
   _M_size._M_size = __n;
      }

      template<__detail::__not_same_as<subrange> _Rng>
 requires safe_range<_Rng>
   && convertible_to<iterator_t<_Rng>, _It>
   && convertible_to<sentinel_t<_Rng>, _Sent>
 constexpr
 subrange(_Rng&& __r) requires (!_S_store_size || sized_range<_Rng>)
 : subrange{ranges::begin(__r), ranges::end(__r)}
 {
   if constexpr (_S_store_size)
     _M_size._M_size = ranges::size(__r);
 }

      template<safe_range _Rng>
 requires convertible_to<iterator_t<_Rng>, _It>
   && convertible_to<sentinel_t<_Rng>, _Sent>
 constexpr
 subrange(_Rng&& __r,
   __detail::__make_unsigned_like_t<iter_difference_t<_It>> __n)
 requires (_Kind == subrange_kind::sized)
 : subrange{ranges::begin(__r), ranges::end(__r), __n}
 { }

      template<__detail::__not_same_as<subrange> _PairLike>
 requires __detail::__pair_like_convertible_to<_PairLike, _It, _Sent>
 constexpr
 subrange(_PairLike&& __r) requires (!_S_store_size)
 : subrange{std::get<0>(std::forward<_PairLike>(__r)),
     std::get<1>(std::forward<_PairLike>(__r))}
 { }

      template<__detail::__pair_like_convertible_to<_It, _Sent> _PairLike>
 constexpr
 subrange(_PairLike&& __r,
   __detail::__make_unsigned_like_t<iter_difference_t<_It>> __n)
 requires (_Kind == subrange_kind::sized)
 : subrange{std::get<0>(std::forward<_PairLike>(__r)),
     std::get<1>(std::forward<_PairLike>(__r)), __n}
 { }

      template<__detail::__not_same_as<subrange> _PairLike>
 requires __detail::__pair_like_convertible_from<_PairLike, const _It&,
       const _Sent&>
      constexpr
      operator _PairLike() const
      { return _PairLike(_M_begin, _M_end); }

      constexpr _It
      begin() const requires copyable<_It>
      { return _M_begin; }

      [[nodiscard]] constexpr _It
      begin() requires (!copyable<_It>)
      { return std::move(_M_begin); }

      constexpr _Sent end() const { return _M_end; }

      constexpr bool empty() const { return _M_begin == _M_end; }

      constexpr __detail::__make_unsigned_like_t<iter_difference_t<_It>>
      size() const requires (_Kind == subrange_kind::sized)
      {
 if constexpr (_S_store_size)
   return _M_size._M_size;
 else
   return __detail::__to_unsigned_like(_M_end - _M_begin);
      }

      [[nodiscard]] constexpr subrange
      next(iter_difference_t<_It> __n = 1) const &
 requires forward_iterator<_It>
      {
 auto __tmp = *this;
 __tmp.advance(__n);
 return __tmp;
      }

      [[nodiscard]] constexpr subrange
      next(iter_difference_t<_It> __n = 1) &&
      {
 advance(__n);
 return std::move(*this);
      }

      [[nodiscard]] constexpr subrange
      prev(iter_difference_t<_It> __n = 1) const
 requires bidirectional_iterator<_It>
      {
 auto __tmp = *this;
 __tmp.advance(--__n);
 return __tmp;
      }

      constexpr subrange&
      advance(iter_difference_t<_It> __n)
      {
 if constexpr (_S_store_size)
   {
     auto __d = __n - ranges::advance(_M_begin, __n, _M_end);
     if (__d >= 0)
       _M_size._M_size -= __detail::__to_unsigned_like(__d);
     else
       _M_size._M_size += __detail::__to_unsigned_like(-__d);
   }
 else
   ranges::advance(_M_begin, __n, _M_end);
 return *this;
      }
    };

  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
    subrange(_It, _Sent,
      __detail::__make_unsigned_like_t<iter_difference_t<_It>>)
      -> subrange<_It, _Sent, subrange_kind::sized>;

  template<__detail::__iterator_sentinel_pair _Pr>
    subrange(_Pr)
      -> subrange<tuple_element_t<0, _Pr>, tuple_element_t<1, _Pr>>;

  template<__detail::__iterator_sentinel_pair _Pr>
    subrange(_Pr, __detail::__make_unsigned_like_t<iter_difference_t<
           tuple_element_t<0, _Pr>>>)
      -> subrange<tuple_element_t<0, _Pr>, tuple_element_t<1, _Pr>,
    subrange_kind::sized>;

  template<safe_range _Rng>
    subrange(_Rng&&)
      -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>,
   (sized_range<_Rng>
    || sized_sentinel_for<sentinel_t<_Rng>, iterator_t<_Rng>>)
   ? subrange_kind::sized : subrange_kind::unsized>;

  template<safe_range _Rng>
    subrange(_Rng&&,
      __detail::__make_unsigned_like_t<range_difference_t<_Rng>>)
      -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>, subrange_kind::sized>;

  template<size_t _Num, class _It, class _Sent, subrange_kind _Kind>
    requires (_Num < 2)
    constexpr auto
    get(const subrange<_It, _Sent, _Kind>& __r)
    {
      if constexpr (_Num == 0)
 return __r.begin();
      else
 return __r.end();
    }

  template<size_t _Num, class _It, class _Sent, subrange_kind _Kind>
    requires (_Num < 2)
    constexpr auto
    get(subrange<_It, _Sent, _Kind>&& __r)
    {
      if constexpr (_Num == 0)
 return __r.begin();
      else
 return __r.end();
    }

  template<input_or_output_iterator _It, sentinel_for<_It> _Sent,
    subrange_kind _Kind>
    inline constexpr bool
      enable_safe_range<subrange<_It, _Sent, _Kind>> = true;

}

  using ranges::get;

namespace ranges
{

  struct dangling
  {
    constexpr dangling() noexcept = default;
    template<typename... _Args>
      constexpr dangling(_Args&&...) noexcept { }
  };

  template<range _Range>
    using safe_iterator_t = conditional_t<safe_range<_Range>,
       iterator_t<_Range>,
       dangling>;

  template<range _Range>
    using safe_subrange_t = conditional_t<safe_range<_Range>,
       subrange<iterator_t<_Range>>,
       dangling>;

  template<typename _Tp> requires is_object_v<_Tp>
    class empty_view
    : public view_interface<empty_view<_Tp>>
    {
    public:
      static constexpr _Tp* begin() noexcept { return nullptr; }
      static constexpr _Tp* end() noexcept { return nullptr; }
      static constexpr _Tp* data() noexcept { return nullptr; }
      static constexpr size_t size() noexcept { return 0; }
      static constexpr bool empty() noexcept { return true; }
    };

  template<typename _Tp>
    inline constexpr bool enable_safe_range<empty_view<_Tp>> = true;

  namespace __detail
  {
    template<copy_constructible _Tp> requires is_object_v<_Tp>
      struct __box : std::optional<_Tp>
      {
 using std::optional<_Tp>::optional;

 constexpr
 __box()
 noexcept(is_nothrow_default_constructible_v<_Tp>)
 requires default_initializable<_Tp>
 : std::optional<_Tp>{std::in_place}
 { }

 using std::optional<_Tp>::operator=;

 __box&
 operator=(const __box& __that)
 noexcept(is_nothrow_copy_constructible_v<_Tp>)
 requires (!assignable_from<_Tp&, const _Tp&>)
 {
   if ((bool)__that)
     this->emplace(*__that);
   else
     this->reset();
   return *this;
 }

 __box&
 operator=(__box&& __that)
 noexcept(is_nothrow_move_constructible_v<_Tp>)
 requires (!assignable_from<_Tp&, _Tp>)
 {
   if ((bool)__that)
     this->emplace(std::move(*__that));
   else
     this->reset();
   return *this;
 }
      };

  }


  template<copy_constructible _Tp> requires is_object_v<_Tp>
    class single_view : public view_interface<single_view<_Tp>>
    {
    public:
      single_view() = default;

      constexpr explicit
      single_view(const _Tp& __t)
      : _M_value(__t)
      { }

      constexpr explicit
      single_view(_Tp&& __t)
      : _M_value(std::move(__t))
      { }

      template<typename... _Args>
 requires constructible_from<_Tp, _Args...>
 constexpr
 single_view(in_place_t, _Args&&... __args)
 : _M_value{in_place, std::forward<_Args>(__args)...}
 { }

      constexpr _Tp*
      begin() noexcept
      { return data(); }

      constexpr const _Tp*
      begin() const noexcept
      { return data(); }

      constexpr _Tp*
      end() noexcept
      { return data() + 1; }

      constexpr const _Tp*
      end() const noexcept
      { return data() + 1; }

      static constexpr size_t
      size() noexcept
      { return 1; }

      constexpr _Tp*
      data() noexcept
      { return _M_value.operator->(); }

      constexpr const _Tp*
      data() const noexcept
      { return _M_value.operator->(); }

    private:
      __detail::__box<_Tp> _M_value;
    };

  namespace __detail
  {
    template<typename _Wp>
      constexpr auto __to_signed_like(_Wp __w) noexcept
      {
 if constexpr (!integral<_Wp>)
   return iter_difference_t<_Wp>();
 else if constexpr (sizeof(iter_difference_t<_Wp>) > sizeof(_Wp))
   return iter_difference_t<_Wp>(__w);
 else if constexpr (sizeof(ptrdiff_t) > sizeof(_Wp))
   return ptrdiff_t(__w);
 else if constexpr (sizeof(long long) > sizeof(_Wp))
   return (long long)(__w);

 else if constexpr (16 > sizeof(_Wp))
   return __int128(__w);

 else
   return __max_diff_type(__w);
      }

    template<typename _Wp>
      using __iota_diff_t = decltype(__to_signed_like(std::declval<_Wp>()));

    template<typename _It>
      concept __decrementable = incrementable<_It>
 && requires(_It __i)
 {
     { --__i } -> same_as<_It&>;
     { __i-- } -> same_as<_It>;
 };

    template<typename _It>
      concept __advanceable = __decrementable<_It> && totally_ordered<_It>
 && requires( _It __i, const _It __j, const __iota_diff_t<_It> __n)
 {
   { __i += __n } -> same_as<_It&>;
   { __i -= __n } -> same_as<_It&>;
   _It(__j + __n);
   _It(__n + __j);
   _It(__j - __n);
   { __j - __j } -> convertible_to<__iota_diff_t<_It>>;
 };

  }

  template<weakly_incrementable _Winc,
    semiregular _Bound = unreachable_sentinel_t>
    requires std::__detail::__weakly_eq_cmp_with<_Winc, _Bound>
    class iota_view : public view_interface<iota_view<_Winc, _Bound>>
    {
    private:
      struct _Iterator
      {
      private:
 static auto
 _S_iter_cat()
 {
   using namespace __detail;
   if constexpr (__advanceable<_Winc>)
     return random_access_iterator_tag{};
   else if constexpr (__decrementable<_Winc>)
     return bidirectional_iterator_tag{};
   else if constexpr (incrementable<_Winc>)
     return forward_iterator_tag{};
   else
     return input_iterator_tag{};
 }

      public:
 using iterator_category = decltype(_S_iter_cat());
 using value_type = _Winc;
 using difference_type = __detail::__iota_diff_t<_Winc>;

 _Iterator() = default;

 constexpr explicit
 _Iterator(_Winc __value)
 : _M_value(__value) { }

 constexpr _Winc
 operator*() const noexcept(is_nothrow_copy_constructible_v<_Winc>)
 { return _M_value; }

 constexpr _Iterator&
 operator++()
 {
   ++_M_value;
   return *this;
 }

 constexpr void
 operator++(int)
 { ++*this; }

 constexpr _Iterator
 operator++(int) requires incrementable<_Winc>
 {
   auto __tmp = *this;
   ++*this;
   return __tmp;
 }

 constexpr _Iterator&
 operator--() requires __detail::__decrementable<_Winc>
 {
   --_M_value;
   return *this;
 }

 constexpr _Iterator
 operator--(int) requires __detail::__decrementable<_Winc>
 {
   auto __tmp = *this;
   --*this;
   return __tmp;
 }

 constexpr _Iterator&
 operator+=(difference_type __n) requires __detail::__advanceable<_Winc>
 {
   using namespace __detail;
   if constexpr (__is_integer_like<_Winc>
       && !__is_signed_integer_like<_Winc>)
     {
       if (__n >= difference_type(0))
  _M_value += static_cast<_Winc>(__n);
       else
  _M_value -= static_cast<_Winc>(-__n);
     }
   else
     _M_value += __n;
   return *this;
 }

 constexpr _Iterator&
 operator-=(difference_type __n) requires __detail::__advanceable<_Winc>
 {
   using namespace __detail;
   if constexpr (__is_integer_like<_Winc>
       && !__is_signed_integer_like<_Winc>)
     {
       if (__n >= difference_type(0))
  _M_value -= static_cast<_Winc>(__n);
       else
  _M_value += static_cast<_Winc>(-__n);
     }
   else
     _M_value -= __n;
   return *this;
 }

 constexpr _Winc
 operator[](difference_type __n) const
 requires __detail::__advanceable<_Winc>
 { return _Winc(_M_value + __n); }

 friend constexpr bool
 operator==(const _Iterator& __x, const _Iterator& __y)
 requires equality_comparable<_Winc>
 { return __x._M_value == __y._M_value; }

 friend constexpr bool
 operator<(const _Iterator& __x, const _Iterator& __y)
 requires totally_ordered<_Winc>
 { return __x._M_value < __y._M_value; }

 friend constexpr bool
 operator>(const _Iterator& __x, const _Iterator& __y)
   requires totally_ordered<_Winc>
 { return __y < __x; }

 friend constexpr bool
 operator<=(const _Iterator& __x, const _Iterator& __y)
   requires totally_ordered<_Winc>
 { return !(__y < __x); }

 friend constexpr bool
 operator>=(const _Iterator& __x, const _Iterator& __y)
   requires totally_ordered<_Winc>
 { return !(__x < __y); }
# 788 "/usr/local/include/c++/10.0.0/ranges" 3
 friend constexpr _Iterator
 operator+(_Iterator __i, difference_type __n)
   requires __detail::__advanceable<_Winc>
 { return __i += __n; }

 friend constexpr _Iterator
 operator+(difference_type __n, _Iterator __i)
   requires __detail::__advanceable<_Winc>
 { return __i += __n; }

 friend constexpr _Iterator
 operator-(_Iterator __i, difference_type __n)
   requires __detail::__advanceable<_Winc>
 { return __i -= __n; }

 friend constexpr difference_type
 operator-(const _Iterator& __x, const _Iterator& __y)
   requires __detail::__advanceable<_Winc>
 {
   using namespace __detail;
   using _Dt = difference_type;
   if constexpr (__is_integer_like<_Winc>)
     {
       if constexpr (__is_signed_integer_like<_Winc>)
  return _Dt(_Dt(__x._M_value) - _Dt(__y._M_value));
       else
  return (__y._M_value > __x._M_value)
    ? _Dt(-_Dt(__y._M_value - __x._M_value))
    : _Dt(__x._M_value - __y._M_value);
     }
   else
     return __x._M_value - __y._M_value;
 }

      private:
 _Winc _M_value = _Winc();
      };

      struct _Sentinel
      {
      private:
 _Bound _M_bound = _Bound();

      public:
 _Sentinel() = default;

 constexpr explicit
 _Sentinel(_Bound __bound)
 : _M_bound(__bound) { }

 friend constexpr bool
 operator==(const _Iterator& __x, const _Sentinel& __y)
 { return __x._M_value == __y._M_bound; }

 friend constexpr iter_difference_t<_Winc>
 operator-(const _Iterator& __x, const _Sentinel& __y)
   requires sized_sentinel_for<_Bound, _Winc>
 { return __x._M_value - __y._M_bound; }

 friend constexpr iter_difference_t<_Winc>
 operator-(const _Sentinel& __x, const _Iterator& __y)
   requires sized_sentinel_for<_Bound, _Winc>
 { return -(__y - __x); }
      };

      _Winc _M_value = _Winc();
      _Bound _M_bound = _Bound();

    public:
      iota_view() = default;

      constexpr explicit
      iota_view(_Winc __value)
      : _M_value(__value)
      { }

      constexpr
      iota_view(type_identity_t<_Winc> __value,
  type_identity_t<_Bound> __bound)
      : _M_value(__value), _M_bound(__bound)
      {
 if constexpr (totally_ordered_with<_Winc, _Bound>)
   ;
      }

      constexpr _Iterator
      begin() const { return _Iterator{_M_value}; }

      constexpr auto
      end() const
      {
 if constexpr (same_as<_Bound, unreachable_sentinel_t>)
   return unreachable_sentinel;
 else
   return _Sentinel{_M_bound};
      }

      constexpr _Iterator
      end() const requires same_as<_Winc, _Bound>
      { return _Iterator{_M_bound}; }

      constexpr auto
      size() const
      requires (same_as<_Winc, _Bound> && __detail::__advanceable<_Winc>)
      || (integral<_Winc> && integral<_Bound>)
      || sized_sentinel_for<_Bound, _Winc>
      {
 using namespace __detail;
 if constexpr (__is_integer_like<_Winc> && __is_integer_like<_Bound>)
   return (_M_value < 0)
     ? ((_M_bound < 0)
  ? __to_unsigned_like(-_M_value) - __to_unsigned_like(-_M_bound)
  : __to_unsigned_like(_M_bound) + __to_unsigned_like(-_M_value))
     : __to_unsigned_like(_M_bound) - __to_unsigned_like(_M_value);
 else
   return __to_unsigned_like(_M_bound - _M_value);
      }
    };

  template<typename _Winc, typename _Bound>
    requires (!__detail::__is_integer_like<_Winc>
 || !__detail::__is_integer_like<_Bound>
 || (__detail::__is_signed_integer_like<_Winc>
     == __detail::__is_signed_integer_like<_Bound>))
    iota_view(_Winc, _Bound) -> iota_view<_Winc, _Bound>;

  template<weakly_incrementable _Winc, semiregular _Bound>
    inline constexpr bool enable_safe_range<iota_view<_Winc, _Bound>> = true;

namespace views
{
  template<typename _Tp>
    inline constexpr empty_view<_Tp> empty{};

  struct _Single
  {
    template<typename _Tp>
      auto
      operator()(_Tp&& __e) const
      { return single_view{std::forward<_Tp>(__e)}; }
  };

  inline constexpr _Single single{};

  struct _Iota
  {
    template<typename _Tp>
      auto
      operator()(_Tp&& __e) const
      { return iota_view{std::forward<_Tp>(__e)}; }

    template<typename _Tp, typename _Up>
      auto
      operator()(_Tp&& __e, _Up&& __f) const
      { return iota_view{std::forward<_Tp>(__e), std::forward<_Tp>(__f)}; }
  };

  inline constexpr _Iota iota{};

}
}

}
# 25 "fast_io/fast_io_core.h" 2
# 1 "/usr/local/include/c++/10.0.0/algorithm" 1 3
# 58 "/usr/local/include/c++/10.0.0/algorithm" 3
       
# 59 "/usr/local/include/c++/10.0.0/algorithm" 3
# 71 "/usr/local/include/c++/10.0.0/algorithm" 3
# 1 "/usr/local/include/c++/10.0.0/pstl/glue_algorithm_defs.h" 1 3
# 13 "/usr/local/include/c++/10.0.0/pstl/glue_algorithm_defs.h" 3
# 1 "/usr/local/include/c++/10.0.0/functional" 1 3
# 46 "/usr/local/include/c++/10.0.0/functional" 3
       
# 47 "/usr/local/include/c++/10.0.0/functional" 3
# 59 "/usr/local/include/c++/10.0.0/functional" 3
# 1 "/usr/local/include/c++/10.0.0/bits/std_function.h" 1 3
# 33 "/usr/local/include/c++/10.0.0/bits/std_function.h" 3
       
# 34 "/usr/local/include/c++/10.0.0/bits/std_function.h" 3
# 47 "/usr/local/include/c++/10.0.0/bits/std_function.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  class bad_function_call : public std::exception
  {
  public:
    virtual ~bad_function_call() noexcept;

    const char* what() const noexcept;
  };







  template<typename _Tp>
    struct __is_location_invariant
    : is_trivially_copyable<_Tp>::type
    { };

  class _Undefined_class;

  union _Nocopy_types
  {
    void* _M_object;
    const void* _M_const_object;
    void (*_M_function_pointer)();
    void (_Undefined_class::*_M_member_pointer)();
  };

  union [[gnu::may_alias]] _Any_data
  {
    void* _M_access() { return &_M_pod_data[0]; }
    const void* _M_access() const { return &_M_pod_data[0]; }

    template<typename _Tp>
      _Tp&
      _M_access()
      { return *static_cast<_Tp*>(_M_access()); }

    template<typename _Tp>
      const _Tp&
      _M_access() const
      { return *static_cast<const _Tp*>(_M_access()); }

    _Nocopy_types _M_unused;
    char _M_pod_data[sizeof(_Nocopy_types)];
  };

  enum _Manager_operation
  {
    __get_type_info,
    __get_functor_ptr,
    __clone_functor,
    __destroy_functor
  };

  template<typename _Signature>
    class function;


  class _Function_base
  {
  public:
    static const size_t _M_max_size = sizeof(_Nocopy_types);
    static const size_t _M_max_align = __alignof__(_Nocopy_types);

    template<typename _Functor>
      class _Base_manager
      {
      protected:
 static const bool __stored_locally =
 (__is_location_invariant<_Functor>::value
  && sizeof(_Functor) <= _M_max_size
  && __alignof__(_Functor) <= _M_max_align
  && (_M_max_align % __alignof__(_Functor) == 0));

 typedef integral_constant<bool, __stored_locally> _Local_storage;


 static _Functor*
 _M_get_pointer(const _Any_data& __source)
 {
   if constexpr (__stored_locally)
     {
       const _Functor& __f = __source._M_access<_Functor>();
       return const_cast<_Functor*>(std::__addressof(__f));
     }
   else
     return __source._M_access<_Functor*>();
 }



 static void
 _M_clone(_Any_data& __dest, const _Any_data& __source, true_type)
 {
   ::new (__dest._M_access()) _Functor(__source._M_access<_Functor>());
 }



 static void
 _M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
 {
   __dest._M_access<_Functor*>() =
     new _Functor(*__source._M_access<const _Functor*>());
 }



 static void
 _M_destroy(_Any_data& __victim, true_type)
 {
   __victim._M_access<_Functor>().~_Functor();
 }


 static void
 _M_destroy(_Any_data& __victim, false_type)
 {
   delete __victim._M_access<_Functor*>();
 }

      public:
 static bool
 _M_manager(_Any_data& __dest, const _Any_data& __source,
     _Manager_operation __op)
 {
   switch (__op)
     {

     case __get_type_info:
       __dest._M_access<const type_info*>() = &typeid(_Functor);
       break;

     case __get_functor_ptr:
       __dest._M_access<_Functor*>() = _M_get_pointer(__source);
       break;

     case __clone_functor:
       _M_clone(__dest, __source, _Local_storage());
       break;

     case __destroy_functor:
       _M_destroy(__dest, _Local_storage());
       break;
     }
   return false;
 }

 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f)
 { _M_init_functor(__functor, std::move(__f), _Local_storage()); }

 template<typename _Signature>
   static bool
   _M_not_empty_function(const function<_Signature>& __f)
   { return static_cast<bool>(__f); }

 template<typename _Tp>
   static bool
   _M_not_empty_function(_Tp* __fp)
   { return __fp != nullptr; }

 template<typename _Class, typename _Tp>
   static bool
   _M_not_empty_function(_Tp _Class::* __mp)
   { return __mp != nullptr; }

 template<typename _Tp>
   static bool
   _M_not_empty_function(const _Tp&)
   { return true; }

      private:
 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
 { ::new (__functor._M_access()) _Functor(std::move(__f)); }

 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
 { __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
    {
      if (_M_manager)
 _M_manager(_M_functor, _M_functor, __destroy_functor);
    }

    bool _M_empty() const { return !_M_manager; }

    typedef bool (*_Manager_type)(_Any_data&, const _Any_data&,
      _Manager_operation);

    _Any_data _M_functor;
    _Manager_type _M_manager;
  };

  template<typename _Signature, typename _Functor>
    class _Function_handler;

  template<typename _Res, typename _Functor, typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), _Functor>
    : public _Function_base::_Base_manager<_Functor>
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

    public:
      static bool
      _M_manager(_Any_data& __dest, const _Any_data& __source,
   _Manager_operation __op)
      {
 switch (__op)
   {

   case __get_type_info:
     __dest._M_access<const type_info*>() = &typeid(_Functor);
     break;

   case __get_functor_ptr:
     __dest._M_access<_Functor*>() = _Base::_M_get_pointer(__source);
     break;

   default:
     _Base::_M_manager(__dest, __source, __op);
   }
 return false;
      }

      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 return std::__invoke_r<_Res>(*_Base::_M_get_pointer(__functor),
         std::forward<_ArgTypes>(__args)...);
      }
    };







  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
    : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
      private _Function_base
    {
      template<typename _Func,
        typename _Res2 = __invoke_result<_Func&, _ArgTypes...>>
 struct _Callable
 : __is_invocable_impl<_Res2, _Res>::type
 { };



      template<typename _Tp>
 struct _Callable<function, _Tp> : false_type { };

      template<typename _Cond, typename _Tp>
 using _Requires = typename enable_if<_Cond::value, _Tp>::type;

    public:
      typedef _Res result_type;







      function() noexcept
      : _Function_base() { }





      function(nullptr_t) noexcept
      : _Function_base() { }
# 348 "/usr/local/include/c++/10.0.0/bits/std_function.h" 3
      function(const function& __x);
# 357 "/usr/local/include/c++/10.0.0/bits/std_function.h" 3
      function(function&& __x) noexcept : _Function_base()
      {
 __x.swap(*this);
      }
# 378 "/usr/local/include/c++/10.0.0/bits/std_function.h" 3
      template<typename _Functor,
        typename = _Requires<__not_<is_same<_Functor, function>>, void>,
        typename = _Requires<_Callable<_Functor>, void>>
 function(_Functor);
# 395 "/usr/local/include/c++/10.0.0/bits/std_function.h" 3
      function&
      operator=(const function& __x)
      {
 function(__x).swap(*this);
 return *this;
      }
# 413 "/usr/local/include/c++/10.0.0/bits/std_function.h" 3
      function&
      operator=(function&& __x) noexcept
      {
 function(std::move(__x)).swap(*this);
 return *this;
      }
# 427 "/usr/local/include/c++/10.0.0/bits/std_function.h" 3
      function&
      operator=(nullptr_t) noexcept
      {
 if (_M_manager)
   {
     _M_manager(_M_functor, _M_functor, __destroy_functor);
     _M_manager = nullptr;
     _M_invoker = nullptr;
   }
 return *this;
      }
# 455 "/usr/local/include/c++/10.0.0/bits/std_function.h" 3
      template<typename _Functor>
 _Requires<_Callable<typename decay<_Functor>::type>, function&>
 operator=(_Functor&& __f)
 {
   function(std::forward<_Functor>(__f)).swap(*this);
   return *this;
 }


      template<typename _Functor>
 function&
 operator=(reference_wrapper<_Functor> __f) noexcept
 {
   function(__f).swap(*this);
   return *this;
 }
# 481 "/usr/local/include/c++/10.0.0/bits/std_function.h" 3
      void swap(function& __x) noexcept
      {
 std::swap(_M_functor, __x._M_functor);
 std::swap(_M_manager, __x._M_manager);
 std::swap(_M_invoker, __x._M_invoker);
      }
# 498 "/usr/local/include/c++/10.0.0/bits/std_function.h" 3
      explicit operator bool() const noexcept
      { return !_M_empty(); }
# 511 "/usr/local/include/c++/10.0.0/bits/std_function.h" 3
      _Res operator()(_ArgTypes... __args) const;
# 524 "/usr/local/include/c++/10.0.0/bits/std_function.h" 3
      const type_info& target_type() const noexcept;
# 537 "/usr/local/include/c++/10.0.0/bits/std_function.h" 3
      template<typename _Functor> _Functor* target() noexcept;

      template<typename _Functor> const _Functor* target() const noexcept;



    private:
      using _Invoker_type = _Res (*)(const _Any_data&, _ArgTypes&&...);
      _Invoker_type _M_invoker;
  };


  template<typename>
    struct __function_guide_helper
    { };

  template<typename _Res, typename _Tp, bool _Nx, typename... _Args>
    struct __function_guide_helper<
      _Res (_Tp::*) (_Args...) noexcept(_Nx)
    >
    { using type = _Res(_Args...); };

  template<typename _Res, typename _Tp, bool _Nx, typename... _Args>
    struct __function_guide_helper<
      _Res (_Tp::*) (_Args...) & noexcept(_Nx)
    >
    { using type = _Res(_Args...); };

  template<typename _Res, typename _Tp, bool _Nx, typename... _Args>
    struct __function_guide_helper<
      _Res (_Tp::*) (_Args...) const noexcept(_Nx)
    >
    { using type = _Res(_Args...); };

  template<typename _Res, typename _Tp, bool _Nx, typename... _Args>
    struct __function_guide_helper<
      _Res (_Tp::*) (_Args...) const & noexcept(_Nx)
    >
    { using type = _Res(_Args...); };

  template<typename _Res, typename... _ArgTypes>
    function(_Res(*)(_ArgTypes...)) -> function<_Res(_ArgTypes...)>;

  template<typename _Functor, typename _Signature = typename
    __function_guide_helper<decltype(&_Functor::operator())>::type>
    function(_Functor) -> function<_Signature>;



  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
    function(const function& __x)
    : _Function_base()
    {
      if (static_cast<bool>(__x))
 {
   __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
   _M_invoker = __x._M_invoker;
   _M_manager = __x._M_manager;
 }
    }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor, typename, typename>
      function<_Res(_ArgTypes...)>::
      function(_Functor __f)
      : _Function_base()
      {
 typedef _Function_handler<_Res(_ArgTypes...), _Functor> _My_handler;

 if (_My_handler::_M_not_empty_function(__f))
   {
     _My_handler::_M_init_functor(_M_functor, std::move(__f));
     _M_invoker = &_My_handler::_M_invoke;
     _M_manager = &_My_handler::_M_manager;
   }
      }

  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 __throw_bad_function_call();
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
    }


  template<typename _Res, typename... _ArgTypes>
    const type_info&
    function<_Res(_ArgTypes...)>::
    target_type() const noexcept
    {
      if (_M_manager)
 {
   _Any_data __typeinfo_result;
   _M_manager(__typeinfo_result, _M_functor, __get_type_info);
   return *__typeinfo_result._M_access<const type_info*>();
 }
      else
 return typeid(void);
    }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor>
      _Functor*
      function<_Res(_ArgTypes...)>::
      target() noexcept
      {
 const function* __const_this = this;
 const _Functor* __func = __const_this->template target<_Functor>();
 return const_cast<_Functor*>(__func);
      }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor>
      const _Functor*
      function<_Res(_ArgTypes...)>::
      target() const noexcept
      {
 if (typeid(_Functor) == target_type() && _M_manager)
   {
     _Any_data __ptr;
     _M_manager(__ptr, _M_functor, __get_functor_ptr);
     return __ptr._M_access<const _Functor*>();
   }
 else
   return nullptr;
      }
# 678 "/usr/local/include/c++/10.0.0/bits/std_function.h" 3
  template<typename _Res, typename... _Args>
    inline bool
    operator==(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
    { return !static_cast<bool>(__f); }


  template<typename _Res, typename... _Args>
    inline bool
    operator==(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
    { return !static_cast<bool>(__f); }
# 696 "/usr/local/include/c++/10.0.0/bits/std_function.h" 3
  template<typename _Res, typename... _Args>
    inline bool
    operator!=(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
    { return static_cast<bool>(__f); }


  template<typename _Res, typename... _Args>
    inline bool
    operator!=(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
    { return static_cast<bool>(__f); }
# 717 "/usr/local/include/c++/10.0.0/bits/std_function.h" 3
  template<typename _Res, typename... _Args>
    inline void
    swap(function<_Res(_Args...)>& __x, function<_Res(_Args...)>& __y) noexcept
    { __x.swap(__y); }


  namespace __detail::__variant
  {
    template<typename> struct _Never_valueless_alt;



    template<typename _Signature>
      struct _Never_valueless_alt<std::function<_Signature>>
      : std::true_type
      { };
  }



}
# 60 "/usr/local/include/c++/10.0.0/functional" 2 3

# 1 "/usr/local/include/c++/10.0.0/unordered_map" 1 3
# 32 "/usr/local/include/c++/10.0.0/unordered_map" 3
       
# 33 "/usr/local/include/c++/10.0.0/unordered_map" 3
# 46 "/usr/local/include/c++/10.0.0/unordered_map" 3
# 1 "/usr/local/include/c++/10.0.0/bits/hashtable.h" 1 3
# 33 "/usr/local/include/c++/10.0.0/bits/hashtable.h" 3
       
# 34 "/usr/local/include/c++/10.0.0/bits/hashtable.h" 3

# 1 "/usr/local/include/c++/10.0.0/bits/hashtable_policy.h" 1 3
# 38 "/usr/local/include/c++/10.0.0/bits/hashtable_policy.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    class _Hashtable;

namespace __detail
{





  template<typename _Key, typename _Value,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _Traits>
    struct _Hashtable_base;



  template<class _Iterator>
    inline typename std::iterator_traits<_Iterator>::difference_type
    __distance_fw(_Iterator __first, _Iterator __last,
    std::input_iterator_tag)
    { return __first != __last ? 1 : 0; }

  template<class _Iterator>
    inline typename std::iterator_traits<_Iterator>::difference_type
    __distance_fw(_Iterator __first, _Iterator __last,
    std::forward_iterator_tag)
    { return std::distance(__first, __last); }

  template<class _Iterator>
    inline typename std::iterator_traits<_Iterator>::difference_type
    __distance_fw(_Iterator __first, _Iterator __last)
    { return __distance_fw(__first, __last,
      std::__iterator_category(__first)); }

  struct _Identity
  {
    template<typename _Tp>
      _Tp&&
      operator()(_Tp&& __x) const
      { return std::forward<_Tp>(__x); }
  };

  struct _Select1st
  {
    template<typename _Tp>
      auto
      operator()(_Tp&& __x) const
      -> decltype(std::get<0>(std::forward<_Tp>(__x)))
      { return std::get<0>(std::forward<_Tp>(__x)); }
  };

  template<typename _NodeAlloc>
    struct _Hashtable_alloc;



  template<typename _NodeAlloc>
    struct _ReuseOrAllocNode
    {
    private:
      using __node_alloc_type = _NodeAlloc;
      using __hashtable_alloc = _Hashtable_alloc<__node_alloc_type>;
      using __node_alloc_traits =
 typename __hashtable_alloc::__node_alloc_traits;
      using __node_type = typename __hashtable_alloc::__node_type;

    public:
      _ReuseOrAllocNode(__node_type* __nodes, __hashtable_alloc& __h)
      : _M_nodes(__nodes), _M_h(__h) { }
      _ReuseOrAllocNode(const _ReuseOrAllocNode&) = delete;

      ~_ReuseOrAllocNode()
      { _M_h._M_deallocate_nodes(_M_nodes); }

      template<typename _Arg>
 __node_type*
 operator()(_Arg&& __arg) const
 {
   if (_M_nodes)
     {
       __node_type* __node = _M_nodes;
       _M_nodes = _M_nodes->_M_next();
       __node->_M_nxt = nullptr;
       auto& __a = _M_h._M_node_allocator();
       __node_alloc_traits::destroy(__a, __node->_M_valptr());
       try
  {
    __node_alloc_traits::construct(__a, __node->_M_valptr(),
       std::forward<_Arg>(__arg));
  }
       catch(...)
  {
    _M_h._M_deallocate_node_ptr(__node);
    throw;
  }
       return __node;
     }
   return _M_h._M_allocate_node(std::forward<_Arg>(__arg));
 }

    private:
      mutable __node_type* _M_nodes;
      __hashtable_alloc& _M_h;
    };



  template<typename _NodeAlloc>
    struct _AllocNode
    {
    private:
      using __hashtable_alloc = _Hashtable_alloc<_NodeAlloc>;
      using __node_type = typename __hashtable_alloc::__node_type;

    public:
      _AllocNode(__hashtable_alloc& __h)
      : _M_h(__h) { }

      template<typename _Arg>
 __node_type*
 operator()(_Arg&& __arg) const
 { return _M_h._M_allocate_node(std::forward<_Arg>(__arg)); }

    private:
      __hashtable_alloc& _M_h;
    };
# 198 "/usr/local/include/c++/10.0.0/bits/hashtable_policy.h" 3
  template<bool _Cache_hash_code, bool _Constant_iterators, bool _Unique_keys>
    struct _Hashtable_traits
    {
      using __hash_cached = __bool_constant<_Cache_hash_code>;
      using __constant_iterators = __bool_constant<_Constant_iterators>;
      using __unique_keys = __bool_constant<_Unique_keys>;
    };
# 214 "/usr/local/include/c++/10.0.0/bits/hashtable_policy.h" 3
  struct _Hash_node_base
  {
    _Hash_node_base* _M_nxt;

    _Hash_node_base() noexcept : _M_nxt() { }

    _Hash_node_base(_Hash_node_base* __next) noexcept : _M_nxt(__next) { }
  };






  template<typename _Value>
    struct _Hash_node_value_base : _Hash_node_base
    {
      typedef _Value value_type;

      __gnu_cxx::__aligned_buffer<_Value> _M_storage;

      _Value*
      _M_valptr() noexcept
      { return _M_storage._M_ptr(); }

      const _Value*
      _M_valptr() const noexcept
      { return _M_storage._M_ptr(); }

      _Value&
      _M_v() noexcept
      { return *_M_valptr(); }

      const _Value&
      _M_v() const noexcept
      { return *_M_valptr(); }
    };




  template<typename _Value, bool _Cache_hash_code>
    struct _Hash_node;






  template<typename _Value>
    struct _Hash_node<_Value, true> : _Hash_node_value_base<_Value>
    {
      std::size_t _M_hash_code;

      _Hash_node*
      _M_next() const noexcept
      { return static_cast<_Hash_node*>(this->_M_nxt); }
    };






  template<typename _Value>
    struct _Hash_node<_Value, false> : _Hash_node_value_base<_Value>
    {
      _Hash_node*
      _M_next() const noexcept
      { return static_cast<_Hash_node*>(this->_M_nxt); }
    };


  template<typename _Value, bool _Cache_hash_code>
    struct _Node_iterator_base
    {
      using __node_type = _Hash_node<_Value, _Cache_hash_code>;

      __node_type* _M_cur;

      _Node_iterator_base(__node_type* __p) noexcept
      : _M_cur(__p) { }

      void
      _M_incr() noexcept
      { _M_cur = _M_cur->_M_next(); }
    };

  template<typename _Value, bool _Cache_hash_code>
    inline bool
    operator==(const _Node_iterator_base<_Value, _Cache_hash_code>& __x,
        const _Node_iterator_base<_Value, _Cache_hash_code >& __y)
    noexcept
    { return __x._M_cur == __y._M_cur; }

  template<typename _Value, bool _Cache_hash_code>
    inline bool
    operator!=(const _Node_iterator_base<_Value, _Cache_hash_code>& __x,
        const _Node_iterator_base<_Value, _Cache_hash_code>& __y)
    noexcept
    { return __x._M_cur != __y._M_cur; }


  template<typename _Value, bool __constant_iterators, bool __cache>
    struct _Node_iterator
    : public _Node_iterator_base<_Value, __cache>
    {
    private:
      using __base_type = _Node_iterator_base<_Value, __cache>;
      using __node_type = typename __base_type::__node_type;

    public:
      typedef _Value value_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      using pointer = typename std::conditional<__constant_iterators,
      const _Value*, _Value*>::type;

      using reference = typename std::conditional<__constant_iterators,
        const _Value&, _Value&>::type;

      _Node_iterator() noexcept
      : __base_type(0) { }

      explicit
      _Node_iterator(__node_type* __p) noexcept
      : __base_type(__p) { }

      reference
      operator*() const noexcept
      { return this->_M_cur->_M_v(); }

      pointer
      operator->() const noexcept
      { return this->_M_cur->_M_valptr(); }

      _Node_iterator&
      operator++() noexcept
      {
 this->_M_incr();
 return *this;
      }

      _Node_iterator
      operator++(int) noexcept
      {
 _Node_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };


  template<typename _Value, bool __constant_iterators, bool __cache>
    struct _Node_const_iterator
    : public _Node_iterator_base<_Value, __cache>
    {
    private:
      using __base_type = _Node_iterator_base<_Value, __cache>;
      using __node_type = typename __base_type::__node_type;

    public:
      typedef _Value value_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      typedef const _Value* pointer;
      typedef const _Value& reference;

      _Node_const_iterator() noexcept
      : __base_type(0) { }

      explicit
      _Node_const_iterator(__node_type* __p) noexcept
      : __base_type(__p) { }

      _Node_const_iterator(const _Node_iterator<_Value, __constant_iterators,
      __cache>& __x) noexcept
      : __base_type(__x._M_cur) { }

      reference
      operator*() const noexcept
      { return this->_M_cur->_M_v(); }

      pointer
      operator->() const noexcept
      { return this->_M_cur->_M_valptr(); }

      _Node_const_iterator&
      operator++() noexcept
      {
 this->_M_incr();
 return *this;
      }

      _Node_const_iterator
      operator++(int) noexcept
      {
 _Node_const_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };






  struct _Mod_range_hashing
  {
    typedef std::size_t first_argument_type;
    typedef std::size_t second_argument_type;
    typedef std::size_t result_type;

    result_type
    operator()(first_argument_type __num,
        second_argument_type __den) const noexcept
    { return __num % __den; }
  };






  struct _Default_ranged_hash { };



  struct _Prime_rehash_policy
  {
    using __has_load_factor = true_type;

    _Prime_rehash_policy(float __z = 1.0) noexcept
    : _M_max_load_factor(__z), _M_next_resize(0) { }

    float
    max_load_factor() const noexcept
    { return _M_max_load_factor; }


    std::size_t
    _M_next_bkt(std::size_t __n) const;


    std::size_t
    _M_bkt_for_elements(std::size_t __n) const
    { return __builtin_ceill(__n / (long double)_M_max_load_factor); }





    std::pair<bool, std::size_t>
    _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,
     std::size_t __n_ins) const;

    typedef std::size_t _State;

    _State
    _M_state() const
    { return _M_next_resize; }

    void
    _M_reset() noexcept
    { _M_next_resize = 0; }

    void
    _M_reset(_State __state)
    { _M_next_resize = __state; }

    static const std::size_t _S_growth_factor = 2;

    float _M_max_load_factor;
    mutable std::size_t _M_next_resize;
  };


  struct _Mask_range_hashing
  {
    typedef std::size_t first_argument_type;
    typedef std::size_t second_argument_type;
    typedef std::size_t result_type;

    result_type
    operator()(first_argument_type __num,
        second_argument_type __den) const noexcept
    { return __num & (__den - 1); }
  };


  inline std::size_t
  __clp2(std::size_t __n) noexcept
  {

    if (__n < 2)
      return __n;
    const unsigned __lz = sizeof(size_t) > sizeof(long)
      ? __builtin_clzll(__n - 1ull)
      : __builtin_clzl(__n - 1ul);

    return (size_t(1) << (numeric_limits<size_t>::digits - __lz - 1)) << 1;
  }



  struct _Power2_rehash_policy
  {
    using __has_load_factor = true_type;

    _Power2_rehash_policy(float __z = 1.0) noexcept
    : _M_max_load_factor(__z), _M_next_resize(0) { }

    float
    max_load_factor() const noexcept
    { return _M_max_load_factor; }



    std::size_t
    _M_next_bkt(std::size_t __n) noexcept
    {
      if (__n == 0)



 return 1;

      const auto __max_width = std::min<size_t>(sizeof(size_t), 8);
      const auto __max_bkt = size_t(1) << (__max_width * 8 - 1);
      std::size_t __res = __clp2(__n);

      if (__res == 0)
 __res = __max_bkt;
      else if (__res == 1)



 __res = 2;

      if (__res == __max_bkt)



 _M_next_resize = numeric_limits<size_t>::max();
      else
 _M_next_resize
   = __builtin_floorl(__res * (long double)_M_max_load_factor);

      return __res;
    }


    std::size_t
    _M_bkt_for_elements(std::size_t __n) const noexcept
    { return __builtin_ceill(__n / (long double)_M_max_load_factor); }





    std::pair<bool, std::size_t>
    _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,
     std::size_t __n_ins) noexcept
    {
      if (__n_elt + __n_ins > _M_next_resize)
 {



   long double __min_bkts
     = std::max<std::size_t>(__n_elt + __n_ins, _M_next_resize ? 0 : 11)
       / (long double)_M_max_load_factor;
   if (__min_bkts >= __n_bkt)
     return { true,
       _M_next_bkt(std::max<std::size_t>(__builtin_floorl(__min_bkts) + 1,
      __n_bkt * _S_growth_factor)) };

   _M_next_resize
     = __builtin_floorl(__n_bkt * (long double)_M_max_load_factor);
   return { false, 0 };
 }
      else
 return { false, 0 };
    }

    typedef std::size_t _State;

    _State
    _M_state() const noexcept
    { return _M_next_resize; }

    void
    _M_reset() noexcept
    { _M_next_resize = 0; }

    void
    _M_reset(_State __state) noexcept
    { _M_next_resize = __state; }

    static const std::size_t _S_growth_factor = 2;

    float _M_max_load_factor;
    std::size_t _M_next_resize;
  };
# 640 "/usr/local/include/c++/10.0.0/bits/hashtable_policy.h" 3
  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits,
    bool _Unique_keys = _Traits::__unique_keys::value>
    struct _Map_base { };


  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, false>
    {
      using mapped_type = typename std::tuple_element<1, _Pair>::type;
    };


  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>
    {
    private:
      using __hashtable_base = __detail::_Hashtable_base<_Key, _Pair,
        _Select1st,
       _Equal, _H1, _H2, _Hash,
         _Traits>;

      using __hashtable = _Hashtable<_Key, _Pair, _Alloc,
         _Select1st, _Equal,
         _H1, _H2, _Hash, _RehashPolicy, _Traits>;

      using __hash_code = typename __hashtable_base::__hash_code;
      using __node_type = typename __hashtable_base::__node_type;

    public:
      using key_type = typename __hashtable_base::key_type;
      using iterator = typename __hashtable_base::iterator;
      using mapped_type = typename std::tuple_element<1, _Pair>::type;

      mapped_type&
      operator[](const key_type& __k);

      mapped_type&
      operator[](key_type&& __k);



      mapped_type&
      at(const key_type& __k);

      const mapped_type&
      at(const key_type& __k) const;
    };

  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    auto
    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    operator[](const key_type& __k)
    -> mapped_type&
    {
      __hashtable* __h = static_cast<__hashtable*>(this);
      __hash_code __code = __h->_M_hash_code(__k);
      std::size_t __bkt = __h->_M_bucket_index(__k, __code);
      if (__node_type* __node = __h->_M_find_node(__bkt, __k, __code))
 return __node->_M_v().second;

      typename __hashtable::_Scoped_node __node {
 __h,
 std::piecewise_construct,
 std::tuple<const key_type&>(__k),
 std::tuple<>()
      };
      auto __pos
 = __h->_M_insert_unique_node(__k, __bkt, __code, __node._M_node);
      __node._M_node = nullptr;
      return __pos->second;
    }

  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    auto
    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    operator[](key_type&& __k)
    -> mapped_type&
    {
      __hashtable* __h = static_cast<__hashtable*>(this);
      __hash_code __code = __h->_M_hash_code(__k);
      std::size_t __bkt = __h->_M_bucket_index(__k, __code);
      if (__node_type* __node = __h->_M_find_node(__bkt, __k, __code))
 return __node->_M_v().second;

      typename __hashtable::_Scoped_node __node {
 __h,
 std::piecewise_construct,
 std::forward_as_tuple(std::move(__k)),
 std::tuple<>()
      };
      auto __pos
 = __h->_M_insert_unique_node(__k, __bkt, __code, __node._M_node);
      __node._M_node = nullptr;
      return __pos->second;
    }

  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    auto
    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    at(const key_type& __k)
    -> mapped_type&
    {
      __hashtable* __h = static_cast<__hashtable*>(this);
      __hash_code __code = __h->_M_hash_code(__k);
      std::size_t __bkt = __h->_M_bucket_index(__k, __code);
      __node_type* __p = __h->_M_find_node(__bkt, __k, __code);

      if (!__p)
 __throw_out_of_range(("_Map_base::at"));
      return __p->_M_v().second;
    }

  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    auto
    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    at(const key_type& __k) const
    -> const mapped_type&
    {
      const __hashtable* __h = static_cast<const __hashtable*>(this);
      __hash_code __code = __h->_M_hash_code(__k);
      std::size_t __bkt = __h->_M_bucket_index(__k, __code);
      __node_type* __p = __h->_M_find_node(__bkt, __k, __code);

      if (!__p)
 __throw_out_of_range(("_Map_base::at"));
      return __p->_M_v().second;
    }






  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Insert_base
    {
    protected:
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,
         _Equal, _H1, _H2, _Hash,
         _RehashPolicy, _Traits>;

      using __hashtable_base = _Hashtable_base<_Key, _Value, _ExtractKey,
            _Equal, _H1, _H2, _Hash,
            _Traits>;

      using value_type = typename __hashtable_base::value_type;
      using iterator = typename __hashtable_base::iterator;
      using const_iterator = typename __hashtable_base::const_iterator;
      using size_type = typename __hashtable_base::size_type;

      using __unique_keys = typename __hashtable_base::__unique_keys;
      using __ireturn_type = typename __hashtable_base::__ireturn_type;
      using __node_type = _Hash_node<_Value, _Traits::__hash_cached::value>;
      using __node_alloc_type = __alloc_rebind<_Alloc, __node_type>;
      using __node_gen_type = _AllocNode<__node_alloc_type>;

      __hashtable&
      _M_conjure_hashtable()
      { return *(static_cast<__hashtable*>(this)); }

      template<typename _InputIterator, typename _NodeGetter>
 void
 _M_insert_range(_InputIterator __first, _InputIterator __last,
   const _NodeGetter&, true_type);

      template<typename _InputIterator, typename _NodeGetter>
 void
 _M_insert_range(_InputIterator __first, _InputIterator __last,
   const _NodeGetter&, false_type);

    public:
      __ireturn_type
      insert(const value_type& __v)
      {
 __hashtable& __h = _M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(__v, __node_gen, __unique_keys());
      }

      iterator
      insert(const_iterator __hint, const value_type& __v)
      {
 __hashtable& __h = _M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(__hint, __v, __node_gen, __unique_keys());
      }

      void
      insert(initializer_list<value_type> __l)
      { this->insert(__l.begin(), __l.end()); }

      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 {
   __hashtable& __h = _M_conjure_hashtable();
   __node_gen_type __node_gen(__h);
   return _M_insert_range(__first, __last, __node_gen, __unique_keys());
 }
    };

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    template<typename _InputIterator, typename _NodeGetter>
      void
      _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
      _RehashPolicy, _Traits>::
      _M_insert_range(_InputIterator __first, _InputIterator __last,
        const _NodeGetter& __node_gen, true_type)
      {
 size_type __n_elt = __detail::__distance_fw(__first, __last);
 if (__n_elt == 0)
   return;

 __hashtable& __h = _M_conjure_hashtable();
 for (; __first != __last; ++__first)
   {
     if (__h._M_insert(*__first, __node_gen, __unique_keys(),
         __n_elt).second)
       __n_elt = 1;
     else if (__n_elt != 1)
       --__n_elt;
   }
      }

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    template<typename _InputIterator, typename _NodeGetter>
      void
      _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
      _RehashPolicy, _Traits>::
      _M_insert_range(_InputIterator __first, _InputIterator __last,
        const _NodeGetter& __node_gen, false_type)
      {
 using __rehash_type = typename __hashtable::__rehash_type;
 using __rehash_state = typename __hashtable::__rehash_state;
 using pair_type = std::pair<bool, std::size_t>;

 size_type __n_elt = __detail::__distance_fw(__first, __last);
 if (__n_elt == 0)
   return;

 __hashtable& __h = _M_conjure_hashtable();
 __rehash_type& __rehash = __h._M_rehash_policy;
 const __rehash_state& __saved_state = __rehash._M_state();
 pair_type __do_rehash = __rehash._M_need_rehash(__h._M_bucket_count,
       __h._M_element_count,
       __n_elt);

 if (__do_rehash.first)
   __h._M_rehash(__do_rehash.second, __saved_state);

 for (; __first != __last; ++__first)
   __h._M_insert(*__first, __node_gen, __unique_keys());
      }







  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits,
    bool _Constant_iterators = _Traits::__constant_iterators::value>
    struct _Insert;


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
     _RehashPolicy, _Traits, true>
    : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      _H1, _H2, _Hash, _RehashPolicy, _Traits>
    {
      using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,
     _Equal, _H1, _H2, _Hash,
     _RehashPolicy, _Traits>;

      using __hashtable_base = _Hashtable_base<_Key, _Value, _ExtractKey,
            _Equal, _H1, _H2, _Hash,
            _Traits>;

      using value_type = typename __base_type::value_type;
      using iterator = typename __base_type::iterator;
      using const_iterator = typename __base_type::const_iterator;

      using __unique_keys = typename __base_type::__unique_keys;
      using __ireturn_type = typename __hashtable_base::__ireturn_type;
      using __hashtable = typename __base_type::__hashtable;
      using __node_gen_type = typename __base_type::__node_gen_type;

      using __base_type::insert;

      __ireturn_type
      insert(value_type&& __v)
      {
 __hashtable& __h = this->_M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(std::move(__v), __node_gen, __unique_keys());
      }

      iterator
      insert(const_iterator __hint, value_type&& __v)
      {
 __hashtable& __h = this->_M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(__hint, std::move(__v), __node_gen,
        __unique_keys());
      }
    };


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
     _RehashPolicy, _Traits, false>
    : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      _H1, _H2, _Hash, _RehashPolicy, _Traits>
    {
      using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,
           _Equal, _H1, _H2, _Hash,
           _RehashPolicy, _Traits>;
      using value_type = typename __base_type::value_type;
      using iterator = typename __base_type::iterator;
      using const_iterator = typename __base_type::const_iterator;

      using __unique_keys = typename __base_type::__unique_keys;
      using __hashtable = typename __base_type::__hashtable;
      using __ireturn_type = typename __base_type::__ireturn_type;

      using __base_type::insert;

      template<typename _Pair>
 using __is_cons = std::is_constructible<value_type, _Pair&&>;

      template<typename _Pair>
 using _IFcons = std::enable_if<__is_cons<_Pair>::value>;

      template<typename _Pair>
 using _IFconsp = typename _IFcons<_Pair>::type;

      template<typename _Pair, typename = _IFconsp<_Pair>>
 __ireturn_type
 insert(_Pair&& __v)
 {
   __hashtable& __h = this->_M_conjure_hashtable();
   return __h._M_emplace(__unique_keys(), std::forward<_Pair>(__v));
 }

      template<typename _Pair, typename = _IFconsp<_Pair>>
 iterator
 insert(const_iterator __hint, _Pair&& __v)
 {
   __hashtable& __h = this->_M_conjure_hashtable();
   return __h._M_emplace(__hint, __unique_keys(),
    std::forward<_Pair>(__v));
 }
   };

  template<typename _Policy>
    using __has_load_factor = typename _Policy::__has_load_factor;







  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits,
    typename =
      __detected_or_t<false_type, __has_load_factor, _RehashPolicy>>
    struct _Rehash_base;


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits,
        false_type>
    {
    };


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits,
   true_type>
    {
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,
         _Equal, _H1, _H2, _Hash,
         _RehashPolicy, _Traits>;

      float
      max_load_factor() const noexcept
      {
 const __hashtable* __this = static_cast<const __hashtable*>(this);
 return __this->__rehash_policy().max_load_factor();
      }

      void
      max_load_factor(float __z)
      {
 __hashtable* __this = static_cast<__hashtable*>(this);
 __this->__rehash_policy(_RehashPolicy(__z));
      }

      void
      reserve(std::size_t __n)
      {
 __hashtable* __this = static_cast<__hashtable*>(this);
 __this->rehash(__this->__rehash_policy()._M_bkt_for_elements(__n));
      }
    };







  template<int _Nm, typename _Tp,
    bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>
    struct _Hashtable_ebo_helper;


  template<int _Nm, typename _Tp>
    struct _Hashtable_ebo_helper<_Nm, _Tp, true>
    : private _Tp
    {
      _Hashtable_ebo_helper() = default;

      template<typename _OtherTp>
 _Hashtable_ebo_helper(_OtherTp&& __tp)
 : _Tp(std::forward<_OtherTp>(__tp))
 { }

      const _Tp& _M_cget() const { return static_cast<const _Tp&>(*this); }
      _Tp& _M_get() { return static_cast<_Tp&>(*this); }
    };


  template<int _Nm, typename _Tp>
    struct _Hashtable_ebo_helper<_Nm, _Tp, false>
    {
      _Hashtable_ebo_helper() = default;

      template<typename _OtherTp>
 _Hashtable_ebo_helper(_OtherTp&& __tp)
 : _M_tp(std::forward<_OtherTp>(__tp))
 { }

      const _Tp& _M_cget() const { return _M_tp; }
      _Tp& _M_get() { return _M_tp; }

    private:
      _Tp _M_tp;
    };







  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash,
    bool __cache_hash_code>
    struct _Local_iterator_base;
# 1172 "/usr/local/include/c++/10.0.0/bits/hashtable_policy.h" 3
  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash,
    bool __cache_hash_code>
    struct _Hash_code_base;



  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, false>
    : private _Hashtable_ebo_helper<0, _ExtractKey>,
      private _Hashtable_ebo_helper<1, _Hash>
    {
    private:
      using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;
      using __ebo_hash = _Hashtable_ebo_helper<1, _Hash>;

    protected:
      typedef void* __hash_code;
      typedef _Hash_node<_Value, false> __node_type;



      _Hash_code_base() = default;

      _Hash_code_base(const _ExtractKey& __ex, const _H1&, const _H2&,
        const _Hash& __h)
      : __ebo_extract_key(__ex), __ebo_hash(__h) { }

      __hash_code
      _M_hash_code(const _Key& __key) const
      { return 0; }

      std::size_t
      _M_bucket_index(const _Key& __k, __hash_code,
        std::size_t __bkt_count) const
      { return _M_ranged_hash()(__k, __bkt_count); }

      std::size_t
      _M_bucket_index(const __node_type* __p, std::size_t __bkt_count) const
 noexcept( noexcept(declval<const _Hash&>()(declval<const _Key&>(),
         (std::size_t)0)) )
      { return _M_ranged_hash()(_M_extract()(__p->_M_v()), __bkt_count); }

      void
      _M_store_code(__node_type*, __hash_code) const
      { }

      void
      _M_copy_code(__node_type*, const __node_type*) const
      { }

      void
      _M_swap(_Hash_code_base& __x)
      {
 std::swap(__ebo_extract_key::_M_get(),
    __x.__ebo_extract_key::_M_get());
 std::swap(__ebo_hash::_M_get(), __x.__ebo_hash::_M_get());
      }

      const _ExtractKey&
      _M_extract() const { return __ebo_extract_key::_M_cget(); }

      const _Hash&
      _M_ranged_hash() const { return __ebo_hash::_M_cget(); }
    };







  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, true>;




  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2>
    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,
      _Default_ranged_hash, false>
    : private _Hashtable_ebo_helper<0, _ExtractKey>,
      private _Hashtable_ebo_helper<1, _H1>,
      private _Hashtable_ebo_helper<2, _H2>
    {
    private:
      using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;
      using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;
      using __ebo_h2 = _Hashtable_ebo_helper<2, _H2>;


      friend struct _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2,
      _Default_ranged_hash, false>;

    public:
      typedef _H1 hasher;

      hasher
      hash_function() const
      { return _M_h1(); }

    protected:
      typedef std::size_t __hash_code;
      typedef _Hash_node<_Value, false> __node_type;



      _Hash_code_base() = default;

      _Hash_code_base(const _ExtractKey& __ex,
        const _H1& __h1, const _H2& __h2,
        const _Default_ranged_hash&)
      : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) { }

      __hash_code
      _M_hash_code(const _Key& __k) const
      {
 static_assert(__is_invocable<const _H1&, const _Key&>{},
     "hash function must be invocable with an argument of key type");
 return _M_h1()(__k);
      }

      std::size_t
      _M_bucket_index(const _Key&, __hash_code __c,
        std::size_t __bkt_count) const
      { return _M_h2()(__c, __bkt_count); }

      std::size_t
      _M_bucket_index(const __node_type* __p, std::size_t __bkt_count) const
 noexcept( noexcept(declval<const _H1&>()(declval<const _Key&>()))
    && noexcept(declval<const _H2&>()((__hash_code)0,
          (std::size_t)0)) )
      { return _M_h2()(_M_h1()(_M_extract()(__p->_M_v())), __bkt_count); }

      void
      _M_store_code(__node_type*, __hash_code) const
      { }

      void
      _M_copy_code(__node_type*, const __node_type*) const
      { }

      void
      _M_swap(_Hash_code_base& __x)
      {
 std::swap(__ebo_extract_key::_M_get(),
    __x.__ebo_extract_key::_M_get());
 std::swap(__ebo_h1::_M_get(), __x.__ebo_h1::_M_get());
 std::swap(__ebo_h2::_M_get(), __x.__ebo_h2::_M_get());
      }

      const _ExtractKey&
      _M_extract() const { return __ebo_extract_key::_M_cget(); }

      const _H1&
      _M_h1() const { return __ebo_h1::_M_cget(); }

      const _H2&
      _M_h2() const { return __ebo_h2::_M_cget(); }
    };




  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2>
    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,
      _Default_ranged_hash, true>
    : private _Hashtable_ebo_helper<0, _ExtractKey>,
      private _Hashtable_ebo_helper<1, _H1>,
      private _Hashtable_ebo_helper<2, _H2>
    {
    private:

      friend struct _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2,
      _Default_ranged_hash, true>;

      using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;
      using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;
      using __ebo_h2 = _Hashtable_ebo_helper<2, _H2>;

    public:
      typedef _H1 hasher;

      hasher
      hash_function() const
      { return _M_h1(); }

    protected:
      typedef std::size_t __hash_code;
      typedef _Hash_node<_Value, true> __node_type;


      _Hash_code_base() = default;
      _Hash_code_base(const _ExtractKey& __ex,
        const _H1& __h1, const _H2& __h2,
        const _Default_ranged_hash&)
      : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) { }

      __hash_code
      _M_hash_code(const _Key& __k) const
      {
 static_assert(__is_invocable<const _H1&, const _Key&>{},
     "hash function must be invocable with an argument of key type");
 return _M_h1()(__k);
      }

      std::size_t
      _M_bucket_index(const _Key&, __hash_code __c,
        std::size_t __bkt_count) const
      { return _M_h2()(__c, __bkt_count); }

      std::size_t
      _M_bucket_index(const __node_type* __p, std::size_t __bkt_count) const
 noexcept( noexcept(declval<const _H2&>()((__hash_code)0,
       (std::size_t)0)) )
      { return _M_h2()(__p->_M_hash_code, __bkt_count); }

      void
      _M_store_code(__node_type* __n, __hash_code __c) const
      { __n->_M_hash_code = __c; }

      void
      _M_copy_code(__node_type* __to, const __node_type* __from) const
      { __to->_M_hash_code = __from->_M_hash_code; }

      void
      _M_swap(_Hash_code_base& __x)
      {
 std::swap(__ebo_extract_key::_M_get(),
    __x.__ebo_extract_key::_M_get());
 std::swap(__ebo_h1::_M_get(), __x.__ebo_h1::_M_get());
 std::swap(__ebo_h2::_M_get(), __x.__ebo_h2::_M_get());
      }

      const _ExtractKey&
      _M_extract() const { return __ebo_extract_key::_M_cget(); }

      const _H1&
      _M_h1() const { return __ebo_h1::_M_cget(); }

      const _H2&
      _M_h2() const { return __ebo_h2::_M_cget(); }
    };


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    struct _Local_iterator_base<_Key, _Value, _ExtractKey,
    _H1, _H2, _Hash, true>
    : private _Hashtable_ebo_helper<0, _H2>
    {
    protected:
      using __base_type = _Hashtable_ebo_helper<0, _H2>;
      using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
            _H1, _H2, _Hash, true>;

      _Local_iterator_base() = default;
      _Local_iterator_base(const __hash_code_base& __base,
      _Hash_node<_Value, true>* __p,
      std::size_t __bkt, std::size_t __bkt_count)
      : __base_type(__base._M_h2()),
 _M_cur(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count) { }

      void
      _M_incr()
      {
 _M_cur = _M_cur->_M_next();
 if (_M_cur)
   {
     std::size_t __bkt
       = __base_type::_M_get()(_M_cur->_M_hash_code,
        _M_bucket_count);
     if (__bkt != _M_bucket)
       _M_cur = nullptr;
   }
      }

      _Hash_node<_Value, true>* _M_cur;
      std::size_t _M_bucket;
      std::size_t _M_bucket_count;

    public:
      const void*
      _M_curr() const { return _M_cur; }

      std::size_t
      _M_get_bucket() const { return _M_bucket; }
    };





  template<typename _Tp, bool _IsEmpty = std::is_empty<_Tp>::value>
    struct _Hash_code_storage
    {
      __gnu_cxx::__aligned_buffer<_Tp> _M_storage;

      _Tp*
      _M_h() { return _M_storage._M_ptr(); }

      const _Tp*
      _M_h() const { return _M_storage._M_ptr(); }
    };


  template<typename _Tp>
    struct _Hash_code_storage<_Tp, true>
    {
      static_assert( std::is_empty<_Tp>::value, "Type must be empty" );



      _Tp*
      _M_h() { return reinterpret_cast<_Tp*>(this); }

      const _Tp*
      _M_h() const { return reinterpret_cast<const _Tp*>(this); }
    };

  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    using __hash_code_for_local_iter
      = _Hash_code_storage<_Hash_code_base<_Key, _Value, _ExtractKey,
        _H1, _H2, _Hash, false>>;


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    struct _Local_iterator_base<_Key, _Value, _ExtractKey,
    _H1, _H2, _Hash, false>
    : __hash_code_for_local_iter<_Key, _Value, _ExtractKey, _H1, _H2, _Hash>
    {
    protected:
      using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
            _H1, _H2, _Hash, false>;

      _Local_iterator_base() : _M_bucket_count(-1) { }

      _Local_iterator_base(const __hash_code_base& __base,
      _Hash_node<_Value, false>* __p,
      std::size_t __bkt, std::size_t __bkt_count)
      : _M_cur(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count)
      { _M_init(__base); }

      ~_Local_iterator_base()
      {
 if (_M_bucket_count != -1)
   _M_destroy();
      }

      _Local_iterator_base(const _Local_iterator_base& __iter)
      : _M_cur(__iter._M_cur), _M_bucket(__iter._M_bucket),
        _M_bucket_count(__iter._M_bucket_count)
      {
 if (_M_bucket_count != -1)
   _M_init(*__iter._M_h());
      }

      _Local_iterator_base&
      operator=(const _Local_iterator_base& __iter)
      {
 if (_M_bucket_count != -1)
   _M_destroy();
 _M_cur = __iter._M_cur;
 _M_bucket = __iter._M_bucket;
 _M_bucket_count = __iter._M_bucket_count;
 if (_M_bucket_count != -1)
   _M_init(*__iter._M_h());
 return *this;
      }

      void
      _M_incr()
      {
 _M_cur = _M_cur->_M_next();
 if (_M_cur)
   {
     std::size_t __bkt = this->_M_h()->_M_bucket_index(_M_cur,
             _M_bucket_count);
     if (__bkt != _M_bucket)
       _M_cur = nullptr;
   }
      }

      _Hash_node<_Value, false>* _M_cur;
      std::size_t _M_bucket;
      std::size_t _M_bucket_count;

      void
      _M_init(const __hash_code_base& __base)
      { ::new(this->_M_h()) __hash_code_base(__base); }

      void
      _M_destroy() { this->_M_h()->~__hash_code_base(); }

    public:
      const void*
      _M_curr() const { return _M_cur; }

      std::size_t
      _M_get_bucket() const { return _M_bucket; }
    };

  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash, bool __cache>
    inline bool
    operator==(const _Local_iterator_base<_Key, _Value, _ExtractKey,
       _H1, _H2, _Hash, __cache>& __x,
        const _Local_iterator_base<_Key, _Value, _ExtractKey,
       _H1, _H2, _Hash, __cache>& __y)
    { return __x._M_curr() == __y._M_curr(); }

  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash, bool __cache>
    inline bool
    operator!=(const _Local_iterator_base<_Key, _Value, _ExtractKey,
       _H1, _H2, _Hash, __cache>& __x,
        const _Local_iterator_base<_Key, _Value, _ExtractKey,
       _H1, _H2, _Hash, __cache>& __y)
    { return __x._M_curr() != __y._M_curr(); }


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash,
    bool __constant_iterators, bool __cache>
    struct _Local_iterator
    : public _Local_iterator_base<_Key, _Value, _ExtractKey,
      _H1, _H2, _Hash, __cache>
    {
    private:
      using __base_type = _Local_iterator_base<_Key, _Value, _ExtractKey,
            _H1, _H2, _Hash, __cache>;
      using __hash_code_base = typename __base_type::__hash_code_base;
    public:
      typedef _Value value_type;
      typedef typename std::conditional<__constant_iterators,
     const _Value*, _Value*>::type
             pointer;
      typedef typename std::conditional<__constant_iterators,
     const _Value&, _Value&>::type
             reference;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      _Local_iterator() = default;

      _Local_iterator(const __hash_code_base& __base,
        _Hash_node<_Value, __cache>* __n,
        std::size_t __bkt, std::size_t __bkt_count)
      : __base_type(__base, __n, __bkt, __bkt_count)
      { }

      reference
      operator*() const
      { return this->_M_cur->_M_v(); }

      pointer
      operator->() const
      { return this->_M_cur->_M_valptr(); }

      _Local_iterator&
      operator++()
      {
 this->_M_incr();
 return *this;
      }

      _Local_iterator
      operator++(int)
      {
 _Local_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash,
    bool __constant_iterators, bool __cache>
    struct _Local_const_iterator
    : public _Local_iterator_base<_Key, _Value, _ExtractKey,
      _H1, _H2, _Hash, __cache>
    {
    private:
      using __base_type = _Local_iterator_base<_Key, _Value, _ExtractKey,
            _H1, _H2, _Hash, __cache>;
      using __hash_code_base = typename __base_type::__hash_code_base;

    public:
      typedef _Value value_type;
      typedef const _Value* pointer;
      typedef const _Value& reference;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      _Local_const_iterator() = default;

      _Local_const_iterator(const __hash_code_base& __base,
       _Hash_node<_Value, __cache>* __n,
       std::size_t __bkt, std::size_t __bkt_count)
      : __base_type(__base, __n, __bkt, __bkt_count)
      { }

      _Local_const_iterator(const _Local_iterator<_Key, _Value, _ExtractKey,
        _H1, _H2, _Hash,
        __constant_iterators,
        __cache>& __x)
      : __base_type(__x)
      { }

      reference
      operator*() const
      { return this->_M_cur->_M_v(); }

      pointer
      operator->() const
      { return this->_M_cur->_M_valptr(); }

      _Local_const_iterator&
      operator++()
      {
 this->_M_incr();
 return *this;
      }

      _Local_const_iterator
      operator++(int)
      {
 _Local_const_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };
# 1722 "/usr/local/include/c++/10.0.0/bits/hashtable_policy.h" 3
  template<typename _Key, typename _Value,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _Traits>
  struct _Hashtable_base
  : public _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash,
      _Traits::__hash_cached::value>,
    private _Hashtable_ebo_helper<0, _Equal>
  {
  public:
    typedef _Key key_type;
    typedef _Value value_type;
    typedef _Equal key_equal;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;

    using __traits_type = _Traits;
    using __hash_cached = typename __traits_type::__hash_cached;
    using __constant_iterators = typename __traits_type::__constant_iterators;
    using __unique_keys = typename __traits_type::__unique_keys;

    using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
          _H1, _H2, _Hash,
          __hash_cached::value>;

    using __hash_code = typename __hash_code_base::__hash_code;
    using __node_type = typename __hash_code_base::__node_type;

    using iterator = __detail::_Node_iterator<value_type,
           __constant_iterators::value,
           __hash_cached::value>;

    using const_iterator = __detail::_Node_const_iterator<value_type,
         __constant_iterators::value,
         __hash_cached::value>;

    using local_iterator = __detail::_Local_iterator<key_type, value_type,
        _ExtractKey, _H1, _H2, _Hash,
        __constant_iterators::value,
           __hash_cached::value>;

    using const_local_iterator = __detail::_Local_const_iterator<key_type,
         value_type,
     _ExtractKey, _H1, _H2, _Hash,
     __constant_iterators::value,
     __hash_cached::value>;

    using __ireturn_type = typename std::conditional<__unique_keys::value,
           std::pair<iterator, bool>,
           iterator>::type;
  private:
    using _EqualEBO = _Hashtable_ebo_helper<0, _Equal>;

    template<typename _NodeT>
      struct _Equal_hash_code
      {
       static bool
       _S_equals(__hash_code, const _NodeT&)
       { return true; }
      };

    template<typename _Ptr2>
      struct _Equal_hash_code<_Hash_node<_Ptr2, true>>
      {
       static bool
       _S_equals(__hash_code __c, const _Hash_node<_Ptr2, true>& __n)
       { return __c == __n._M_hash_code; }
      };

  protected:
    _Hashtable_base() = default;
    _Hashtable_base(const _ExtractKey& __ex, const _H1& __h1, const _H2& __h2,
      const _Hash& __hash, const _Equal& __eq)
    : __hash_code_base(__ex, __h1, __h2, __hash), _EqualEBO(__eq)
    { }

    bool
    _M_equals(const _Key& __k, __hash_code __c, __node_type* __n) const
    {
      static_assert(__is_invocable<const _Equal&, const _Key&, const _Key&>{},
   "key equality predicate must be invocable with two arguments of "
   "key type");
      return _Equal_hash_code<__node_type>::_S_equals(__c, *__n)
 && _M_eq()(__k, this->_M_extract()(__n->_M_v()));
    }

    void
    _M_swap(_Hashtable_base& __x)
    {
      __hash_code_base::_M_swap(__x);
      std::swap(_EqualEBO::_M_get(), __x._EqualEBO::_M_get());
    }

    const _Equal&
    _M_eq() const { return _EqualEBO::_M_cget(); }
  };






  struct _Equality_base
  {
  protected:
    template<typename _Uiterator>
      static bool
      _S_is_permutation(_Uiterator, _Uiterator, _Uiterator);
  };


  template<typename _Uiterator>
    bool
    _Equality_base::
    _S_is_permutation(_Uiterator __first1, _Uiterator __last1,
        _Uiterator __first2)
    {
      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!(*__first1 == *__first2))
   break;

      if (__first1 == __last1)
 return true;

      _Uiterator __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));

      for (_Uiterator __it1 = __first1; __it1 != __last1; ++__it1)
 {
   _Uiterator __tmp = __first1;
   while (__tmp != __it1 && !bool(*__tmp == *__it1))
     ++__tmp;


   if (__tmp != __it1)
     continue;

   std::ptrdiff_t __n2 = 0;
   for (__tmp = __first2; __tmp != __last2; ++__tmp)
     if (*__tmp == *__it1)
       ++__n2;

   if (!__n2)
     return false;

   std::ptrdiff_t __n1 = 0;
   for (__tmp = __it1; __tmp != __last1; ++__tmp)
     if (*__tmp == *__it1)
       ++__n1;

   if (__n1 != __n2)
     return false;
 }
      return true;
    }
# 1885 "/usr/local/include/c++/10.0.0/bits/hashtable_policy.h" 3
  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits,
    bool _Unique_keys = _Traits::__unique_keys::value>
    struct _Equality;


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>
    {
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         _H1, _H2, _Hash, _RehashPolicy, _Traits>;

      bool
      _M_equal(const __hashtable&) const;
    };

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    bool
    _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    _M_equal(const __hashtable& __other) const
    {
      const __hashtable* __this = static_cast<const __hashtable*>(this);

      if (__this->size() != __other.size())
 return false;

      for (auto __itx = __this->begin(); __itx != __this->end(); ++__itx)
 {
   const auto __ity = __other.find(_ExtractKey()(*__itx));
   if (__ity == __other.end() || !bool(*__ity == *__itx))
     return false;
 }
      return true;
    }


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, false>
    : public _Equality_base
    {
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         _H1, _H2, _Hash, _RehashPolicy, _Traits>;

      bool
      _M_equal(const __hashtable&) const;
    };

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    bool
    _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, false>::
    _M_equal(const __hashtable& __other) const
    {
      const __hashtable* __this = static_cast<const __hashtable*>(this);

      if (__this->size() != __other.size())
 return false;

      for (auto __itx = __this->begin(); __itx != __this->end();)
 {
   const auto __xrange = __this->equal_range(_ExtractKey()(*__itx));
   const auto __yrange = __other.equal_range(_ExtractKey()(*__itx));

   if (std::distance(__xrange.first, __xrange.second)
       != std::distance(__yrange.first, __yrange.second))
     return false;

   if (!_S_is_permutation(__xrange.first, __xrange.second,
     __yrange.first))
     return false;

   __itx = __xrange.second;
 }
      return true;
    }





  template<typename _NodeAlloc>
    struct _Hashtable_alloc : private _Hashtable_ebo_helper<0, _NodeAlloc>
    {
    private:
      using __ebo_node_alloc = _Hashtable_ebo_helper<0, _NodeAlloc>;
    public:
      using __node_type = typename _NodeAlloc::value_type;
      using __node_alloc_type = _NodeAlloc;

      using __node_alloc_traits = __gnu_cxx::__alloc_traits<__node_alloc_type>;

      using __value_alloc_traits = typename __node_alloc_traits::template
 rebind_traits<typename __node_type::value_type>;

      using __node_base = __detail::_Hash_node_base;
      using __bucket_type = __node_base*;
      using __bucket_alloc_type =
 __alloc_rebind<__node_alloc_type, __bucket_type>;
      using __bucket_alloc_traits = std::allocator_traits<__bucket_alloc_type>;

      _Hashtable_alloc() = default;
      _Hashtable_alloc(const _Hashtable_alloc&) = default;
      _Hashtable_alloc(_Hashtable_alloc&&) = default;

      template<typename _Alloc>
 _Hashtable_alloc(_Alloc&& __a)
 : __ebo_node_alloc(std::forward<_Alloc>(__a))
 { }

      __node_alloc_type&
      _M_node_allocator()
      { return __ebo_node_alloc::_M_get(); }

      const __node_alloc_type&
      _M_node_allocator() const
      { return __ebo_node_alloc::_M_cget(); }


      template<typename... _Args>
 __node_type*
 _M_allocate_node(_Args&&... __args);


      void
      _M_deallocate_node(__node_type* __n);


      void
      _M_deallocate_node_ptr(__node_type* __n);



      void
      _M_deallocate_nodes(__node_type* __n);

      __bucket_type*
      _M_allocate_buckets(std::size_t __bkt_count);

      void
      _M_deallocate_buckets(__bucket_type*, std::size_t __bkt_count);
    };



  template<typename _NodeAlloc>
    template<typename... _Args>
      auto
      _Hashtable_alloc<_NodeAlloc>::_M_allocate_node(_Args&&... __args)
      -> __node_type*
      {
 auto __nptr = __node_alloc_traits::allocate(_M_node_allocator(), 1);
 __node_type* __n = std::__to_address(__nptr);
 try
   {
     ::new ((void*)__n) __node_type;
     __node_alloc_traits::construct(_M_node_allocator(),
        __n->_M_valptr(),
        std::forward<_Args>(__args)...);
     return __n;
   }
 catch(...)
   {
     __node_alloc_traits::deallocate(_M_node_allocator(), __nptr, 1);
     throw;
   }
      }

  template<typename _NodeAlloc>
    void
    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node(__node_type* __n)
    {
      __node_alloc_traits::destroy(_M_node_allocator(), __n->_M_valptr());
      _M_deallocate_node_ptr(__n);
    }

  template<typename _NodeAlloc>
    void
    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node_ptr(__node_type* __n)
    {
      typedef typename __node_alloc_traits::pointer _Ptr;
      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__n);
      __n->~__node_type();
      __node_alloc_traits::deallocate(_M_node_allocator(), __ptr, 1);
    }

  template<typename _NodeAlloc>
    void
    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_nodes(__node_type* __n)
    {
      while (__n)
 {
   __node_type* __tmp = __n;
   __n = __n->_M_next();
   _M_deallocate_node(__tmp);
 }
    }

  template<typename _NodeAlloc>
    typename _Hashtable_alloc<_NodeAlloc>::__bucket_type*
    _Hashtable_alloc<_NodeAlloc>::_M_allocate_buckets(std::size_t __bkt_count)
    {
      __bucket_alloc_type __alloc(_M_node_allocator());

      auto __ptr = __bucket_alloc_traits::allocate(__alloc, __bkt_count);
      __bucket_type* __p = std::__to_address(__ptr);
      __builtin_memset(__p, 0, __bkt_count * sizeof(__bucket_type));
      return __p;
    }

  template<typename _NodeAlloc>
    void
    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_buckets(__bucket_type* __bkts,
       std::size_t __bkt_count)
    {
      typedef typename __bucket_alloc_traits::pointer _Ptr;
      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__bkts);
      __bucket_alloc_type __alloc(_M_node_allocator());
      __bucket_alloc_traits::deallocate(__alloc, __ptr, __bkt_count);
    }


}

}
# 36 "/usr/local/include/c++/10.0.0/bits/hashtable.h" 2 3

# 1 "/usr/local/include/c++/10.0.0/bits/node_handle.h" 1 3
# 34 "/usr/local/include/c++/10.0.0/bits/node_handle.h" 3
       
# 35 "/usr/local/include/c++/10.0.0/bits/node_handle.h" 3
# 43 "/usr/local/include/c++/10.0.0/bits/node_handle.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Val, typename _NodeAlloc>
    class _Node_handle_common
    {
      using _AllocTraits = allocator_traits<_NodeAlloc>;

    public:
      using allocator_type = __alloc_rebind<_NodeAlloc, _Val>;

      allocator_type
      get_allocator() const noexcept
      {
 ;
 return allocator_type(*_M_alloc);
      }

      explicit operator bool() const noexcept { return _M_ptr != nullptr; }

      [[nodiscard]] bool empty() const noexcept { return _M_ptr == nullptr; }

    protected:
      constexpr _Node_handle_common() noexcept : _M_ptr(), _M_alloc() {}

      ~_Node_handle_common() { _M_destroy(); }

      _Node_handle_common(_Node_handle_common&& __nh) noexcept
      : _M_ptr(__nh._M_ptr), _M_alloc(std::move(__nh._M_alloc))
      {
 __nh._M_ptr = nullptr;
 __nh._M_alloc = nullopt;
      }

      _Node_handle_common&
      operator=(_Node_handle_common&& __nh) noexcept
      {
 _M_destroy();
 _M_ptr = __nh._M_ptr;
 if constexpr (is_move_assignable_v<_NodeAlloc>)
   {
     if (_AllocTraits::propagate_on_container_move_assignment::value
  || !this->_M_alloc)
       this->_M_alloc = std::move(__nh._M_alloc);
     else
       {
  ;
       }
   }
 else
   {
     ;
   }
 __nh._M_ptr = nullptr;
 __nh._M_alloc = nullopt;
 return *this;
      }

      _Node_handle_common(typename _AllocTraits::pointer __ptr,
     const _NodeAlloc& __alloc)
      : _M_ptr(__ptr), _M_alloc(__alloc) { }

      void
      _M_swap(_Node_handle_common& __nh) noexcept
      {
 using std::swap;
 swap(_M_ptr, __nh._M_ptr);
 if (_AllocTraits::propagate_on_container_swap::value
     || !_M_alloc || !__nh._M_alloc)
   _M_alloc.swap(__nh._M_alloc);
 else
   {
     ;
   }
      }

    private:
      void
      _M_destroy() noexcept
      {
 if (_M_ptr != nullptr)
   {
     allocator_type __alloc(*_M_alloc);
     allocator_traits<allocator_type>::destroy(__alloc,
            _M_ptr->_M_valptr());
     _AllocTraits::deallocate(*_M_alloc, _M_ptr, 1);
   }
      }

    protected:
      typename _AllocTraits::pointer _M_ptr;
    private:
      optional<_NodeAlloc> _M_alloc;

      template<typename _Key2, typename _Value2, typename _KeyOfValue,
        typename _Compare, typename _ValueAlloc>
 friend class _Rb_tree;
    };


  template<typename _Key, typename _Value, typename _NodeAlloc>
    class _Node_handle : public _Node_handle_common<_Value, _NodeAlloc>
    {
    public:
      constexpr _Node_handle() noexcept = default;
      ~_Node_handle() = default;
      _Node_handle(_Node_handle&&) noexcept = default;

      _Node_handle&
      operator=(_Node_handle&&) noexcept = default;

      using key_type = _Key;
      using mapped_type = typename _Value::second_type;

      key_type&
      key() const noexcept
      {
 ;
 return *_M_pkey;
      }

      mapped_type&
      mapped() const noexcept
      {
 ;
 return *_M_pmapped;
      }

      void
      swap(_Node_handle& __nh) noexcept
      {
 this->_M_swap(__nh);
 using std::swap;
 swap(_M_pkey, __nh._M_pkey);
 swap(_M_pmapped, __nh._M_pmapped);
      }

      friend void
      swap(_Node_handle& __x, _Node_handle& __y)
      noexcept(noexcept(__x.swap(__y)))
      { __x.swap(__y); }

    private:
      using _AllocTraits = allocator_traits<_NodeAlloc>;

      _Node_handle(typename _AllocTraits::pointer __ptr,
     const _NodeAlloc& __alloc)
      : _Node_handle_common<_Value, _NodeAlloc>(__ptr, __alloc)
      {
 if (__ptr)
   {
     auto& __key = const_cast<_Key&>(__ptr->_M_valptr()->first);
     _M_pkey = _S_pointer_to(__key);
     _M_pmapped = _S_pointer_to(__ptr->_M_valptr()->second);
   }
 else
   {
     _M_pkey = nullptr;
     _M_pmapped = nullptr;
   }
      }

      template<typename _Tp>
 using __pointer
   = __ptr_rebind<typename _AllocTraits::pointer,
    remove_reference_t<_Tp>>;

      __pointer<_Key> _M_pkey = nullptr;
      __pointer<typename _Value::second_type> _M_pmapped = nullptr;

      template<typename _Tp>
 __pointer<_Tp>
 _S_pointer_to(_Tp& __obj)
 { return pointer_traits<__pointer<_Tp>>::pointer_to(__obj); }

      const key_type&
      _M_key() const noexcept { return key(); }

      template<typename _Key2, typename _Value2, typename _KeyOfValue,
        typename _Compare, typename _ValueAlloc>
 friend class _Rb_tree;

      template<typename _Key2, typename _Value2, typename _ValueAlloc,
        typename _ExtractKey, typename _Equal,
        typename _H1, typename _H2, typename _Hash,
        typename _RehashPolicy, typename _Traits>
 friend class _Hashtable;
    };


  template<typename _Value, typename _NodeAlloc>
    class _Node_handle<_Value, _Value, _NodeAlloc>
    : public _Node_handle_common<_Value, _NodeAlloc>
    {
    public:
      constexpr _Node_handle() noexcept = default;
      ~_Node_handle() = default;
      _Node_handle(_Node_handle&&) noexcept = default;

      _Node_handle&
      operator=(_Node_handle&&) noexcept = default;

      using value_type = _Value;

      value_type&
      value() const noexcept
      {
 ;
 return *this->_M_ptr->_M_valptr();
      }

      void
      swap(_Node_handle& __nh) noexcept
      { this->_M_swap(__nh); }

      friend void
      swap(_Node_handle& __x, _Node_handle& __y)
      noexcept(noexcept(__x.swap(__y)))
      { __x.swap(__y); }

    private:
      using _AllocTraits = allocator_traits<_NodeAlloc>;

      _Node_handle(typename _AllocTraits::pointer __ptr,
     const _NodeAlloc& __alloc)
      : _Node_handle_common<_Value, _NodeAlloc>(__ptr, __alloc) { }

      const value_type&
      _M_key() const noexcept { return value(); }

      template<typename _Key, typename _Val, typename _KeyOfValue,
        typename _Compare, typename _Alloc>
 friend class _Rb_tree;

      template<typename _Key2, typename _Value2, typename _ValueAlloc,
        typename _ExtractKey, typename _Equal,
        typename _H1, typename _H2, typename _Hash,
        typename _RehashPolicy, typename _Traits>
 friend class _Hashtable;
    };


  template<typename _Iterator, typename _NodeHandle>
    struct _Node_insert_return
    {
      _Iterator position = _Iterator();
      bool inserted = false;
      _NodeHandle node;
    };


}
# 38 "/usr/local/include/c++/10.0.0/bits/hashtable.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, typename _Hash>
    using __cache_default
      = __not_<__and_<
         __is_fast_hash<_Hash>,

         __is_nothrow_invocable<const _Hash&, const _Tp&>>>;
# 169 "/usr/local/include/c++/10.0.0/bits/hashtable.h" 3
  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    class _Hashtable
    : public __detail::_Hashtable_base<_Key, _Value, _ExtractKey, _Equal,
           _H1, _H2, _Hash, _Traits>,
      public __detail::_Map_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _H1, _H2, _Hash, _RehashPolicy, _Traits>,
      public __detail::_Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          _H1, _H2, _Hash, _RehashPolicy, _Traits>,
      public __detail::_Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>,
      public __detail::_Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _H1, _H2, _Hash, _RehashPolicy, _Traits>,
      private __detail::_Hashtable_alloc<
 __alloc_rebind<_Alloc,
         __detail::_Hash_node<_Value,
         _Traits::__hash_cached::value>>>
    {
      static_assert(is_same<typename remove_cv<_Value>::type, _Value>::value,
   "unordered container must have a non-const, non-volatile value_type");

      static_assert(is_same<typename _Alloc::value_type, _Value>{},
   "unordered container must have the same value_type as its allocator");


      using __traits_type = _Traits;
      using __hash_cached = typename __traits_type::__hash_cached;
      using __node_type = __detail::_Hash_node<_Value, __hash_cached::value>;
      using __node_alloc_type = __alloc_rebind<_Alloc, __node_type>;

      using __hashtable_alloc = __detail::_Hashtable_alloc<__node_alloc_type>;

      using __value_alloc_traits =
 typename __hashtable_alloc::__value_alloc_traits;
      using __node_alloc_traits =
 typename __hashtable_alloc::__node_alloc_traits;
      using __node_base = typename __hashtable_alloc::__node_base;
      using __bucket_type = typename __hashtable_alloc::__bucket_type;

    public:
      typedef _Key key_type;
      typedef _Value value_type;
      typedef _Alloc allocator_type;
      typedef _Equal key_equal;



      typedef typename __value_alloc_traits::pointer pointer;
      typedef typename __value_alloc_traits::const_pointer const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;

    private:
      using __rehash_type = _RehashPolicy;
      using __rehash_state = typename __rehash_type::_State;

      using __constant_iterators = typename __traits_type::__constant_iterators;
      using __unique_keys = typename __traits_type::__unique_keys;

      using __key_extract = typename std::conditional<
          __constant_iterators::value,
                 __detail::_Identity,
          __detail::_Select1st>::type;

      using __hashtable_base = __detail::
          _Hashtable_base<_Key, _Value, _ExtractKey,
           _Equal, _H1, _H2, _Hash, _Traits>;

      using __hash_code_base = typename __hashtable_base::__hash_code_base;
      using __hash_code = typename __hashtable_base::__hash_code;
      using __ireturn_type = typename __hashtable_base::__ireturn_type;

      using __map_base = __detail::_Map_base<_Key, _Value, _Alloc, _ExtractKey,
          _Equal, _H1, _H2, _Hash,
          _RehashPolicy, _Traits>;

      using __rehash_base = __detail::_Rehash_base<_Key, _Value, _Alloc,
         _ExtractKey, _Equal,
         _H1, _H2, _Hash,
         _RehashPolicy, _Traits>;

      using __eq_base = __detail::_Equality<_Key, _Value, _Alloc, _ExtractKey,
         _Equal, _H1, _H2, _Hash,
         _RehashPolicy, _Traits>;

      using __reuse_or_alloc_node_gen_t =
 __detail::_ReuseOrAllocNode<__node_alloc_type>;


      struct _Scoped_node
      {

 _Scoped_node(__node_type* __n, __hashtable_alloc* __h)
 : _M_h(__h), _M_node(__n) { }


 template<typename... _Args>
   _Scoped_node(__hashtable_alloc* __h, _Args&&... __args)
   : _M_h(__h),
     _M_node(__h->_M_allocate_node(std::forward<_Args>(__args)...))
   { }


 ~_Scoped_node() { if (_M_node) _M_h->_M_deallocate_node(_M_node); };

 _Scoped_node(const _Scoped_node&) = delete;
 _Scoped_node& operator=(const _Scoped_node&) = delete;

 __hashtable_alloc* _M_h;
 __node_type* _M_node;
      };


      template<typename _Cond>
 using __if_hash_cached = __or_<__not_<__hash_cached>, _Cond>;

      template<typename _Cond>
 using __if_hash_not_cached = __or_<__hash_cached, _Cond>;





      struct __hash_code_base_access : __hash_code_base
      { using __hash_code_base::_M_bucket_index; };



      static_assert(noexcept(declval<const __hash_code_base_access&>()
        ._M_bucket_index((const __node_type*)nullptr,
           (std::size_t)0)),
      "Cache the hash code or qualify your functors involved"
      " in hash code and bucket index computation with noexcept");



      static_assert(__if_hash_cached<is_default_constructible<_H2>>::value,
      "Functor used to map hash code to bucket index"
      " must be default constructible");

      template<typename _Keya, typename _Valuea, typename _Alloca,
        typename _ExtractKeya, typename _Equala,
        typename _H1a, typename _H2a, typename _Hasha,
        typename _RehashPolicya, typename _Traitsa,
        bool _Unique_keysa>
 friend struct __detail::_Map_base;

      template<typename _Keya, typename _Valuea, typename _Alloca,
        typename _ExtractKeya, typename _Equala,
        typename _H1a, typename _H2a, typename _Hasha,
        typename _RehashPolicya, typename _Traitsa>
 friend struct __detail::_Insert_base;

      template<typename _Keya, typename _Valuea, typename _Alloca,
        typename _ExtractKeya, typename _Equala,
        typename _H1a, typename _H2a, typename _Hasha,
        typename _RehashPolicya, typename _Traitsa,
        bool _Constant_iteratorsa>
 friend struct __detail::_Insert;

    public:
      using size_type = typename __hashtable_base::size_type;
      using difference_type = typename __hashtable_base::difference_type;

      using iterator = typename __hashtable_base::iterator;
      using const_iterator = typename __hashtable_base::const_iterator;

      using local_iterator = typename __hashtable_base::local_iterator;
      using const_local_iterator = typename __hashtable_base::
       const_local_iterator;


      using node_type = _Node_handle<_Key, _Value, __node_alloc_type>;
      using insert_return_type = _Node_insert_return<iterator, node_type>;


    private:
      __bucket_type* _M_buckets = &_M_single_bucket;
      size_type _M_bucket_count = 1;
      __node_base _M_before_begin;
      size_type _M_element_count = 0;
      _RehashPolicy _M_rehash_policy;







      __bucket_type _M_single_bucket = nullptr;

      bool
      _M_uses_single_bucket(__bucket_type* __bkts) const
      { return __builtin_expect(__bkts == &_M_single_bucket, false); }

      bool
      _M_uses_single_bucket() const
      { return _M_uses_single_bucket(_M_buckets); }

      __hashtable_alloc&
      _M_base_alloc() { return *this; }

      __bucket_type*
      _M_allocate_buckets(size_type __bkt_count)
      {
 if (__builtin_expect(__bkt_count == 1, false))
   {
     _M_single_bucket = nullptr;
     return &_M_single_bucket;
   }

 return __hashtable_alloc::_M_allocate_buckets(__bkt_count);
      }

      void
      _M_deallocate_buckets(__bucket_type* __bkts, size_type __bkt_count)
      {
 if (_M_uses_single_bucket(__bkts))
   return;

 __hashtable_alloc::_M_deallocate_buckets(__bkts, __bkt_count);
      }

      void
      _M_deallocate_buckets()
      { _M_deallocate_buckets(_M_buckets, _M_bucket_count); }



      __node_type*
      _M_bucket_begin(size_type __bkt) const;

      __node_type*
      _M_begin() const
      { return static_cast<__node_type*>(_M_before_begin._M_nxt); }



      template<typename _Ht, typename _NodeGenerator>
 void
 _M_assign_elements(_Ht&&, const _NodeGenerator&);

      template<typename _NodeGenerator>
 void
 _M_assign(const _Hashtable&, const _NodeGenerator&);

      void
      _M_move_assign(_Hashtable&&, true_type);

      void
      _M_move_assign(_Hashtable&&, false_type);

      void
      _M_reset() noexcept;

      _Hashtable(const _H1& __h1, const _H2& __h2, const _Hash& __h,
   const _Equal& __eq, const _ExtractKey& __exk,
   const allocator_type& __a)
      : __hashtable_base(__exk, __h1, __h2, __h, __eq),
 __hashtable_alloc(__node_alloc_type(__a))
      { }

    public:

      _Hashtable() = default;
      _Hashtable(size_type __bkt_count_hint,
   const _H1&, const _H2&, const _Hash&,
   const _Equal&, const _ExtractKey&,
   const allocator_type&);

      template<typename _InputIterator>
 _Hashtable(_InputIterator __first, _InputIterator __last,
     size_type __bkt_count_hint,
     const _H1&, const _H2&, const _Hash&,
     const _Equal&, const _ExtractKey&,
     const allocator_type&);

      _Hashtable(const _Hashtable&);

      _Hashtable(_Hashtable&&) noexcept;

      _Hashtable(const _Hashtable&, const allocator_type&);

      _Hashtable(_Hashtable&&, const allocator_type&);


      explicit
      _Hashtable(const allocator_type& __a)
      : __hashtable_alloc(__node_alloc_type(__a))
      { }

      explicit
      _Hashtable(size_type __bkt_count_hint,
   const _H1& __hf = _H1(),
   const key_equal& __eql = key_equal(),
   const allocator_type& __a = allocator_type())
      : _Hashtable(__bkt_count_hint, __hf, _H2(), _Hash(), __eql,
     __key_extract(), __a)
      { }

      template<typename _InputIterator>
 _Hashtable(_InputIterator __f, _InputIterator __l,
     size_type __bkt_count_hint = 0,
     const _H1& __hf = _H1(),
     const key_equal& __eql = key_equal(),
     const allocator_type& __a = allocator_type())
 : _Hashtable(__f, __l, __bkt_count_hint, __hf, _H2(), _Hash(), __eql,
       __key_extract(), __a)
 { }

      _Hashtable(initializer_list<value_type> __l,
   size_type __bkt_count_hint = 0,
   const _H1& __hf = _H1(),
   const key_equal& __eql = key_equal(),
   const allocator_type& __a = allocator_type())
      : _Hashtable(__l.begin(), __l.end(), __bkt_count_hint,
     __hf, _H2(), _Hash(), __eql,
     __key_extract(), __a)
      { }

      _Hashtable&
      operator=(const _Hashtable& __ht);

      _Hashtable&
      operator=(_Hashtable&& __ht)
      noexcept(__node_alloc_traits::_S_nothrow_move()
        && is_nothrow_move_assignable<_H1>::value
        && is_nothrow_move_assignable<_Equal>::value)
      {
        constexpr bool __move_storage =
   __node_alloc_traits::_S_propagate_on_move_assign()
   || __node_alloc_traits::_S_always_equal();
 _M_move_assign(std::move(__ht), __bool_constant<__move_storage>());
 return *this;
      }

      _Hashtable&
      operator=(initializer_list<value_type> __l)
      {
 __reuse_or_alloc_node_gen_t __roan(_M_begin(), *this);
 _M_before_begin._M_nxt = nullptr;
 clear();
 this->_M_insert_range(__l.begin(), __l.end(), __roan, __unique_keys());
 return *this;
      }

      ~_Hashtable() noexcept;

      void
      swap(_Hashtable&)
      noexcept(__and_<__is_nothrow_swappable<_H1>,
                   __is_nothrow_swappable<_Equal>>::value);


      iterator
      begin() noexcept
      { return iterator(_M_begin()); }

      const_iterator
      begin() const noexcept
      { return const_iterator(_M_begin()); }

      iterator
      end() noexcept
      { return iterator(nullptr); }

      const_iterator
      end() const noexcept
      { return const_iterator(nullptr); }

      const_iterator
      cbegin() const noexcept
      { return const_iterator(_M_begin()); }

      const_iterator
      cend() const noexcept
      { return const_iterator(nullptr); }

      size_type
      size() const noexcept
      { return _M_element_count; }

      [[__nodiscard__]] bool
      empty() const noexcept
      { return size() == 0; }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(this->_M_node_allocator()); }

      size_type
      max_size() const noexcept
      { return __node_alloc_traits::max_size(this->_M_node_allocator()); }


      key_equal
      key_eq() const
      { return this->_M_eq(); }




      size_type
      bucket_count() const noexcept
      { return _M_bucket_count; }

      size_type
      max_bucket_count() const noexcept
      { return max_size(); }

      size_type
      bucket_size(size_type __bkt) const
      { return std::distance(begin(__bkt), end(__bkt)); }

      size_type
      bucket(const key_type& __k) const
      { return _M_bucket_index(__k, this->_M_hash_code(__k)); }

      local_iterator
      begin(size_type __bkt)
      {
 return local_iterator(*this, _M_bucket_begin(__bkt),
         __bkt, _M_bucket_count);
      }

      local_iterator
      end(size_type __bkt)
      { return local_iterator(*this, nullptr, __bkt, _M_bucket_count); }

      const_local_iterator
      begin(size_type __bkt) const
      {
 return const_local_iterator(*this, _M_bucket_begin(__bkt),
        __bkt, _M_bucket_count);
      }

      const_local_iterator
      end(size_type __bkt) const
      { return const_local_iterator(*this, nullptr, __bkt, _M_bucket_count); }


      const_local_iterator
      cbegin(size_type __bkt) const
      {
 return const_local_iterator(*this, _M_bucket_begin(__bkt),
        __bkt, _M_bucket_count);
      }

      const_local_iterator
      cend(size_type __bkt) const
      { return const_local_iterator(*this, nullptr, __bkt, _M_bucket_count); }

      float
      load_factor() const noexcept
      {
 return static_cast<float>(size()) / static_cast<float>(bucket_count());
      }






      const _RehashPolicy&
      __rehash_policy() const
      { return _M_rehash_policy; }

      void
      __rehash_policy(const _RehashPolicy& __pol)
      { _M_rehash_policy = __pol; }


      iterator
      find(const key_type& __k);

      const_iterator
      find(const key_type& __k) const;

      size_type
      count(const key_type& __k) const;

      std::pair<iterator, iterator>
      equal_range(const key_type& __k);

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __k) const;

    protected:

      size_type
      _M_bucket_index(__node_type* __n) const noexcept
      { return __hash_code_base::_M_bucket_index(__n, _M_bucket_count); }

      size_type
      _M_bucket_index(const key_type& __k, __hash_code __c) const
      { return __hash_code_base::_M_bucket_index(__k, __c, _M_bucket_count); }



      __node_base*
      _M_find_before_node(size_type, const key_type&, __hash_code) const;

      __node_type*
      _M_find_node(size_type __bkt, const key_type& __key,
     __hash_code __c) const
      {
 __node_base* __before_n = _M_find_before_node(__bkt, __key, __c);
 if (__before_n)
   return static_cast<__node_type*>(__before_n->_M_nxt);
 return nullptr;
      }


      void
      _M_insert_bucket_begin(size_type, __node_type*);


      void
      _M_remove_bucket_begin(size_type __bkt, __node_type* __next_n,
        size_type __next_bkt);


      __node_base*
      _M_get_previous_node(size_type __bkt, __node_base* __n);




      iterator
      _M_insert_unique_node(const key_type& __k, size_type __bkt,
       __hash_code __code, __node_type* __n,
       size_type __n_elt = 1);



      iterator
      _M_insert_multi_node(__node_type* __hint, const key_type& __k,
      __hash_code __code, __node_type* __n);

      template<typename... _Args>
 std::pair<iterator, bool>
 _M_emplace(true_type, _Args&&... __args);

      template<typename... _Args>
 iterator
 _M_emplace(false_type __uk, _Args&&... __args)
 { return _M_emplace(cend(), __uk, std::forward<_Args>(__args)...); }


      template<typename... _Args>
 iterator
 _M_emplace(const_iterator, true_type __uk, _Args&&... __args)
 { return _M_emplace(__uk, std::forward<_Args>(__args)...).first; }

      template<typename... _Args>
 iterator
 _M_emplace(const_iterator, false_type, _Args&&... __args);

      template<typename _Arg, typename _NodeGenerator>
 std::pair<iterator, bool>
 _M_insert(_Arg&&, const _NodeGenerator&, true_type, size_type = 1);

      template<typename _Arg, typename _NodeGenerator>
 iterator
 _M_insert(_Arg&& __arg, const _NodeGenerator& __node_gen,
    false_type __uk)
 {
   return _M_insert(cend(), std::forward<_Arg>(__arg), __node_gen,
      __uk);
 }


      template<typename _Arg, typename _NodeGenerator>
 iterator
 _M_insert(const_iterator, _Arg&& __arg,
    const _NodeGenerator& __node_gen, true_type __uk)
 {
   return
     _M_insert(std::forward<_Arg>(__arg), __node_gen, __uk).first;
 }


      template<typename _Arg, typename _NodeGenerator>
 iterator
 _M_insert(const_iterator, _Arg&&,
    const _NodeGenerator&, false_type);

      size_type
      _M_erase(true_type, const key_type&);

      size_type
      _M_erase(false_type, const key_type&);

      iterator
      _M_erase(size_type __bkt, __node_base* __prev_n, __node_type* __n);

    public:

      template<typename... _Args>
 __ireturn_type
 emplace(_Args&&... __args)
 { return _M_emplace(__unique_keys(), std::forward<_Args>(__args)...); }

      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __hint, _Args&&... __args)
 {
   return _M_emplace(__hint, __unique_keys(),
       std::forward<_Args>(__args)...);
 }




      iterator
      erase(const_iterator);


      iterator
      erase(iterator __it)
      { return erase(const_iterator(__it)); }

      size_type
      erase(const key_type& __k)
      { return _M_erase(__unique_keys(), __k); }

      iterator
      erase(const_iterator, const_iterator);

      void
      clear() noexcept;



      void rehash(size_type __bkt_count);






      insert_return_type
      _M_reinsert_node(node_type&& __nh)
      {
 insert_return_type __ret;
 if (__nh.empty())
   __ret.position = end();
 else
   {
     ;

     const key_type& __k = __nh._M_key();
     __hash_code __code = this->_M_hash_code(__k);
     size_type __bkt = _M_bucket_index(__k, __code);
     if (__node_type* __n = _M_find_node(__bkt, __k, __code))
       {
  __ret.node = std::move(__nh);
  __ret.position = iterator(__n);
  __ret.inserted = false;
       }
     else
       {
  __ret.position
    = _M_insert_unique_node(__k, __bkt, __code, __nh._M_ptr);
  __nh._M_ptr = nullptr;
  __ret.inserted = true;
       }
   }
 return __ret;
      }


      iterator
      _M_reinsert_node_multi(const_iterator __hint, node_type&& __nh)
      {
 if (__nh.empty())
   return end();

 ;

 const key_type& __k = __nh._M_key();
 auto __code = this->_M_hash_code(__k);
 auto __ret
   = _M_insert_multi_node(__hint._M_cur, __k, __code, __nh._M_ptr);
 __nh._M_ptr = nullptr;
 return __ret;
      }

    private:
      node_type
      _M_extract_node(size_t __bkt, __node_base* __prev_n)
      {
 __node_type* __n = static_cast<__node_type*>(__prev_n->_M_nxt);
 if (__prev_n == _M_buckets[__bkt])
   _M_remove_bucket_begin(__bkt, __n->_M_next(),
      __n->_M_nxt ? _M_bucket_index(__n->_M_next()) : 0);
 else if (__n->_M_nxt)
   {
     size_type __next_bkt = _M_bucket_index(__n->_M_next());
     if (__next_bkt != __bkt)
       _M_buckets[__next_bkt] = __prev_n;
   }

 __prev_n->_M_nxt = __n->_M_nxt;
 __n->_M_nxt = nullptr;
 --_M_element_count;
 return { __n, this->_M_node_allocator() };
      }

    public:

      node_type
      extract(const_iterator __pos)
      {
 size_t __bkt = _M_bucket_index(__pos._M_cur);
 return _M_extract_node(__bkt,
          _M_get_previous_node(__bkt, __pos._M_cur));
      }


      node_type
      extract(const _Key& __k)
      {
 node_type __nh;
 __hash_code __code = this->_M_hash_code(__k);
 std::size_t __bkt = _M_bucket_index(__k, __code);
 if (__node_base* __prev_node = _M_find_before_node(__bkt, __k, __code))
   __nh = _M_extract_node(__bkt, __prev_node);
 return __nh;
      }


      template<typename _Compatible_Hashtable>
 void
 _M_merge_unique(_Compatible_Hashtable& __src) noexcept
 {
   static_assert(is_same_v<typename _Compatible_Hashtable::node_type,
       node_type>, "Node types are compatible");
   ;

   auto __n_elt = __src.size();
   for (auto __i = __src.begin(), __end = __src.end(); __i != __end;)
     {
       auto __pos = __i++;
       const key_type& __k = this->_M_extract()(*__pos);
       __hash_code __code = this->_M_hash_code(__k);
       size_type __bkt = _M_bucket_index(__k, __code);
       if (_M_find_node(__bkt, __k, __code) == nullptr)
  {
    auto __nh = __src.extract(__pos);
    _M_insert_unique_node(__k, __bkt, __code, __nh._M_ptr,
     __n_elt);
    __nh._M_ptr = nullptr;
    __n_elt = 1;
  }
       else if (__n_elt != 1)
  --__n_elt;
     }
 }


      template<typename _Compatible_Hashtable>
 void
 _M_merge_multi(_Compatible_Hashtable& __src) noexcept
 {
   static_assert(is_same_v<typename _Compatible_Hashtable::node_type,
       node_type>, "Node types are compatible");
   ;

   this->reserve(size() + __src.size());
   for (auto __i = __src.begin(), __end = __src.end(); __i != __end;)
     _M_reinsert_node_multi(cend(), __src.extract(__i++));
 }


    private:

      void _M_rehash_aux(size_type __bkt_count, true_type);


      void _M_rehash_aux(size_type __bkt_count, false_type);



      void _M_rehash(size_type __bkt_count, const __rehash_state& __state);
    };



  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_bucket_begin(size_type __bkt) const
    -> __node_type*
    {
      __node_base* __n = _M_buckets[__bkt];
      return __n ? static_cast<__node_type*>(__n->_M_nxt) : nullptr;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _Hashtable(size_type __bkt_count_hint,
        const _H1& __h1, const _H2& __h2, const _Hash& __h,
        const _Equal& __eq, const _ExtractKey& __exk,
        const allocator_type& __a)
    : _Hashtable(__h1, __h2, __h, __eq, __exk, __a)
    {
      auto __bkt_count = _M_rehash_policy._M_next_bkt(__bkt_count_hint);
      if (__bkt_count > _M_bucket_count)
 {
   _M_buckets = _M_allocate_buckets(__bkt_count);
   _M_bucket_count = __bkt_count;
 }
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename _InputIterator>
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _Hashtable(_InputIterator __f, _InputIterator __l,
   size_type __bkt_count_hint,
   const _H1& __h1, const _H2& __h2, const _Hash& __h,
   const _Equal& __eq, const _ExtractKey& __exk,
   const allocator_type& __a)
      : _Hashtable(__h1, __h2, __h, __eq, __exk, __a)
      {
 auto __nb_elems = __detail::__distance_fw(__f, __l);
 auto __bkt_count =
   _M_rehash_policy._M_next_bkt(
     std::max(_M_rehash_policy._M_bkt_for_elements(__nb_elems),
       __bkt_count_hint));

 if (__bkt_count > _M_bucket_count)
   {
     _M_buckets = _M_allocate_buckets(__bkt_count);
     _M_bucket_count = __bkt_count;
   }

 for (; __f != __l; ++__f)
   this->insert(*__f);
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    operator=(const _Hashtable& __ht)
    -> _Hashtable&
    {
      if (&__ht == this)
 return *this;

      if (__node_alloc_traits::_S_propagate_on_copy_assign())
 {
   auto& __this_alloc = this->_M_node_allocator();
   auto& __that_alloc = __ht._M_node_allocator();
   if (!__node_alloc_traits::_S_always_equal()
       && __this_alloc != __that_alloc)
     {

       this->_M_deallocate_nodes(_M_begin());
       _M_before_begin._M_nxt = nullptr;
       _M_deallocate_buckets();
       _M_buckets = nullptr;
       std::__alloc_on_copy(__this_alloc, __that_alloc);
       __hashtable_base::operator=(__ht);
       _M_bucket_count = __ht._M_bucket_count;
       _M_element_count = __ht._M_element_count;
       _M_rehash_policy = __ht._M_rehash_policy;
       try
  {
    _M_assign(__ht,
       [this](const __node_type* __n)
       { return this->_M_allocate_node(__n->_M_v()); });
  }
       catch(...)
  {


    _M_reset();
    throw;
  }
       return *this;
     }
   std::__alloc_on_copy(__this_alloc, __that_alloc);
 }


      _M_assign_elements(__ht,
 [](const __reuse_or_alloc_node_gen_t& __roan, const __node_type* __n)
 { return __roan(__n->_M_v()); });
      return *this;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename _Ht, typename _NodeGenerator>
      void
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_assign_elements(_Ht&& __ht, const _NodeGenerator& __node_gen)
      {
 __bucket_type* __former_buckets = nullptr;
 std::size_t __former_bucket_count = _M_bucket_count;
 const __rehash_state& __former_state = _M_rehash_policy._M_state();

 if (_M_bucket_count != __ht._M_bucket_count)
   {
     __former_buckets = _M_buckets;
     _M_buckets = _M_allocate_buckets(__ht._M_bucket_count);
     _M_bucket_count = __ht._M_bucket_count;
   }
 else
   __builtin_memset(_M_buckets, 0,
      _M_bucket_count * sizeof(__bucket_type));

 try
   {
     __hashtable_base::operator=(std::forward<_Ht>(__ht));
     _M_element_count = __ht._M_element_count;
     _M_rehash_policy = __ht._M_rehash_policy;
     __reuse_or_alloc_node_gen_t __roan(_M_begin(), *this);
     _M_before_begin._M_nxt = nullptr;
     _M_assign(__ht,
        [&__node_gen, &__roan](__node_type* __n)
        { return __node_gen(__roan, __n); });
     if (__former_buckets)
       _M_deallocate_buckets(__former_buckets, __former_bucket_count);
   }
 catch(...)
   {
     if (__former_buckets)
       {

  _M_deallocate_buckets();
  _M_rehash_policy._M_reset(__former_state);
  _M_buckets = __former_buckets;
  _M_bucket_count = __former_bucket_count;
       }
     __builtin_memset(_M_buckets, 0,
        _M_bucket_count * sizeof(__bucket_type));
     throw;
   }
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename _NodeGenerator>
      void
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_assign(const _Hashtable& __ht, const _NodeGenerator& __node_gen)
      {
 __bucket_type* __buckets = nullptr;
 if (!_M_buckets)
   _M_buckets = __buckets = _M_allocate_buckets(_M_bucket_count);

 try
   {
     if (!__ht._M_before_begin._M_nxt)
       return;



     __node_type* __ht_n = __ht._M_begin();
     __node_type* __this_n = __node_gen(__ht_n);
     this->_M_copy_code(__this_n, __ht_n);
     _M_before_begin._M_nxt = __this_n;
     _M_buckets[_M_bucket_index(__this_n)] = &_M_before_begin;


     __node_base* __prev_n = __this_n;
     for (__ht_n = __ht_n->_M_next(); __ht_n; __ht_n = __ht_n->_M_next())
       {
  __this_n = __node_gen(__ht_n);
  __prev_n->_M_nxt = __this_n;
  this->_M_copy_code(__this_n, __ht_n);
  size_type __bkt = _M_bucket_index(__this_n);
  if (!_M_buckets[__bkt])
    _M_buckets[__bkt] = __prev_n;
  __prev_n = __this_n;
       }
   }
 catch(...)
   {
     clear();
     if (__buckets)
       _M_deallocate_buckets();
     throw;
   }
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_reset() noexcept
    {
      _M_rehash_policy._M_reset();
      _M_bucket_count = 1;
      _M_single_bucket = nullptr;
      _M_buckets = &_M_single_bucket;
      _M_before_begin._M_nxt = nullptr;
      _M_element_count = 0;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_move_assign(_Hashtable&& __ht, true_type)
    {
      this->_M_deallocate_nodes(_M_begin());
      _M_deallocate_buckets();
      __hashtable_base::operator=(std::move(__ht));
      _M_rehash_policy = __ht._M_rehash_policy;
      if (!__ht._M_uses_single_bucket())
 _M_buckets = __ht._M_buckets;
      else
 {
   _M_buckets = &_M_single_bucket;
   _M_single_bucket = __ht._M_single_bucket;
 }
      _M_bucket_count = __ht._M_bucket_count;
      _M_before_begin._M_nxt = __ht._M_before_begin._M_nxt;
      _M_element_count = __ht._M_element_count;
      std::__alloc_on_move(this->_M_node_allocator(), __ht._M_node_allocator());



      if (_M_begin())
 _M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;
      __ht._M_reset();
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_move_assign(_Hashtable&& __ht, false_type)
    {
      if (__ht._M_node_allocator() == this->_M_node_allocator())
 _M_move_assign(std::move(__ht), true_type());
      else
 {

   _M_assign_elements(std::move(__ht),
  [](const __reuse_or_alloc_node_gen_t& __roan, __node_type* __n)
  { return __roan(std::move_if_noexcept(__n->_M_v())); });
   __ht.clear();
 }
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _Hashtable(const _Hashtable& __ht)
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      __hashtable_alloc(
 __node_alloc_traits::_S_select_on_copy(__ht._M_node_allocator())),
      _M_buckets(nullptr),
      _M_bucket_count(__ht._M_bucket_count),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {
      _M_assign(__ht,
  [this](const __node_type* __n)
  { return this->_M_allocate_node(__n->_M_v()); });
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _Hashtable(_Hashtable&& __ht) noexcept
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      __hashtable_alloc(std::move(__ht._M_base_alloc())),
      _M_buckets(__ht._M_buckets),
      _M_bucket_count(__ht._M_bucket_count),
      _M_before_begin(__ht._M_before_begin._M_nxt),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {

      if (__ht._M_uses_single_bucket())
 {
   _M_buckets = &_M_single_bucket;
   _M_single_bucket = __ht._M_single_bucket;
 }



      if (_M_begin())
 _M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;

      __ht._M_reset();
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _Hashtable(const _Hashtable& __ht, const allocator_type& __a)
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      __hashtable_alloc(__node_alloc_type(__a)),
      _M_buckets(),
      _M_bucket_count(__ht._M_bucket_count),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {
      _M_assign(__ht,
  [this](const __node_type* __n)
  { return this->_M_allocate_node(__n->_M_v()); });
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _Hashtable(_Hashtable&& __ht, const allocator_type& __a)
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      __hashtable_alloc(__node_alloc_type(__a)),
      _M_buckets(nullptr),
      _M_bucket_count(__ht._M_bucket_count),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {
      if (__ht._M_node_allocator() == this->_M_node_allocator())
 {
   if (__ht._M_uses_single_bucket())
     {
       _M_buckets = &_M_single_bucket;
       _M_single_bucket = __ht._M_single_bucket;
     }
   else
     _M_buckets = __ht._M_buckets;

   _M_before_begin._M_nxt = __ht._M_before_begin._M_nxt;


   if (_M_begin())
     _M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;
   __ht._M_reset();
 }
      else
 {
   _M_assign(__ht,
      [this](__node_type* __n)
      {
        return this->_M_allocate_node(
     std::move_if_noexcept(__n->_M_v()));
      });
   __ht.clear();
 }
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    ~_Hashtable() noexcept
    {
      clear();
      _M_deallocate_buckets();
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    swap(_Hashtable& __x)
    noexcept(__and_<__is_nothrow_swappable<_H1>,
                 __is_nothrow_swappable<_Equal>>::value)
    {



      this->_M_swap(__x);

      std::__alloc_on_swap(this->_M_node_allocator(), __x._M_node_allocator());
      std::swap(_M_rehash_policy, __x._M_rehash_policy);


      if (this->_M_uses_single_bucket())
 {
   if (!__x._M_uses_single_bucket())
     {
       _M_buckets = __x._M_buckets;
       __x._M_buckets = &__x._M_single_bucket;
     }
 }
      else if (__x._M_uses_single_bucket())
 {
   __x._M_buckets = _M_buckets;
   _M_buckets = &_M_single_bucket;
 }
      else
 std::swap(_M_buckets, __x._M_buckets);

      std::swap(_M_bucket_count, __x._M_bucket_count);
      std::swap(_M_before_begin._M_nxt, __x._M_before_begin._M_nxt);
      std::swap(_M_element_count, __x._M_element_count);
      std::swap(_M_single_bucket, __x._M_single_bucket);



      if (_M_begin())
 _M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;

      if (__x._M_begin())
 __x._M_buckets[__x._M_bucket_index(__x._M_begin())]
   = &__x._M_before_begin;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    find(const key_type& __k)
    -> iterator
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __bkt = _M_bucket_index(__k, __code);
      __node_type* __p = _M_find_node(__bkt, __k, __code);
      return __p ? iterator(__p) : end();
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    find(const key_type& __k) const
    -> const_iterator
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __bkt = _M_bucket_index(__k, __code);
      __node_type* __p = _M_find_node(__bkt, __k, __code);
      return __p ? const_iterator(__p) : end();
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    count(const key_type& __k) const
    -> size_type
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __bkt = _M_bucket_index(__k, __code);
      __node_type* __p = _M_bucket_begin(__bkt);
      if (!__p)
 return 0;

      std::size_t __result = 0;
      for (;; __p = __p->_M_next())
 {
   if (this->_M_equals(__k, __code, __p))
     ++__result;
   else if (__result)



     break;
   if (!__p->_M_nxt || _M_bucket_index(__p->_M_next()) != __bkt)
     break;
 }
      return __result;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    equal_range(const key_type& __k)
    -> pair<iterator, iterator>
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __bkt = _M_bucket_index(__k, __code);
      __node_type* __p = _M_find_node(__bkt, __k, __code);

      if (__p)
 {
   __node_type* __p1 = __p->_M_next();
   while (__p1 && _M_bucket_index(__p1) == __bkt
   && this->_M_equals(__k, __code, __p1))
     __p1 = __p1->_M_next();

   return std::make_pair(iterator(__p), iterator(__p1));
 }
      else
 return std::make_pair(end(), end());
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    equal_range(const key_type& __k) const
    -> pair<const_iterator, const_iterator>
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __bkt = _M_bucket_index(__k, __code);
      __node_type* __p = _M_find_node(__bkt, __k, __code);

      if (__p)
 {
   __node_type* __p1 = __p->_M_next();
   while (__p1 && _M_bucket_index(__p1) == __bkt
   && this->_M_equals(__k, __code, __p1))
     __p1 = __p1->_M_next();

   return std::make_pair(const_iterator(__p), const_iterator(__p1));
 }
      else
 return std::make_pair(end(), end());
    }



  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_find_before_node(size_type __bkt, const key_type& __k,
   __hash_code __code) const
    -> __node_base*
    {
      __node_base* __prev_p = _M_buckets[__bkt];
      if (!__prev_p)
 return nullptr;

      for (__node_type* __p = static_cast<__node_type*>(__prev_p->_M_nxt);;
    __p = __p->_M_next())
 {
   if (this->_M_equals(__k, __code, __p))
     return __prev_p;

   if (!__p->_M_nxt || _M_bucket_index(__p->_M_next()) != __bkt)
     break;
   __prev_p = __p;
 }
      return nullptr;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_insert_bucket_begin(size_type __bkt, __node_type* __node)
    {
      if (_M_buckets[__bkt])
 {


   __node->_M_nxt = _M_buckets[__bkt]->_M_nxt;
   _M_buckets[__bkt]->_M_nxt = __node;
 }
      else
 {



   __node->_M_nxt = _M_before_begin._M_nxt;
   _M_before_begin._M_nxt = __node;
   if (__node->_M_nxt)


     _M_buckets[_M_bucket_index(__node->_M_next())] = __node;
   _M_buckets[__bkt] = &_M_before_begin;
 }
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_remove_bucket_begin(size_type __bkt, __node_type* __next,
      size_type __next_bkt)
    {
      if (!__next || __next_bkt != __bkt)
 {


   if (__next)
     _M_buckets[__next_bkt] = _M_buckets[__bkt];


   if (&_M_before_begin == _M_buckets[__bkt])
     _M_before_begin._M_nxt = __next;
   _M_buckets[__bkt] = nullptr;
 }
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_get_previous_node(size_type __bkt, __node_base* __n)
    -> __node_base*
    {
      __node_base* __prev_n = _M_buckets[__bkt];
      while (__prev_n->_M_nxt != __n)
 __prev_n = __prev_n->_M_nxt;
      return __prev_n;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename... _Args>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_emplace(true_type, _Args&&... __args)
      -> pair<iterator, bool>
      {

 _Scoped_node __node { this, std::forward<_Args>(__args)... };
 const key_type& __k = this->_M_extract()(__node._M_node->_M_v());
 __hash_code __code = this->_M_hash_code(__k);
 size_type __bkt = _M_bucket_index(__k, __code);
 if (__node_type* __p = _M_find_node(__bkt, __k, __code))

   return std::make_pair(iterator(__p), false);


 auto __pos = _M_insert_unique_node(__k, __bkt, __code, __node._M_node);
 __node._M_node = nullptr;
 return { __pos, true };
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename... _Args>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_emplace(const_iterator __hint, false_type, _Args&&... __args)
      -> iterator
      {

 _Scoped_node __node { this, std::forward<_Args>(__args)... };
 const key_type& __k = this->_M_extract()(__node._M_node->_M_v());

 __hash_code __code = this->_M_hash_code(__k);
 auto __pos
   = _M_insert_multi_node(__hint._M_cur, __k, __code, __node._M_node);
 __node._M_node = nullptr;
 return __pos;
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_insert_unique_node(const key_type& __k, size_type __bkt,
     __hash_code __code, __node_type* __node,
     size_type __n_elt)
    -> iterator
    {
      const __rehash_state& __saved_state = _M_rehash_policy._M_state();
      std::pair<bool, std::size_t> __do_rehash
 = _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count,
       __n_elt);

      if (__do_rehash.first)
 {
   _M_rehash(__do_rehash.second, __saved_state);
   __bkt = _M_bucket_index(__k, __code);
 }

      this->_M_store_code(__node, __code);


      _M_insert_bucket_begin(__bkt, __node);
      ++_M_element_count;
      return iterator(__node);
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_insert_multi_node(__node_type* __hint, const key_type& __k,
    __hash_code __code, __node_type* __node)
    -> iterator
    {
      const __rehash_state& __saved_state = _M_rehash_policy._M_state();
      std::pair<bool, std::size_t> __do_rehash
 = _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count, 1);

      if (__do_rehash.first)
 _M_rehash(__do_rehash.second, __saved_state);

      this->_M_store_code(__node, __code);
      size_type __bkt = _M_bucket_index(__k, __code);



      __node_base* __prev
 = __builtin_expect(__hint != nullptr, false)
   && this->_M_equals(__k, __code, __hint)
     ? __hint
     : _M_find_before_node(__bkt, __k, __code);
      if (__prev)
 {

   __node->_M_nxt = __prev->_M_nxt;
   __prev->_M_nxt = __node;
   if (__builtin_expect(__prev == __hint, false))


     if (__node->_M_nxt
  && !this->_M_equals(__k, __code, __node->_M_next()))
       {
  size_type __next_bkt = _M_bucket_index(__node->_M_next());
  if (__next_bkt != __bkt)
    _M_buckets[__next_bkt] = __node;
       }
 }
      else



 _M_insert_bucket_begin(__bkt, __node);
      ++_M_element_count;
      return iterator(__node);
    }


  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename _Arg, typename _NodeGenerator>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_insert(_Arg&& __v, const _NodeGenerator& __node_gen, true_type,
  size_type __n_elt)
      -> pair<iterator, bool>
      {
 const key_type& __k = this->_M_extract()(__v);
 __hash_code __code = this->_M_hash_code(__k);
 size_type __bkt = _M_bucket_index(__k, __code);

 if (__node_type* __node = _M_find_node(__bkt, __k, __code))
   return { iterator(__node), false };

 _Scoped_node __node{ __node_gen(std::forward<_Arg>(__v)), this };
 auto __pos
   = _M_insert_unique_node(__k, __bkt, __code, __node._M_node, __n_elt);
 __node._M_node = nullptr;
 return { __pos, true };
      }


  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename _Arg, typename _NodeGenerator>
      auto
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_insert(const_iterator __hint, _Arg&& __v,
  const _NodeGenerator& __node_gen, false_type)
      -> iterator
      {


 __hash_code __code = this->_M_hash_code(this->_M_extract()(__v));


 _Scoped_node __node{ __node_gen(std::forward<_Arg>(__v)), this };
 const key_type& __k = this->_M_extract()(__node._M_node->_M_v());
 auto __pos
   = _M_insert_multi_node(__hint._M_cur, __k, __code, __node._M_node);
 __node._M_node = nullptr;
 return __pos;
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    erase(const_iterator __it)
    -> iterator
    {
      __node_type* __n = __it._M_cur;
      std::size_t __bkt = _M_bucket_index(__n);




      __node_base* __prev_n = _M_get_previous_node(__bkt, __n);
      return _M_erase(__bkt, __prev_n, __n);
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_erase(size_type __bkt, __node_base* __prev_n, __node_type* __n)
    -> iterator
    {
      if (__prev_n == _M_buckets[__bkt])
 _M_remove_bucket_begin(__bkt, __n->_M_next(),
    __n->_M_nxt ? _M_bucket_index(__n->_M_next()) : 0);
      else if (__n->_M_nxt)
 {
   size_type __next_bkt = _M_bucket_index(__n->_M_next());
   if (__next_bkt != __bkt)
     _M_buckets[__next_bkt] = __prev_n;
 }

      __prev_n->_M_nxt = __n->_M_nxt;
      iterator __result(__n->_M_next());
      this->_M_deallocate_node(__n);
      --_M_element_count;

      return __result;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_erase(true_type, const key_type& __k)
    -> size_type
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __bkt = _M_bucket_index(__k, __code);


      __node_base* __prev_n = _M_find_before_node(__bkt, __k, __code);
      if (!__prev_n)
 return 0;


      __node_type* __n = static_cast<__node_type*>(__prev_n->_M_nxt);
      _M_erase(__bkt, __prev_n, __n);
      return 1;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_erase(false_type, const key_type& __k)
    -> size_type
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __bkt = _M_bucket_index(__k, __code);


      __node_base* __prev_n = _M_find_before_node(__bkt, __k, __code);
      if (!__prev_n)
 return 0;







      __node_type* __n = static_cast<__node_type*>(__prev_n->_M_nxt);
      __node_type* __n_last = __n;
      std::size_t __n_last_bkt = __bkt;
      do
 {
   __n_last = __n_last->_M_next();
   if (!__n_last)
     break;
   __n_last_bkt = _M_bucket_index(__n_last);
 }
      while (__n_last_bkt == __bkt && this->_M_equals(__k, __code, __n_last));


      size_type __result = 0;
      do
 {
   __node_type* __p = __n->_M_next();
   this->_M_deallocate_node(__n);
   __n = __p;
   ++__result;
   --_M_element_count;
 }
      while (__n != __n_last);

      if (__prev_n == _M_buckets[__bkt])
 _M_remove_bucket_begin(__bkt, __n_last, __n_last_bkt);
      else if (__n_last && __n_last_bkt != __bkt)
 _M_buckets[__n_last_bkt] = __prev_n;
      __prev_n->_M_nxt = __n_last;
      return __result;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    auto
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    erase(const_iterator __first, const_iterator __last)
    -> iterator
    {
      __node_type* __n = __first._M_cur;
      __node_type* __last_n = __last._M_cur;
      if (__n == __last_n)
 return iterator(__n);

      std::size_t __bkt = _M_bucket_index(__n);

      __node_base* __prev_n = _M_get_previous_node(__bkt, __n);
      bool __is_bucket_begin = __n == _M_bucket_begin(__bkt);
      std::size_t __n_bkt = __bkt;
      for (;;)
 {
   do
     {
       __node_type* __tmp = __n;
       __n = __n->_M_next();
       this->_M_deallocate_node(__tmp);
       --_M_element_count;
       if (!__n)
  break;
       __n_bkt = _M_bucket_index(__n);
     }
   while (__n != __last_n && __n_bkt == __bkt);
   if (__is_bucket_begin)
     _M_remove_bucket_begin(__bkt, __n, __n_bkt);
   if (__n == __last_n)
     break;
   __is_bucket_begin = true;
   __bkt = __n_bkt;
 }

      if (__n && (__n_bkt != __bkt || __is_bucket_begin))
 _M_buckets[__n_bkt] = __prev_n;
      __prev_n->_M_nxt = __n;
      return iterator(__n);
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    clear() noexcept
    {
      this->_M_deallocate_nodes(_M_begin());
      __builtin_memset(_M_buckets, 0, _M_bucket_count * sizeof(__bucket_type));
      _M_element_count = 0;
      _M_before_begin._M_nxt = nullptr;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    rehash(size_type __bkt_count)
    {
      const __rehash_state& __saved_state = _M_rehash_policy._M_state();
      __bkt_count
 = std::max(_M_rehash_policy._M_bkt_for_elements(_M_element_count + 1),
     __bkt_count);
      __bkt_count = _M_rehash_policy._M_next_bkt(__bkt_count);

      if (__bkt_count != _M_bucket_count)
 _M_rehash(__bkt_count, __saved_state);
      else


 _M_rehash_policy._M_reset(__saved_state);
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_rehash(size_type __bkt_count, const __rehash_state& __state)
    {
      try
 {
   _M_rehash_aux(__bkt_count, __unique_keys());
 }
      catch(...)
 {


   _M_rehash_policy._M_reset(__state);
   throw;
 }
    }


  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_rehash_aux(size_type __bkt_count, true_type)
    {
      __bucket_type* __new_buckets = _M_allocate_buckets(__bkt_count);
      __node_type* __p = _M_begin();
      _M_before_begin._M_nxt = nullptr;
      std::size_t __bbegin_bkt = 0;
      while (__p)
 {
   __node_type* __next = __p->_M_next();
   std::size_t __bkt
     = __hash_code_base::_M_bucket_index(__p, __bkt_count);
   if (!__new_buckets[__bkt])
     {
       __p->_M_nxt = _M_before_begin._M_nxt;
       _M_before_begin._M_nxt = __p;
       __new_buckets[__bkt] = &_M_before_begin;
       if (__p->_M_nxt)
  __new_buckets[__bbegin_bkt] = __p;
       __bbegin_bkt = __bkt;
     }
   else
     {
       __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
       __new_buckets[__bkt]->_M_nxt = __p;
     }
   __p = __next;
 }

      _M_deallocate_buckets();
      _M_bucket_count = __bkt_count;
      _M_buckets = __new_buckets;
    }



  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_rehash_aux(size_type __bkt_count, false_type)
    {
      __bucket_type* __new_buckets = _M_allocate_buckets(__bkt_count);

      __node_type* __p = _M_begin();
      _M_before_begin._M_nxt = nullptr;
      std::size_t __bbegin_bkt = 0;
      std::size_t __prev_bkt = 0;
      __node_type* __prev_p = nullptr;
      bool __check_bucket = false;

      while (__p)
 {
   __node_type* __next = __p->_M_next();
   std::size_t __bkt
     = __hash_code_base::_M_bucket_index(__p, __bkt_count);

   if (__prev_p && __prev_bkt == __bkt)
     {



       __p->_M_nxt = __prev_p->_M_nxt;
       __prev_p->_M_nxt = __p;






       __check_bucket = true;
     }
   else
     {
       if (__check_bucket)
  {


    if (__prev_p->_M_nxt)
      {
        std::size_t __next_bkt
   = __hash_code_base::_M_bucket_index(__prev_p->_M_next(),
           __bkt_count);
        if (__next_bkt != __prev_bkt)
   __new_buckets[__next_bkt] = __prev_p;
      }
    __check_bucket = false;
  }

       if (!__new_buckets[__bkt])
  {
    __p->_M_nxt = _M_before_begin._M_nxt;
    _M_before_begin._M_nxt = __p;
    __new_buckets[__bkt] = &_M_before_begin;
    if (__p->_M_nxt)
      __new_buckets[__bbegin_bkt] = __p;
    __bbegin_bkt = __bkt;
  }
       else
  {
    __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
    __new_buckets[__bkt]->_M_nxt = __p;
  }
     }
   __prev_p = __p;
   __prev_bkt = __bkt;
   __p = __next;
 }

      if (__check_bucket && __prev_p->_M_nxt)
 {
   std::size_t __next_bkt
     = __hash_code_base::_M_bucket_index(__prev_p->_M_next(),
      __bkt_count);
   if (__next_bkt != __prev_bkt)
     __new_buckets[__next_bkt] = __prev_p;
 }

      _M_deallocate_buckets();
      _M_bucket_count = __bkt_count;
      _M_buckets = __new_buckets;
    }


  template<typename, typename, typename> class _Hash_merge_helper { };




  template<typename _Hash>
    using _RequireNotAllocatorOrIntegral
      = __enable_if_t<!__or_<is_integral<_Hash>, __is_allocator<_Hash>>::value>;



}
# 47 "/usr/local/include/c++/10.0.0/unordered_map" 2 3
# 1 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 1 3
# 33 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{




  template<bool _Cache>
    using __umap_traits = __detail::_Hashtable_traits<_Cache, false, true>;

  template<typename _Key,
    typename _Tp,
    typename _Hash = hash<_Key>,
    typename _Pred = std::equal_to<_Key>,
    typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >,
    typename _Tr = __umap_traits<__cache_default<_Key, _Hash>::value>>
    using __umap_hashtable = _Hashtable<_Key, std::pair<const _Key, _Tp>,
                                        _Alloc, __detail::_Select1st,
            _Pred, _Hash,
            __detail::_Mod_range_hashing,
            __detail::_Default_ranged_hash,
            __detail::_Prime_rehash_policy, _Tr>;


  template<bool _Cache>
    using __ummap_traits = __detail::_Hashtable_traits<_Cache, false, false>;

  template<typename _Key,
    typename _Tp,
    typename _Hash = hash<_Key>,
    typename _Pred = std::equal_to<_Key>,
    typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >,
    typename _Tr = __ummap_traits<__cache_default<_Key, _Hash>::value>>
    using __ummap_hashtable = _Hashtable<_Key, std::pair<const _Key, _Tp>,
      _Alloc, __detail::_Select1st,
      _Pred, _Hash,
      __detail::_Mod_range_hashing,
      __detail::_Default_ranged_hash,
      __detail::_Prime_rehash_policy, _Tr>;

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    class unordered_multimap;
# 98 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
  template<typename _Key, typename _Tp,
    typename _Hash = hash<_Key>,
    typename _Pred = equal_to<_Key>,
    typename _Alloc = allocator<std::pair<const _Key, _Tp>>>
    class unordered_map
    {
      typedef __umap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc> _Hashtable;
      _Hashtable _M_h;

    public:



      typedef typename _Hashtable::key_type key_type;
      typedef typename _Hashtable::value_type value_type;
      typedef typename _Hashtable::mapped_type mapped_type;
      typedef typename _Hashtable::hasher hasher;
      typedef typename _Hashtable::key_equal key_equal;
      typedef typename _Hashtable::allocator_type allocator_type;




      typedef typename _Hashtable::pointer pointer;
      typedef typename _Hashtable::const_pointer const_pointer;
      typedef typename _Hashtable::reference reference;
      typedef typename _Hashtable::const_reference const_reference;
      typedef typename _Hashtable::iterator iterator;
      typedef typename _Hashtable::const_iterator const_iterator;
      typedef typename _Hashtable::local_iterator local_iterator;
      typedef typename _Hashtable::const_local_iterator const_local_iterator;
      typedef typename _Hashtable::size_type size_type;
      typedef typename _Hashtable::difference_type difference_type;



      using node_type = typename _Hashtable::node_type;
      using insert_return_type = typename _Hashtable::insert_return_type;





      unordered_map() = default;
# 150 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      explicit
      unordered_map(size_type __n,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal(),
      const allocator_type& __a = allocator_type())
      : _M_h(__n, __hf, __eql, __a)
      { }
# 171 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      template<typename _InputIterator>
 unordered_map(_InputIterator __first, _InputIterator __last,
        size_type __n = 0,
        const hasher& __hf = hasher(),
        const key_equal& __eql = key_equal(),
        const allocator_type& __a = allocator_type())
 : _M_h(__first, __last, __n, __hf, __eql, __a)
 { }


      unordered_map(const unordered_map&) = default;


      unordered_map(unordered_map&&) = default;





      explicit
      unordered_map(const allocator_type& __a)
 : _M_h(__a)
      { }






      unordered_map(const unordered_map& __umap,
      const allocator_type& __a)
      : _M_h(__umap._M_h, __a)
      { }






      unordered_map(unordered_map&& __umap,
      const allocator_type& __a)
      : _M_h(std::move(__umap._M_h), __a)
      { }
# 226 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      unordered_map(initializer_list<value_type> __l,
      size_type __n = 0,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal(),
      const allocator_type& __a = allocator_type())
      : _M_h(__l, __n, __hf, __eql, __a)
      { }

      unordered_map(size_type __n, const allocator_type& __a)
      : unordered_map(__n, hasher(), key_equal(), __a)
      { }

      unordered_map(size_type __n, const hasher& __hf,
      const allocator_type& __a)
      : unordered_map(__n, __hf, key_equal(), __a)
      { }

      template<typename _InputIterator>
 unordered_map(_InputIterator __first, _InputIterator __last,
        size_type __n,
        const allocator_type& __a)
 : unordered_map(__first, __last, __n, hasher(), key_equal(), __a)
 { }

      template<typename _InputIterator>
 unordered_map(_InputIterator __first, _InputIterator __last,
        size_type __n, const hasher& __hf,
        const allocator_type& __a)
   : unordered_map(__first, __last, __n, __hf, key_equal(), __a)
 { }

      unordered_map(initializer_list<value_type> __l,
      size_type __n,
      const allocator_type& __a)
      : unordered_map(__l, __n, hasher(), key_equal(), __a)
      { }

      unordered_map(initializer_list<value_type> __l,
      size_type __n, const hasher& __hf,
      const allocator_type& __a)
      : unordered_map(__l, __n, __hf, key_equal(), __a)
      { }


      unordered_map&
      operator=(const unordered_map&) = default;


      unordered_map&
      operator=(unordered_map&&) = default;
# 288 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      unordered_map&
      operator=(initializer_list<value_type> __l)
      {
 _M_h = __l;
 return *this;
      }


      allocator_type
      get_allocator() const noexcept
      { return _M_h.get_allocator(); }




      [[__nodiscard__]] bool
      empty() const noexcept
      { return _M_h.empty(); }


      size_type
      size() const noexcept
      { return _M_h.size(); }


      size_type
      max_size() const noexcept
      { return _M_h.max_size(); }







      iterator
      begin() noexcept
      { return _M_h.begin(); }






      const_iterator
      begin() const noexcept
      { return _M_h.begin(); }

      const_iterator
      cbegin() const noexcept
      { return _M_h.begin(); }






      iterator
      end() noexcept
      { return _M_h.end(); }






      const_iterator
      end() const noexcept
      { return _M_h.end(); }

      const_iterator
      cend() const noexcept
      { return _M_h.end(); }
# 385 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      template<typename... _Args>
 std::pair<iterator, bool>
 emplace(_Args&&... __args)
 { return _M_h.emplace(std::forward<_Args>(__args)...); }
# 416 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 { return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }



      node_type
      extract(const_iterator __pos)
      {
 ;
 return _M_h.extract(__pos);
      }


      node_type
      extract(const key_type& __key)
      { return _M_h.extract(__key); }


      insert_return_type
      insert(node_type&& __nh)
      { return _M_h._M_reinsert_node(std::move(__nh)); }


      iterator
      insert(const_iterator, node_type&& __nh)
      { return _M_h._M_reinsert_node(std::move(__nh)).position; }
# 468 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      template <typename... _Args>
        pair<iterator, bool>
        try_emplace(const key_type& __k, _Args&&... __args)
        {
          iterator __i = find(__k);
          if (__i == end())
            {
              __i = emplace(std::piecewise_construct,
                            std::forward_as_tuple(__k),
                            std::forward_as_tuple(
                              std::forward<_Args>(__args)...))
                .first;
              return {__i, true};
            }
          return {__i, false};
        }


      template <typename... _Args>
        pair<iterator, bool>
        try_emplace(key_type&& __k, _Args&&... __args)
        {
          iterator __i = find(__k);
          if (__i == end())
            {
              __i = emplace(std::piecewise_construct,
                            std::forward_as_tuple(std::move(__k)),
                            std::forward_as_tuple(
                              std::forward<_Args>(__args)...))
                .first;
              return {__i, true};
            }
          return {__i, false};
        }
# 531 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      template <typename... _Args>
        iterator
        try_emplace(const_iterator __hint, const key_type& __k,
                    _Args&&... __args)
        {
          iterator __i = find(__k);
          if (__i == end())
            __i = emplace_hint(__hint, std::piecewise_construct,
                               std::forward_as_tuple(__k),
                               std::forward_as_tuple(
                                 std::forward<_Args>(__args)...));
          return __i;
        }


      template <typename... _Args>
        iterator
        try_emplace(const_iterator __hint, key_type&& __k, _Args&&... __args)
        {
          iterator __i = find(__k);
          if (__i == end())
            __i = emplace_hint(__hint, std::piecewise_construct,
                               std::forward_as_tuple(std::move(__k)),
                               std::forward_as_tuple(
                                 std::forward<_Args>(__args)...));
          return __i;
        }
# 578 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      { return _M_h.insert(__x); }



      std::pair<iterator, bool>
      insert(value_type&& __x)
      { return _M_h.insert(std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair&&>::value,
        pair<iterator, bool>>
 insert(_Pair&& __x)
        { return _M_h.emplace(std::forward<_Pair>(__x)); }
# 617 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      iterator
      insert(const_iterator __hint, const value_type& __x)
      { return _M_h.insert(__hint, __x); }



      iterator
      insert(const_iterator __hint, value_type&& __x)
      { return _M_h.insert(__hint, std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 insert(const_iterator __hint, _Pair&& __x)
 { return _M_h.emplace_hint(__hint, std::forward<_Pair>(__x)); }
# 642 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_h.insert(__first, __last); }
# 654 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      void
      insert(initializer_list<value_type> __l)
      { _M_h.insert(__l); }
# 681 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      template <typename _Obj>
        pair<iterator, bool>
        insert_or_assign(const key_type& __k, _Obj&& __obj)
        {
          iterator __i = find(__k);
          if (__i == end())
            {
              __i = emplace(std::piecewise_construct,
                            std::forward_as_tuple(__k),
                            std::forward_as_tuple(std::forward<_Obj>(__obj)))
                .first;
              return {__i, true};
            }
          (*__i).second = std::forward<_Obj>(__obj);
          return {__i, false};
        }


      template <typename _Obj>
        pair<iterator, bool>
        insert_or_assign(key_type&& __k, _Obj&& __obj)
        {
          iterator __i = find(__k);
          if (__i == end())
            {
              __i = emplace(std::piecewise_construct,
                            std::forward_as_tuple(std::move(__k)),
                            std::forward_as_tuple(std::forward<_Obj>(__obj)))
                .first;
              return {__i, true};
            }
          (*__i).second = std::forward<_Obj>(__obj);
          return {__i, false};
        }
# 742 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      template <typename _Obj>
        iterator
        insert_or_assign(const_iterator __hint, const key_type& __k,
                         _Obj&& __obj)
        {
          iterator __i = find(__k);
          if (__i == end())
            {
              return emplace_hint(__hint, std::piecewise_construct,
                                  std::forward_as_tuple(__k),
                                  std::forward_as_tuple(
                                    std::forward<_Obj>(__obj)));
            }
          (*__i).second = std::forward<_Obj>(__obj);
          return __i;
        }


      template <typename _Obj>
        iterator
        insert_or_assign(const_iterator __hint, key_type&& __k, _Obj&& __obj)
        {
          iterator __i = find(__k);
          if (__i == end())
            {
              return emplace_hint(__hint, std::piecewise_construct,
                                  std::forward_as_tuple(std::move(__k)),
                                  std::forward_as_tuple(
                                    std::forward<_Obj>(__obj)));
            }
          (*__i).second = std::forward<_Obj>(__obj);
          return __i;
        }
# 791 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      iterator
      erase(const_iterator __position)
      { return _M_h.erase(__position); }


      iterator
      erase(iterator __position)
      { return _M_h.erase(__position); }
# 813 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_h.erase(__x); }
# 831 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_h.erase(__first, __last); }







      void
      clear() noexcept
      { _M_h.clear(); }
# 855 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      void
      swap(unordered_map& __x)
      noexcept( noexcept(_M_h.swap(__x._M_h)) )
      { _M_h.swap(__x._M_h); }


      template<typename, typename, typename>
 friend class std::_Hash_merge_helper;

      template<typename _H2, typename _P2>
 void
 merge(unordered_map<_Key, _Tp, _H2, _P2, _Alloc>& __source)
 {
   using _Merge_helper = _Hash_merge_helper<unordered_map, _H2, _P2>;
   _M_h._M_merge_unique(_Merge_helper::_S_get_table(__source));
 }

      template<typename _H2, typename _P2>
 void
 merge(unordered_map<_Key, _Tp, _H2, _P2, _Alloc>&& __source)
 { merge(__source); }

      template<typename _H2, typename _P2>
 void
 merge(unordered_multimap<_Key, _Tp, _H2, _P2, _Alloc>& __source)
 {
   using _Merge_helper = _Hash_merge_helper<unordered_map, _H2, _P2>;
   _M_h._M_merge_unique(_Merge_helper::_S_get_table(__source));
 }

      template<typename _H2, typename _P2>
 void
 merge(unordered_multimap<_Key, _Tp, _H2, _P2, _Alloc>&& __source)
 { merge(__source); }






      hasher
      hash_function() const
      { return _M_h.hash_function(); }



      key_equal
      key_eq() const
      { return _M_h.key_eq(); }
# 919 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      iterator
      find(const key_type& __x)
      { return _M_h.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_h.find(__x); }
# 937 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_h.count(__x); }







      bool
      contains(const key_type& __x) const
      { return _M_h.find(__x) != _M_h.end(); }
# 961 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_h.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_h.equal_range(__x); }
# 983 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      mapped_type&
      operator[](const key_type& __k)
      { return _M_h[__k]; }

      mapped_type&
      operator[](key_type&& __k)
      { return _M_h[std::move(__k)]; }
# 1000 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      mapped_type&
      at(const key_type& __k)
      { return _M_h.at(__k); }

      const mapped_type&
      at(const key_type& __k) const
      { return _M_h.at(__k); }





      size_type
      bucket_count() const noexcept
      { return _M_h.bucket_count(); }


      size_type
      max_bucket_count() const noexcept
      { return _M_h.max_bucket_count(); }






      size_type
      bucket_size(size_type __n) const
      { return _M_h.bucket_size(__n); }






      size_type
      bucket(const key_type& __key) const
      { return _M_h.bucket(__key); }







      local_iterator
      begin(size_type __n)
      { return _M_h.begin(__n); }
# 1056 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      const_local_iterator
      begin(size_type __n) const
      { return _M_h.begin(__n); }

      const_local_iterator
      cbegin(size_type __n) const
      { return _M_h.cbegin(__n); }
# 1071 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      local_iterator
      end(size_type __n)
      { return _M_h.end(__n); }
# 1082 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      const_local_iterator
      end(size_type __n) const
      { return _M_h.end(__n); }

      const_local_iterator
      cend(size_type __n) const
      { return _M_h.cend(__n); }





      float
      load_factor() const noexcept
      { return _M_h.load_factor(); }



      float
      max_load_factor() const noexcept
      { return _M_h.max_load_factor(); }





      void
      max_load_factor(float __z)
      { _M_h.max_load_factor(__z); }
# 1119 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      void
      rehash(size_type __n)
      { _M_h.rehash(__n); }
# 1130 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      void
      reserve(size_type __n)
      { _M_h.reserve(__n); }

      template<typename _Key1, typename _Tp1, typename _Hash1, typename _Pred1,
        typename _Alloc1>
        friend bool
 operator==(const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>&,
     const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>&);
    };



  template<typename _InputIterator,
    typename _Hash = hash<__iter_key_t<_InputIterator>>,
    typename _Pred = equal_to<__iter_key_t<_InputIterator>>,
    typename _Allocator = allocator<__iter_to_alloc_t<_InputIterator>>,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireNotAllocatorOrIntegral<_Hash>,
    typename = _RequireNotAllocator<_Pred>,
    typename = _RequireAllocator<_Allocator>>
    unordered_map(_InputIterator, _InputIterator,
    typename unordered_map<int, int>::size_type = {},
    _Hash = _Hash(), _Pred = _Pred(), _Allocator = _Allocator())
    -> unordered_map<__iter_key_t<_InputIterator>,
       __iter_val_t<_InputIterator>,
       _Hash, _Pred, _Allocator>;

  template<typename _Key, typename _Tp, typename _Hash = hash<_Key>,
    typename _Pred = equal_to<_Key>,
    typename _Allocator = allocator<pair<const _Key, _Tp>>,
    typename = _RequireNotAllocatorOrIntegral<_Hash>,
    typename = _RequireNotAllocator<_Pred>,
    typename = _RequireAllocator<_Allocator>>
    unordered_map(initializer_list<pair<_Key, _Tp>>,
    typename unordered_map<int, int>::size_type = {},
    _Hash = _Hash(), _Pred = _Pred(), _Allocator = _Allocator())
    -> unordered_map<_Key, _Tp, _Hash, _Pred, _Allocator>;

  template<typename _InputIterator, typename _Allocator,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireAllocator<_Allocator>>
    unordered_map(_InputIterator, _InputIterator,
    typename unordered_map<int, int>::size_type, _Allocator)
    -> unordered_map<__iter_key_t<_InputIterator>,
       __iter_val_t<_InputIterator>,
       hash<__iter_key_t<_InputIterator>>,
       equal_to<__iter_key_t<_InputIterator>>,
       _Allocator>;

  template<typename _InputIterator, typename _Allocator,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireAllocator<_Allocator>>
    unordered_map(_InputIterator, _InputIterator, _Allocator)
    -> unordered_map<__iter_key_t<_InputIterator>,
       __iter_val_t<_InputIterator>,
       hash<__iter_key_t<_InputIterator>>,
       equal_to<__iter_key_t<_InputIterator>>,
       _Allocator>;

  template<typename _InputIterator, typename _Hash, typename _Allocator,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireNotAllocatorOrIntegral<_Hash>,
    typename = _RequireAllocator<_Allocator>>
    unordered_map(_InputIterator, _InputIterator,
    typename unordered_map<int, int>::size_type,
    _Hash, _Allocator)
    -> unordered_map<__iter_key_t<_InputIterator>,
       __iter_val_t<_InputIterator>, _Hash,
       equal_to<__iter_key_t<_InputIterator>>, _Allocator>;

  template<typename _Key, typename _Tp, typename _Allocator,
    typename = _RequireAllocator<_Allocator>>
    unordered_map(initializer_list<pair<_Key, _Tp>>,
    typename unordered_map<int, int>::size_type,
    _Allocator)
    -> unordered_map<_Key, _Tp, hash<_Key>, equal_to<_Key>, _Allocator>;

  template<typename _Key, typename _Tp, typename _Allocator,
    typename = _RequireAllocator<_Allocator>>
    unordered_map(initializer_list<pair<_Key, _Tp>>, _Allocator)
    -> unordered_map<_Key, _Tp, hash<_Key>, equal_to<_Key>, _Allocator>;

  template<typename _Key, typename _Tp, typename _Hash, typename _Allocator,
    typename = _RequireNotAllocatorOrIntegral<_Hash>,
    typename = _RequireAllocator<_Allocator>>
    unordered_map(initializer_list<pair<_Key, _Tp>>,
    typename unordered_map<int, int>::size_type,
    _Hash, _Allocator)
    -> unordered_map<_Key, _Tp, _Hash, equal_to<_Key>, _Allocator>;
# 1246 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
  template<typename _Key, typename _Tp,
    typename _Hash = hash<_Key>,
    typename _Pred = equal_to<_Key>,
    typename _Alloc = allocator<std::pair<const _Key, _Tp>>>
    class unordered_multimap
    {
      typedef __ummap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc> _Hashtable;
      _Hashtable _M_h;

    public:



      typedef typename _Hashtable::key_type key_type;
      typedef typename _Hashtable::value_type value_type;
      typedef typename _Hashtable::mapped_type mapped_type;
      typedef typename _Hashtable::hasher hasher;
      typedef typename _Hashtable::key_equal key_equal;
      typedef typename _Hashtable::allocator_type allocator_type;




      typedef typename _Hashtable::pointer pointer;
      typedef typename _Hashtable::const_pointer const_pointer;
      typedef typename _Hashtable::reference reference;
      typedef typename _Hashtable::const_reference const_reference;
      typedef typename _Hashtable::iterator iterator;
      typedef typename _Hashtable::const_iterator const_iterator;
      typedef typename _Hashtable::local_iterator local_iterator;
      typedef typename _Hashtable::const_local_iterator const_local_iterator;
      typedef typename _Hashtable::size_type size_type;
      typedef typename _Hashtable::difference_type difference_type;



      using node_type = typename _Hashtable::node_type;





      unordered_multimap() = default;
# 1297 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      explicit
      unordered_multimap(size_type __n,
    const hasher& __hf = hasher(),
    const key_equal& __eql = key_equal(),
    const allocator_type& __a = allocator_type())
      : _M_h(__n, __hf, __eql, __a)
      { }
# 1318 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      template<typename _InputIterator>
 unordered_multimap(_InputIterator __first, _InputIterator __last,
      size_type __n = 0,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal(),
      const allocator_type& __a = allocator_type())
 : _M_h(__first, __last, __n, __hf, __eql, __a)
 { }


      unordered_multimap(const unordered_multimap&) = default;


      unordered_multimap(unordered_multimap&&) = default;





      explicit
      unordered_multimap(const allocator_type& __a)
      : _M_h(__a)
      { }






      unordered_multimap(const unordered_multimap& __ummap,
    const allocator_type& __a)
      : _M_h(__ummap._M_h, __a)
      { }






      unordered_multimap(unordered_multimap&& __ummap,
    const allocator_type& __a)
      : _M_h(std::move(__ummap._M_h), __a)
      { }
# 1373 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      unordered_multimap(initializer_list<value_type> __l,
    size_type __n = 0,
    const hasher& __hf = hasher(),
    const key_equal& __eql = key_equal(),
    const allocator_type& __a = allocator_type())
      : _M_h(__l, __n, __hf, __eql, __a)
      { }

      unordered_multimap(size_type __n, const allocator_type& __a)
      : unordered_multimap(__n, hasher(), key_equal(), __a)
      { }

      unordered_multimap(size_type __n, const hasher& __hf,
    const allocator_type& __a)
      : unordered_multimap(__n, __hf, key_equal(), __a)
      { }

      template<typename _InputIterator>
 unordered_multimap(_InputIterator __first, _InputIterator __last,
      size_type __n,
      const allocator_type& __a)
 : unordered_multimap(__first, __last, __n, hasher(), key_equal(), __a)
 { }

      template<typename _InputIterator>
 unordered_multimap(_InputIterator __first, _InputIterator __last,
      size_type __n, const hasher& __hf,
      const allocator_type& __a)
 : unordered_multimap(__first, __last, __n, __hf, key_equal(), __a)
 { }

      unordered_multimap(initializer_list<value_type> __l,
    size_type __n,
    const allocator_type& __a)
      : unordered_multimap(__l, __n, hasher(), key_equal(), __a)
      { }

      unordered_multimap(initializer_list<value_type> __l,
    size_type __n, const hasher& __hf,
    const allocator_type& __a)
      : unordered_multimap(__l, __n, __hf, key_equal(), __a)
      { }


      unordered_multimap&
      operator=(const unordered_multimap&) = default;


      unordered_multimap&
      operator=(unordered_multimap&&) = default;
# 1435 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      unordered_multimap&
      operator=(initializer_list<value_type> __l)
      {
 _M_h = __l;
 return *this;
      }


      allocator_type
      get_allocator() const noexcept
      { return _M_h.get_allocator(); }




      [[__nodiscard__]] bool
      empty() const noexcept
      { return _M_h.empty(); }


      size_type
      size() const noexcept
      { return _M_h.size(); }


      size_type
      max_size() const noexcept
      { return _M_h.max_size(); }







      iterator
      begin() noexcept
      { return _M_h.begin(); }






      const_iterator
      begin() const noexcept
      { return _M_h.begin(); }

      const_iterator
      cbegin() const noexcept
      { return _M_h.begin(); }






      iterator
      end() noexcept
      { return _M_h.end(); }






      const_iterator
      end() const noexcept
      { return _M_h.end(); }

      const_iterator
      cend() const noexcept
      { return _M_h.end(); }
# 1527 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      template<typename... _Args>
 iterator
 emplace(_Args&&... __args)
 { return _M_h.emplace(std::forward<_Args>(__args)...); }
# 1554 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 { return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }
# 1569 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_h.insert(__x); }

      iterator
      insert(value_type&& __x)
      { return _M_h.insert(std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 insert(_Pair&& __x)
        { return _M_h.emplace(std::forward<_Pair>(__x)); }
# 1603 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      iterator
      insert(const_iterator __hint, const value_type& __x)
      { return _M_h.insert(__hint, __x); }



      iterator
      insert(const_iterator __hint, value_type&& __x)
      { return _M_h.insert(__hint, std::move(__x)); }

      template<typename _Pair>
 __enable_if_t<is_constructible<value_type, _Pair&&>::value, iterator>
 insert(const_iterator __hint, _Pair&& __x)
        { return _M_h.emplace_hint(__hint, std::forward<_Pair>(__x)); }
# 1628 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_h.insert(__first, __last); }
# 1641 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      void
      insert(initializer_list<value_type> __l)
      { _M_h.insert(__l); }



      node_type
      extract(const_iterator __pos)
      {
 ;
 return _M_h.extract(__pos);
      }


      node_type
      extract(const key_type& __key)
      { return _M_h.extract(__key); }


      iterator
      insert(node_type&& __nh)
      { return _M_h._M_reinsert_node_multi(cend(), std::move(__nh)); }


      iterator
      insert(const_iterator __hint, node_type&& __nh)
      { return _M_h._M_reinsert_node_multi(__hint, std::move(__nh)); }
# 1684 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      iterator
      erase(const_iterator __position)
      { return _M_h.erase(__position); }


      iterator
      erase(iterator __position)
      { return _M_h.erase(__position); }
# 1705 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_h.erase(__x); }
# 1724 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_h.erase(__first, __last); }







      void
      clear() noexcept
      { _M_h.clear(); }
# 1748 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      void
      swap(unordered_multimap& __x)
      noexcept( noexcept(_M_h.swap(__x._M_h)) )
      { _M_h.swap(__x._M_h); }


      template<typename, typename, typename>
 friend class std::_Hash_merge_helper;

      template<typename _H2, typename _P2>
 void
 merge(unordered_multimap<_Key, _Tp, _H2, _P2, _Alloc>& __source)
 {
   using _Merge_helper
     = _Hash_merge_helper<unordered_multimap, _H2, _P2>;
   _M_h._M_merge_multi(_Merge_helper::_S_get_table(__source));
 }

      template<typename _H2, typename _P2>
 void
 merge(unordered_multimap<_Key, _Tp, _H2, _P2, _Alloc>&& __source)
 { merge(__source); }

      template<typename _H2, typename _P2>
 void
 merge(unordered_map<_Key, _Tp, _H2, _P2, _Alloc>& __source)
 {
   using _Merge_helper
     = _Hash_merge_helper<unordered_multimap, _H2, _P2>;
   _M_h._M_merge_multi(_Merge_helper::_S_get_table(__source));
 }

      template<typename _H2, typename _P2>
 void
 merge(unordered_map<_Key, _Tp, _H2, _P2, _Alloc>&& __source)
 { merge(__source); }






      hasher
      hash_function() const
      { return _M_h.hash_function(); }



      key_equal
      key_eq() const
      { return _M_h.key_eq(); }
# 1814 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      iterator
      find(const key_type& __x)
      { return _M_h.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_h.find(__x); }







      size_type
      count(const key_type& __x) const
      { return _M_h.count(__x); }







      bool
      contains(const key_type& __x) const
      { return _M_h.find(__x) != _M_h.end(); }
# 1850 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_h.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_h.equal_range(__x); }





      size_type
      bucket_count() const noexcept
      { return _M_h.bucket_count(); }


      size_type
      max_bucket_count() const noexcept
      { return _M_h.max_bucket_count(); }






      size_type
      bucket_size(size_type __n) const
      { return _M_h.bucket_size(__n); }






      size_type
      bucket(const key_type& __key) const
      { return _M_h.bucket(__key); }







      local_iterator
      begin(size_type __n)
      { return _M_h.begin(__n); }
# 1906 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      const_local_iterator
      begin(size_type __n) const
      { return _M_h.begin(__n); }

      const_local_iterator
      cbegin(size_type __n) const
      { return _M_h.cbegin(__n); }
# 1921 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      local_iterator
      end(size_type __n)
      { return _M_h.end(__n); }
# 1932 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      const_local_iterator
      end(size_type __n) const
      { return _M_h.end(__n); }

      const_local_iterator
      cend(size_type __n) const
      { return _M_h.cend(__n); }





      float
      load_factor() const noexcept
      { return _M_h.load_factor(); }



      float
      max_load_factor() const noexcept
      { return _M_h.max_load_factor(); }





      void
      max_load_factor(float __z)
      { _M_h.max_load_factor(__z); }
# 1969 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      void
      rehash(size_type __n)
      { _M_h.rehash(__n); }
# 1980 "/usr/local/include/c++/10.0.0/bits/unordered_map.h" 3
      void
      reserve(size_type __n)
      { _M_h.reserve(__n); }

      template<typename _Key1, typename _Tp1, typename _Hash1, typename _Pred1,
        typename _Alloc1>
        friend bool
 operator==(const unordered_multimap<_Key1, _Tp1,
         _Hash1, _Pred1, _Alloc1>&,
     const unordered_multimap<_Key1, _Tp1,
         _Hash1, _Pred1, _Alloc1>&);
    };



  template<typename _InputIterator,
    typename _Hash = hash<__iter_key_t<_InputIterator>>,
    typename _Pred = equal_to<__iter_key_t<_InputIterator>>,
    typename _Allocator = allocator<__iter_to_alloc_t<_InputIterator>>,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireNotAllocatorOrIntegral<_Hash>,
    typename = _RequireNotAllocator<_Pred>,
    typename = _RequireAllocator<_Allocator>>
    unordered_multimap(_InputIterator, _InputIterator,
         unordered_multimap<int, int>::size_type = {},
         _Hash = _Hash(), _Pred = _Pred(),
         _Allocator = _Allocator())
    -> unordered_multimap<__iter_key_t<_InputIterator>,
     __iter_val_t<_InputIterator>, _Hash, _Pred,
     _Allocator>;

  template<typename _Key, typename _Tp, typename _Hash = hash<_Key>,
    typename _Pred = equal_to<_Key>,
    typename _Allocator = allocator<pair<const _Key, _Tp>>,
    typename = _RequireNotAllocatorOrIntegral<_Hash>,
    typename = _RequireNotAllocator<_Pred>,
    typename = _RequireAllocator<_Allocator>>
    unordered_multimap(initializer_list<pair<_Key, _Tp>>,
         unordered_multimap<int, int>::size_type = {},
         _Hash = _Hash(), _Pred = _Pred(),
         _Allocator = _Allocator())
    -> unordered_multimap<_Key, _Tp, _Hash, _Pred, _Allocator>;

  template<typename _InputIterator, typename _Allocator,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireAllocator<_Allocator>>
    unordered_multimap(_InputIterator, _InputIterator,
         unordered_multimap<int, int>::size_type, _Allocator)
    -> unordered_multimap<__iter_key_t<_InputIterator>,
     __iter_val_t<_InputIterator>,
     hash<__iter_key_t<_InputIterator>>,
     equal_to<__iter_key_t<_InputIterator>>, _Allocator>;

  template<typename _InputIterator, typename _Allocator,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireAllocator<_Allocator>>
    unordered_multimap(_InputIterator, _InputIterator, _Allocator)
    -> unordered_multimap<__iter_key_t<_InputIterator>,
     __iter_val_t<_InputIterator>,
     hash<__iter_key_t<_InputIterator>>,
     equal_to<__iter_key_t<_InputIterator>>, _Allocator>;

  template<typename _InputIterator, typename _Hash, typename _Allocator,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireNotAllocatorOrIntegral<_Hash>,
    typename = _RequireAllocator<_Allocator>>
    unordered_multimap(_InputIterator, _InputIterator,
         unordered_multimap<int, int>::size_type, _Hash,
         _Allocator)
    -> unordered_multimap<__iter_key_t<_InputIterator>,
     __iter_val_t<_InputIterator>, _Hash,
     equal_to<__iter_key_t<_InputIterator>>, _Allocator>;

  template<typename _Key, typename _Tp, typename _Allocator,
    typename = _RequireAllocator<_Allocator>>
    unordered_multimap(initializer_list<pair<_Key, _Tp>>,
         unordered_multimap<int, int>::size_type,
         _Allocator)
    -> unordered_multimap<_Key, _Tp, hash<_Key>, equal_to<_Key>, _Allocator>;

  template<typename _Key, typename _Tp, typename _Allocator,
    typename = _RequireAllocator<_Allocator>>
    unordered_multimap(initializer_list<pair<_Key, _Tp>>, _Allocator)
    -> unordered_multimap<_Key, _Tp, hash<_Key>, equal_to<_Key>, _Allocator>;

  template<typename _Key, typename _Tp, typename _Hash, typename _Allocator,
    typename = _RequireNotAllocatorOrIntegral<_Hash>,
    typename = _RequireAllocator<_Allocator>>
    unordered_multimap(initializer_list<pair<_Key, _Tp>>,
         unordered_multimap<int, int>::size_type,
         _Hash, _Allocator)
    -> unordered_multimap<_Key, _Tp, _Hash, equal_to<_Key>, _Allocator>;



  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline void
    swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
  unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline void
    swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
  unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { return __x._M_h._M_equal(__y._M_h); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { return !(__x == __y); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { return __x._M_h._M_equal(__y._M_h); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { return !(__x == __y); }





  template<typename _Key, typename _Val, typename _Hash1, typename _Eq1,
    typename _Alloc, typename _Hash2, typename _Eq2>
    struct _Hash_merge_helper<
      std::unordered_map<_Key, _Val, _Hash1, _Eq1, _Alloc>,
      _Hash2, _Eq2>
    {
    private:
      template<typename... _Tp>
 using unordered_map = std::unordered_map<_Tp...>;
      template<typename... _Tp>
 using unordered_multimap = std::unordered_multimap<_Tp...>;

      friend unordered_map<_Key, _Val, _Hash1, _Eq1, _Alloc>;

      static auto&
      _S_get_table(unordered_map<_Key, _Val, _Hash2, _Eq2, _Alloc>& __map)
      { return __map._M_h; }

      static auto&
      _S_get_table(unordered_multimap<_Key, _Val, _Hash2, _Eq2, _Alloc>& __map)
      { return __map._M_h; }
    };


  template<typename _Key, typename _Val, typename _Hash1, typename _Eq1,
    typename _Alloc, typename _Hash2, typename _Eq2>
    struct _Hash_merge_helper<
      std::unordered_multimap<_Key, _Val, _Hash1, _Eq1, _Alloc>,
      _Hash2, _Eq2>
    {
    private:
      template<typename... _Tp>
 using unordered_map = std::unordered_map<_Tp...>;
      template<typename... _Tp>
 using unordered_multimap = std::unordered_multimap<_Tp...>;

      friend unordered_multimap<_Key, _Val, _Hash1, _Eq1, _Alloc>;

      static auto&
      _S_get_table(unordered_map<_Key, _Val, _Hash2, _Eq2, _Alloc>& __map)
      { return __map._M_h; }

      static auto&
      _S_get_table(unordered_multimap<_Key, _Val, _Hash2, _Eq2, _Alloc>& __map)
      { return __map._M_h; }
    };



}
# 48 "/usr/local/include/c++/10.0.0/unordered_map" 2 3

# 1 "/usr/local/include/c++/10.0.0/bits/erase_if.h" 1 3
# 33 "/usr/local/include/c++/10.0.0/bits/erase_if.h" 3
       
# 34 "/usr/local/include/c++/10.0.0/bits/erase_if.h" 3



namespace std
{






  namespace __detail
  {
    template<typename _Container, typename _Predicate>
      typename _Container::size_type
      __erase_nodes_if(_Container& __cont, _Predicate __pred)
      {
 typename _Container::size_type __num = 0;
 for (auto __iter = __cont.begin(), __last = __cont.end();
      __iter != __last;)
   {
     if (__pred(*__iter))
       {
  __iter = __cont.erase(__iter);
  ++__num;
       }
     else
       ++__iter;
   }
 return __num;
      }
  }


}
# 50 "/usr/local/include/c++/10.0.0/unordered_map" 2 3






namespace std __attribute__ ((__visibility__ ("default")))
{

  namespace pmr
  {
    template<typename _Tp> class polymorphic_allocator;
    template<typename _Key, typename _Tp, typename _Hash = std::hash<_Key>,
      typename _Pred = std::equal_to<_Key>>
      using unordered_map
 = std::unordered_map<_Key, _Tp, _Hash, _Pred,
        polymorphic_allocator<pair<const _Key, _Tp>>>;
    template<typename _Key, typename _Tp, typename _Hash = std::hash<_Key>,
      typename _Pred = std::equal_to<_Key>>
      using unordered_multimap
 = std::unordered_multimap<_Key, _Tp, _Hash, _Pred,
      polymorphic_allocator<pair<const _Key, _Tp>>>;
  }

}



namespace std __attribute__ ((__visibility__ ("default")))
{

  template<typename _Key, typename _Tp, typename _Hash, typename _CPred,
    typename _Alloc, typename _Predicate>
    inline typename unordered_map<_Key, _Tp, _Hash, _CPred, _Alloc>::size_type
    erase_if(unordered_map<_Key, _Tp, _Hash, _CPred, _Alloc>& __cont,
      _Predicate __pred)
    { return __detail::__erase_nodes_if(__cont, __pred); }

  template<typename _Key, typename _Tp, typename _Hash, typename _CPred,
    typename _Alloc, typename _Predicate>
    inline typename unordered_multimap<_Key, _Tp, _Hash, _CPred, _Alloc>::
      size_type
    erase_if(unordered_multimap<_Key, _Tp, _Hash, _CPred, _Alloc>& __cont,
      _Predicate __pred)
    { return __detail::__erase_nodes_if(__cont, __pred); }

}
# 62 "/usr/local/include/c++/10.0.0/functional" 2 3
# 1 "/usr/local/include/c++/10.0.0/vector" 1 3
# 58 "/usr/local/include/c++/10.0.0/vector" 3
       
# 59 "/usr/local/include/c++/10.0.0/vector" 3
# 67 "/usr/local/include/c++/10.0.0/vector" 3
# 1 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 1 3
# 74 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_Tp>::other _Tp_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer
        pointer;

      struct _Vector_impl_data
      {
 pointer _M_start;
 pointer _M_finish;
 pointer _M_end_of_storage;

 _Vector_impl_data() noexcept
 : _M_start(), _M_finish(), _M_end_of_storage()
 { }


 _Vector_impl_data(_Vector_impl_data&& __x) noexcept
 : _M_start(__x._M_start), _M_finish(__x._M_finish),
   _M_end_of_storage(__x._M_end_of_storage)
 { __x._M_start = __x._M_finish = __x._M_end_of_storage = pointer(); }


 void
 _M_copy_data(_Vector_impl_data const& __x) noexcept
 {
   _M_start = __x._M_start;
   _M_finish = __x._M_finish;
   _M_end_of_storage = __x._M_end_of_storage;
 }

 void
 _M_swap_data(_Vector_impl_data& __x) noexcept
 {


   _Vector_impl_data __tmp;
   __tmp._M_copy_data(*this);
   _M_copy_data(__x);
   __x._M_copy_data(__tmp);
 }
      };

      struct _Vector_impl
 : public _Tp_alloc_type, public _Vector_impl_data
      {
 _Vector_impl() noexcept(is_nothrow_default_constructible<_Tp_alloc_type>::value)

 : _Tp_alloc_type()
 { }

 _Vector_impl(_Tp_alloc_type const& __a) noexcept
 : _Tp_alloc_type(__a)
 { }




 _Vector_impl(_Vector_impl&& __x) noexcept
 : _Tp_alloc_type(std::move(__x)), _Vector_impl_data(std::move(__x))
 { }

 _Vector_impl(_Tp_alloc_type&& __a) noexcept
 : _Tp_alloc_type(std::move(__a))
 { }

 _Vector_impl(_Tp_alloc_type&& __a, _Vector_impl&& __rv) noexcept
 : _Tp_alloc_type(std::move(__a)), _Vector_impl_data(std::move(__rv))
 { }
# 267 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator() noexcept
      { return this->_M_impl; }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const noexcept
      { return this->_M_impl; }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Tp_allocator()); }


      _Vector_base() = default;




      _Vector_base(const allocator_type& __a) noexcept
      : _M_impl(__a) { }



      _Vector_base(size_t __n)
      : _M_impl()
      { _M_create_storage(__n); }


      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      { _M_create_storage(__n); }


      _Vector_base(_Vector_base&&) = default;



      _Vector_base(_Tp_alloc_type&& __a) noexcept
      : _M_impl(std::move(__a)) { }

      _Vector_base(_Vector_base&& __x, const allocator_type& __a)
      : _M_impl(__a)
      {
 if (__x.get_allocator() == __a)
   this->_M_impl._M_swap_data(__x._M_impl);
 else
   {
     size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;
     _M_create_storage(__n);
   }
      }


      _Vector_base(const allocator_type& __a, _Vector_base&& __x)
      : _M_impl(_Tp_alloc_type(__a), std::move(__x._M_impl))
      { }


      ~_Vector_base() noexcept
      {
 _M_deallocate(_M_impl._M_start,
        _M_impl._M_end_of_storage - _M_impl._M_start);
      }

    public:
      _Vector_impl _M_impl;

      pointer
      _M_allocate(size_t __n)
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
      }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 if (__p)
   _Tr::deallocate(_M_impl, __p, __n);
      }

    protected:
      void
      _M_create_storage(size_t __n)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
    };
# 385 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {
# 398 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      static_assert(is_same<typename remove_cv<_Tp>::type, _Tp>::value,
   "std::vector must have a non-const, non-volatile value_type");

      static_assert(is_same<typename _Alloc::value_type, _Tp>::value,
   "std::vector must have the same value_type as its allocator");



      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;

    public:
      typedef _Tp value_type;
      typedef typename _Base::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    private:

      static constexpr bool
      _S_nothrow_relocate(true_type)
      {
 return noexcept(std::__relocate_a(std::declval<pointer>(),
       std::declval<pointer>(),
       std::declval<pointer>(),
       std::declval<_Tp_alloc_type&>()));
      }

      static constexpr bool
      _S_nothrow_relocate(false_type)
      { return false; }

      static constexpr bool
      _S_use_relocate()
      {



 return _S_nothrow_relocate(__is_move_insertable<_Tp_alloc_type>{});
      }

      static pointer
      _S_do_relocate(pointer __first, pointer __last, pointer __result,
       _Tp_alloc_type& __alloc, true_type) noexcept
      {
 return std::__relocate_a(__first, __last, __result, __alloc);
      }

      static pointer
      _S_do_relocate(pointer, pointer, pointer __result,
       _Tp_alloc_type&, false_type) noexcept
      { return __result; }

      static pointer
      _S_relocate(pointer __first, pointer __last, pointer __result,
    _Tp_alloc_type& __alloc) noexcept
      {
 using __do_it = __bool_constant<_S_use_relocate()>;
 return _S_do_relocate(__first, __last, __result, __alloc, __do_it{});
      }


    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:







      vector() = default;
# 493 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      explicit
      vector(const allocator_type& __a) noexcept
      : _Base(__a) { }
# 506 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      explicit
      vector(size_type __n, const allocator_type& __a = allocator_type())
      : _Base(_S_check_init_len(__n, __a), __a)
      { _M_default_initialize(__n); }
# 519 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      vector(size_type __n, const value_type& __value,
      const allocator_type& __a = allocator_type())
      : _Base(_S_check_init_len(__n, __a), __a)
      { _M_fill_initialize(__n, __value); }
# 550 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(),
 _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
      {
 this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
# 569 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      vector(vector&&) noexcept = default;


      vector(const vector& __x, const allocator_type& __a)
      : _Base(__x.size(), __a)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }

    private:
      vector(vector&& __rv, const allocator_type& __m, true_type) noexcept
      : _Base(__m, std::move(__rv))
      { }

      vector(vector&& __rv, const allocator_type& __m, false_type)
      : _Base(__m)
      {
 if (__rv.get_allocator() == __m)
   this->_M_impl._M_swap_data(__rv._M_impl);
 else if (!__rv.empty())
   {
     this->_M_create_storage(__rv.size());
     this->_M_impl._M_finish =
       std::__uninitialized_move_a(__rv.begin(), __rv.end(),
       this->_M_impl._M_start,
       _M_get_Tp_allocator());
     __rv.clear();
   }
      }

    public:

      vector(vector&& __rv, const allocator_type& __m)
      noexcept( noexcept(
 vector(std::declval<vector&&>(), std::declval<const allocator_type&>(),
        std::declval<typename _Alloc_traits::is_always_equal>())) )
      : vector(std::move(__rv), __m, typename _Alloc_traits::is_always_equal{})
      { }
# 622 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      vector(initializer_list<value_type> __l,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_range_initialize(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }
# 648 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
 {
   _M_range_initialize(__first, __last,
         std::__iterator_category(__first));
 }
# 675 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      ~vector() noexcept
      {
 std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator());
 ;
      }
# 691 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
# 705 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      vector&
      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
      {
 constexpr bool __move_storage =
   _Alloc_traits::_S_propagate_on_move_assign()
   || _Alloc_traits::_S_always_equal();
 _M_move_assign(std::move(__x), __bool_constant<__move_storage>());
 return *this;
      }
# 726 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      vector&
      operator=(initializer_list<value_type> __l)
      {
 this->_M_assign_aux(__l.begin(), __l.end(),
       random_access_iterator_tag());
 return *this;
      }
# 745 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 762 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 void
 assign(_InputIterator __first, _InputIterator __last)
 { _M_assign_dispatch(__first, __last, __false_type()); }
# 790 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      void
      assign(initializer_list<value_type> __l)
      {
 this->_M_assign_aux(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }



      using _Base::get_allocator;







      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_start); }






      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      iterator
      end() noexcept
      { return iterator(this->_M_impl._M_finish); }






      const_iterator
      end() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }







      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }




      size_type
      size() const noexcept
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }


      size_type
      max_size() const noexcept
      { return _S_max_size(_M_get_Tp_allocator()); }
# 933 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      void
      resize(size_type __new_size)
      {
 if (__new_size > size())
   _M_default_append(__new_size - size());
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 953 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, const value_type& __x)
      {
 if (__new_size > size())
   _M_fill_insert(end(), __new_size - size(), __x);
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 985 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      void
      shrink_to_fit()
      { _M_shrink_to_fit(); }






      size_type
      capacity() const noexcept
      { return size_type(this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start); }





      [[__nodiscard__]] bool
      empty() const noexcept
      { return begin() == end(); }
# 1024 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
# 1039 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      reference
      operator[](size_type __n) noexcept
      {
 ;
 return *(this->_M_impl._M_start + __n);
      }
# 1057 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const noexcept
      {
 ;
 return *(this->_M_impl._M_start + __n);
      }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("vector::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
      }

    public:
# 1088 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 1106 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front() noexcept
      {
 ;
 return *begin();
      }





      const_reference
      front() const noexcept
      {
 ;
 return *begin();
      }





      reference
      back() noexcept
      {
 ;
 return *(end() - 1);
      }





      const_reference
      back() const noexcept
      {
 ;
 return *(end() - 1);
      }
# 1164 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      _Tp*
      data() noexcept
      { return _M_data_ptr(this->_M_impl._M_start); }

      const _Tp*
      data() const noexcept
      { return _M_data_ptr(this->_M_impl._M_start); }
# 1183 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     ;
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         __x);
     ++this->_M_impl._M_finish;
     ;
   }
 else
   _M_realloc_insert(end(), __x);
      }


      void
      push_back(value_type&& __x)
      { emplace_back(std::move(__x)); }

      template<typename... _Args>

 reference



 emplace_back(_Args&&... __args);
# 1221 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      void
      pop_back() noexcept
      {
 ;
 --this->_M_impl._M_finish;
 _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
 ;
      }
# 1243 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      template<typename... _Args>
 iterator
 emplace(const_iterator __position, _Args&&... __args)
 { return _M_emplace_aux(__position, std::forward<_Args>(__args)...); }
# 1259 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x);
# 1289 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, value_type&& __x)
      { return _M_insert_rval(__position, std::move(__x)); }
# 1306 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, initializer_list<value_type> __l)
      {
 auto __offset = __position - cbegin();
 _M_range_insert(begin() + __offset, __l.begin(), __l.end(),
   std::random_access_iterator_tag());
 return begin() + __offset;
      }
# 1331 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, size_type __n, const value_type& __x)
      {
 difference_type __offset = __position - cbegin();
 _M_fill_insert(begin() + __offset, __n, __x);
 return begin() + __offset;
      }
# 1373 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
 insert(const_iterator __position, _InputIterator __first,
        _InputIterator __last)
 {
   difference_type __offset = __position - cbegin();
   _M_insert_dispatch(begin() + __offset,
        __first, __last, __false_type());
   return begin() + __offset;
 }
# 1425 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      iterator

      erase(const_iterator __position)
      { return _M_erase(begin() + (__position - cbegin())); }
# 1452 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      iterator

      erase(const_iterator __first, const_iterator __last)
      {
 const auto __beg = begin();
 const auto __cbeg = cbegin();
 return _M_erase(__beg + (__first - __cbeg), __beg + (__last - __cbeg));
      }
# 1476 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      void
      swap(vector& __x) noexcept
      {


                                                          ;

 this->_M_impl._M_swap_data(__x._M_impl);
 _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
      __x._M_get_Tp_allocator());
      }







      void
      clear() noexcept
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:




      template<typename _ForwardIterator>
 pointer
 _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
 {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }
# 1553 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      template<typename _InputIterator>
 void
 _M_range_initialize(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag)
 {
   try {
     for (; __first != __last; ++__first)

       emplace_back(*__first);



   } catch(...) {
     clear();
     throw;
   }
 }


      template<typename _ForwardIterator>
 void
 _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag)
 {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start
     = this->_M_allocate(_S_check_init_len(__n, _M_get_Tp_allocator()));
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __value)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
     _M_get_Tp_allocator());
      }



      void
      _M_default_initialize(size_type __n)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
        _M_get_Tp_allocator());
      }
# 1615 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      template<typename _Integer>
 void
 _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
 { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
 void
 _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
 { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }


      template<typename _InputIterator>
 void
 _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
 void
 _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);







      template<typename _Integer>
 void
 _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
 { _M_fill_insert(__pos, __n, __val); }


      template<typename _InputIterator>
 void
 _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
 {
   _M_range_insert(__pos, __first, __last,
     std::__iterator_category(__first));
 }


      template<typename _InputIterator>
 void
 _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
 void
 _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);



      void
      _M_default_append(size_type __n);

      bool
      _M_shrink_to_fit();
# 1702 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
      struct _Temporary_value
      {
 template<typename... _Args>
   explicit
   _Temporary_value(vector* __vec, _Args&&... __args) : _M_this(__vec)
   {
     _Alloc_traits::construct(_M_this->_M_impl, _M_ptr(),
         std::forward<_Args>(__args)...);
   }

 ~_Temporary_value()
 { _Alloc_traits::destroy(_M_this->_M_impl, _M_ptr()); }

 value_type&
 _M_val() { return *_M_ptr(); }

      private:
 _Tp*
 _M_ptr() { return reinterpret_cast<_Tp*>(&__buf); }

 vector* _M_this;
 typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __buf;
      };



      template<typename _Arg>
 void
 _M_insert_aux(iterator __position, _Arg&& __arg);

      template<typename... _Args>
 void
 _M_realloc_insert(iterator __position, _Args&&... __args);


      iterator
      _M_insert_rval(const_iterator __position, value_type&& __v);


      template<typename... _Args>
 iterator
 _M_emplace_aux(const_iterator __position, _Args&&... __args);


      iterator
      _M_emplace_aux(const_iterator __position, value_type&& __v)
      { return _M_insert_rval(__position, std::move(__v)); }



      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + (std::max)(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }


      static size_type
      _S_check_init_len(size_type __n, const allocator_type& __a)
      {
 if (__n > _S_max_size(_Tp_alloc_type(__a)))
   __throw_length_error(
       ("cannot create std::vector larger than max_size()"));
 return __n;
      }

      static size_type
      _S_max_size(const _Tp_alloc_type& __a) noexcept
      {



 const size_t __diffmax
   = __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
 const size_t __allocmax = _Alloc_traits::max_size(__a);
 return (std::min)(__diffmax, __allocmax);
      }





      void
      _M_erase_at_end(pointer __pos) noexcept
      {
 if (size_type __n = this->_M_impl._M_finish - __pos)
   {
     std::_Destroy(__pos, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     this->_M_impl._M_finish = __pos;
     ;
   }
      }

      iterator
      _M_erase(iterator __position);

      iterator
      _M_erase(iterator __first, iterator __last);


    private:



      void
      _M_move_assign(vector&& __x, true_type) noexcept
      {
 vector __tmp(get_allocator());
 this->_M_impl._M_swap_data(__x._M_impl);
 __tmp._M_impl._M_swap_data(__x._M_impl);
 std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
      }



      void
      _M_move_assign(vector&& __x, false_type)
      {
 if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
   _M_move_assign(std::move(__x), true_type());
 else
   {


     this->_M_assign_aux(std::make_move_iterator(__x.begin()),
           std::make_move_iterator(__x.end()),
    std::random_access_iterator_tag());
     __x.clear();
   }
      }


      template<typename _Up>
 _Up*
 _M_data_ptr(_Up* __ptr) const noexcept
 { return __ptr; }


      template<typename _Ptr>
 typename std::pointer_traits<_Ptr>::element_type*
 _M_data_ptr(_Ptr __ptr) const
 { return empty() ? nullptr : std::__to_address(__ptr); }
# 1865 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
    };


  template<typename _InputIterator, typename _ValT
      = typename iterator_traits<_InputIterator>::value_type,
    typename _Allocator = allocator<_ValT>,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireAllocator<_Allocator>>
    vector(_InputIterator, _InputIterator, _Allocator = _Allocator())
      -> vector<_ValT, _Allocator>;
# 1887 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
# 1904 "/usr/local/include/c++/10.0.0/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }




  namespace __detail::__variant
  {
    template<typename> struct _Never_valueless_alt;



    template<typename _Tp, typename _Alloc>
      struct _Never_valueless_alt<std::vector<_Tp, _Alloc>>
      : std::is_nothrow_move_assignable<std::vector<_Tp, _Alloc>>
      { };
  }



}
# 68 "/usr/local/include/c++/10.0.0/vector" 2 3
# 1 "/usr/local/include/c++/10.0.0/bits/stl_bvector.h" 1 3
# 64 "/usr/local/include/c++/10.0.0/bits/stl_bvector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() noexcept : _M_p(0), _M_mask(0) { }


    _Bit_reference(const _Bit_reference&) = default;


    operator bool() const noexcept
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x) noexcept
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x) noexcept
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip() noexcept
    { *_M_p ^= _M_mask; }
  };


  inline void
  swap(_Bit_reference __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(_Bit_reference __x, bool& __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(bool& __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }


  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }

    friend bool
    operator==(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
    { return __x._M_p == __y._M_p && __x._M_offset == __y._M_offset; }

    friend bool
    operator<(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
    {
      return __x._M_p < __y._M_p
     || (__x._M_p == __y._M_p && __x._M_offset < __y._M_offset);
    }

    friend bool
    operator!=(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
    { return !(__x == __y); }

    friend bool
    operator>(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
    { return __y < __x; }

    friend bool
    operator<=(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
    { return !(__y < __x); }

    friend bool
    operator>=(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
    { return !(__x < __y); }

    friend ptrdiff_t
    operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
    {
      return (int(_S_word_bit) * (__x._M_p - __y._M_p)
       + __x._M_offset - __y._M_offset);
    }
  };

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;

    typedef void pointer;



    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    iterator
    _M_const_cast() const
    { return *this; }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }

    friend iterator
    operator+(const iterator& __x, difference_type __n)
    {
      iterator __tmp = __x;
      __tmp += __n;
      return __tmp;
    }

    friend iterator
    operator+(difference_type __n, const iterator& __x)
    { return __x + __n; }

    friend iterator
    operator-(const iterator& __x, difference_type __n)
    {
      iterator __tmp = __x;
      __tmp -= __n;
      return __tmp;
    }
  };

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;

    typedef void pointer;



    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    _Bit_iterator
    _M_const_cast() const
    { return _Bit_iterator(_M_p, _M_offset); }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }

    friend const_iterator
    operator+(const const_iterator& __x, difference_type __n)
    {
      const_iterator __tmp = __x;
      __tmp += __n;
      return __tmp;
    }

    friend const_iterator
    operator-(const const_iterator& __x, difference_type __n)
    {
      const_iterator __tmp = __x;
      __tmp -= __n;
      return __tmp;
    }

    friend const_iterator
    operator+(difference_type __n, const const_iterator& __x)
    { return __x + __n; }
  };

  inline void
  __fill_bvector(_Bit_type * __v,
   unsigned int __first, unsigned int __last, bool __x)
  {
    const _Bit_type __fmask = ~0ul << __first;
    const _Bit_type __lmask = ~0ul >> (_S_word_bit - __last);
    const _Bit_type __mask = __fmask & __lmask;

    if (__x)
      *__v |= __mask;
    else
      *__v &= ~__mask;
  }

  inline void
  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
 _Bit_type* __first_p = __first._M_p;
 if (__first._M_offset != 0)
   __fill_bvector(__first_p++, __first._M_offset, _S_word_bit, __x);

 __builtin_memset(__first_p, __x ? ~0 : 0,
    (__last._M_p - __first_p) * sizeof(_Bit_type));

 if (__last._M_offset != 0)
   __fill_bvector(__last._M_p, 0, __last._M_offset, __x);
      }
    else if (__first._M_offset != __last._M_offset)
      __fill_bvector(__first._M_p, __first._M_offset, __last._M_offset, __x);
  }

  template<typename _Alloc>
    struct _Bvector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
        rebind<_Bit_type>::other _Bit_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Bit_alloc_type>
 _Bit_alloc_traits;
      typedef typename _Bit_alloc_traits::pointer _Bit_pointer;

      struct _Bvector_impl_data
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_pointer _M_end_of_storage;

 _Bvector_impl_data() noexcept
 : _M_start(), _M_finish(), _M_end_of_storage()
 { }


 _Bvector_impl_data(_Bvector_impl_data&& __x) noexcept
 : _M_start(__x._M_start), _M_finish(__x._M_finish)
 , _M_end_of_storage(__x._M_end_of_storage)
 { __x._M_reset(); }

 void
 _M_move_data(_Bvector_impl_data&& __x) noexcept
 {
   this->_M_start = __x._M_start;
   this->_M_finish = __x._M_finish;
   this->_M_end_of_storage = __x._M_end_of_storage;
   __x._M_reset();
 }


 void
 _M_reset() noexcept
 {
   _M_start = _M_finish = _Bit_iterator();
   _M_end_of_storage = _Bit_pointer();
 }
      };

      struct _Bvector_impl
 : public _Bit_alloc_type, public _Bvector_impl_data
 {
 public:
   _Bvector_impl() noexcept(is_nothrow_default_constructible<_Bit_alloc_type>::value)

   : _Bit_alloc_type()
   { }

   _Bvector_impl(const _Bit_alloc_type& __a) noexcept
   : _Bit_alloc_type(__a)
   { }


 _Bvector_impl(_Bvector_impl&&) = default;


 _Bit_type*
 _M_end_addr() const noexcept
 {
   if (this->_M_end_of_storage)
     return std::__addressof(this->_M_end_of_storage[-1]) + 1;
   return 0;
 }
      };

    public:
      typedef _Alloc allocator_type;

      _Bit_alloc_type&
      _M_get_Bit_allocator() noexcept
      { return this->_M_impl; }

      const _Bit_alloc_type&
      _M_get_Bit_allocator() const noexcept
      { return this->_M_impl; }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Bit_allocator()); }


      _Bvector_base() = default;




      _Bvector_base(const allocator_type& __a)
      : _M_impl(__a) { }


      _Bvector_base(_Bvector_base&&) = default;


      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_pointer
      _M_allocate(size_t __n)
      { return _Bit_alloc_traits::allocate(_M_impl, _S_nword(__n)); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   {
     const size_t __n = _M_impl._M_end_addr() - _M_impl._M_start._M_p;
     _Bit_alloc_traits::deallocate(_M_impl,
       _M_impl._M_end_of_storage - __n,
       __n);
     _M_impl._M_reset();
   }
      }


      void
      _M_move_data(_Bvector_base&& __x) noexcept
      { _M_impl._M_move_data(std::move(__x._M_impl)); }


      static size_t
      _S_nword(size_t __n)
      { return (__n + int(_S_word_bit) - 1) / int(_S_word_bit); }
    };



}




namespace std __attribute__ ((__visibility__ ("default")))
{


# 603 "/usr/local/include/c++/10.0.0/bits/stl_bvector.h" 3
  template<typename _Alloc>
    class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
    {
      typedef _Bvector_base<_Alloc> _Base;
      typedef typename _Base::_Bit_pointer _Bit_pointer;
      typedef typename _Base::_Bit_alloc_traits _Bit_alloc_traits;


      friend struct std::hash<vector>;


    public:
      typedef bool value_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Bit_reference reference;
      typedef bool const_reference;
      typedef _Bit_reference* pointer;
      typedef const bool* const_pointer;
      typedef _Bit_iterator iterator;
      typedef _Bit_const_iterator const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef _Alloc allocator_type;

      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_S_nword;
      using _Base::_M_get_Bit_allocator;

    public:

      vector() = default;




      explicit
      vector(const allocator_type& __a)
      : _Base(__a) { }


      explicit
      vector(size_type __n, const allocator_type& __a = allocator_type())
      : vector(__n, false, __a)
      { }

      vector(size_type __n, const bool& __value,
      const allocator_type& __a = allocator_type())





      : _Base(__a)
      {
 _M_initialize(__n);
 _M_initialize_value(__value);
      }

      vector(const vector& __x)
      : _Base(_Bit_alloc_traits::_S_select_on_copy(__x._M_get_Bit_allocator()))
      {
 _M_initialize(__x.size());
 _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
      }


      vector(vector&&) = default;

      vector(vector&& __x, const allocator_type& __a)
      noexcept(_Bit_alloc_traits::_S_always_equal())
      : _Base(__a)
      {
 if (__x.get_allocator() == __a)
   this->_M_move_data(std::move(__x));
 else
   {
     _M_initialize(__x.size());
     _M_copy_aligned(__x.begin(), __x.end(), begin());
     __x.clear();
   }
      }

      vector(const vector& __x, const allocator_type& __a)
      : _Base(__a)
      {
 _M_initialize(__x.size());
 _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
      }

      vector(initializer_list<bool> __l,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_initialize_range(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }



      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
 { _M_initialize_dispatch(__first, __last, __false_type()); }
# 726 "/usr/local/include/c++/10.0.0/bits/stl_bvector.h" 3
      ~vector() noexcept { }

      vector&
      operator=(const vector& __x)
      {
 if (&__x == this)
   return *this;

 if (_Bit_alloc_traits::_S_propagate_on_copy_assign())
   {
     if (this->_M_get_Bit_allocator() != __x._M_get_Bit_allocator())
       {
  this->_M_deallocate();
  std::__alloc_on_copy(_M_get_Bit_allocator(),
         __x._M_get_Bit_allocator());
  _M_initialize(__x.size());
       }
     else
       std::__alloc_on_copy(_M_get_Bit_allocator(),
       __x._M_get_Bit_allocator());
   }

 if (__x.size() > capacity())
   {
     this->_M_deallocate();
     _M_initialize(__x.size());
   }
 this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
        begin());
 return *this;
      }


      vector&
      operator=(vector&& __x) noexcept(_Bit_alloc_traits::_S_nothrow_move())
      {
 if (_Bit_alloc_traits::_S_propagate_on_move_assign()
     || this->_M_get_Bit_allocator() == __x._M_get_Bit_allocator())
   {
     this->_M_deallocate();
     this->_M_move_data(std::move(__x));
     std::__alloc_on_move(_M_get_Bit_allocator(),
     __x._M_get_Bit_allocator());
   }
 else
   {
     if (__x.size() > capacity())
       {
  this->_M_deallocate();
  _M_initialize(__x.size());
       }
     this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
            begin());
     __x.clear();
   }
 return *this;
      }

      vector&
      operator=(initializer_list<bool> __l)
      {
 this->assign (__l.begin(), __l.end());
 return *this;
      }






      void
      assign(size_type __n, const bool& __x)
      { _M_fill_assign(__n, __x); }


      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 void
 assign(_InputIterator __first, _InputIterator __last)
 { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }
# 817 "/usr/local/include/c++/10.0.0/bits/stl_bvector.h" 3
      void
      assign(initializer_list<bool> __l)
      { _M_assign_aux(__l.begin(), __l.end(), random_access_iterator_tag()); }


      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_start._M_p, 0); }

      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_start._M_p, 0); }

      iterator
      end() noexcept
      { return this->_M_impl._M_finish; }

      const_iterator
      end() const noexcept
      { return this->_M_impl._M_finish; }

      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }


      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_impl._M_start._M_p, 0); }

      const_iterator
      cend() const noexcept
      { return this->_M_impl._M_finish; }

      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }

      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }


      size_type
      size() const noexcept
      { return size_type(end() - begin()); }

      size_type
      max_size() const noexcept
      {
 const size_type __isize =
   __gnu_cxx::__numeric_traits<difference_type>::__max
   - int(_S_word_bit) + 1;
 const size_type __asize
   = _Bit_alloc_traits::max_size(_M_get_Bit_allocator());
 return (__asize <= __isize / int(_S_word_bit)
  ? __asize * int(_S_word_bit) : __isize);
      }

      size_type
      capacity() const noexcept
      { return size_type(const_iterator(this->_M_impl._M_end_addr(), 0)
    - begin()); }

      [[__nodiscard__]] bool
      empty() const noexcept
      { return begin() == end(); }

      reference
      operator[](size_type __n)
      {
 return *iterator(this->_M_impl._M_start._M_p
    + __n / int(_S_word_bit), __n % int(_S_word_bit));
      }

      const_reference
      operator[](size_type __n) const
      {
 return *const_iterator(this->_M_impl._M_start._M_p
        + __n / int(_S_word_bit), __n % int(_S_word_bit));
      }

    protected:
      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("vector<bool>::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
      }

    public:
      reference
      at(size_type __n)
      { _M_range_check(__n); return (*this)[__n]; }

      const_reference
      at(size_type __n) const
      { _M_range_check(__n); return (*this)[__n]; }

      void
      reserve(size_type __n)
      {
 if (__n > max_size())
   __throw_length_error(("vector::reserve"));
 if (capacity() < __n)
   _M_reallocate(__n);
      }

      reference
      front()
      { return *begin(); }

      const_reference
      front() const
      { return *begin(); }

      reference
      back()
      { return *(end() - 1); }

      const_reference
      back() const
      { return *(end() - 1); }






      void
      data() noexcept { }

      void
      push_back(bool __x)
      {
 if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
   *this->_M_impl._M_finish++ = __x;
 else
   _M_insert_aux(end(), __x);
      }

      void
      swap(vector& __x) noexcept
      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_end_of_storage,
    __x._M_impl._M_end_of_storage);
 _Bit_alloc_traits::_S_on_swap(_M_get_Bit_allocator(),
          __x._M_get_Bit_allocator());
      }


      static void
      swap(reference __x, reference __y) noexcept
      {
 bool __tmp = __x;
 __x = __y;
 __y = __tmp;
      }

      iterator

      insert(const_iterator __position, const bool& __x = bool())



      {
 const difference_type __n = __position - begin();
 if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr()
     && __position == end())
   *this->_M_impl._M_finish++ = __x;
 else
   _M_insert_aux(__position._M_const_cast(), __x);
 return begin() + __n;
      }


      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
 insert(const_iterator __position,
        _InputIterator __first, _InputIterator __last)
 {
   difference_type __offset = __position - cbegin();
   _M_insert_dispatch(__position._M_const_cast(),
        __first, __last, __false_type());
   return begin() + __offset;
 }
# 1033 "/usr/local/include/c++/10.0.0/bits/stl_bvector.h" 3
      iterator
      insert(const_iterator __position, size_type __n, const bool& __x)
      {
 difference_type __offset = __position - cbegin();
 _M_fill_insert(__position._M_const_cast(), __n, __x);
 return begin() + __offset;
      }







      iterator
      insert(const_iterator __p, initializer_list<bool> __l)
      { return this->insert(__p, __l.begin(), __l.end()); }


      void
      pop_back()
      { --this->_M_impl._M_finish; }

      iterator

      erase(const_iterator __position)



      { return _M_erase(__position._M_const_cast()); }

      iterator

      erase(const_iterator __first, const_iterator __last)



      { return _M_erase(__first._M_const_cast(), __last._M_const_cast()); }

      void
      resize(size_type __new_size, bool __x = bool())
      {
 if (__new_size < size())
   _M_erase_at_end(begin() + difference_type(__new_size));
 else
   insert(end(), __new_size - size(), __x);
      }


      void
      shrink_to_fit()
      { _M_shrink_to_fit(); }


      void
      flip() noexcept
      {
 _Bit_type * const __end = this->_M_impl._M_end_addr();
 for (_Bit_type * __p = this->_M_impl._M_start._M_p; __p != __end; ++__p)
   *__p = ~*__p;
      }

      void
      clear() noexcept
      { _M_erase_at_end(begin()); }


      template<typename... _Args>

 reference



 emplace_back(_Args&&... __args)
 {
   push_back(bool(__args...));

   return back();

 }

      template<typename... _Args>
 iterator
 emplace(const_iterator __pos, _Args&&... __args)
 { return insert(__pos, bool(__args...)); }


    protected:

      iterator
      _M_copy_aligned(const_iterator __first, const_iterator __last,
        iterator __result)
      {
 _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
 return std::copy(const_iterator(__last._M_p, 0), __last,
    iterator(__q, 0));
      }

      void
      _M_initialize(size_type __n)
      {
 if (__n)
   {
     _Bit_pointer __q = this->_M_allocate(__n);
     this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
     this->_M_impl._M_start = iterator(std::__addressof(*__q), 0);
   }
 else
   {
     this->_M_impl._M_end_of_storage = _Bit_pointer();
     this->_M_impl._M_start = iterator(0, 0);
   }
 this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);

      }

      void
      _M_initialize_value(bool __x)
      {
 if (_Bit_type* __p = this->_M_impl._M_start._M_p)
   __builtin_memset(__p, __x ? ~0 : 0,
      (this->_M_impl._M_end_addr() - __p)
      * sizeof(_Bit_type));
      }

      void
      _M_reallocate(size_type __n);


      bool
      _M_shrink_to_fit();






      template<typename _Integer>
 void
 _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
 {
   _M_initialize(static_cast<size_type>(__n));
   _M_initialize_value(__x);
 }

      template<typename _InputIterator>
 void
 _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
 { _M_initialize_range(__first, __last,
         std::__iterator_category(__first)); }

      template<typename _InputIterator>
 void
 _M_initialize_range(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag)
 {
   for (; __first != __last; ++__first)
     push_back(*__first);
 }

      template<typename _ForwardIterator>
 void
 _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag)
 {
   const size_type __n = std::distance(__first, __last);
   _M_initialize(__n);
   std::copy(__first, __last, this->_M_impl._M_start);
 }
# 1219 "/usr/local/include/c++/10.0.0/bits/stl_bvector.h" 3
      void
      _M_fill_assign(size_t __n, bool __x)
      {
 if (__n > size())
   {
     _M_initialize_value(__x);
     insert(end(), __n - size(), __x);
   }
 else
   {
     _M_erase_at_end(begin() + __n);
     _M_initialize_value(__x);
   }
      }

      template<typename _InputIterator>
 void
 _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag)
 {
   iterator __cur = begin();
   for (; __first != __last && __cur != end(); ++__cur, (void)++__first)
     *__cur = *__first;
   if (__first == __last)
     _M_erase_at_end(__cur);
   else
     insert(end(), __first, __last);
 }

      template<typename _ForwardIterator>
 void
 _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag)
 {
   const size_type __len = std::distance(__first, __last);
   if (__len < size())
     _M_erase_at_end(std::copy(__first, __last, begin()));
   else
     {
       _ForwardIterator __mid = __first;
       std::advance(__mid, size());
       std::copy(__first, __mid, begin());
       insert(end(), __mid, __last);
     }
 }





      template<typename _Integer>
 void
 _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
      __true_type)
 { _M_fill_insert(__pos, __n, __x); }

      template<typename _InputIterator>
 void
 _M_insert_dispatch(iterator __pos,
      _InputIterator __first, _InputIterator __last,
      __false_type)
 { _M_insert_range(__pos, __first, __last,
     std::__iterator_category(__first)); }

      void
      _M_fill_insert(iterator __position, size_type __n, bool __x);

      template<typename _InputIterator>
 void
 _M_insert_range(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag)
 {
   for (; __first != __last; ++__first)
     {
       __pos = insert(__pos, *__first);
       ++__pos;
     }
 }

      template<typename _ForwardIterator>
 void
 _M_insert_range(iterator __position, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);

      void
      _M_insert_aux(iterator __position, bool __x);

      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }

      void
      _M_erase_at_end(iterator __pos)
      { this->_M_impl._M_finish = __pos; }

      iterator
      _M_erase(iterator __pos);

      iterator
      _M_erase(iterator __first, iterator __last);
  };



}



namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Alloc>
    struct hash<std::vector<bool, _Alloc>>
    : public __hash_base<size_t, std::vector<bool, _Alloc>>
    {
      size_t
      operator()(const std::vector<bool, _Alloc>&) const noexcept;
    };


}
# 69 "/usr/local/include/c++/10.0.0/vector" 2 3



# 1 "/usr/local/include/c++/10.0.0/bits/vector.tcc" 1 3
# 59 "/usr/local/include/c++/10.0.0/bits/vector.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp;

   if constexpr (_S_use_relocate())
     {
       __tmp = this->_M_allocate(__n);
       _S_relocate(this->_M_impl._M_start, this->_M_impl._M_finish,
     __tmp, _M_get_Tp_allocator());
     }
   else

     {
       __tmp = _M_allocate_and_copy(__n,
  std::__make_move_if_noexcept_iterator(this->_M_impl._M_start),
  std::__make_move_if_noexcept_iterator(this->_M_impl._M_finish));
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   ;
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>

      typename vector<_Tp, _Alloc>::reference



      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     ;
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish;
     ;
   }
 else
   _M_realloc_insert(end(), std::forward<_Args>(__args)...);

 return back();

      }


  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::

    insert(const_iterator __position, const value_type& __x)



    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 if (__position == end())
   {
     ;
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         __x);
     ++this->_M_impl._M_finish;
     ;
   }
 else
   {

     const auto __pos = begin() + (__position - cbegin());


     _Temporary_value __x_copy(this, __x);
     _M_insert_aux(__pos, std::move(__x_copy._M_val()));



   }
      else

 _M_realloc_insert(begin() + (__position - cbegin()), __x);




      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    _M_erase(iterator __position)
    {
      if (__position + 1 != end())
 std::move(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      ;
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 {
   if (__last != end())
     std::move(__last, end(), __first);
   _M_erase_at_end(__first.base() + (end() - __last));
 }
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {
   ;

   if (_Alloc_traits::_S_propagate_on_copy_assign())
     {
       if (!_Alloc_traits::_S_always_equal()
           && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
         {

    this->clear();
    _M_deallocate(this->_M_impl._M_start,
    this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start);
    this->_M_impl._M_start = nullptr;
    this->_M_impl._M_finish = nullptr;
    this->_M_impl._M_end_of_storage = nullptr;
  }
       std::__alloc_on_copy(_M_get_Tp_allocator(),
       __x._M_get_Tp_allocator());
     }

   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp._M_impl._M_swap_data(this->_M_impl);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   const size_type __add = __n - size();
   ;
   this->_M_impl._M_finish =
     std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
       __add, __val, _M_get_Tp_allocator());
   ;
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, (void)++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   _M_range_insert(end(), __first, __last,
     std::__iterator_category(__first));
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     _S_check_init_len(__len, _M_get_Tp_allocator());
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     ;
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     const size_type __attribute__((__unused__)) __n = __len - size();
     ;
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     ;
   }
      }


  template<typename _Tp, typename _Alloc>
    auto
    vector<_Tp, _Alloc>::
    _M_insert_rval(const_iterator __position, value_type&& __v) -> iterator
    {
      const auto __n = __position - cbegin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 if (__position == cend())
   {
     ;
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::move(__v));
     ++this->_M_impl._M_finish;
     ;
   }
 else
   _M_insert_aux(begin() + __n, std::move(__v));
      else
 _M_realloc_insert(begin() + __n, std::move(__v));

      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      auto
      vector<_Tp, _Alloc>::
      _M_emplace_aux(const_iterator __position, _Args&&... __args)
      -> iterator
      {
 const auto __n = __position - cbegin();
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   if (__position == cend())
     {
       ;
       _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
           std::forward<_Args>(__args)...);
       ++this->_M_impl._M_finish;
       ;
     }
   else
     {



       _Temporary_value __tmp(this, std::forward<_Args>(__args)...);
       _M_insert_aux(begin() + __n, std::move(__tmp._M_val()));
     }
 else
   _M_realloc_insert(begin() + __n, std::forward<_Args>(__args)...);

 return iterator(this->_M_impl._M_start + __n);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _Arg>
      void
      vector<_Tp, _Alloc>::
      _M_insert_aux(iterator __position, _Arg&& __arg)






    {
      ;
      _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
          std::move(*(this->_M_impl._M_finish - 1)));
      ++this->_M_impl._M_finish;
      ;



      std::move_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1)

                                     ;



      *__position = std::forward<_Arg>(__arg);

    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      _M_realloc_insert(iterator __position, _Args&&... __args)






    {
      const size_type __len =
 _M_check_len(size_type(1), "vector::_M_realloc_insert");
      pointer __old_start = this->_M_impl._M_start;
      pointer __old_finish = this->_M_impl._M_finish;
      const size_type __elems_before = __position - begin();
      pointer __new_start(this->_M_allocate(__len));
      pointer __new_finish(__new_start);
      try
 {





   _Alloc_traits::construct(this->_M_impl,
       __new_start + __elems_before,

       std::forward<_Args>(__args)...);



   __new_finish = pointer();


   if constexpr (_S_use_relocate())
     {
       __new_finish = _S_relocate(__old_start, __position.base(),
      __new_start, _M_get_Tp_allocator());

       ++__new_finish;

       __new_finish = _S_relocate(__position.base(), __old_finish,
      __new_finish, _M_get_Tp_allocator());
     }
   else

     {
       __new_finish
  = std::__uninitialized_move_if_noexcept_a
  (__old_start, __position.base(),
   __new_start, _M_get_Tp_allocator());

       ++__new_finish;

       __new_finish
  = std::__uninitialized_move_if_noexcept_a
  (__position.base(), __old_finish,
   __new_finish, _M_get_Tp_allocator());
     }
 }
      catch(...)
 {
   if (!__new_finish)
     _Alloc_traits::destroy(this->_M_impl,
       __new_start + __elems_before);
   else
     std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
   _M_deallocate(__new_start, __len);
   throw;
 }

      if constexpr (!_S_use_relocate())

 std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
      ;
      _M_deallocate(__old_start,
      this->_M_impl._M_end_of_storage - __old_start);
      this->_M_impl._M_start = __new_start;
      this->_M_impl._M_finish = __new_finish;
      this->_M_impl._M_end_of_storage = __new_start + __len;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {



       _Temporary_value __tmp(this, __x);
       value_type& __x_copy = __tmp._M_val();

       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    ;
    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
    ;
    std::move_backward(__position.base(), __old_finish - __n, __old_finish)
                                        ;
    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
    ;
    this->_M_impl._M_finish =
      std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
        __n - __elems_after,
        __x_copy,
        _M_get_Tp_allocator());
    ;
    std::__uninitialized_move_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
    ;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_fill_insert");
       const size_type __elems_before = __position - begin();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {

    std::__uninitialized_fill_n_a(__new_start + __elems_before,
      __n, __x,
      _M_get_Tp_allocator());
    __new_finish = pointer();

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (this->_M_impl._M_start, __position.base(),
       __new_start, _M_get_Tp_allocator());

    __new_finish += __n;

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (__position.base(), this->_M_impl._M_finish,
       __new_finish, _M_get_Tp_allocator());
  }
       catch(...)
  {
    if (!__new_finish)
      std::_Destroy(__new_start + __elems_before,
      __new_start + __elems_before + __n,
      _M_get_Tp_allocator());
    else
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       ;
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_default_append(size_type __n)
    {
      if (__n != 0)
 {
   const size_type __size = size();
   size_type __navail = size_type(this->_M_impl._M_end_of_storage
      - this->_M_impl._M_finish);

   if (__size > max_size() || __navail > max_size() - __size)
     __builtin_unreachable();

   if (__navail >= __n)
     {
       ;
       this->_M_impl._M_finish =
  std::__uninitialized_default_n_a(this->_M_impl._M_finish,
       __n, _M_get_Tp_allocator());
       ;
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_default_append");
       pointer __new_start(this->_M_allocate(__len));
       if constexpr (_S_use_relocate())
  {
    try
      {
        std::__uninitialized_default_n_a(__new_start + __size,
         __n, _M_get_Tp_allocator());
      }
    catch(...)
      {
        _M_deallocate(__new_start, __len);
        throw;
      }
    _S_relocate(this->_M_impl._M_start, this->_M_impl._M_finish,
         __new_start, _M_get_Tp_allocator());
  }
       else
  {
    pointer __destroy_from = pointer();
    try
      {
        std::__uninitialized_default_n_a(__new_start + __size,
         __n, _M_get_Tp_allocator());
        __destroy_from = __new_start + __size;
        std::__uninitialized_move_if_noexcept_a(
         this->_M_impl._M_start, this->_M_impl._M_finish,
         __new_start, _M_get_Tp_allocator());
      }
    catch(...)
      {
        if (__destroy_from)
   std::_Destroy(__destroy_from, __destroy_from + __n,
          _M_get_Tp_allocator());
        _M_deallocate(__new_start, __len);
        throw;
      }
    std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
    _M_get_Tp_allocator());
  }
       ;
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_start + __size + __n;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }

  template<typename _Tp, typename _Alloc>
    bool
    vector<_Tp, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() == size())
 return false;
      ;
      return std::__shrink_to_fit_aux<vector>::_S_do_it(*this);
    }


  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 if (__pos == end())
   {
     for (; __first != __last; ++__first)
       insert(end(), *__first);
   }
 else if (__first != __last)
   {
     vector __tmp(__first, __last, _M_get_Tp_allocator());
     insert(__pos,
     std::make_move_iterator(__tmp.begin()),
     std::make_move_iterator(__tmp.end()));
   }
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      ;
      std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
      ;
      std::move_backward(__position.base(), __old_finish - __n, __old_finish)
                                          ;
      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      ;
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      ;
      std::__uninitialized_move_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
      ;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector::_M_range_insert");
  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  try
    {
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (this->_M_impl._M_start, __position.base(),
         __new_start, _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_copy_a(__first, __last,
          __new_finish,
          _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (__position.base(), this->_M_impl._M_finish,
         __new_finish, _M_get_Tp_allocator());
    }
  catch(...)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
      throw;
    }
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  ;
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }



  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_reallocate(size_type __n)
    {
      _Bit_pointer __q = this->_M_allocate(__n);
      iterator __start(std::__addressof(*__q), 0);
      iterator __finish(_M_copy_aligned(begin(), end(), __start));
      this->_M_deallocate();
      this->_M_impl._M_start = __start;
      this->_M_impl._M_finish = __finish;
      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
    }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len =
     _M_check_len(__n, "vector<bool>::_M_fill_insert");
   _Bit_pointer __q = this->_M_allocate(__len);
   iterator __start(std::__addressof(*__q), 0);
   iterator __i = _M_copy_aligned(begin(), __position, __start);
   std::fill(__i, __i + difference_type(__n), __x);
   iterator __finish = std::copy(__position, end(),
     __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = __start;
   this->_M_impl._M_finish = __finish;
 }
    }

  template<typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<bool, _Alloc>::
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector<bool>::_M_insert_range");
  _Bit_pointer __q = this->_M_allocate(__len);
  iterator __start(std::__addressof(*__q), 0);
  iterator __i = _M_copy_aligned(begin(), __position, __start);
  __i = std::copy(__first, __last, __i);
  iterator __finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
  this->_M_impl._M_start = __start;
  this->_M_impl._M_finish = __finish;
       }
   }
      }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
   _Bit_pointer __q = this->_M_allocate(__len);
   iterator __start(std::__addressof(*__q), 0);
   iterator __i = _M_copy_aligned(begin(), __position, __start);
   *__i++ = __x;
   iterator __finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = __start;
   this->_M_impl._M_finish = __finish;
 }
    }

  template<typename _Alloc>
    typename vector<bool, _Alloc>::iterator
    vector<bool, _Alloc>::
    _M_erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

  template<typename _Alloc>
    typename vector<bool, _Alloc>::iterator
    vector<bool, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }


  template<typename _Alloc>
    bool
    vector<bool, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() - size() < int(_S_word_bit))
 return false;
      try
 {
   _M_reallocate(size());
   return true;
 }
      catch(...)
 { return false; }
    }




}



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Alloc>
    size_t
    hash<std::vector<bool, _Alloc>>::
    operator()(const std::vector<bool, _Alloc>& __b) const noexcept
    {
      size_t __hash = 0;
      using std::_S_word_bit;
      using std::_Bit_type;

      const size_t __words = __b.size() / _S_word_bit;
      if (__words)
 {
   const size_t __clength = __words * sizeof(_Bit_type);
   __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength);
 }

      const size_t __extrabits = __b.size() % _S_word_bit;
      if (__extrabits)
 {
   _Bit_type __hiword = *__b._M_impl._M_finish._M_p;
   __hiword &= ~((~static_cast<_Bit_type>(0)) << __extrabits);

   const size_t __clength
     = (__extrabits + 8 - 1) / 8;
   if (__words)
     __hash = std::_Hash_impl::hash(&__hiword, __clength, __hash);
   else
     __hash = std::_Hash_impl::hash(&__hiword, __clength);
 }

      return __hash;
    }


}
# 73 "/usr/local/include/c++/10.0.0/vector" 2 3







namespace std __attribute__ ((__visibility__ ("default")))
{

  namespace pmr {
    template<typename _Tp> class polymorphic_allocator;
    template<typename _Tp>
      using vector = std::vector<_Tp, polymorphic_allocator<_Tp>>;
  }








}



namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Tp, typename _Alloc, typename _Predicate>
    inline typename vector<_Tp, _Alloc>::size_type
    erase_if(vector<_Tp, _Alloc>& __cont, _Predicate __pred)
    {
      const auto __osz = __cont.size();
      __cont.erase(std::remove_if(__cont.begin(), __cont.end(), __pred),
     __cont.end());
      return __osz - __cont.size();
    }

  template<typename _Tp, typename _Alloc, typename _Up>
    inline typename vector<_Tp, _Alloc>::size_type
    erase(vector<_Tp, _Alloc>& __cont, const _Up& __value)
    {
      const auto __osz = __cont.size();
      __cont.erase(std::remove(__cont.begin(), __cont.end(), __value),
     __cont.end());
      return __osz - __cont.size();
    }

}
# 63 "/usr/local/include/c++/10.0.0/functional" 2 3
# 72 "/usr/local/include/c++/10.0.0/functional" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 83 "/usr/local/include/c++/10.0.0/functional" 3
  template<typename _Callable, typename... _Args>
    inline constexpr invoke_result_t<_Callable, _Args...>
    invoke(_Callable&& __fn, _Args&&... __args)
    noexcept(is_nothrow_invocable_v<_Callable, _Args...>)
    {
      return std::__invoke(std::forward<_Callable>(__fn),
      std::forward<_Args>(__args)...);
    }


  template<typename _MemFunPtr,
    bool __is_mem_fn = is_member_function_pointer<_MemFunPtr>::value>
    class _Mem_fn_base
    : public _Mem_fn_traits<_MemFunPtr>::__maybe_type
    {
      using _Traits = _Mem_fn_traits<_MemFunPtr>;

      using _Arity = typename _Traits::__arity;
      using _Varargs = typename _Traits::__vararg;

      template<typename _Func, typename... _BoundArgs>
 friend struct _Bind_check_arity;

      _MemFunPtr _M_pmf;

    public:

      using result_type = typename _Traits::__result_type;

      explicit constexpr
      _Mem_fn_base(_MemFunPtr __pmf) noexcept : _M_pmf(__pmf) { }

      template<typename... _Args>
 constexpr
 auto
 operator()(_Args&&... __args) const
 noexcept(noexcept(
       std::__invoke(_M_pmf, std::forward<_Args>(__args)...)))
 -> decltype(std::__invoke(_M_pmf, std::forward<_Args>(__args)...))
 { return std::__invoke(_M_pmf, std::forward<_Args>(__args)...); }
    };


  template<typename _MemObjPtr>
    class _Mem_fn_base<_MemObjPtr, false>
    {
      using _Arity = integral_constant<size_t, 0>;
      using _Varargs = false_type;

      template<typename _Func, typename... _BoundArgs>
 friend struct _Bind_check_arity;

      _MemObjPtr _M_pm;

    public:
      explicit constexpr
      _Mem_fn_base(_MemObjPtr __pm) noexcept : _M_pm(__pm) { }

      template<typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __obj) const
 noexcept(noexcept(std::__invoke(_M_pm, std::forward<_Tp>(__obj))))
 -> decltype(std::__invoke(_M_pm, std::forward<_Tp>(__obj)))
 { return std::__invoke(_M_pm, std::forward<_Tp>(__obj)); }
    };

  template<typename _MemberPointer>
    struct _Mem_fn;

  template<typename _Res, typename _Class>
    struct _Mem_fn<_Res _Class::*>
    : _Mem_fn_base<_Res _Class::*>
    {
      using _Mem_fn_base<_Res _Class::*>::_Mem_fn_base;
    };
# 167 "/usr/local/include/c++/10.0.0/functional" 3
  template<typename _Tp, typename _Class>
    constexpr
    inline _Mem_fn<_Tp _Class::*>
    mem_fn(_Tp _Class::* __pm) noexcept
    {
      return _Mem_fn<_Tp _Class::*>(__pm);
    }
# 183 "/usr/local/include/c++/10.0.0/functional" 3
  template<typename _Tp>
    struct is_bind_expression
    : public false_type { };
# 194 "/usr/local/include/c++/10.0.0/functional" 3
  template<typename _Tp>
    struct is_placeholder
    : public integral_constant<int, 0>
    { };


  template <typename _Tp> inline constexpr bool is_bind_expression_v
    = is_bind_expression<_Tp>::value;
  template <typename _Tp> inline constexpr int is_placeholder_v
    = is_placeholder<_Tp>::value;





  template<int _Num> struct _Placeholder { };





  namespace placeholders
  {




    extern const _Placeholder<1> _1;
    extern const _Placeholder<2> _2;
    extern const _Placeholder<3> _3;
    extern const _Placeholder<4> _4;
    extern const _Placeholder<5> _5;
    extern const _Placeholder<6> _6;
    extern const _Placeholder<7> _7;
    extern const _Placeholder<8> _8;
    extern const _Placeholder<9> _9;
    extern const _Placeholder<10> _10;
    extern const _Placeholder<11> _11;
    extern const _Placeholder<12> _12;
    extern const _Placeholder<13> _13;
    extern const _Placeholder<14> _14;
    extern const _Placeholder<15> _15;
    extern const _Placeholder<16> _16;
    extern const _Placeholder<17> _17;
    extern const _Placeholder<18> _18;
    extern const _Placeholder<19> _19;
    extern const _Placeholder<20> _20;
    extern const _Placeholder<21> _21;
    extern const _Placeholder<22> _22;
    extern const _Placeholder<23> _23;
    extern const _Placeholder<24> _24;
    extern const _Placeholder<25> _25;
    extern const _Placeholder<26> _26;
    extern const _Placeholder<27> _27;
    extern const _Placeholder<28> _28;
    extern const _Placeholder<29> _29;
  }






  template<int _Num>
    struct is_placeholder<_Placeholder<_Num> >
    : public integral_constant<int, _Num>
    { };

  template<int _Num>
    struct is_placeholder<const _Placeholder<_Num> >
    : public integral_constant<int, _Num>
    { };



  template<std::size_t __i, typename _Tuple>
    using _Safe_tuple_element_t
      = typename enable_if<(__i < tuple_size<_Tuple>::value),
      tuple_element<__i, _Tuple>>::type::type;
# 285 "/usr/local/include/c++/10.0.0/functional" 3
  template<typename _Arg,
    bool _IsBindExp = is_bind_expression<_Arg>::value,
    bool _IsPlaceholder = (is_placeholder<_Arg>::value > 0)>
    class _Mu;






  template<typename _Tp>
    class _Mu<reference_wrapper<_Tp>, false, false>
    {
    public:




      template<typename _CVRef, typename _Tuple>
 constexpr
 _Tp&
 operator()(_CVRef& __arg, _Tuple&) const volatile
 { return __arg.get(); }
    };







  template<typename _Arg>
    class _Mu<_Arg, true, false>
    {
    public:
      template<typename _CVArg, typename... _Args>
 constexpr
 auto
 operator()(_CVArg& __arg,
     tuple<_Args...>& __tuple) const volatile
 -> decltype(__arg(declval<_Args>()...))
 {

   typedef typename _Build_index_tuple<sizeof...(_Args)>::__type
     _Indexes;
   return this->__call(__arg, __tuple, _Indexes());
 }

    private:


      template<typename _CVArg, typename... _Args, std::size_t... _Indexes>
 constexpr
 auto
 __call(_CVArg& __arg, tuple<_Args...>& __tuple,
        const _Index_tuple<_Indexes...>&) const volatile
 -> decltype(__arg(declval<_Args>()...))
 {
   return __arg(std::get<_Indexes>(std::move(__tuple))...);
 }
    };






  template<typename _Arg>
    class _Mu<_Arg, false, true>
    {
    public:
      template<typename _Tuple>
 constexpr
 _Safe_tuple_element_t<(is_placeholder<_Arg>::value - 1), _Tuple>&&
 operator()(const volatile _Arg&, _Tuple& __tuple) const volatile
 {
   return
     ::std::get<(is_placeholder<_Arg>::value - 1)>(std::move(__tuple));
 }
    };






  template<typename _Arg>
    class _Mu<_Arg, false, false>
    {
    public:
      template<typename _CVArg, typename _Tuple>
 constexpr
 _CVArg&&
 operator()(_CVArg&& __arg, _Tuple&) const volatile
 { return std::forward<_CVArg>(__arg); }
    };


  template<std::size_t _Ind, typename... _Tp>
    inline auto
    __volget(volatile tuple<_Tp...>& __tuple)
    -> __tuple_element_t<_Ind, tuple<_Tp...>> volatile&
    { return std::get<_Ind>(const_cast<tuple<_Tp...>&>(__tuple)); }


  template<std::size_t _Ind, typename... _Tp>
    inline auto
    __volget(const volatile tuple<_Tp...>& __tuple)
    -> __tuple_element_t<_Ind, tuple<_Tp...>> const volatile&
    { return std::get<_Ind>(const_cast<const tuple<_Tp...>&>(__tuple)); }


  template<typename _Signature>
    struct _Bind;

   template<typename _Functor, typename... _Bound_args>
    class _Bind<_Functor(_Bound_args...)>
    : public _Weak_result_type<_Functor>
    {
      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
 _Bound_indexes;

      _Functor _M_f;
      tuple<_Bound_args...> _M_bound_args;


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 constexpr
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
 {
   return std::__invoke(_M_f,
       _Mu<_Bound_args>()(std::get<_Indexes>(_M_bound_args), __args)...
       );
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 constexpr
 _Result
 __call_c(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const
 {
   return std::__invoke(_M_f,
       _Mu<_Bound_args>()(std::get<_Indexes>(_M_bound_args), __args)...
       );
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_v(tuple<_Args...>&& __args,
   _Index_tuple<_Indexes...>) volatile
 {
   return std::__invoke(_M_f,
       _Mu<_Bound_args>()(__volget<_Indexes>(_M_bound_args), __args)...
       );
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_c_v(tuple<_Args...>&& __args,
     _Index_tuple<_Indexes...>) const volatile
 {
   return std::__invoke(_M_f,
       _Mu<_Bound_args>()(__volget<_Indexes>(_M_bound_args), __args)...
       );
 }

      template<typename _BoundArg, typename _CallArgs>
 using _Mu_type = decltype(
     _Mu<typename remove_cv<_BoundArg>::type>()(
       std::declval<_BoundArg&>(), std::declval<_CallArgs&>()) );

      template<typename _Fn, typename _CallArgs, typename... _BArgs>
 using _Res_type_impl
   = typename result_of< _Fn&(_Mu_type<_BArgs, _CallArgs>&&...) >::type;

      template<typename _CallArgs>
 using _Res_type = _Res_type_impl<_Functor, _CallArgs, _Bound_args...>;

      template<typename _CallArgs>
 using __dependent = typename
   enable_if<bool(tuple_size<_CallArgs>::value+1), _Functor>::type;

      template<typename _CallArgs, template<class> class __cv_quals>
 using _Res_type_cv = _Res_type_impl<
   typename __cv_quals<__dependent<_CallArgs>>::type,
   _CallArgs,
   typename __cv_quals<_Bound_args>::type...>;

     public:
      template<typename... _Args>
 explicit constexpr
 _Bind(const _Functor& __f, _Args&&... __args)
 : _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      template<typename... _Args>
 explicit constexpr
 _Bind(_Functor&& __f, _Args&&... __args)
 : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      _Bind(const _Bind&) = default;
      _Bind(_Bind&&) = default;


      template<typename... _Args,
        typename _Result = _Res_type<tuple<_Args...>>>
 constexpr
 _Result
 operator()(_Args&&... __args)
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args,
        typename _Result = _Res_type_cv<tuple<_Args...>, add_const>>
 constexpr
 _Result
 operator()(_Args&&... __args) const
 {
   return this->__call_c<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }
# 523 "/usr/local/include/c++/10.0.0/functional" 3
      template<typename... _Args,
        typename _Result = _Res_type_cv<tuple<_Args...>, add_volatile>>
 [[deprecated("std::bind does not support volatile in C++17")]]
 _Result
 operator()(_Args&&... __args) volatile
 {
   return this->__call_v<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args,
        typename _Result = _Res_type_cv<tuple<_Args...>, add_cv>>
 [[deprecated("std::bind does not support volatile in C++17")]]
 _Result
 operator()(_Args&&... __args) const volatile
 {
   return this->__call_c_v<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }
    };


  template<typename _Result, typename _Signature>
    struct _Bind_result;

  template<typename _Result, typename _Functor, typename... _Bound_args>
    class _Bind_result<_Result, _Functor(_Bound_args...)>
    {
      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
 _Bound_indexes;

      _Functor _M_f;
      tuple<_Bound_args...> _M_bound_args;


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 constexpr
 _Res
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
 {
   return std::__invoke_r<_Res>(_M_f, _Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 constexpr
 _Res
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const
 {
   return std::__invoke_r<_Res>(_M_f, _Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 constexpr
 _Res
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) volatile
 {
   return std::__invoke_r<_Res>(_M_f, _Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 constexpr
 _Res
 __call(tuple<_Args...>&& __args,
        _Index_tuple<_Indexes...>) const volatile
 {
   return std::__invoke_r<_Res>(_M_f, _Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }

    public:
      typedef _Result result_type;

      template<typename... _Args>
 explicit constexpr
 _Bind_result(const _Functor& __f, _Args&&... __args)
 : _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      template<typename... _Args>
 explicit constexpr
 _Bind_result(_Functor&& __f, _Args&&... __args)
 : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      _Bind_result(const _Bind_result&) = default;
      _Bind_result(_Bind_result&&) = default;


      template<typename... _Args>
 constexpr
 result_type
 operator()(_Args&&... __args)
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>
 constexpr
 result_type
 operator()(_Args&&... __args) const
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>
 [[deprecated("std::bind does not support volatile in C++17")]]
 result_type
 operator()(_Args&&... __args) volatile
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>
 [[deprecated("std::bind does not support volatile in C++17")]]
 result_type
 operator()(_Args&&... __args) const volatile
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }
    };






  template<typename _Signature>
    struct is_bind_expression<_Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<const _Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<volatile _Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<const volatile _Bind<_Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<_Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<const _Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<volatile _Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<const volatile _Bind_result<_Result, _Signature>>
    : public true_type { };

  template<typename _Func, typename... _BoundArgs>
    struct _Bind_check_arity { };

  template<typename _Ret, typename... _Args, typename... _BoundArgs>
    struct _Bind_check_arity<_Ret (*)(_Args...), _BoundArgs...>
    {
      static_assert(sizeof...(_BoundArgs) == sizeof...(_Args),
                   "Wrong number of arguments for function");
    };

  template<typename _Ret, typename... _Args, typename... _BoundArgs>
    struct _Bind_check_arity<_Ret (*)(_Args......), _BoundArgs...>
    {
      static_assert(sizeof...(_BoundArgs) >= sizeof...(_Args),
                   "Wrong number of arguments for function");
    };

  template<typename _Tp, typename _Class, typename... _BoundArgs>
    struct _Bind_check_arity<_Tp _Class::*, _BoundArgs...>
    {
      using _Arity = typename _Mem_fn<_Tp _Class::*>::_Arity;
      using _Varargs = typename _Mem_fn<_Tp _Class::*>::_Varargs;
      static_assert(_Varargs::value
      ? sizeof...(_BoundArgs) >= _Arity::value + 1
      : sizeof...(_BoundArgs) == _Arity::value + 1,
      "Wrong number of arguments for pointer-to-member");
    };




  template<typename _Tp, typename _Tp2 = typename decay<_Tp>::type>
    using __is_socketlike = __or_<is_integral<_Tp2>, is_enum<_Tp2>>;

  template<bool _SocketLike, typename _Func, typename... _BoundArgs>
    struct _Bind_helper
    : _Bind_check_arity<typename decay<_Func>::type, _BoundArgs...>
    {
      typedef typename decay<_Func>::type __func_type;
      typedef _Bind<__func_type(typename decay<_BoundArgs>::type...)> type;
    };




  template<typename _Func, typename... _BoundArgs>
    struct _Bind_helper<true, _Func, _BoundArgs...>
    { };





  template<typename _Func, typename... _BoundArgs>
    inline constexpr typename
    _Bind_helper<__is_socketlike<_Func>::value, _Func, _BoundArgs...>::type
    bind(_Func&& __f, _BoundArgs&&... __args)
    {
      typedef _Bind_helper<false, _Func, _BoundArgs...> __helper_type;
      return typename __helper_type::type(std::forward<_Func>(__f),
       std::forward<_BoundArgs>(__args)...);
    }

  template<typename _Result, typename _Func, typename... _BoundArgs>
    struct _Bindres_helper
    : _Bind_check_arity<typename decay<_Func>::type, _BoundArgs...>
    {
      typedef typename decay<_Func>::type __functor_type;
      typedef _Bind_result<_Result,
      __functor_type(typename decay<_BoundArgs>::type...)>
 type;
    };





  template<typename _Result, typename _Func, typename... _BoundArgs>
    inline constexpr
    typename _Bindres_helper<_Result, _Func, _BoundArgs...>::type
    bind(_Func&& __f, _BoundArgs&&... __args)
    {
      typedef _Bindres_helper<_Result, _Func, _BoundArgs...> __helper_type;
      return typename __helper_type::type(std::forward<_Func>(__f),
       std::forward<_BoundArgs>(__args)...);
    }




  template<typename _Fd, typename... _BoundArgs>
    struct _Bind_front
    {
      static_assert(is_move_constructible_v<_Fd>);
      static_assert((is_move_constructible_v<_BoundArgs> && ...));



      template<typename _Fn, typename... _Args>
 explicit constexpr
 _Bind_front(int, _Fn&& __fn, _Args&&... __args)
 noexcept(__and_<is_nothrow_constructible<_Fd, _Fn>,
   is_nothrow_constructible<_BoundArgs, _Args>...>::value)
 : _M_fd(std::forward<_Fn>(__fn)),
   _M_bound_args(std::forward<_Args>(__args)...)
 { static_assert(sizeof...(_Args) == sizeof...(_BoundArgs)); }

      _Bind_front(const _Bind_front&) = default;
      _Bind_front(_Bind_front&&) = default;
      _Bind_front& operator=(const _Bind_front&) = default;
      _Bind_front& operator=(_Bind_front&&) = default;
      ~_Bind_front() = default;

      template<typename... _CallArgs>
 constexpr
 invoke_result_t<_Fd&, _BoundArgs&..., _CallArgs...>
 operator()(_CallArgs&&... __call_args) &
 noexcept(is_nothrow_invocable_v<_Fd&, _BoundArgs&..., _CallArgs...>)
 {
   return _S_call(*this, _BoundIndices(),
       std::forward<_CallArgs>(__call_args)...);
 }

      template<typename... _CallArgs>
 constexpr
 invoke_result_t<const _Fd&, const _BoundArgs&..., _CallArgs...>
 operator()(_CallArgs&&... __call_args) const &
 noexcept(is_nothrow_invocable_v<const _Fd&, const _BoundArgs&...,
     _CallArgs...>)
 {
   return _S_call(*this, _BoundIndices(),
       std::forward<_CallArgs>(__call_args)...);
 }

      template<typename... _CallArgs>
 constexpr
 invoke_result_t<_Fd, _BoundArgs..., _CallArgs...>
 operator()(_CallArgs&&... __call_args) &&
 noexcept(is_nothrow_invocable_v<_Fd, _BoundArgs..., _CallArgs...>)
 {
   return _S_call(std::move(*this), _BoundIndices(),
       std::forward<_CallArgs>(__call_args)...);
 }

      template<typename... _CallArgs>
 constexpr
 invoke_result_t<const _Fd, const _BoundArgs..., _CallArgs...>
 operator()(_CallArgs&&... __call_args) const &&
 noexcept(is_nothrow_invocable_v<const _Fd, const _BoundArgs...,
     _CallArgs...>)
 {
   return _S_call(std::move(*this), _BoundIndices(),
       std::forward<_CallArgs>(__call_args)...);
 }

    private:
      using _BoundIndices = index_sequence_for<_BoundArgs...>;

      template<typename _Tp, size_t... _Ind, typename... _CallArgs>
 static constexpr
 decltype(auto)
 _S_call(_Tp&& __g, index_sequence<_Ind...>, _CallArgs&&... __call_args)
 {
   return std::invoke(std::forward<_Tp>(__g)._M_fd,
       std::get<_Ind>(std::forward<_Tp>(__g)._M_bound_args)...,
       std::forward<_CallArgs>(__call_args)...);
 }

      _Fd _M_fd;
      std::tuple<_BoundArgs...> _M_bound_args;
    };

  template<typename _Fn, typename... _Args>
    using _Bind_front_t
      = _Bind_front<decay_t<_Fn>, decay_t<_Args>...>;

  template<typename _Fn, typename... _Args>
    constexpr _Bind_front_t<_Fn, _Args...>
    bind_front(_Fn&& __fn, _Args&&... __args)
    noexcept(is_nothrow_constructible_v<int, _Bind_front_t<_Fn, _Args...>,
     _Fn, _Args...>)
    {
      return _Bind_front_t<_Fn, _Args...>(0, std::forward<_Fn>(__fn),
       std::forward<_Args>(__args)...);
    }




  template<typename _Fn>
    class _Not_fn
    {
      template<typename _Fn2, typename... _Args>
 using __inv_res_t = typename __invoke_result<_Fn2, _Args...>::type;

      template<typename _Tp>
 static decltype(!std::declval<_Tp>())
 _S_not() noexcept(noexcept(!std::declval<_Tp>()));

    public:
      template<typename _Fn2>
 constexpr
 _Not_fn(_Fn2&& __fn, int)
 : _M_fn(std::forward<_Fn2>(__fn)) { }

      _Not_fn(const _Not_fn& __fn) = default;
      _Not_fn(_Not_fn&& __fn) = default;
      ~_Not_fn() = default;
# 952 "/usr/local/include/c++/10.0.0/functional" 3
      template<typename... _Args> constexpr decltype(_S_not<__inv_res_t<_Fn &, _Args...>>()) operator()(_Args&&... __args) & noexcept(__is_nothrow_invocable<_Fn &, _Args...>::value && noexcept(_S_not<__inv_res_t<_Fn &, _Args...>>())) { return !std::__invoke(std::forward< _Fn & >(_M_fn), std::forward<_Args>(__args)...); }
      template<typename... _Args> constexpr decltype(_S_not<__inv_res_t<_Fn const &, _Args...>>()) operator()(_Args&&... __args) const & noexcept(__is_nothrow_invocable<_Fn const &, _Args...>::value && noexcept(_S_not<__inv_res_t<_Fn const &, _Args...>>())) { return !std::__invoke(std::forward< _Fn const & >(_M_fn), std::forward<_Args>(__args)...); }
      template<typename... _Args> constexpr decltype(_S_not<__inv_res_t<_Fn &&, _Args...>>()) operator()(_Args&&... __args) && noexcept(__is_nothrow_invocable<_Fn &&, _Args...>::value && noexcept(_S_not<__inv_res_t<_Fn &&, _Args...>>())) { return !std::__invoke(std::forward< _Fn && >(_M_fn), std::forward<_Args>(__args)...); }
      template<typename... _Args> constexpr decltype(_S_not<__inv_res_t<_Fn const &&, _Args...>>()) operator()(_Args&&... __args) const && noexcept(__is_nothrow_invocable<_Fn const &&, _Args...>::value && noexcept(_S_not<__inv_res_t<_Fn const &&, _Args...>>())) { return !std::__invoke(std::forward< _Fn const && >(_M_fn), std::forward<_Args>(__args)...); }


    private:
      _Fn _M_fn;
    };

  template<typename _Tp, typename _Pred>
    struct __is_byte_like : false_type { };

  template<typename _Tp>
    struct __is_byte_like<_Tp, equal_to<_Tp>>
    : __bool_constant<sizeof(_Tp) == 1 && is_integral<_Tp>::value> { };

  template<typename _Tp>
    struct __is_byte_like<_Tp, equal_to<void>>
    : __bool_constant<sizeof(_Tp) == 1 && is_integral<_Tp>::value> { };



  enum class byte : unsigned char;

  template<>
    struct __is_byte_like<byte, equal_to<byte>>
    : true_type { };

  template<>
    struct __is_byte_like<byte, equal_to<void>>
    : true_type { };



  template<typename _Fn>
    constexpr
    inline auto
    not_fn(_Fn&& __fn)
    noexcept(std::is_nothrow_constructible<std::decay_t<_Fn>, _Fn&&>::value)
    {
      return _Not_fn<std::decay_t<_Fn>>{std::forward<_Fn>(__fn), 0};
    }




  template<typename _ForwardIterator1, typename _BinaryPredicate = equal_to<>>
    class default_searcher
    {
    public:
      constexpr
      default_searcher(_ForwardIterator1 __pat_first,
         _ForwardIterator1 __pat_last,
         _BinaryPredicate __pred = _BinaryPredicate())
      : _M_m(__pat_first, __pat_last, std::move(__pred))
      { }

      template<typename _ForwardIterator2>
 constexpr
 pair<_ForwardIterator2, _ForwardIterator2>
 operator()(_ForwardIterator2 __first, _ForwardIterator2 __last) const
 {
   _ForwardIterator2 __first_ret =
     std::search(__first, __last, std::get<0>(_M_m), std::get<1>(_M_m),
   std::get<2>(_M_m));
   auto __ret = std::make_pair(__first_ret, __first_ret);
   if (__ret.first != __last)
     std::advance(__ret.second, std::distance(std::get<0>(_M_m),
           std::get<1>(_M_m)));
   return __ret;
 }

    private:
      tuple<_ForwardIterator1, _ForwardIterator1, _BinaryPredicate> _M_m;
    };

  template<typename _Key, typename _Tp, typename _Hash, typename _Pred>
    struct __boyer_moore_map_base
    {
      template<typename _RAIter>
 __boyer_moore_map_base(_RAIter __pat, size_t __patlen,
          _Hash&& __hf, _Pred&& __pred)
 : _M_bad_char{ __patlen, std::move(__hf), std::move(__pred) }
 {
   if (__patlen > 0)
     for (__diff_type __i = 0; __i < __patlen - 1; ++__i)
       _M_bad_char[__pat[__i]] = __patlen - 1 - __i;
 }

      using __diff_type = _Tp;

      __diff_type
      _M_lookup(_Key __key, __diff_type __not_found) const
      {
 auto __iter = _M_bad_char.find(__key);
 if (__iter == _M_bad_char.end())
   return __not_found;
 return __iter->second;
      }

      _Pred
      _M_pred() const { return _M_bad_char.key_eq(); }

      std::unordered_map<_Key, _Tp, _Hash, _Pred> _M_bad_char;
    };

  template<typename _Tp, size_t _Len, typename _Pred>
    struct __boyer_moore_array_base
    {
      template<typename _RAIter, typename _Unused>
 __boyer_moore_array_base(_RAIter __pat, size_t __patlen,
     _Unused&&, _Pred&& __pred)
 : _M_bad_char{ std::array<_Tp, _Len>{}, std::move(__pred) }
 {
   std::get<0>(_M_bad_char).fill(__patlen);
   if (__patlen > 0)
     for (__diff_type __i = 0; __i < __patlen - 1; ++__i)
       {
  auto __ch = __pat[__i];
  using _UCh = make_unsigned_t<decltype(__ch)>;
  auto __uch = static_cast<_UCh>(__ch);
  std::get<0>(_M_bad_char)[__uch] = __patlen - 1 - __i;
       }
 }

      using __diff_type = _Tp;

      template<typename _Key>
 __diff_type
 _M_lookup(_Key __key, __diff_type __not_found) const
 {
   auto __ukey = static_cast<make_unsigned_t<_Key>>(__key);
   if (__ukey >= _Len)
     return __not_found;
   return std::get<0>(_M_bad_char)[__ukey];
 }

      const _Pred&
      _M_pred() const { return std::get<1>(_M_bad_char); }

      tuple<std::array<_Tp, _Len>, _Pred> _M_bad_char;
    };



  template<typename _RAIter, typename _Hash, typename _Pred,
           typename _Val = typename iterator_traits<_RAIter>::value_type,
    typename _Diff = typename iterator_traits<_RAIter>::difference_type>
    using __boyer_moore_base_t
      = conditional_t<__is_byte_like<_Val, _Pred>::value,
        __boyer_moore_array_base<_Diff, 256, _Pred>,
        __boyer_moore_map_base<_Val, _Diff, _Hash, _Pred>>;

  template<typename _RAIter, typename _Hash
      = hash<typename iterator_traits<_RAIter>::value_type>,
    typename _BinaryPredicate = equal_to<>>
    class boyer_moore_searcher
    : __boyer_moore_base_t<_RAIter, _Hash, _BinaryPredicate>
    {
      using _Base = __boyer_moore_base_t<_RAIter, _Hash, _BinaryPredicate>;
      using typename _Base::__diff_type;

    public:
      boyer_moore_searcher(_RAIter __pat_first, _RAIter __pat_last,
      _Hash __hf = _Hash(),
      _BinaryPredicate __pred = _BinaryPredicate());

      template<typename _RandomAccessIterator2>
        pair<_RandomAccessIterator2, _RandomAccessIterator2>
 operator()(_RandomAccessIterator2 __first,
     _RandomAccessIterator2 __last) const;

    private:
      bool
      _M_is_prefix(_RAIter __word, __diff_type __len,
     __diff_type __pos)
      {
 const auto& __pred = this->_M_pred();
 __diff_type __suffixlen = __len - __pos;
 for (__diff_type __i = 0; __i < __suffixlen; ++__i)
   if (!__pred(__word[__i], __word[__pos + __i]))
     return false;
 return true;
      }

      __diff_type
      _M_suffix_length(_RAIter __word, __diff_type __len,
         __diff_type __pos)
      {
 const auto& __pred = this->_M_pred();
 __diff_type __i = 0;
 while (__pred(__word[__pos - __i], __word[__len - 1 - __i])
        && __i < __pos)
   {
     ++__i;
   }
 return __i;
      }

      template<typename _Tp>
 __diff_type
 _M_bad_char_shift(_Tp __c) const
 { return this->_M_lookup(__c, _M_pat_end - _M_pat); }

      _RAIter _M_pat;
      _RAIter _M_pat_end;
      std::vector<__diff_type> _M_good_suffix;
    };

  template<typename _RAIter, typename _Hash
      = hash<typename iterator_traits<_RAIter>::value_type>,
    typename _BinaryPredicate = equal_to<>>
    class boyer_moore_horspool_searcher
    : __boyer_moore_base_t<_RAIter, _Hash, _BinaryPredicate>
    {
      using _Base = __boyer_moore_base_t<_RAIter, _Hash, _BinaryPredicate>;
      using typename _Base::__diff_type;

    public:
      boyer_moore_horspool_searcher(_RAIter __pat,
        _RAIter __pat_end,
        _Hash __hf = _Hash(),
        _BinaryPredicate __pred
        = _BinaryPredicate())
      : _Base(__pat, __pat_end - __pat, std::move(__hf), std::move(__pred)),
 _M_pat(__pat), _M_pat_end(__pat_end)
      { }

      template<typename _RandomAccessIterator2>
        pair<_RandomAccessIterator2, _RandomAccessIterator2>
 operator()(_RandomAccessIterator2 __first,
     _RandomAccessIterator2 __last) const
 {
   const auto& __pred = this->_M_pred();
   auto __patlen = _M_pat_end - _M_pat;
   if (__patlen == 0)
     return std::make_pair(__first, __first);
   auto __len = __last - __first;
   while (__len >= __patlen)
     {
       for (auto __scan = __patlen - 1;
     __pred(__first[__scan], _M_pat[__scan]); --__scan)
  if (__scan == 0)
    return std::make_pair(__first, __first + __patlen);
       auto __shift = _M_bad_char_shift(__first[__patlen - 1]);
       __len -= __shift;
       __first += __shift;
     }
   return std::make_pair(__last, __last);
 }

    private:
      template<typename _Tp>
 __diff_type
 _M_bad_char_shift(_Tp __c) const
 { return this->_M_lookup(__c, _M_pat_end - _M_pat); }

      _RAIter _M_pat;
      _RAIter _M_pat_end;
    };

  template<typename _RAIter, typename _Hash, typename _BinaryPredicate>
    boyer_moore_searcher<_RAIter, _Hash, _BinaryPredicate>::
    boyer_moore_searcher(_RAIter __pat, _RAIter __pat_end,
    _Hash __hf, _BinaryPredicate __pred)
    : _Base(__pat, __pat_end - __pat, std::move(__hf), std::move(__pred)),
      _M_pat(__pat), _M_pat_end(__pat_end), _M_good_suffix(__pat_end - __pat)
    {
      auto __patlen = __pat_end - __pat;
      if (__patlen == 0)
 return;
      __diff_type __last_prefix = __patlen - 1;
      for (__diff_type __p = __patlen - 1; __p >= 0; --__p)
 {
   if (_M_is_prefix(__pat, __patlen, __p + 1))
     __last_prefix = __p + 1;
   _M_good_suffix[__p] = __last_prefix + (__patlen - 1 - __p);
 }
      for (__diff_type __p = 0; __p < __patlen - 1; ++__p)
 {
   auto __slen = _M_suffix_length(__pat, __patlen, __p);
   auto __pos = __patlen - 1 - __slen;
   if (!__pred(__pat[__p - __slen], __pat[__pos]))
     _M_good_suffix[__pos] = __patlen - 1 - __p + __slen;
 }
    }

  template<typename _RAIter, typename _Hash, typename _BinaryPredicate>
  template<typename _RandomAccessIterator2>
    pair<_RandomAccessIterator2, _RandomAccessIterator2>
    boyer_moore_searcher<_RAIter, _Hash, _BinaryPredicate>::
    operator()(_RandomAccessIterator2 __first,
        _RandomAccessIterator2 __last) const
    {
      auto __patlen = _M_pat_end - _M_pat;
      if (__patlen == 0)
 return std::make_pair(__first, __first);
      const auto& __pred = this->_M_pred();
      __diff_type __i = __patlen - 1;
      auto __stringlen = __last - __first;
      while (__i < __stringlen)
 {
   __diff_type __j = __patlen - 1;
   while (__j >= 0 && __pred(__first[__i], _M_pat[__j]))
     {
       --__i;
       --__j;
     }
   if (__j < 0)
     {
       const auto __match = __first + __i + 1;
       return std::make_pair(__match, __match + __patlen);
     }
   __i += std::max(_M_bad_char_shift(__first[__i]),
     _M_good_suffix[__j]);
 }
      return std::make_pair(__last, __last);
    }





}
# 14 "/usr/local/include/c++/10.0.0/pstl/glue_algorithm_defs.h" 2 3



namespace std
{



template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
any_of(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred);



template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
all_of(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred);



template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
none_of(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred);



template <class _ExecutionPolicy, class _ForwardIterator, class _Function>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
for_each(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Function __f);

template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Function>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
for_each_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Size __n, _Function __f);



template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
find_if(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
find_if_not(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
find(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __value);



template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator1>
find_end(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __s_first,
         _ForwardIterator2 __s_last, _BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator1>
find_end(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __s_first,
         _ForwardIterator2 __s_last);



template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator1>
find_first_of(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,
              _ForwardIterator2 __s_first, _ForwardIterator2 __s_last, _BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator1>
find_first_of(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,
              _ForwardIterator2 __s_first, _ForwardIterator2 __s_last);



template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
adjacent_find(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
adjacent_find(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred);



template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 typename iterator_traits<_ForwardIterator>::difference_type>
count(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __value);

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,
                                                 typename iterator_traits<_ForwardIterator>::difference_type>
count_if(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred);



template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator1>
search(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __s_first,
       _ForwardIterator2 __s_last, _BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator1>
search(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __s_first,
       _ForwardIterator2 __s_last);

template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
search_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Size __count,
         const _Tp& __value, _BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
search_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Size __count,
         const _Tp& __value);



template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>
copy(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __result);

template <class _ExecutionPolicy, class _ForwardIterator1, class _Size, class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>
copy_n(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _Size __n, _ForwardIterator2 __result);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>
copy_if(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 result,
        _Predicate __pred);



template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>
swap_ranges(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,
            _ForwardIterator2 __first2);



template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _UnaryOperation>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>
transform(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __result,
          _UnaryOperation __op);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator,
          class _BinaryOperation>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
transform(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
          _ForwardIterator __result, _BinaryOperation __op);



template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
replace_if(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _UnaryPredicate __pred,
           const _Tp& __new_value);

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
replace(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value,
        const _Tp& __new_value);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _UnaryPredicate, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>
replace_copy_if(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,
                _ForwardIterator2 __result, _UnaryPredicate __pred, const _Tp& __new_value);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>
replace_copy(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __result,
             const _Tp& __old_value, const _Tp& __new_value);



template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
fill(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __value);

template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
fill_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Size __count, const _Tp& __value);


template <class _ExecutionPolicy, class _ForwardIterator, class _Generator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
generate(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Generator __g);

template <class _ExecutionPolicy, class _ForwardIterator, class _Size, class _Generator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
generate_n(_ExecutionPolicy&& __exec, _ForwardIterator __first, _Size count, _Generator __g);



template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Predicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>
remove_copy_if(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last,
               _ForwardIterator2 __result, _Predicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>
remove_copy(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __result,
            const _Tp& __value);

template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
remove_if(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _UnaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
remove(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __value);



template <class _ExecutionPolicy, class _ForwardIterator, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
unique(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
unique(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>
unique_copy(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __result,
            _BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>
unique_copy(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __result);



template <class _ExecutionPolicy, class _BidirectionalIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
reverse(_ExecutionPolicy&& __exec, _BidirectionalIterator __first, _BidirectionalIterator __last);

template <class _ExecutionPolicy, class _BidirectionalIterator, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
reverse_copy(_ExecutionPolicy&& __exec, _BidirectionalIterator __first, _BidirectionalIterator __last,
             _ForwardIterator __d_first);



template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
rotate(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>
rotate_copy(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __middle, _ForwardIterator1 __last,
            _ForwardIterator2 __result);



template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
is_partitioned(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _UnaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator, class _UnaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
partition(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _UnaryPredicate __pred);

template <class _ExecutionPolicy, class _BidirectionalIterator, class _UnaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _BidirectionalIterator>
stable_partition(_ExecutionPolicy&& __exec, _BidirectionalIterator __first, _BidirectionalIterator __last,
                 _UnaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator, class _ForwardIterator1, class _ForwardIterator2,
          class _UnaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>
partition_copy(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last,
               _ForwardIterator1 __out_true, _ForwardIterator2 __out_false, _UnaryPredicate __pred);



template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last);



template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
stable_sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
stable_sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last);



template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>
mismatch(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
         _ForwardIterator2 __last2, _BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>
mismatch(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
         _BinaryPredicate __pred);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>
mismatch(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
         _ForwardIterator2 __last2);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, std::pair<_ForwardIterator1, _ForwardIterator2>>
mismatch(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2);



template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
equal(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
      _BinaryPredicate __p);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
equal(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
equal(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
      _ForwardIterator2 __last2, _BinaryPredicate __p);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
equal(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
      _ForwardIterator2 __last2);


template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator2>
move(_ExecutionPolicy&& __exec, _ForwardIterator1 __first, _ForwardIterator1 __last, _ForwardIterator2 __d_first);



template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
partial_sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __middle,
             _RandomAccessIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
partial_sort(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __middle,
             _RandomAccessIterator __last);



template <class _ExecutionPolicy, class _ForwardIterator, class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _RandomAccessIterator>
partial_sort_copy(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last,
                  _RandomAccessIterator __d_first, _RandomAccessIterator __d_last, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator, class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _RandomAccessIterator>
partial_sort_copy(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last,
                  _RandomAccessIterator __d_first, _RandomAccessIterator __d_last);


template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
is_sorted_until(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
is_sorted_until(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
is_sorted(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
is_sorted(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last);



template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
nth_element(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __nth,
            _RandomAccessIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
nth_element(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __nth,
            _RandomAccessIterator __last);


template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator,
          class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
merge(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
      _ForwardIterator2 __last2, _ForwardIterator __d_first, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
merge(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
      _ForwardIterator2 __last2, _ForwardIterator __d_first);

template <class _ExecutionPolicy, class _BidirectionalIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
inplace_merge(_ExecutionPolicy&& __exec, _BidirectionalIterator __first, _BidirectionalIterator __middle,
              _BidirectionalIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _BidirectionalIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void>
inplace_merge(_ExecutionPolicy&& __exec, _BidirectionalIterator __first, _BidirectionalIterator __middle,
              _BidirectionalIterator __last);



template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
includes(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
         _ForwardIterator2 __last2, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
includes(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
         _ForwardIterator2 __last2);



template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator,
          class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
set_union(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
          _ForwardIterator2 __last2, _ForwardIterator __result, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
set_union(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2,
          _ForwardIterator2 __last2, _ForwardIterator __result);



template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator,
          class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
set_intersection(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,
                 _ForwardIterator2 __first2, _ForwardIterator2 __last2, _ForwardIterator __result, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
set_intersection(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,
                 _ForwardIterator2 __first2, _ForwardIterator2 __last2, _ForwardIterator __result);



template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator,
          class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
set_difference(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2, _ForwardIterator2 __last2, _ForwardIterator __result, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
set_difference(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2, _ForwardIterator2 __last2, _ForwardIterator __result);



template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator,
          class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
set_symmetric_difference(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,
                         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _ForwardIterator result,
                         _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
set_symmetric_difference(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,
                         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _ForwardIterator __result);


template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _RandomAccessIterator>
is_heap_until(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _RandomAccessIterator>
is_heap_until(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last);

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
is_heap(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _RandomAccessIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
is_heap(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, _RandomAccessIterator __last);



template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
min_element(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
min_element(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
max_element(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, _ForwardIterator>
max_element(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last);

template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, std::pair<_ForwardIterator, _ForwardIterator>>
minmax_element(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, std::pair<_ForwardIterator, _ForwardIterator>>
minmax_element(_ExecutionPolicy&& __exec, _ForwardIterator __first, _ForwardIterator __last);



template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2, class _Compare>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
lexicographical_compare(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,
                        _ForwardIterator2 __first2, _ForwardIterator2 __last2, _Compare __comp);

template <class _ExecutionPolicy, class _ForwardIterator1, class _ForwardIterator2>
__pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, bool>
lexicographical_compare(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, _ForwardIterator1 __last1,
                        _ForwardIterator2 __first2, _ForwardIterator2 __last2);

}
# 72 "/usr/local/include/c++/10.0.0/algorithm" 2 3
# 26 "fast_io/fast_io_core.h" 2
# 1 "/usr/local/include/c++/10.0.0/cstring" 1 3
# 39 "/usr/local/include/c++/10.0.0/cstring" 3
       
# 40 "/usr/local/include/c++/10.0.0/cstring" 3


# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4

extern "C" {




# 1 "/usr/local/lib/gcc/x86_64-pc-linux-gnu/10.0.0/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 42 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const void *memchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) void *
memchr (void *__s, int __c, size_t __n) throw ()
{
  return __builtin_memchr (__s, __c, __n);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const void *
memchr (const void *__s, int __c, size_t __n) throw ()
{
  return __builtin_memchr (__s, __c, __n);
}

}
# 98 "/usr/include/string.h" 3 4
extern "C++" void *rawmemchr (void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *rawmemchr (const void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *memrchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 121 "/usr/include/string.h" 3 4
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));






extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 203 "/usr/include/string.h" 3 4
extern "C++"
{
extern char *strchr (char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strchr (const char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
strchr (char *__s, int __c) throw ()
{
  return __builtin_strchr (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
strchr (const char *__s, int __c) throw ()
{
  return __builtin_strchr (__s, __c);
}

}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strrchr (const char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
strrchr (char *__s, int __c) throw ()
{
  return __builtin_strrchr (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
strrchr (const char *__s, int __c) throw ()
{
  return __builtin_strrchr (__s, __c);
}

}
# 260 "/usr/include/string.h" 3 4
extern "C++" char *strchrnul (char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const char *strchrnul (const char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 272 "/usr/include/string.h" 3 4
extern size_t strcspn (const char *__s, const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strpbrk (const char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
strpbrk (char *__s, const char *__accept) throw ()
{
  return __builtin_strpbrk (__s, __accept);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
strpbrk (const char *__s, const char *__accept) throw ()
{
  return __builtin_strpbrk (__s, __accept);
}

}






extern "C++"
{
extern char *strstr (char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strstr (const char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
strstr (char *__haystack, const char *__needle) throw ()
{
  return __builtin_strstr (__haystack, __needle);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
strstr (const char *__haystack, const char *__needle) throw ()
{
  return __builtin_strstr (__haystack, __needle);
}

}







extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" const char *strcasestr (const char *__haystack,
         const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 368 "/usr/include/string.h" 3 4
extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlen (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) throw ();
# 420 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;





extern char *strerror_l (int __errnum, locale_t __l) throw ();



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/local/lib/gcc/x86_64-pc-linux-gnu/10.0.0/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4






extern "C" {



extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern "C++"
{
extern char *index (char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *index (const char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
index (char *__s, int __c) throw ()
{
  return __builtin_index (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
index (const char *__s, int __c) throw ()
{
  return __builtin_index (__s, __c);
}

}







extern "C++"
{
extern char *rindex (char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *rindex (const char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
rindex (char *__s, int __c) throw ()
{
  return __builtin_rindex (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
rindex (const char *__s, int __c) throw ()
{
  return __builtin_rindex (__s, __c);
}

}
# 104 "/usr/include/strings.h" 3 4
extern int ffs (int __i) throw () __attribute__ ((__const__));





extern int ffsl (long int __l) throw () __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));


}
# 432 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));







extern "C++" char *basename (char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" const char *basename (const char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
# 498 "/usr/include/string.h" 3 4
}
# 43 "/usr/local/include/c++/10.0.0/cstring" 2 3
# 71 "/usr/local/include/c++/10.0.0/cstring" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;
  using ::strtok;
  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;
# 122 "/usr/local/include/c++/10.0.0/cstring" 3

}
}
# 27 "fast_io/fast_io_core.h" 2



# 1 "fast_io/fast_io_core_impl/concept.h" 1
       

# 1 "fast_io/fast_io_core_impl/before_cpp20_concept.h" 1
       



# 4 "fast_io/fast_io_core_impl/before_cpp20_concept.h"
namespace fast_io
{



template<typename To,typename From>
requires (sizeof(To)==sizeof(From) && std::is_trivially_copyable_v<To> && std::is_trivial_v<From>)
inline To bit_cast(From const& src) noexcept
{
 To dst;
 std::memcpy(std::addressof(dst), std::addressof(src), sizeof(To));
 return dst;
}


namespace details
{

template<std::unsigned_integral U>
inline constexpr U big_endian(U u)
{
 if constexpr(std::endian::little==std::endian::native)
 {
  auto pun(bit_cast<std::array<std::byte,sizeof(U)>>(u));
  std::reverse(pun.begin(),pun.end());
  return bit_cast<U>(pun);
 }
 else
  return u;
}
}

}
# 4 "fast_io/fast_io_core_impl/concept.h" 2

namespace fast_io
{

namespace details
{

template<typename T>
concept stream_char_type_requirement = requires(T&)
{
 typename T::char_type;
};

template<typename T>
concept input_stream_impl = stream_char_type_requirement<T>&&requires(T& in,typename T::char_type* b,typename T::char_type* e)
{
 receive(in,b,e);
};

template<typename T>
concept output_stream_impl = stream_char_type_requirement<T>&&requires(T& out,typename T::char_type const* b,typename T::char_type const* e)
{
 {send(out,b,e)};
 {flush(out)};
};

template<typename T>
concept mutex_stream_impl = requires(T& t)
{
 typename T::lock_guard_type;
 mutex(t);
 unlocked_handle(t);
};

template<typename T>
concept character_input_stream_impl = requires(T& in)
{
 get(in);
};

template<typename T>
concept character_output_stream_impl = requires(T& out,typename T::char_type ch)
{
 put(out,ch);
};

template<typename T>
concept random_access_stream_impl = requires(T& t)
{
 seek(t,5);
};

namespace dummy
{
 struct dummy_output_stream
 {
  using char_type = char;
 };
 inline void flush(dummy_output_stream&){}
 template<std::contiguous_iterator Iter>
 inline void send(dummy_output_stream&,Iter,Iter){}
}

template<typename T>
concept buffer_input_stream_impl = requires(T& in,std::size_t n)
{
 ireserve(in,n);
 irelease(in,n);
}&&requires(dummy::dummy_output_stream& dumout,T& in)
{
 idump(dumout,in);
};

template<typename T>
concept buffer_output_stream_impl = requires(T& out,std::size_t n)
{
 oreserve(out,n);
 orelease(out,n);
};
template<typename T>
concept zero_copy_input_stream_impl = requires(T& in)
{
 zero_copy_in_handle(in);
};

template<typename T>
concept zero_copy_output_stream_impl = requires(T& out)
{
 zero_copy_out_handle(out);
};
}


template<typename T>
concept stream = std::movable<T>&&(details::input_stream_impl<T>||details::output_stream_impl<T>);

template<typename T>
concept input_stream = stream<T>&&details::input_stream_impl<T>;

template<typename T>
concept output_stream = stream<T>&&details::output_stream_impl<T>;

template<typename T>
concept mutex_stream = stream<T>&&details::mutex_stream_impl<T>;

template<typename T>
concept mutex_input_stream = mutex_stream<T>&&input_stream<T>;

template<typename T>
concept mutex_output_stream = mutex_stream<T>&&output_stream<T>;

template<typename T>
concept random_access_stream = stream<T>&&details::random_access_stream_impl<T>;

template<typename T>
concept io_stream = input_stream<T>&&output_stream<T>;

template<typename T>
concept character_input_stream = input_stream<T>&&details::character_input_stream_impl<T>;

template<typename T>
concept character_output_stream = output_stream<T>&&details::character_output_stream_impl<T>;

template<typename T>
concept character_io_stream = character_input_stream<T>&&character_output_stream<T>;

template<typename T>
concept mutex_io_stream = mutex_input_stream<T>&&mutex_output_stream<T>;

template<typename T>
concept buffer_input_stream = input_stream<T>&&details::buffer_input_stream_impl<T>;

template<typename T>
concept buffer_output_stream = output_stream<T>&&details::buffer_output_stream_impl<T>;

template<typename T>
concept buffer_io_stream = buffer_input_stream<T>&&buffer_output_stream<T>&&io_stream<T>;

template<typename T>
concept zero_copy_buffer_input_stream = details::zero_copy_input_stream_impl<T>&&buffer_input_stream<T>;

template<typename T>
concept zero_copy_buffer_output_stream = details::zero_copy_output_stream_impl<T>&&buffer_output_stream<T>;

template<typename T>
concept zero_copy_buffer_io_stream = zero_copy_buffer_input_stream<T>&&zero_copy_buffer_output_stream<T>;


template<typename T>
concept zero_copy_input_stream = input_stream<T>&&details::zero_copy_input_stream_impl<T>&&!zero_copy_buffer_input_stream<T>;

template<typename T>
concept zero_copy_output_stream = output_stream<T>&&details::zero_copy_output_stream_impl<T>&&!zero_copy_buffer_output_stream<T>;

template<typename T>
concept zero_copy_io_stream = zero_copy_input_stream<T>&&zero_copy_output_stream<T>;


template<typename input,typename T>
concept scanable=input_stream<input>&&requires(input& in,T&& t)
{
 scan_define(in,std::forward<T>(t));
};

template<typename input,typename T>
concept readable=input_stream<input>&&requires(input& in,T&& t)
{
 read_define(in,std::forward<T>(t));
};


template<typename output,typename T>
concept printable=output_stream<output>&&requires(output& out,T&& t)
{
 print_define(out,std::forward<T>(t));
};

template<typename output,typename T>
concept printlnable=output_stream<output>&&requires(output& out,T&& t)
{
 println_define(out,std::forward<T>(t));
};

template<typename output,typename T>
concept writeable=output_stream<output>&&requires(output& out,T&& t)
{
 write_define(out,std::forward<T>(t));
};

}
# 31 "fast_io/fast_io_core.h" 2
# 1 "fast_io/fast_io_core_impl/eof.h" 1
       



namespace fast_io
{

class eof:public std::exception
{
public:
 explicit eof()=default;
 char const* what() const noexcept{return "EOF";}
};


}
# 32 "fast_io/fast_io_core.h" 2
# 1 "fast_io/fast_io_core_impl/fill_nc.h" 1
       

namespace fast_io
{

template<character_output_stream output>
inline constexpr void fill_nc(output& out,std::size_t count,typename output::char_type const& ch)
{
 for(std::size_t i(0);i!=count;++i)
  put(out,ch);
}

}
# 33 "fast_io/fast_io_core.h" 2
# 1 "fast_io/fast_io_core_impl/io_ref.h" 1
       

namespace fast_io
{

template<stream T>
class io_ref
{
 T* ptr;
public:
 using char_type = typename T::char_type;
 constexpr io_ref(T& t): ptr(std::addressof(t)){}
 constexpr T& operator*() const
 {
  return *ptr;
 }
 constexpr T& operator*()
 {
  return *ptr;
 }
 constexpr T* operator->() const
 {
  return ptr;
 }
 constexpr T* operator->()
 {
  return ptr;
 }
};

template<stream T>
inline constexpr T* to_address(io_ref<T>& ref)
{
 return ref.operator->();
}

template<stream T>
inline constexpr T const* to_address(io_ref<T> const& ref)
{
 return ref.operator->();
}

template<stream srm>
io_ref(srm&) -> io_ref<srm>;

template<input_stream input,std::contiguous_iterator Iter>
inline constexpr Iter receive(io_ref<input>& in,Iter begin,Iter end)
{
 return receive(*in,begin,end);
}

template<output_stream output,std::contiguous_iterator Iter>
inline constexpr auto send(io_ref<output>& out,Iter begin,Iter end)
{
 return send(*out,begin,end);
}

template<output_stream output>
inline constexpr void flush(io_ref<output>& out)
{
 flush(*out);
}

template<mutex_stream T>
inline constexpr decltype(auto) mutex(io_ref<T>& t)
{
 return mutex(*t);
}

template<bool err=false,character_input_stream input>
inline constexpr auto get(io_ref<input>& in)
{
 return get<err>(*in);
}

template<character_output_stream output>
inline constexpr void put(io_ref<output>& out,typename output::char_type ch)
{
 put(*out,ch);
}

template<zero_copy_input_stream in>
inline constexpr decltype(auto) zero_copy_in_handle(io_ref<in>& t)
{
 return zero_copy_in_handle(*t);
}

template<zero_copy_output_stream out>
inline constexpr decltype(auto) zero_copy_out_handle(io_ref<out>& t)
{
 return zero_copy_out_handle(*t);
}

template<buffer_input_stream in>
inline constexpr decltype(auto) ireserve(io_ref<in>& t)
{
 return ireserve(*t);
}

template<buffer_input_stream in>
inline constexpr void irelease(io_ref<in>& t)
{
 irelease(*t);
}

template<output_stream output,buffer_input_stream in>
inline constexpr void idump(output& out,io_ref<in>& t)
{
 idump(out,*t);
}

template<buffer_output_stream out>
inline constexpr decltype(auto) oreserve(io_ref<out>& t)
{
 return zero_copy_in_handle(*t);
}

template<buffer_output_stream out>
inline constexpr decltype(auto) orelease(io_ref<out>& t)
{
 orelease(*t);
}




}
# 34 "fast_io/fast_io_core.h" 2
# 1 "fast_io/fast_io_core_impl/manip.h" 1
       

namespace fast_io
{
namespace manip
{
template<typename T>
struct char_view
{
 T& reference;
};

template<std::integral T>
struct unsigned_view
{
 T& reference;
};

template<std::integral T>
struct signed_view
{
 T& reference;
};

template<std::size_t w,bool left,char char_type,typename T>
struct width
{
 T& reference;
};

template<std::size_t precision,typename T>
struct fixed
{
 T& reference;
};

template<std::size_t precision,bool uppercase_e,typename T>
struct scientific
{
 T& reference;
};

template<typename T>
struct fixed_shortest
{
 T& reference;
};

template<bool uppercase_e,typename T>
struct scientific_shortest
{
 T& reference;
};

template<std::size_t precision,bool uppercase_e,typename T>
struct shortest
{
 T& reference;
};

template<bool uppercase_e,typename T>
struct shortest_shortest
{
 T& reference;
};

}
template<typename T>
requires (std::floating_point<T>||std::integral<T>)
inline constexpr manip::char_view<T> char_view(T& ch)
{
 return {ch};
}
template<typename T>
requires (std::floating_point<T>||std::integral<T>)
inline constexpr manip::char_view<T const> char_view(T const& ch)
{
 return {ch};
}

template<std::integral T>
inline constexpr decltype(auto) unsigned_view(T& value)
{
 return reinterpret_cast<std::make_unsigned_t<T>&>(value);
}

template<std::integral T>
inline constexpr decltype(auto) signed_view(T& value)
{
 return reinterpret_cast<std::make_signed_t<T>&>(value);
}

template<std::integral T>
inline constexpr decltype(auto) unsigned_view(T const& value)
{
 return reinterpret_cast<std::make_unsigned_t<T const>&>(value);
}

template<std::integral T>
inline constexpr decltype(auto) floating_view(T const& value)
{
 return static_cast<long double>(value);
}

template<std::floating_point F>
inline constexpr decltype(auto) floating_view(F const& p)
{
 return p;
}

template<std::floating_point F>
inline constexpr decltype(auto) unsigned_view(F const& f)
{
 return static_cast<std::uintmax_t>(f);
}

template<std::floating_point F>
inline constexpr decltype(auto) signed_view(F const& f)
{
 return static_cast<std::intmax_t>(f);
}

template<std::integral T>
inline constexpr decltype(auto) signed_view(T const& value)
{
 return reinterpret_cast<std::make_signed_t<T const>&>(value);
}

template<typename T>
inline constexpr std::size_t unsigned_view(T * const pointer)
{
 return bit_cast<std::size_t>(pointer);
}

template<std::size_t precision,typename T>
inline constexpr manip::fixed<precision,T const> fixed(T const &f){return {f};}

template<std::size_t precision,typename T>
inline constexpr manip::scientific<precision,false,T const> scientific(T const &f){return {f};}
template<std::size_t precision,typename T>
inline constexpr manip::scientific<precision,true,T const> scientific_upper(T const &f){return {f};}

template<typename T>
inline constexpr manip::scientific_shortest<false,T const> scientific(T const &f){return {f};}
template<typename T>
inline constexpr manip::scientific_shortest<true,T const> scientific_upper(T const &f){return {f};}

template<typename T>
inline constexpr manip::fixed_shortest<T const> fixed(T const &f){return {f};}


template<typename T>
inline constexpr manip::shortest_shortest<false,T const> shortest(T const &f){return {f};}
template<typename T>
inline constexpr manip::shortest_shortest<true,T const> shortest_upper(T const &f){return {f};}

template<character_input_stream input,std::integral T>
inline void scan_define(input& in,manip::char_view<T> a)
{
 a.reference = get(in);
}

template<character_output_stream output,std::integral T>
inline void print_define(output& out,manip::char_view<T> a)
{
 put(out,static_cast<typename output::char_type>(a.reference));
}

template<character_input_stream input,std::floating_point T>
inline void scan_define(input& in,manip::char_view<T> a)
{
 a.reference = get(in);
}

template<character_output_stream output,std::floating_point T>
inline void print_define(output& out,manip::char_view<T> a)
{
 put(out,static_cast<typename output::char_type>(a.reference));
}

template<std::size_t indent_w,bool left=false,char fill_ch=0x20,typename T>
inline constexpr manip::width<indent_w,left,fill_ch,T const> width(T const& t)
{
 return {t};
}

}
# 35 "fast_io/fast_io_core.h" 2


# 1 "fast_io/fast_io_core_impl/shared_base_table.h" 1
       

namespace fast_io::details
{
inline constexpr std::pair<std::size_t,std::size_t> cal_base_pw_size(std::size_t u)
{
 std::size_t retch(0);
 std::size_t retpw(0);

 std::size_t chars(0);
 std::size_t pw(1);
 for(;pw*chars<512;++chars)
 {
  retch=chars;
  retpw=pw;
  pw*=u;
 }
 if(retch<2)
  return {2,u*u};
 else
  return {retch,retpw};
}

template<std::size_t base,bool upper>
inline constexpr auto cal_content()
{
 constexpr auto val(cal_base_pw_size(base));
 constexpr std::size_t chars(val.first);
 static_assert(1<chars,"table width must be larger than 1");
 constexpr std::size_t pw(val.second);
 std::array<std::array<char,chars>,pw> vals{};
 for(std::size_t i(1);i<pw;++i)
 {
  auto& val(vals[i]);
  val=vals[i-1];
  std::size_t j(chars);
  for(;j--;)
  {
   if(val[j]==base-1)
    val[j]=0;
   else
    break;
  }
  ++val[j];
 }
 for(auto &e : vals)
  for(auto &e1 : e)
   if constexpr(10<base)
   {
    if(e1<10)
     e1+=0x30;
    else
    {
     if constexpr(upper)
      e1+=0x41-10;
     else
      e1+=0x61-10;
    }
   }
   else
    e1+=0x30;
 return vals;
}

template<std::size_t base,bool upper>
struct shared_static_base_table
{
 inline static constexpr auto table=cal_content<base,upper>();
};
}
# 38 "fast_io/fast_io_core.h" 2
# 1 "fast_io/fast_io_core_impl/base.h" 1
       

namespace fast_io
{

namespace details
{

template<std::size_t bs,bool uppercase=false>
struct base_number_upper_constraints
{
 explicit base_number_upper_constraints() = default;
 static constexpr bool value = 2<=bs&&bs<=36&&((bs<=10&&!uppercase)||10<bs);
};

template<std::uint8_t base,bool uppercase,bool point=false,std::random_access_iterator Iter,typename U>
requires (!std::signed_integral<U>)
inline constexpr auto output_base_number_impl(Iter iter,U a)
{



 constexpr auto &table(details::shared_static_base_table<base,uppercase>::table);
 constexpr std::uint32_t pw(static_cast<std::uint32_t>(table.size()));
 constexpr std::size_t chars(table.front().size());
 for(;pw<=a;)
 {
  auto const rem(a%pw);
  a/=pw;
  std::copy_n(table[rem].data(),chars,iter-=chars);
 }
 if constexpr(chars==2)
 {
  if(base<=a)
  {
   auto const& tm(table[a]);

   if constexpr(point)
   {
    *--iter=tm[1];
    *--iter=0x2E;
    *--iter=tm.front();
   }
   else
   {
    std::copy_n(tm.data(),chars,iter-=chars);
   }
  }
  else
  {
   if constexpr(point)
    *--iter=0x2E;
   if constexpr(10 < base)
   {
    if(a<10)
     *--iter = a+0x30;
    else
    {
     if constexpr (uppercase)
      *--iter = a+55;
     else
      *--iter = a+87;
    }
   }
   else
    *--iter=a+0x30;
  }
 }
 else
 {
  if(base<=a)
  {
   auto const& tm(table[a]);
   auto i(tm.data());
   for(;*i==0x30;++i);
   auto const ed(tm.data()+chars);
   if constexpr(point)
   {
    std::copy(i+1,ed,iter-=ed-(i+1));
    *--iter=0x2E;
    *--iter=*i;
   }
   else
    std::copy(i,ed,iter-=ed-i);
  }
  else
  {
   if constexpr(point)
    *--iter=0x2E;
   if constexpr(10 < base)
   {
    if(a<10)
     *--iter = a+0x30;
    else
    {
     if constexpr (uppercase)
      *--iter = a+55;
     else
      *--iter = a+87;
    }
   }
   else
    *--iter=a+0x30;
  }
 }
 return iter;
}

template<std::uint32_t base,bool ryu_mode=false,typename U>
requires (!std::signed_integral<U>)
inline constexpr std::size_t chars_len(U value) noexcept
{
 if constexpr(base==10&&sizeof(U)<9)
 {
  if constexpr(7<sizeof(U))
  {
   if constexpr(!ryu_mode)
   {
    if(10000000000000000000ULL<=value)
     return 20;
    if(1000000000000000000ULL<=value)
     return 19;
    if(100000000000000000ULL<=value)
     return 18;
   }
   if(10000000000000000ULL<=value)
    return 17;
   if(1000000000000000ULL<=value)
    return 16;
   if(100000000000000ULL<=value)
    return 15;
   if(10000000000000ULL<=value)
    return 14;
   if(1000000000000ULL<=value)
    return 13;
   if(100000000000ULL<=value)
    return 12;
   if(10000000000ULL<=value)
    return 11;
  }
  if constexpr(3<sizeof(U))
  {
   if constexpr(4<sizeof(U)||!ryu_mode)
   {
    if(1000000000U<=value)
     return 10;
   }
   if(100000000U<=value)
    return 9;
   if(10000000U<=value)
    return 8;
   if(1000000U<=value)
    return 7;
   if(100000U<=value)
    return 6;
  }
  if constexpr(1<sizeof(U))
  {
   if(10000U<=value)
    return 5;
   if(1000U<=value)
    return 4;
  }
  if(100U<=value)
   return 3;
  if(10U<=value)
   return 2;
  return 1;
 }
 else
 {
  constexpr std::uint32_t base2(base * base);
  constexpr std::uint32_t base3(base2 * base);
  constexpr std::uint32_t base4(base3 * base);
  for (std::size_t n(1);;n+=4)
  {
   if (value < base)
    return n;
   if (value < base2)
    return n + 1;
   if (value < base3)
    return n + 2;
   if (value < base4)
    return n + 3;
   value /= base4;
  }
 }
}


template<std::uint8_t base,bool uppercase,bool ln=false,output_stream output,std::unsigned_integral U>
inline constexpr void output_base_number(output& out,U a)
{
 if constexpr(buffer_output_stream<output>)
 {
  if constexpr(ln)
  {
   auto reserved(oreserve(out,chars_len<base,false>(a)+1));
   if constexpr(std::is_pointer_v<decltype(reserved)>)
   {
    if(reserved)
    {
     *--reserved=0xA;
     output_base_number_impl<base,uppercase>(reserved,a);
     return;
    }
   }
   else
   {
    *--reserved=0xA;
    output_base_number_impl<base,uppercase>(reserved,a);
    return;
   }
  }
  else
  {
   auto reserved(oreserve(out,chars_len<base,false>(a)));
   if constexpr(std::is_pointer_v<decltype(reserved)>)
   {
    if(reserved)
    {
     output_base_number_impl<base,uppercase>(reserved,a);
     return;
    }
   }
   else
   {
    output_base_number_impl<base,uppercase>(reserved,a);
    return;
   }
  }
 }
 if constexpr(ln)
 {
  std::array<typename output::char_type,sizeof(a)*8+1> v;
  v.back()=0xA;
  auto const e(v.data()+v.size());
  send(out,output_base_number_impl<base,uppercase>(e-1,a),e);
 }
 else
 {
  std::array<typename output::char_type,sizeof(a)*8> v;
  auto const e(v.data()+v.size());
  send(out,output_base_number_impl<base,uppercase>(e,a),e);
 }
}

template<std::uint8_t base,bool uppercase,bool ln=false,output_stream output,std::signed_integral T>
inline constexpr void output_base_number(output& out,T b)
{
 bool const minus(b<0);
 auto const a(static_cast<std::make_unsigned_t<T>>(minus?-b:b));
 if constexpr(buffer_output_stream<output>)
 {
  if constexpr(ln)
  {
   auto reserved(oreserve(out,chars_len<base>(a)+1+minus));
   if constexpr(std::is_pointer_v<decltype(reserved)>)
   {
    if(reserved)
    {
     *--reserved=0xA;
     auto p(output_base_number_impl<base,uppercase>(reserved,a));
     if(minus)
      *--p=0x2d;
     return;
    }
   }
   else
   {
    *--reserved=0xA;
    auto p(output_base_number_impl<base,uppercase>(reserved,a));
    if(minus)
     *--p=0x2d;
    return;
   }
  }
  else
  {
   auto reserved(oreserve(out,chars_len<base>(a)+minus));
   if constexpr(std::is_pointer_v<decltype(reserved)>)
   {
    if(reserved)
    {
     auto p(output_base_number_impl<base,uppercase>(reserved,a));
     if(minus)
      *--p=0x2d;
     return;
    }
   }
   else
   {
    auto p(output_base_number_impl<base,uppercase>(reserved,a));
    if(minus)
     *--p=0x2d;
    return;
   }
  }
 }
 if constexpr(ln)
 {
  std::array<typename output::char_type,sizeof(a)*8+2> v;
  v.back()=0xA;
  auto const e(v.data()+v.size());
  auto iter(output_base_number_impl<base,uppercase>(e-1,a));
  if(minus)
   *--iter=0x2d;
  send(out,iter,e);
 }
 else
 {
  std::array<typename output::char_type,sizeof(a)*8+1> v;
  auto const e(v.data()+v.size());
  auto iter(output_base_number_impl<base,uppercase>(e,a));
  if(minus)
   *--iter=0x2d;
  send(out,iter,e);
 }
}

template<std::uint8_t base,character_input_stream input,std::integral U>
inline constexpr void input_base_number_phase2(input& in,U& a)
{
 using unsigned_char_type = std::make_unsigned_t<decltype(get(in))>;
 unsigned_char_type constexpr baseed(std::min(static_cast<unsigned_char_type>(base),static_cast<unsigned_char_type>(10)));
 while(true)
 {
  unsigned_char_type ch(get<true>(in).first);
  if((ch-=48)<baseed)
   a=a*base+ch;
  else if constexpr (10 < base)
  {
   unsigned_char_type constexpr bm10(base-10);
   if((ch-=17)<bm10||(ch-=32)<bm10)
    a=a*base+(ch+10);
   else
    return;
  }
  else
   return;
 }
}

template<std::uint8_t base,character_input_stream input,std::unsigned_integral U>
inline constexpr void input_base_number(input& in,U& a)
{
 using unsigned_char_type = std::make_unsigned_t<decltype(get(in))>;
 unsigned_char_type constexpr baseed(std::min(static_cast<unsigned_char_type>(base),static_cast<unsigned_char_type>(10)));
 while(true)
 {
  unsigned_char_type ch(get(in));
  if((ch-=48)<baseed)
  {
   a=ch;
   break;
  }
  else if constexpr (10 < base)
  {
   unsigned_char_type constexpr bm10(base-10);
   if((ch-=17)<bm10||(ch-=32)<bm10)
   {
    a=ch+10;
    break;
   }
  }
 }
 input_base_number_phase2<base>(in,a);
}
template<std::uint8_t base,character_input_stream input, std::signed_integral T>
inline constexpr void input_base_number(input& in,T& a)
{
 using unsigned_char_type = std::make_unsigned_t<decltype(get(in))>;
 unsigned_char_type constexpr baseed(std::min(static_cast<unsigned_char_type>(base),static_cast<unsigned_char_type>(10)));
 bool rev(false);
 while(true)
 {
  unsigned_char_type ch(get(in));
  if(ch==45)
  {
   a=0;
   rev=true;
   break;
  }
  else if((ch-=48)<baseed)
  {
   a=ch;
   break;
  }
  else if constexpr (10 < base)
  {
   unsigned_char_type constexpr bm10(base-10);
   if((ch-=17)<bm10||(ch-=32)<bm10)
   {
    a=ch+10;
    break;
   }
  }
 }
 input_base_number_phase2<base>(in,a);
 if(rev)
  a=-a;
}

}

namespace manip
{

template<std::size_t bs,bool uppercase,typename T>
requires fast_io::details::base_number_upper_constraints<bs,uppercase>::value
struct base_t
{
 T& reference;
};

template<std::size_t bs,bool uppercase,typename T,std::integral char_type>
requires fast_io::details::base_number_upper_constraints<bs,uppercase>::value
struct base_split_t
{
 T& reference;
 char_type character;
};

}

template<std::size_t b,bool uppercase=false,typename T>
inline constexpr manip::base_t<b,uppercase,T> base(T& t) {return {t};}
template<std::size_t b,bool uppercase=false,typename T>
inline constexpr manip::base_t<b,uppercase,T const> base(T const& t) {return {t};}

template<typename T> inline constexpr manip::base_t<16,false,T> hex(T& t) {return {t};}
template<typename T> inline constexpr manip::base_t<16,false,T const> hex(T const& t){return {t};}

template<typename T> inline constexpr manip::base_t<16,true,T> hexupper(T& t){return {t};}
template<typename T> inline constexpr manip::base_t<16,true,T const> hexupper(T const& t) {return {t};}

template<typename T> inline constexpr manip::base_t<8,false,T> oct(T& t) {return {t};}
template<typename T> inline constexpr manip::base_t<8,false,T const> oct(T const& t){return {t};}

template<typename T> inline constexpr manip::base_t<10,false,T> dec(T& t) {return {t};}
template<typename T> inline constexpr manip::base_t<10,false,T const> dec(T const& t){return {t};}

template<typename T> inline constexpr manip::base_t<2,false,T> bin(T& t){return {t};}
template<typename T> inline constexpr manip::base_t<2,false,T const> bin(T const& t) {return {t};}


template<std::size_t b,bool uppercase=false,typename T,std::integral char_type>
inline constexpr manip::base_split_t<b,uppercase,T,char_type> base_split(T& t,char_type ch) {return {t,ch};}
template<std::size_t b,bool uppercase=false,typename T,std::integral char_type>
inline constexpr manip::base_split_t<b,uppercase,T const,char_type> base_split(T const& t,char_type ch) {return {t,ch};}

template<typename T,std::integral char_type> inline constexpr manip::base_split_t<16,false,T,char_type> hex_split(T& t,char_type ch) {return {t,ch};}
template<typename T,std::integral char_type> inline constexpr manip::base_split_t<16,false,T const,char_type> hex_split(T const& t,char_type ch){return {t,ch};}

template<typename T,std::integral char_type> inline constexpr manip::base_split_t<16,true,T,char_type> hexupper_split(T& t,char_type ch){return {t,ch};}
template<typename T,std::integral char_type> inline constexpr manip::base_split_t<16,true,T const,char_type> hexupper_split(T const& t,char_type ch) {return {t,ch};}

template<typename T,std::integral char_type> inline constexpr manip::base_split_t<8,false,T,char_type> oct_split(T& t,char_type ch) {return {t,ch};}
template<typename T,std::integral char_type> inline constexpr manip::base_split_t<8,false,T const,char_type> oct_split(T const& t,char_type ch){return {t,ch};}

template<typename T,std::integral char_type> inline constexpr manip::base_split_t<10,false,T,char_type> dec_split(T& t,char_type ch) {return {t,ch};}
template<typename T,std::integral char_type> inline constexpr manip::base_split_t<10,false,T const,char_type> dec_split(T const& t,char_type ch){return {t,ch};}

template<typename T,std::integral char_type> inline constexpr manip::base_split_t<2,false,T,char_type> bin_split(T& t,char_type ch){return {t,ch};}
template<typename T,std::integral char_type> inline constexpr manip::base_split_t<2,false,T const,char_type> bin_split(T const& t,char_type ch) {return {t,ch};}

template<std::size_t base,bool uppercase,character_output_stream output,std::integral T>
inline constexpr void print_define(output& out,manip::base_t<base,uppercase,T> v)
{
 details::output_base_number<base,uppercase>(out,v.reference);
}

template<std::size_t base,bool uppercase,character_output_stream output,std::integral T>
inline constexpr void println_define(output& out,manip::base_t<base,uppercase,T> v)
{
 details::output_base_number<base,uppercase,true>(out,v.reference);
}

template<std::size_t base,bool uppercase,character_input_stream input,std::integral T>
inline constexpr void scan_define(input& in,manip::base_t<base,uppercase,T> v)
{
 details::input_base_number<base>(in,v.reference);
}


template<character_input_stream input,std::integral T>
inline constexpr void scan_define(input& in,T& a)
{
 details::input_base_number<10>(in,a);
}

template<output_stream output,std::integral T>
inline constexpr void print_define(output& out,T const& a)
{
 details::output_base_number<10,false>(out,a);
}

template<output_stream output,std::integral T>
inline constexpr void println_define(output& out,T const& a)
{
 details::output_base_number<10,false,true>(out,a);
}

template<std::size_t base,bool uppercase,output_stream output,typename T>
requires std::same_as<std::byte,std::remove_cvref_t<T>>
inline constexpr void print_define(output& out,manip::base_t<base,uppercase,T> v)
{
 details::output_base_number<base,uppercase>(out,std::to_integer<char unsigned>(v.reference));
}

template<std::size_t base,bool uppercase,character_input_stream input,typename T>
requires std::same_as<std::byte,std::remove_cvref_t<T>>
inline constexpr void scan_define(input& in,manip::base_t<base,uppercase,T> v)
{
 char unsigned u{};
 details::input_base_number<base>(in,u);
 v.reference=static_cast<std::byte>(u);
}


template<character_input_stream input,typename T>
requires std::same_as<std::byte,std::remove_cvref_t<T>>
inline constexpr void scan_define(input& in,T& a)
{
 char unsigned u{};
 details::input_base_number<10>(in,u);
 a=static_cast<std::byte>(u);
}

template<output_stream output,typename T>
requires std::same_as<std::byte,std::remove_cvref_t<T>>
inline constexpr void print_define(output& out,T& a)
{
 details::output_base_number<10,false>(out,std::to_integer<char unsigned>(a));
}

template<output_stream output,typename T>
requires std::same_as<std::byte,std::remove_cvref_t<T>>
inline constexpr void println_define(output& out,T& a)
{
 details::output_base_number<10,false,true>(out,std::to_integer<char unsigned>(a));
}


template<std::size_t bas,bool uppercase,std::integral char_type,character_output_stream output,std::ranges::range T>
inline constexpr void print_define(output& out,manip::base_split_t<bas,uppercase,T,char_type> rangeref)
{
 auto i(cbegin(rangeref.reference));
 auto e(cend(rangeref.reference));
 if(i==e)
  return;
 print(out,base<bas,uppercase>(*i));
 for(++i;i!=e;++i)
  print(out,char_view(rangeref.character),base<bas,uppercase>(*i));
}

}
# 39 "fast_io/fast_io_core.h" 2
# 1 "fast_io/fast_io_core_impl/mode.h" 1
       

namespace fast_io
{

namespace open
{

struct mode
{
 std::size_t value;
 constexpr operator std::size_t() const
 {
  return value;
 }
 constexpr mode& operator|=(mode const& b)
 {
  value|=b.value;
  return *this;
 }
 constexpr mode(std::size_t val=0):value(val){}
};

inline static mode constexpr app{1};
inline static mode constexpr ate{1<<1};
inline static mode constexpr binary{1<<2};
inline static mode constexpr direct{1<<3};
inline static mode constexpr excl{1<<4};
inline static mode constexpr in{1<<5};
inline static mode constexpr out{1<<6};
inline static mode constexpr overlapped{1<<7};
inline static mode constexpr sync{1<<8};
inline static mode constexpr trunc{1<<9};

inline constexpr mode operator|(mode const& a,mode const& b)
{
 auto temp(a);
 temp|=b;
 return temp;
}

inline constexpr mode remove_ate(mode const& m)
{
 return {m.value&~ate.value};
}
inline constexpr mode remove_ate_overlapped(mode const& m)
{
 return {m.value&~ate.value&~overlapped.value};
}

inline constexpr mode remove_binary(mode const& m)
{
 return {m.value&~binary.value};
}

inline constexpr bool with_ate(mode const& m)
{
 return m.value&ate.value;
}
inline constexpr bool with_binary(mode const& m)
{
 return m.value&binary.value;
}

inline constexpr mode remove_direct(mode const& m)
{
 return {m.value&~direct.value};
}

inline constexpr bool with_direct(mode const& m)
{
 return m.value&direct.value;
}

inline constexpr mode remove_sync(mode const& m)
{
 return {m.value&~sync.value};
}

inline constexpr bool with_sync(mode const& m)
{
 return m.value&sync.value;
}

inline constexpr mode remove_ate_direct_sync(mode const& m)
{
 return {m.value&~ate.value&~direct.value&~sync.value};
}
inline constexpr mode remove_ate_binary_direct_sync(mode const& m)
{
 return {m.value&~ate.value&~binary.value&~direct.value&~sync.value};
}


inline auto constexpr c_style(mode const& m)
{
 using namespace std::string_view_literals;
 switch(remove_ate_direct_sync(m))
 {


 case in:
  return "r"sv;

 case out:
 case out|trunc:
  return "w"sv;

 case app:
 case out|app:
  return "a"sv;

 case out|in:
  return "r+"sv;

 case out|in|trunc:
  return "w+"sv;

 case out|in|app:
 case in|app:
  return "a+"sv;

 case out|excl:
 case out|trunc|excl:
  return "wx"sv;

 case app|excl:
 case out|app|excl:
  return "ax"sv;

 case out|in|trunc|excl:
  return "w+x"sv;

 case out|in|app|excl:
 case in|app|excl:
  return "a+x"sv;
 break;





 case in|binary:
  return "rb"sv;

 case out|binary:
 case out|trunc|binary:
  return "wb"sv;

 case app|binary:
 case out|app|binary:
  return "ab"sv;

 case out|in|binary:
  return "r+b"sv;

 case out|in|trunc|binary:
  return "w+b"sv;

 case out|in|app|binary:
 case in|app|binary:
  return "a+b"sv;

 case out|excl|binary:
 case out|trunc|excl|binary:
  return "wxb"sv;

 case app|excl|binary:
 case out|app|excl|binary:
  return "axb"sv;

 case out|in|trunc|excl|binary:
  return "w+xb"sv;

 case out|in|app|excl|binary:
 case in|app|excl|binary:
  return "a+xb"sv;
 break;
 default:
  static_assert(true, "unknown open mode");
 }
}

inline auto constexpr c_style(std::string_view csm)
{
 mode v{};
 bool extended(false);
 for(auto const& e : csm)
  if(e==0x2b)
   extended=true;
 for(auto const& e : csm)
  switch(e)
  {
   case u8'a':
    v|=app;
    if(extended)
     v|=in|out;
   break;
   case u8'b':
    v|=binary;
   break;
   case 0x72:
    v|=in;
    if(extended)
     v|=out;
   break;
   case 0x77:
    v|=out;
    if(extended)
     v|=in|trunc;
   break;
   case 0x78:
    v|=excl;
   break;
   case 0x2b:
   break;
   default:
    static_assert(true,"unknown C-style open mode");
  }
 return v;
}


template<std::size_t om>
struct interface_t
{
inline static fast_io::open::mode constexpr mode = {om};
explicit interface_t()=default;
};

template<std::size_t om>
inline interface_t<om> constexpr interface{};

}

struct native_interface_t
{
 explicit native_interface_t() = default;
};
inline native_interface_t constexpr native_interface;


}
# 40 "fast_io/fast_io_core.h" 2
# 1 "fast_io/fast_io_core_impl/perms.h" 1
       

namespace fast_io
{

enum class perms : unsigned
{
none = 0,
owner_read = 0400,
owner_write = 0200,
owner_exec = 0100,
owner_all = 0700,
group_read = 040,
group_write = 020,
group_exec = 010,
group_all = 070,
others_read = 04,
others_write = 02,
others_exec = 01,
others_all = 07,
all = 0777,
set_uid = 04000,
set_gid = 02000,
sticky_bit = 01000,
mask = 07777,
unknown = 0xFFFF,
add_perms = 0x10000,
remove_perms = 0x20000,
symlink_nofollow= 0x40000
};

constexpr perms operator&(perms x, perms y) noexcept
{
using utype = typename std::underlying_type<perms>::type;
return static_cast<perms>(static_cast<utype>(x) & static_cast<utype>(y));
}

constexpr perms operator|(perms x, perms y) noexcept
{
using utype = typename std::underlying_type<perms>::type;
return static_cast<perms>(static_cast<utype>(x) | static_cast<utype>(y));
}

constexpr perms operator^(perms x, perms y) noexcept
{
using utype = typename std::underlying_type<perms>::type;
return static_cast<perms>(static_cast<utype>(x) ^ static_cast<utype>(y));
}

constexpr perms operator~(perms x) noexcept
{
using utype = typename std::underlying_type<perms>::type;
return static_cast<perms>(~static_cast<utype>(x));
}

inline perms& operator&=(perms& x, perms y) noexcept{return x=x&y;}

inline perms& operator|=(perms& x, perms y) noexcept{return x=x|y;}

inline perms& operator^=(perms& x, perms y) noexcept{return x=x^y;}

template<perms pm>
struct perms_interface_t
{
inline constexpr static fast_io::open::mode permission = {pm};
explicit constexpr perms_interface_t()=default;
};

template<perms pm>
inline constexpr perms_interface_t<pm> perms_interface{};

namespace details::perm
{
template<char fillch,character_output_stream output>
inline constexpr void print_perm_per_check(output& out,perms p,perms checked)
{
 if((p&checked)==perms::none)
  put(out,0x2d);
 else
  put(out,fillch);
}
}


template<character_output_stream output>
inline constexpr void print_define(output& out,perms p)
{
 details::perm::print_perm_per_check<0x72>(out,p,perms::owner_read);
 details::perm::print_perm_per_check<0x77>(out,p,perms::owner_write);
 details::perm::print_perm_per_check<0x78>(out,p,perms::owner_exec);
 details::perm::print_perm_per_check<0x72>(out,p,perms::group_read);
 details::perm::print_perm_per_check<0x77>(out,p,perms::group_write);
 details::perm::print_perm_per_check<0x78>(out,p,perms::group_exec);
 details::perm::print_perm_per_check<0x72>(out,p,perms::others_read);
 details::perm::print_perm_per_check<0x77>(out,p,perms::others_write);
 details::perm::print_perm_per_check<0x78>(out,p,perms::others_exec);
}

}
# 41 "fast_io/fast_io_core.h" 2
# 1 "fast_io/fast_io_core_impl/istring_view.h" 1
       


namespace fast_io
{

template< typename T>
class basic_istring_view
{
 T s;
public:
 using char_type = typename T::value_type;
 template<typename ...Args>
 requires std::constructible_from<T,Args...>
 constexpr basic_istring_view(Args&& ...args):s(std::forward<Args>(args)...){}
 constexpr auto& str()
 {
  return s;
 }
 constexpr auto empty() const {return s.empty();}
};
template<typename T>
[[nodiscard]] inline constexpr std::size_t isize(basic_istring_view<T>& isv)
{
 return isv.str().size();
}

template<typename T>
[[nodiscard]] inline constexpr auto ireserve(basic_istring_view<T>& isv,std::size_t size)
{
 isv.str().remove_prefix(size);
 return isv.str().begin();
}

template<typename T>
inline constexpr void irelease(basic_istring_view<T>& isv,std::size_t size)
{
 isv.str()={isv.str().data()-size,isv.str().size()+size};
}

template<output_stream output, typename T>
inline constexpr void idump(output& out,basic_istring_view<T>& isv)
{
 send(out,isv.str().data(),isv.str().data()+isv.str().size());
 isv.str()={};
}

template<typename T,std::contiguous_iterator Iter>
inline constexpr Iter receive(basic_istring_view<T>& istrvw,Iter begin,Iter end)
{
 auto pb(static_cast<typename T::value_type*>(static_cast<void*>(std::to_address(begin))));
 auto pe(static_cast<typename T::value_type*>(static_cast<void*>(std::to_address(end))));
 std::size_t const cped(istrvw.str().copy(pb,pe-pb));
 istrvw.str().remove_prefix(cped);
 return begin+cped*sizeof(*begin)/sizeof(typename T::value_type);
}

template<bool err=false,typename T>
inline constexpr auto get(basic_istring_view<T>& istrvw)
{
 if(istrvw.empty())
 {
  if constexpr(err)
   return std::pair<typename T::value_type,bool>{0,true};
  else
  {

  throw eof();



  }
 }
 auto ch(istrvw.str().front());
 istrvw.str().remove_prefix(1);
 if constexpr(err)
  return std::pair<typename T::value_type,bool>{ch,false};
 else
  return ch;
}

using istring_view = basic_istring_view<std::string_view>;

}
# 42 "fast_io/fast_io_core.h" 2
# 1 "fast_io/fast_io_core_impl/ospan.h" 1
       


namespace fast_io
{

template<typename T>
class basic_ospan
{
 T s;
public:
 typename T::pointer internal_pointer;
 using value_type = T;
 using char_type = typename T::value_type;
 template<typename ...Args>
 requires std::constructible_from<T,Args...>
 constexpr basic_ospan(Args&& ...args):s(std::forward<Args>(args)...),internal_pointer(s.data()){}
 constexpr auto& span()
 {
  return s;
 }
 constexpr void clear(){internal_pointer=s.data();}
};

template<typename T>
[[nodiscard]] inline constexpr std::size_t osize(basic_ospan<T>& ob)
{
 return ob.internal_pointer-ob.span().data();
}

template<typename T>
[[nodiscard]] inline constexpr auto oreserve(basic_ospan<T>& ob,std::size_t size)
{
 return ob.internal_pointer+=size;
}

template<typename T>
inline constexpr void orelease(basic_ospan<T>& ob,std::size_t size)
{
 ob.internal_pointer-=size;
}

template<typename T,std::contiguous_iterator Iter>
inline constexpr void send(basic_ospan<T>& ob,Iter cbegin,Iter cend)
{
 using char_type = typename T::value_type;
 ob.internal_pointer=std::copy(static_cast<char_type const*>(static_cast<void const*>(std::to_address(cbegin))),
  static_cast<char_type const*>(static_cast<void const*>(std::to_address(cend))),ob.internal_pointer);
}
template<typename T>
inline constexpr void put(basic_ospan<T>& ob,typename T::value_type ch)
{
 *ob.internal_pointer=ch;
 ++ob.internal_pointer;
}

template<typename T>
inline constexpr void flush(basic_ospan<T>&){}

template<typename T>
inline constexpr void fill_nc(basic_ospan<T>& os,std::size_t count,typename T::value_type const& ch)
{
 os.internal_pointer=std::fill_n(os.internal_pointer,count,ch);
}

template<output_stream output,typename T>
inline constexpr void print_define(output& out,basic_ospan<T> s)
{
 send(out,s.span().data(),s.internal_pointer);
}

template<typename T>
[[nodiscard]] inline constexpr basic_istring_view<std::basic_string_view<typename T::value_type>> to_istring_view(basic_ospan<T> s)
{
 return {s.span().data(),static_cast<std::size_t>(s.internal_pointer-s.span().data())};
}

template<typename T>
[[nodiscard]] inline constexpr std::basic_string_view<typename T::value_type> to_string_view(basic_ospan<T> s)
{
 return {s.span().data(),static_cast<std::size_t>(s.internal_pointer-s.span().data())};
}

}



# 1 "/usr/local/include/c++/10.0.0/span" 1 3
# 37 "/usr/local/include/c++/10.0.0/span" 3
       
# 38 "/usr/local/include/c++/10.0.0/span" 3
# 47 "/usr/local/include/c++/10.0.0/span" 3

# 47 "/usr/local/include/c++/10.0.0/span" 3
namespace std __attribute__ ((__visibility__ ("default")))
{




  inline constexpr size_t dynamic_extent = static_cast<size_t>(-1);

  template<typename _Type, size_t _Extent>
    class span;

  namespace __detail
  {
    template<typename _Tp>
      struct __is_std_span : false_type { };

    template<typename _Tp, size_t _Num>
      struct __is_std_span<span<_Tp, _Num>> : true_type { };

    template<typename _Tp>
      struct __is_std_array : false_type { };

    template<typename _Tp, size_t _Num>
      struct __is_std_array<std::array<_Tp, _Num>> : true_type { };






    template<size_t _Extent>
      class __extent_storage
      {
      public:
 constexpr
 __extent_storage(size_t) noexcept
 { }

 static constexpr size_t
 _M_extent() noexcept
 { return _Extent; }
      };

    template<>
      class __extent_storage<dynamic_extent>
      {
      public:
 constexpr
 __extent_storage(size_t __extent) noexcept
 : _M_extent_value(__extent)
 { }

 constexpr size_t
 _M_extent() const noexcept
 { return this->_M_extent_value; }

      private:
 size_t _M_extent_value;
      };
  }

  template<typename _Type, size_t _Extent = dynamic_extent>
    class span
    {
      template<size_t _Offset, size_t _Count>
 static constexpr size_t
 _S_subspan_extent()
 {
   if constexpr (_Count != dynamic_extent)
     return _Count;
   else if constexpr (extent != dynamic_extent)
     return _Extent - _Offset;
   else
     return dynamic_extent;
 }



      template<typename _Tp, size_t _ArrayExtent>
 using __is_compatible_array = __and_<
   bool_constant<(_Extent == dynamic_extent || _ArrayExtent == _Extent)>,
   __is_array_convertible<_Type, _Tp>>;

      template<typename _Iter, typename _Ref = iter_reference_t<_Iter>>
 using __is_compatible_iterator = __and_<
   bool_constant<contiguous_iterator<_Iter>>,
   is_lvalue_reference<iter_reference_t<_Iter>>,
   is_same<iter_value_t<_Iter>, remove_cvref_t<_Ref>>,
   __is_array_convertible<_Type, remove_reference_t<_Ref>>>;

      template<typename _Range>
 using __is_compatible_range
   = __is_compatible_iterator<ranges::iterator_t<_Range>>;

    public:

      using value_type = remove_cv_t<_Type>;
      using element_type = _Type;
      using size_type = size_t;
      using reference = element_type&;
      using const_reference = const element_type&;
      using pointer = _Type*;
      using const_pointer = const _Type*;
      using iterator
 = __gnu_cxx::__normal_iterator<pointer, span>;
      using const_iterator
 = __gnu_cxx::__normal_iterator<const_pointer, span>;
      using reverse_iterator = std::reverse_iterator<iterator>;
      using const_reverse_iterator = std::reverse_iterator<const_iterator>;
      using difference_type = ptrdiff_t;


      static inline constexpr size_t extent = _Extent;



      constexpr
      span() noexcept
      requires ((_Extent + 1u) <= 1u)
      : _M_extent(0), _M_ptr(nullptr)
      { }

      constexpr
      span(const span&) noexcept = default;

      template<typename _Tp, size_t _ArrayExtent>
 requires (__is_compatible_array<_Tp, _ArrayExtent>::value)
 constexpr
 span(_Tp (&__arr)[_ArrayExtent]) noexcept
 : span(static_cast<pointer>(__arr), _ArrayExtent)
 { }

      template<typename _Tp, size_t _ArrayExtent>
 requires (__is_compatible_array<_Tp, _ArrayExtent>::value)
 constexpr
 span(array<_Tp, _ArrayExtent>& __arr) noexcept
 : span(static_cast<pointer>(__arr.data()), _ArrayExtent)
 { }

      template<typename _Tp, size_t _ArrayExtent>
   requires (__is_compatible_array<const _Tp, _ArrayExtent>::value)
 constexpr
 span(const array<_Tp, _ArrayExtent>& __arr) noexcept
 : span(static_cast<pointer>(__arr.data()), _ArrayExtent)
 { }

    public:
      template<ranges::contiguous_range _Range>
 requires (_Extent == dynamic_extent)
   && (!__detail::__is_std_span<remove_cvref_t<_Range>>::value)
   && (!__detail::__is_std_array<remove_cvref_t<_Range>>::value)
   && (!is_array_v<remove_reference_t<_Range>>)
   && (__is_compatible_range<_Range>::value)
 constexpr
 span(_Range&& __range)
 noexcept(noexcept(ranges::data(__range))
    && noexcept(ranges::size(__range)))
 : span(ranges::data(__range), ranges::size(__range))
 { }

      template<contiguous_iterator _ContiguousIterator,
 sized_sentinel_for<_ContiguousIterator> _Sentinel>
   requires (__is_compatible_iterator<_ContiguousIterator>::value)
     && (!is_convertible_v<_Sentinel, size_type>)
 constexpr
 span(_ContiguousIterator __first, _Sentinel __last)
 noexcept(noexcept(__last - __first))
 : _M_extent(static_cast<size_type>(__last - __first)),
   _M_ptr(std::to_address(__first))
 {
   if (_Extent != dynamic_extent)
     ;
 }

      template<contiguous_iterator _ContiguousIterator>
 requires (__is_compatible_iterator<_ContiguousIterator>::value)
 constexpr
 span(_ContiguousIterator __first, size_type __count)
 noexcept
 : _M_extent(__count), _M_ptr(std::to_address(__first))
 { ; }

      template<typename _OType, size_t _OExtent>
 requires (_Extent == dynamic_extent || _Extent == _OExtent)
   && (__is_array_convertible<_Type, _OType>::value)
 constexpr
 span(const span<_OType, _OExtent>& __s) noexcept
 : _M_extent(__s.size()), _M_ptr(__s.data())
 { }



      constexpr span&
      operator=(const span&) noexcept = default;



      constexpr size_type
      size() const noexcept
      { return this->_M_extent._M_extent(); }

      constexpr size_type
      size_bytes() const noexcept
      { return this->_M_extent._M_extent() * sizeof(element_type); }

      [[nodiscard]] constexpr bool
      empty() const noexcept
      { return size() == 0; }



      constexpr reference
      front() const noexcept
      {
 static_assert(extent != 0);
 ;
 return *this->_M_ptr;
      }

      constexpr reference
      back() const noexcept
      {
 static_assert(extent != 0);
 ;
 return *(this->_M_ptr + (size() - 1));
      }

      constexpr reference
      operator[](size_type __idx) const noexcept
      {
 static_assert(extent != 0);
 ;
 return *(this->_M_ptr + __idx);
      }

      constexpr pointer
      data() const noexcept
      { return this->_M_ptr; }



      constexpr iterator
      begin() const noexcept
      { return iterator(this->_M_ptr); }

      constexpr const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_ptr); }

      constexpr iterator
      end() const noexcept
      { return iterator(this->_M_ptr + this->size()); }

      constexpr const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_ptr + this->size()); }

      constexpr reverse_iterator
      rbegin() const noexcept
      { return reverse_iterator(this->end()); }

      constexpr const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->cend()); }

      constexpr reverse_iterator
      rend() const noexcept
      { return reverse_iterator(this->begin()); }

      constexpr const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->cbegin()); }



      template<size_t _Count>
 constexpr span<element_type, _Count>
 first() const noexcept
 {
   if constexpr (_Extent == dynamic_extent)
     ;
   else
     static_assert(_Count <= extent);
   return { this->data(), _Count };
 }

      constexpr span<element_type, dynamic_extent>
      first(size_type __count) const noexcept
      {
 ;
 return { this->data(), __count };
      }

      template<size_t _Count>
 constexpr span<element_type, _Count>
 last() const noexcept
 {
   if constexpr (_Extent == dynamic_extent)
     ;
   else
     static_assert(_Count <= extent);
   return { this->data() + (this->size() - _Count), _Count };
 }

      constexpr span<element_type, dynamic_extent>
      last(size_type __count) const noexcept
      {
 ;
 return { this->data() + (this->size() - __count), __count };
      }

      template<size_t _Offset, size_t _Count = dynamic_extent>
 constexpr auto
 subspan() const noexcept
 -> span<element_type, _S_subspan_extent<_Offset, _Count>()>
 {
   if constexpr (_Extent == dynamic_extent)
     ;
   else
     static_assert(_Offset <= extent);

   if constexpr (_Count == dynamic_extent)
     return { this->data() + _Offset, this->size() - _Offset };
   else
     {
       if constexpr (_Extent == dynamic_extent)
  {
    ;
    ;
  }
       else
  {
    static_assert(_Count <= extent);
    static_assert(_Count <= (extent - _Offset));
  }
       return { this->data() + _Offset, _Count };
     }
 }

      constexpr span<element_type, dynamic_extent>
      subspan(size_type __offset, size_type __count = dynamic_extent) const
      noexcept
      {
 ;
 if (__count == dynamic_extent)
   __count = this->size() - __offset;
 else
   {
     ;
     ;
   }
 return {this->data() + __offset, __count};
      }

    private:
      [[no_unique_address]] __detail::__extent_storage<extent> _M_extent;
      pointer _M_ptr;
    };


  template<typename _Type, size_t _ArrayExtent>
    span(_Type(&)[_ArrayExtent]) -> span<_Type, _ArrayExtent>;

  template<typename _Type, size_t _ArrayExtent>
    span(array<_Type, _ArrayExtent>&) -> span<_Type, _ArrayExtent>;

  template<typename _Type, size_t _ArrayExtent>
    span(const array<_Type, _ArrayExtent>&)
      -> span<const _Type, _ArrayExtent>;

  template<contiguous_iterator _Iter, typename _Sentinel>
    span(_Iter, _Sentinel)
      -> span<remove_reference_t<ranges::range_reference_t<_Iter>>>;

  template<typename _Range>
    span(_Range &&)
      -> span<remove_reference_t<ranges::range_reference_t<_Range&>>>;

  template<typename _Type, size_t _Extent>
    inline
    span<const byte, _Extent == dynamic_extent
 ? dynamic_extent : _Extent * sizeof(_Type)>
    as_bytes(span<_Type, _Extent> __sp) noexcept
    {
      return {reinterpret_cast<const byte*>(__sp.data()), __sp.size_bytes()};
    }

  template<typename _Type, size_t _Extent>
    inline
    span<byte, _Extent == dynamic_extent
       ? dynamic_extent : _Extent * sizeof(_Type)>
    as_writable_bytes(span<_Type, _Extent> __sp) noexcept
    {
      return {reinterpret_cast<byte*>(__sp.data()), __sp.size_bytes()};
    }


  template<size_t _Index, typename _Type, size_t _Extent>
    constexpr _Type&
    get(span<_Type, _Extent> __sp) noexcept
    {
      static_assert(_Extent != dynamic_extent && _Index < _Extent,
 "get<I> can only be used with a span of non-dynamic (fixed) extent");
      return __sp[_Index];
    }

  template<typename _Tp> struct tuple_size;
  template<size_t __i, typename _Tp> struct tuple_element;

  template<typename _Type, size_t _Extent>
    struct tuple_size<span<_Type, _Extent>>
    : public integral_constant<size_t, _Extent>
    {
      static_assert(_Extent != dynamic_extent, "tuple_size can only "
 "be used with a span of non-dynamic (fixed) extent");
    };

  template<size_t _Index, typename _Type, size_t _Extent>
    struct tuple_element<_Index, span<_Type, _Extent>>
    {
      static_assert(_Extent != dynamic_extent, "tuple_element can only "
 "be used with a span of non-dynamic (fixed) extent");
      static_assert(_Index < _Extent, "Index is less than Extent");
      using type = _Type;
    };

  namespace ranges
  {
    template<typename> extern inline const bool enable_safe_range;

    template<typename _ElementType, size_t _Extent>
      inline constexpr bool
 enable_safe_range<span<_ElementType, _Extent>> = true;
  }

}
# 89 "fast_io/fast_io_core_impl/ospan.h" 2


# 90 "fast_io/fast_io_core_impl/ospan.h"
namespace fast_io
{
 using ospan = basic_ospan<std::span<char>>;
}
# 43 "fast_io/fast_io_core.h" 2

# 1 "fast_io/fast_io_core_impl/ostring.h" 1
       


namespace fast_io
{

template< typename T>
class basic_ostring
{
 T s;
public:
 using value_type = T;
 using char_type = typename T::value_type;
 template<typename ...Args>
 requires std::constructible_from<T,Args...>
 constexpr basic_ostring(Args&& ...args):s(std::forward<Args>(args)...){}
 constexpr auto& str()
 {
  return s;
 }
 constexpr void clear(){s.clear();}
 constexpr auto empty() const {return s.empty();}
};

template<typename T>
[[nodiscard]] inline constexpr std::size_t osize(basic_ostring<T>& ob)
{
 return ob.str().size();
}

template<typename T>
[[nodiscard]] inline constexpr auto oreserve(basic_ostring<T>& ob,std::size_t size)
{
 ob.str().append(size,0);
 return ob.str().end();
}

template<typename T>
inline constexpr void orelease(basic_ostring<T>& ob,std::size_t size)
{
 ob.str().erase(ob.str().cend()-size,ob.str().cend());
}

template<typename T,std::contiguous_iterator Iter>
inline constexpr void send(basic_ostring<T>& ostr,Iter cbegin,Iter cend)
{
 using char_type = typename T::value_type;
 ostr.str().append(static_cast<char_type const*>(static_cast<void const*>(std::to_address(cbegin))),static_cast<char_type const*>(static_cast<void const*>(std::to_address(cend))));
}
template<typename T>
inline constexpr void put(basic_ostring<T>& ostr,typename T::value_type ch)
{
 ostr.str().push_back(ch);
}

template<typename T>
inline constexpr void flush(basic_ostring<T>&){}

template<typename T>
inline constexpr void fill_nc(basic_ostring<T>& os,std::size_t count,typename T::value_type const& ch)
{
 os.str().append(count,ch);
}


}
# 45 "fast_io/fast_io_core.h" 2



# 1 "fast_io/fast_io_core_impl/precondition.h" 1
       

namespace fast_io
{

template<std::signed_integral offset_type,typename T,typename char_type, std::integral integr>
inline constexpr auto seek_precondition(integr i)
{
# 18 "fast_io/fast_io_core_impl/precondition.h"
 return static_cast<offset_type>(i * static_cast<std::ptrdiff_t>(sizeof(T))/static_cast<std::ptrdiff_t>(sizeof(char_type)));
}


template<typename stm>
requires requires(stm& s)
{
 s.native_handle();
}
inline constexpr decltype(auto) ultimate_native_handle(stm& s)
{
 if constexpr(requires(stm& s)
 {
  s.native_handle().native_handle();
 })
  return ultimate_native_handle(s.native_handle());
 else
  return s.native_handle();
}


}
# 49 "fast_io/fast_io_core.h" 2
# 1 "fast_io/fast_io_core_impl/sendrecv.h" 1
       

namespace fast_io
{
template<details::character_output_stream_impl T,std::forward_iterator Iter>
requires (std::same_as<typename std::iterator_traits<Iter>::value_type,typename T::char_type>)
inline constexpr void define_send_by_put(T& stm,Iter b,Iter e)
{
 for(auto i(b);i!=e;++i)
  put(stm,*i);
}

template<details::character_input_stream_impl T,std::forward_iterator Iter>
requires (std::same_as<typename std::iterator_traits<Iter>::value_type,typename T::char_type>)
inline constexpr Iter define_receive_by_get(T& stm,Iter b,Iter e)
{
 for(auto i(b);i!=e;++i)
 {
  auto [ch,err](get<true>(stm));
  if(err) [[unlikely]]
   return i;
  *i=ch;
 }
 return e;
}

template<fast_io::output_stream output,std::ranges::random_access_range range>
inline void send(output& out,range const& rg)
{
 send(out,cbegin(rg),cend(rg));
}

template<fast_io::input_stream input,std::ranges::random_access_range range>
inline void receive(input& in,range& rg)
{
 receive(in,begin(rg),end(rg));
}


}
# 50 "fast_io/fast_io_core.h" 2
# 1 "fast_io/fast_io_core_impl/print_scan.h" 1
       

namespace fast_io
{

namespace details
{

template<std::integral T>
inline constexpr bool isspace(T ch)
{
 if(ch==0x20)
  return true;
 std::make_unsigned_t<T> e(ch);
 e-=9;
 return e<5;
}

}


template<character_input_stream input>
inline constexpr std::size_t skip_line(input& in)
{
 std::size_t skipped(0);
 for(decltype(get<true>(in)) ch;!(ch=get<true>(in)).second&&ch.first!=0xA;++skipped);
 return skipped;
}

template<character_input_stream input>
inline constexpr auto eat_space_get(input& in)
{
 decltype(get(in)) ch(get(in));
 for(;details::isspace(ch);ch=get(in));
 return ch;
}

template<character_input_stream input>
inline constexpr auto try_eat_space_get(input& in)
{
 auto ch(get<true>(in));
 for(;details::isspace(ch.first);ch=get<true>(in));
 return ch;
}

template<character_input_stream input,std::integral T>
requires std::same_as<T,bool>
inline constexpr void scan_define(input& in, T& b)
{
 auto value(eat_space_get(in));
 if(value==0x30)
  b=0;
 else
  b=1;
}

template<character_output_stream output,std::integral T>
requires std::same_as<T,bool>
inline constexpr void print_define(output& out, T const& b)
{
 put(out,b+0x30);
}

template<output_stream output>
inline constexpr void print_define(output& out,std::basic_string_view<typename output::char_type> str)
{
 send(out,str.data(),str.data()+str.size());
}

template<output_stream output>
requires (std::same_as<typename output::char_type,char>)
inline constexpr void print_define(output& out,std::basic_string_view<char8_t> str)
{
 send(out,str.data(),str.data()+str.size());
}

inline namespace print_scan_details
{
template<input_stream input,typename ...Args>
requires(scanable<input,Args>&&...)
inline constexpr void normal_scan(input &in,Args&& ...args)
{
 (scan_define(in,std::forward<Args>(args)),...);
}

template<output_stream output,typename ...Args>
requires(printable<output,Args>&&...)
inline constexpr void normal_print(output &out,Args&& ...args)
{
 (print_define(out,std::forward<Args>(args)),...);
}

template<output_stream output,typename ...Args>
requires((sizeof...(Args)==1&&(printlnable<output,Args>&&...))||(character_output_stream<output>&&(printable<output,Args>&&...)))
inline constexpr void normal_println(output &out,Args&& ...args)
{
 if constexpr((sizeof...(Args)==1)&&(printlnable<output,Args>&&...))
 {
  (println_define(out,std::forward<Args>(args)),...);
 }
 else
 {
  (print_define(out,std::forward<Args>(args)),...);
  put(out,0xA);
 }
}

template<input_stream input,typename ...Args>
requires(readable<input,Args>&&...)
inline constexpr void normal_read(input &in,Args&& ...args)
{
 (read_define(in,std::forward<Args>(args)),...);
}

template<output_stream output,typename ...Args>
requires(writeable<output,Args>&&...)
inline constexpr void normal_write(output &out,Args&& ...args)
{
 (write_define(out,std::forward<Args>(args)),...);
}

}

template<input_stream input,typename ...Args>
requires (sizeof...(Args)!=0)
inline constexpr void scan(input &in,Args&& ...args)
{
 using namespace print_scan_details;
 if constexpr(mutex_input_stream<input>)
 {
  typename input::lock_guard_type lg{mutex(in)};
  decltype(auto) uh(unlocked_handle(in));
  scan(uh,std::forward<Args>(args)...);
 }
 else if constexpr(true)
  normal_scan(in,std::forward<Args>(args)...);
}

template<input_stream input,typename ...Args>
requires (sizeof...(Args)!=0)
inline constexpr void read(input &in,Args&& ...args)
{
 using namespace print_scan_details;
 if constexpr(mutex_input_stream<input>)
 {
  typename input::lock_guard_type lg{mutex(in)};
  decltype(auto) uh(unlocked_handle(in));
  read(uh,std::forward<Args>(args)...);
 }
 else if constexpr(true)
  normal_read(in,std::forward<Args>(args)...);
}

template<output_stream output,typename ...Args>
requires (sizeof...(Args)!=0)
inline constexpr void print(output &out,Args&& ...args)
{
 using namespace print_scan_details;
 if constexpr(mutex_output_stream<output>)
 {
  typename output::lock_guard_type lg{mutex(out)};
  decltype(auto) uh(unlocked_handle(out));
  print(uh,std::forward<Args>(args)...);
 }
 else if constexpr((printable<output,Args>&&...)&&(sizeof...(Args)==1||buffer_output_stream<output>))
  normal_print(out,std::forward<Args>(args)...);
 else if constexpr(true)
  buffer_print(out,std::forward<Args>(args)...);
}

template<output_stream output,typename ...Args>
inline constexpr void println(output &out,Args&& ...args)
{
 using namespace print_scan_details;
 if constexpr(mutex_output_stream<output>)
 {
  typename output::lock_guard_type lg{mutex(out)};
  decltype(auto) uh(unlocked_handle(out));
  println(uh,std::forward<Args>(args)...);
 }
 else if constexpr((sizeof...(Args)==1&&(printlnable<output,Args>&&...))||
 ((printable<output,Args>&&...)&&buffer_output_stream<output>&&character_output_stream<output>))
  normal_println(out,std::forward<Args>(args)...);
 else if constexpr(true)
  buffer_println(out,std::forward<Args>(args)...);
}

template<output_stream output,typename ...Args>
requires (sizeof...(Args)!=0)
inline constexpr void write(output &out,Args&& ...args)
{
 using namespace print_scan_details;
 if constexpr(mutex_output_stream<output>)
 {
  typename output::lock_guard_type lg{mutex(out)};
  decltype(auto) uh(unlocked_handle(out));
  write(uh,std::forward<Args>(args)...);
 }
 else if constexpr((writeable<output,Args>&&...)&&(sizeof...(Args)==1||buffer_output_stream<output>))
  normal_write(out,std::forward<Args>(args)...);
 else if constexpr(true)
  buffer_write(out,std::forward<Args>(args)...);
}


template<output_stream output,typename ...Args>
requires (sizeof...(Args)!=0)
inline constexpr void print_flush(output &out,Args&& ...args)
{
 using namespace print_scan_details;
 if constexpr(mutex_output_stream<output>)
 {
  typename output::lock_guard_type lg{mutex(out)};
  decltype(auto) uh(unlocked_handle(out));
  print_flush(uh,std::forward<Args>(args)...);
 }
 else
 {
  if constexpr((printable<output,Args>&&...)&&(sizeof...(Args)==1||buffer_output_stream<output>))
   normal_print(out,std::forward<Args>(args)...);
  else if constexpr(true)
   buffer_print(out,std::forward<Args>(args)...);
  flush(out);
 }
}

template<output_stream output,typename ...Args>
inline constexpr void println_flush(output &out,Args&& ...args)
{
 using namespace print_scan_details;
 if constexpr(mutex_output_stream<output>)
 {
  typename output::lock_guard_type lg{mutex(out)};
  decltype(auto) uh(unlocked_handle(out));
  println_flush(out.native_handle(),std::forward<Args>(args)...);
 }
 else
 {
  if constexpr((sizeof...(Args)==1&&(printlnable<output,Args>&&...))||
   ((printable<output,Args>&&...)&&buffer_output_stream<output>&&character_output_stream<output>))
   normal_println(out,std::forward<Args>(args)...);
  else if constexpr(true)
   buffer_println(out,std::forward<Args>(args)...);
  flush(out);
 }
}

template<output_stream output,typename ...Args>
requires (sizeof...(Args)!=0)
inline constexpr void write_flush(output &out,Args&& ...args)
{
 using namespace print_scan_details;
 if constexpr(mutex_output_stream<output>)
 {
  typename output::lock_guard_type lg{mutex(out)};
  decltype(auto) uh(unlocked_handle(out));
  write_flush(out.native_handle(),std::forward<Args>(args)...);
 }
 else
 {
  if constexpr((writeable<output,Args>&&...)&&(sizeof...(Args)==1||buffer_output_stream<output>))
   normal_write(out,std::forward<Args>(args)...);
  else if constexpr(true)
   buffer_write(out,std::forward<Args>(args)...);
  flush(out);
 }
}


inline namespace print_scan_details
{
template<output_stream os,typename ch_type,typename ...Args>
inline void fprint_impl(os &out,std::basic_string_view<ch_type> format)
{
 std::size_t percent_pos;
 for(;(percent_pos=format.find(0X25))!=std::string_view::npos&&percent_pos+1!=format.size()&&format[percent_pos+1]==0X25;format.remove_prefix(percent_pos+2))
  send(out,format.cbegin(),format.cbegin()+percent_pos+1);
 if(percent_pos!=std::string_view::npos)
  std::terminate();
 send(out,format.cbegin(),format.cend());
}

template<output_stream os,typename ch_type,typename T,typename ...Args>
inline void fprint_impl(os &out,std::basic_string_view<ch_type> format,T&& cr,Args&& ...args)
{
 std::size_t percent_pos;
 for(;(percent_pos=format.find(0X25))!=std::string_view::npos&&percent_pos+1!=format.size()&&format[percent_pos+1]==0X25;format.remove_prefix(percent_pos+2))
  send(out,format.cbegin(),format.cbegin()+percent_pos+1);
 if(percent_pos==std::string_view::npos)
 {
  send(out,format.cbegin(),format.cend());
  return;
 }
 else
 {
  send(out,format.cbegin(),format.cbegin()+percent_pos);
  format.remove_prefix(percent_pos+1);
 }
 print(out,std::forward<T>(cr));
 fprint_impl(out,format,std::forward<Args>(args)...);
}

template<output_stream output,typename ch_type,typename ...Args>
requires((std::same_as<typename output::char_type,ch_type>||std::same_as<char8_t,ch_type>)&&(printable<output,Args>&&...))
inline constexpr void normal_fprint(output &out,std::basic_string_view<ch_type> mv,Args&& ...args)
{
 fprint_impl(out,mv,std::forward<Args>(args)...);
}

}

template<output_stream output,typename ...Args>
requires (sizeof...(Args)!=0)
inline constexpr void fprint(output &out,Args&& ...args)
{
 using namespace print_scan_details;
 if constexpr(mutex_output_stream<output>)
 {
  typename output::lock_guard_type lg{mutex(out)};
  decltype(auto) uh(unlocked_handle(out));
  fprint(uh,std::forward<Args>(args)...);
 }
 else if constexpr((printable<output,Args>&&...)&&(sizeof...(Args)==1||(buffer_output_stream<output>&&character_output_stream<output>)))
  normal_fprint(out,std::forward<Args>(args)...);
 else if constexpr(true)
  buffer_fprint(out,std::forward<Args>(args)...);
}

template<output_stream output,typename ...Args>
requires (sizeof...(Args)!=0)
inline constexpr void fprint_flush(output &out,Args&& ...args)
{
 using namespace print_scan_details;
 if constexpr(mutex_output_stream<output>)
 {
  typename output::lock_guard_type lg{mutex(out)};
  decltype(auto) uh(unlocked_handle(out));
  fprint_flush(uh,std::forward<Args>(args)...);
 }
 else
 {
  if constexpr((printable<output,Args>&&...)&&(sizeof...(Args)==1||buffer_output_stream<output>))
   normal_fprint(out,std::forward<Args>(args)...);
  else if constexpr(true)
   buffer_fprint(out,std::forward<Args>(args)...);
  flush(out);
 }
}


}
# 51 "fast_io/fast_io_core.h" 2
# 1 "fast_io/fast_io_core_impl/seek.h" 1
       

namespace fast_io
{

enum class seekdir
{
beg = 0,
cur = 1,
end = 2,
};

template<typename T>
struct seek_type_t
{
 inline constexpr explicit seek_type_t() = default;
};

template<typename T>
inline constexpr seek_type_t<T> seek_type{};

}
# 52 "fast_io/fast_io_core.h" 2
# 1 "fast_io/fast_io_core_impl/sync.h" 1
       

namespace fast_io
{
template<output_stream output,typename ostr>
class basic_sync
{
public:
 using native_handle_type = output;
 using char_type = typename native_handle_type::char_type;
 using buffer_type = ostr;
private:
 native_handle_type handle;
 buffer_type mostr;
public:
 auto& buffer(){return mostr;}
 auto& native_handle() {return handle;}
 template<typename ...Args>
 requires std::constructible_from<output,Args...>
 basic_sync(Args&& ...args):handle(std::forward<Args>(args)...){}
};

template<output_stream output,typename ostr>
inline constexpr void flush(basic_sync<output,ostr>& sync)
{
 send(sync.native_handle(),sync.buffer().str().cbegin(),sync.buffer().str().cend());
 sync.buffer().clear();
}

template<output_stream output,typename ostr>
inline constexpr auto oreserve(basic_sync<output,ostr>& sync)
{
 return oreserve(sync.buffer());
}
template<output_stream output,typename ostr>
inline constexpr void orelease(basic_sync<output,ostr>& sync)
{
 orelease(sync.buffer());
}


template<output_stream output,typename ostr>
inline constexpr auto osize(basic_sync<output,ostr>& sync)
{
 return osize(sync.buffer());
}

template<output_stream output,typename ostr,std::contiguous_iterator Iter>
inline constexpr void send(basic_sync<output,ostr>& sync,Iter cbegin,Iter cend)
{
 send(sync.buffer(),cbegin,cend);
}
template<output_stream output,typename ostr>
inline constexpr void put(basic_sync<output,ostr>& sync,typename output::char_type ch)
{
 put(sync.buffer(),ch);
}

template<output_stream output,typename ostr,typename... Args>
requires random_access_stream<output>
inline constexpr auto seek(basic_sync<output,ostr>& sync,Args&& ...args)
{
 flush(sync);
 return seek(sync.native_handle(),std::forward<Args>(args)...);
}

template<io_stream input,typename ostr,std::contiguous_iterator Iter>
inline constexpr Iter receive(basic_sync<input,ostr>& sync,Iter begin,Iter end)
{
 flush(sync);
 return receive(sync.native_handle(),begin,end);
}
template<bool err=false,io_stream input,typename ostr>
requires character_input_stream<input>
inline constexpr auto get(basic_sync<input,ostr>& sync)
{
 flush(sync);
 return get<err>(sync.native_handle());
}

template<output_stream output,typename ostr>
inline constexpr void fill_nc(basic_sync<output,ostr>& ob,std::size_t count,typename output::char_type const& ch)
{
 fill_nc(ob.buffer(),count,ch);
}

template<output_stream output,typename ostr>
class basic_fsync:public basic_sync<output,ostr>
{
 bool need_sync = true;
 void sync()
 try
 {
  if(need_sync)
   flush(static_cast<basic_sync<output,ostr>&>(*this));
 }
 catch(...){}
public:
 using native_handle_type = output;
 using char_type = typename native_handle_type::char_type;
 using buffer_type = ostr;
 template<typename ...Args>
 requires std::constructible_from<output,Args...>
 constexpr basic_fsync(Args&& ...args):basic_sync<output,ostr>(std::forward<Args>(args)...) {}
 basic_fsync(basic_fsync const&) = delete;
 basic_fsync& operator=(basic_fsync const&) = delete;
 basic_fsync(basic_fsync&& other) noexcept:basic_sync<output,ostr>(std::move(other)),need_sync(other.need_sync)
 {
  other.need_sync=false;
 }
 basic_fsync& operator=(basic_fsync&& other) noexcept
 {
  if(std::addressof(other)!=this)
  {
   sync();
   basic_sync<output,ostr>::operator=(std::move(other));
   other.need_sync=false;
  }
  return *this;
 }
 ~basic_fsync(){sync();}
};

}
# 53 "fast_io/fast_io_core.h" 2
# 1 "fast_io/fast_io_core_impl/text.h" 1
       

namespace fast_io
{

namespace details
{

template<typename>
struct text_view_interal_variable{};

template<character_input_stream T>
struct text_view_interal_variable<T>
{
 bool state=false;
 typename T::char_type internal_character{};
};

}
namespace details
{
enum class operating_system
{
 win32,
 posix,



 native=posix

};
}

template<typename T,bool sys=false>
requires character_input_stream<T>||character_output_stream<T>
class text_view
{
public:
 T ib;
 details::text_view_interal_variable<T> state;
public:
 using native_interface_t = T;
 using char_type = typename native_interface_t::char_type;
public:
 template<typename ...Args>
 requires std::constructible_from<T,Args...>
 constexpr text_view(Args&& ...args):ib(std::forward<Args>(args)...){}
 constexpr inline auto& native_handle()
 {
  return ib;
 }
};
# 76 "fast_io/fast_io_core_impl/text.h"
template<bool err=false,character_input_stream T,bool sys>
constexpr inline auto get(text_view<T,sys>& input)
{
 if(input.state.state)
 {
  input.state.state=false;
  if constexpr(err)
   return std::pair<typename T::char_type,bool>{input.state.internal_character,false};
  else
   return input.state.internal_character;
 }
 auto ch(get<err>(input.native_handle()));
 if constexpr(err)
 {
  if(ch.second)
   return std::pair<typename T::char_type,bool>{0,true};
  if(ch.first==0xD)
  {
   auto internal(get<true>(input.native_handle()));
   if(internal.second)
    return ch;
   if(internal.first==0xA)
    return internal;
   input.state.state=true;
   input.state.internal_character=internal.first;
  }
 }
 else
 {
  if(ch==0xD)
  {
   auto internal(get<true>(input.native_handle()));
   if(internal.second)
    return ch;
   if(internal.first==0xA)
    return internal.first;
   input.state.state=true;
   input.state.internal_character=internal.first;
  }
 }
 return ch;
}

template<character_input_stream T,bool sys,std::contiguous_iterator Iter>
constexpr inline Iter receive(text_view<T,sys>& input,Iter b,Iter e)
{
 return define_receive_by_get(input,b,e);
}

template<character_output_stream T,bool sys>
constexpr inline void put(text_view<T,sys>& output,typename text_view<T,sys>::char_type ch)
{
 if constexpr((!sys)||details::operating_system::win32==details::operating_system::native)
  if(ch==0xA)
   put(output.ib,0xD);
 put(output.ib,ch);
}

template<character_output_stream T,bool sys,std::contiguous_iterator Iter>
constexpr inline void send(text_view<T,sys>& output,Iter b,Iter e)
{
 using char_type = T::char_type;
 if constexpr(sys&&details::operating_system::win32!=details::operating_system::native)
  send(output,b,e);
 else
 {
  auto pb(static_cast<char_type const*>(static_cast<void const*>(std::to_address(b))));
  auto last(pb);
  auto pi(pb),pe(pb+(e-b)*sizeof(*b)/sizeof(char_type));
  for(;pi!=pe;++pi)
   if(*pi==0xA)
   {
    send(output.ib,last,pi);
    put(output.ib,0xD);
    last=pi;
   }
  send(output.ib,last,pe);
 }
}

template<character_output_stream T,bool sys>
constexpr inline void flush(text_view<T,sys>& output)
{
 flush(output.ib);
}

template<stream T,bool sys>
inline constexpr void fill_nc(text_view<T,sys>& view,std::size_t count,typename T::char_type const& ch)
{
 if constexpr((!sys)||details::operating_system::win32==details::operating_system::native)
 {
  if(ch==0xA)
  {
   for(std::size_t i(0);i!=count;++i)
   {
    put(view.ib,0xD);
    put(view.ib,0xA);
   }
   return;
  }
 }
 fill_nc(view.ib,count,ch);
}

template<buffer_output_stream T,bool sys>
requires (sys&&details::operating_system::win32!=details::operating_system::native)
inline constexpr void oreserve(text_view<T,sys>& view,std::size_t size)
{
 oreserve(view.ib,size);
}

template<buffer_output_stream T,bool sys>
requires (sys&&details::operating_system::win32!=details::operating_system::native)
inline constexpr void orelease(text_view<T,sys>& view,std::size_t size)
{
 orelease(view.ib,size);
}


}
# 54 "fast_io/fast_io_core.h" 2
# 1 "fast_io/fast_io_core_impl/tie.h" 1
       

namespace fast_io
{

template<stream T,output_stream out>
class tie
{
 out* o;
public:
 using native_handle_type = T;
 using char_type = typename native_handle_type::char_type;
private:
 T t;
public:
 template<typename ...Args>
 requires std::constructible_from<T,Args...>
 constexpr tie(out &oo,Args&& ...args):o(std::addressof(oo)),t(std::forward<Args>(args)...){}
 constexpr auto& to() {return *o;}
 constexpr auto& native_handle() {return t;}
};

template<bool err=false,character_input_stream T,output_stream out>
inline constexpr auto get(tie<T,out>& t)
{
 flush(t.to());
 return get<err>(t.native_handle());
}

template<character_output_stream T,output_stream out>
inline constexpr void put(tie<T,out>& t,typename T::char_type ch)
{
 flush(t.to());
 put(t.native_handle(),ch);
}

template<input_stream T,output_stream O,std::contiguous_iterator Iter>
inline constexpr Iter receive(tie<T,O>& t,Iter begin,Iter end)
{
 flush(t.to());
 return receive(t.native_handle(),begin,end);
}

template<output_stream T,output_stream out>
inline constexpr void flush(tie<T,out>& t)
{
 flush(t.to());
 flush(t.native_handle());
}

template<output_stream T,output_stream out,std::contiguous_iterator Iter>
inline constexpr auto send(tie<T,out>& t,Iter begin,Iter end)
{
 flush(t.to());
 return send(t.native_handle(),begin,end);
}

template<character_output_stream T,output_stream out>
inline constexpr void fill_nc(tie<T,out>& ob,std::size_t count,typename T::char_type const& ch)
{
 flush(ob.to());
 fill_nc(ob.native_handle(),count,ch);
}

template<random_access_stream T,output_stream out,typename... Args>
inline constexpr auto seek(tie<T,out>& t,Args&& ...args)
{
 flush(t.to());
 return seek(t.native_handle(),std::forward<Args>(args)...);
}

template<io_stream T>
class self_tie
{
public:
 using native_handle_type = T;
 using char_type = typename native_handle_type::char_type;
private:
 T t;
public:
 template<typename ...Args>
 requires std::constructible_from<T,Args...>
 constexpr self_tie(Args&& ...args):t(std::forward<Args>(args)...){}
 constexpr auto& native_handle() {return t;}
};

template<io_stream T>
inline constexpr void flush(self_tie<T>& t)
{
 flush(t.native_handle());
}

template<bool err=false,character_input_stream T>
inline constexpr auto get(self_tie<T>& t)
{
 flush(t);
 return get<err>(t.native_handle());
}

template<character_output_stream T>
inline constexpr auto put(self_tie<T>& t,typename T::char_type ch)
{
 flush(t);
 return put(t.native_handle(),ch);
}

template<input_stream T,std::contiguous_iterator Iter>
inline constexpr Iter receive(self_tie<T>& t,Iter begin,Iter end)
{
 flush(t);
 return receive(t.native_handle(),begin,end);
}

template<output_stream T,std::contiguous_iterator Iter>
inline constexpr auto send(self_tie<T>& t,Iter begin,Iter end)
{
 flush(t);
 return send(t.native_handle(),begin,end);
}

template<character_output_stream T>
inline constexpr void fill_nc(self_tie<T>& t,std::size_t count,typename T::char_type const& ch)
{
 flush(t);
 fill_nc(t.native_handle(),count,ch);
}

template<random_access_stream T,typename... Args>
inline constexpr auto seek(self_tie<T>& t,Args&& ...args)
{
 flush(t);
 return seek(t.native_handle(),std::forward<Args>(args)...);
}

}
# 55 "fast_io/fast_io_core.h" 2
# 1 "fast_io/fast_io_core_impl/transmit.h" 1
       

namespace fast_io
{

template<output_stream output,input_stream input>
inline std::size_t bufferred_transmit(output& outp,input& inp)
{
 std::size_t transmitted_bytes(0);
 for(std::array<unsigned char,65536> array;;)
 {
  auto p(receive(inp,array.data(),array.data()+array.size()));
  std::size_t transmitted_this_round(p-array.data());
  transmitted_bytes+=transmitted_this_round;
  send(outp,array.data(),p);
  if(!transmitted_this_round)
   return transmitted_bytes;
 }
}

template<output_stream output,input_stream input>
inline std::size_t bufferred_transmit(output& outp,input& inp,std::size_t bytes)
{
 std::size_t transmitted_bytes(0);
 for(std::array<unsigned char,65536> array;bytes;)
 {
  std::size_t b(array.size());
  if(bytes<b)
   b=bytes;
  auto p(receive(inp,array.data(),array.data()+b));
  std::size_t read_bytes(p-array.data());
  send(outp,array.data(),p);
  transmitted_bytes+=read_bytes;
  if(read_bytes!=b)
   return transmitted_bytes;
  bytes-=read_bytes;
 }
 return transmitted_bytes;
}

template<output_stream output,input_stream input,typename... Args>
inline auto transmit(output& outp,input& inp,Args&& ...args)
{
 if constexpr((zero_copy_output_stream<output>||zero_copy_buffer_output_stream<output>)
  &&(zero_copy_buffer_input_stream<input>||zero_copy_input_stream<input>))
 {
  if constexpr(zero_copy_output_stream<output>&&zero_copy_input_stream<input>)
   return zero_copy_transmit(outp,inp,std::forward<Args>(args)...);
  else if constexpr(zero_copy_buffer_output_stream<output>&&zero_copy_input_stream<input>)
  {
   flush(outp);
   return zero_copy_transmit(outp.native_handle(),inp,std::forward<Args>(args)...);
  }
  else if constexpr(zero_copy_output_stream<output>&&zero_copy_buffer_input_stream<input>)
  {
   idump(outp,inp);
   return zero_copy_transmit(outp.native_handle(),std::forward<Args>(args)...);
  }
  else
  {
   idump(outp,inp);
   flush(outp);
   return zero_copy_transmit(outp.native_handle(),inp.native_handle(),std::forward<Args>(args)...);
  }
 }
 else
  return bufferred_transmit(outp,inp,std::forward<Args>(args)...);
}

}
# 56 "fast_io/fast_io_core.h" 2
# 1 "fast_io/fast_io_core_impl/unsigned_extension.h" 1
       





namespace fast_io
{
template<typename T>
struct basic_unsigned_extension
{
 T low={},high={};
 using value_type = T;
 constexpr basic_unsigned_extension()=default;
 template<typename U>
 requires std::constructible_from<T,U>&&(!std::same_as<U,basic_unsigned_extension<T>>)
 constexpr explicit basic_unsigned_extension(U && a):low(std::forward<U>(a)){}
 template<typename U,typename U1>
 requires std::constructible_from<T,U>&&std::constructible_from<T,U1>
 constexpr basic_unsigned_extension(U && a,U1 && b):low(std::forward<U>(a)),high(std::forward<U1>(b)){}
 inline explicit constexpr operator bool()
 {
  return low||high;
 }

 inline constexpr bool operator[](std::size_t n) const
 {
  return (static_cast<std::uint8_t const*>(static_cast<void const*>(this))[n / 8] >> (n % 8)) & 1;
 }
 inline constexpr bool front() const
 {
  return (*static_cast<std::uint8_t const*>(static_cast<void const*>(this)))&1;
 }
 inline explicit constexpr operator T() const
 {
  return low;
 }
 inline explicit constexpr operator std::uint64_t() const requires(sizeof(T)!=8)
 {
  return static_cast<std::uint64_t>(low);
 }
 inline explicit constexpr operator std::uint32_t() const
 {
  return static_cast<std::uint32_t>(low);
 }
};


template<typename T>
inline constexpr T const& low(basic_unsigned_extension<T> const&a)
{
 return a.low;
}

template<typename T>
inline constexpr T const& high(basic_unsigned_extension<T> const&a)
{
 return a.high;
}

inline constexpr std::uint32_t low(std::uint64_t a)
{
 return a&
# 63 "fast_io/fast_io_core_impl/unsigned_extension.h" 3 4
         (4294967295U)
# 63 "fast_io/fast_io_core_impl/unsigned_extension.h"
                   ;
}

inline constexpr std::uint32_t high(std::uint64_t a)
{
 return a>>32;
}

template<typename T>
inline constexpr basic_unsigned_extension<basic_unsigned_extension<T>> construct(basic_unsigned_extension<T> const& a,basic_unsigned_extension<T> const& b)
{
 return {a,b};
}


inline constexpr std::uint64_t low(__uint128_t a)
{
 return a&
# 80 "fast_io/fast_io_core_impl/unsigned_extension.h" 3 4
         (18446744073709551615UL)
# 80 "fast_io/fast_io_core_impl/unsigned_extension.h"
                   ;
}

inline constexpr std::uint64_t high(__uint128_t a)
{
 return a>>64;
}

inline constexpr __uint128_t construct_unsigned_extension(std::uint64_t a,std::uint64_t b)
{
 return (static_cast<__uint128_t>(b)<<64)|a;
}

inline constexpr basic_unsigned_extension<__uint128_t> construct_unsigned_extension(__uint128_t a,__uint128_t b)
{
 return {a,b};
}

template<typename T>
requires (!std::unsigned_integral<T>&&std::same_as<T,__uint128_t>)
inline constexpr T reset_high(T& a)
{
 T temp(a>>64);
 a&=
# 103 "fast_io/fast_io_core_impl/unsigned_extension.h" 3 4
   (18446744073709551615UL)
# 103 "fast_io/fast_io_core_impl/unsigned_extension.h"
             ;
 return temp;
}
inline constexpr __uint128_t merge(__uint128_t a,__uint128_t b)
{
 return a|(b<<64);
}







inline constexpr std::uint64_t merge(std::uint64_t a,std::uint64_t b)
{
 return a|(b<<32);
}

template<typename T>
inline constexpr basic_unsigned_extension<T> merge(basic_unsigned_extension<T> const& a,basic_unsigned_extension<T> const& b)
{
 return {a.low,b.low};
}

template<typename T>
inline constexpr T reset_high(basic_unsigned_extension<T>& a)
{
 T temp(a.high);
 a.high={};
 return temp;
}

template<typename T>
requires std::unsigned_integral<T>
inline constexpr auto reset_high(T& a)
{
 constexpr T bytes(sizeof(T)*4),bytes_m1((static_cast<T>(1)<<bytes)-1);
 auto temp(a>>bytes);
 a&=bytes_m1;
 return temp;
}


template<typename T>
inline constexpr bool operator==(basic_unsigned_extension<T> const& a,basic_unsigned_extension<T> const& b)
{
 return a.low==b.low&&a.high==b.high;
}

template<typename T>
inline constexpr bool operator!=(basic_unsigned_extension<T> const& a,basic_unsigned_extension<T> const& b)
{
 return a.low!=b.low||a.high!=b.high;
}

template<typename T>
inline constexpr bool operator<(basic_unsigned_extension<T> const& a,basic_unsigned_extension<T> const& b)
{
 return a.high==b.high?a.low<b.low:a.high<b.high;
}

template<typename T>
inline constexpr bool operator>(basic_unsigned_extension<T> const& a,basic_unsigned_extension<T> const& b)
{
 return b<a;
}

template<typename T>
inline constexpr bool operator<=(basic_unsigned_extension<T> const& a,basic_unsigned_extension<T> const& b)
{
 return !(b<a);
}

template<typename T>
inline constexpr bool operator>=(basic_unsigned_extension<T> const& a,basic_unsigned_extension<T> const& b)
{
 return !(a<b);
}

template<typename T>
inline constexpr basic_unsigned_extension<T>& operator++(basic_unsigned_extension<T>& a)
{
 if(!++a.low)
  ++a.high;
 return a;
}
template<typename T>
inline constexpr basic_unsigned_extension<T>& operator--(basic_unsigned_extension<T>& a)
{
 if(!a.low)
  --a.high;
 --a.low;
 return a;
}

template<typename T,typename P>
requires

((std::unsigned_integral<T>||std::same_as<T,__uint128_t>)&&(std::unsigned_integral<P>||std::same_as<P,__uint128_t>))



inline constexpr bool add_carry_assignment(bool carry_flag,T& a,P b)
{
 auto const temp(carry_flag+a+b);
 bool const carry(temp<a);
 a=temp;
 return carry;
}

template<typename T>
inline constexpr bool add_carry_assignment(bool carry_flag,basic_unsigned_extension<T>& a,basic_unsigned_extension<T> const& b)
{
 return add_carry_assignment(add_carry_assignment(carry_flag,a.low,b.low),a.high,b.high);
}

template<typename T,typename P>
requires

(std::unsigned_integral<P>||std::same_as<P,__uint128_t>)



inline constexpr bool add_carry_assignment(bool carry_flag,basic_unsigned_extension<T>& a,P value)
{
 return add_carry_assignment(add_carry_assignment(carry_flag,a.low,value),a.high,0u);
}
# 240 "fast_io/fast_io_core_impl/unsigned_extension.h"
template<typename T>
inline constexpr basic_unsigned_extension<T>& operator+=(basic_unsigned_extension<T>& a,basic_unsigned_extension<T> const& b)
{
 add_carry_assignment(false,a,b);
 return a;
}

template<typename T>
inline constexpr basic_unsigned_extension<T>& operator+=(basic_unsigned_extension<T>& a,T const& b)
{
 add_carry_assignment(add_carry_assignment(false,a.low,b),a.high,0u);
 return a;
}

template<typename T,typename P>
inline constexpr basic_unsigned_extension<T> operator+(basic_unsigned_extension<T> a,P&& b)
{
 return a+=std::forward<P>(b);
}

template<typename T>
inline constexpr basic_unsigned_extension<T>& operator-=(basic_unsigned_extension<T>& a,basic_unsigned_extension<T> const& b)
{
 auto const added_low(a.low-b.low);
 a.high-=b.high;
 if(a.low<added_low)
  --a.high;
 a.low=added_low;
 return a;
}

template<typename T,typename P>
requires std::constructible_from<basic_unsigned_extension<T>,P>
inline constexpr basic_unsigned_extension<T>& operator-=(basic_unsigned_extension<T>& a,P const& b)
{
 auto const added_low(a.low-b);
 if(a.low<added_low)
  --a.high;
 a.low = added_low;
 return a;
}

template<typename T,typename P>
requires std::constructible_from<basic_unsigned_extension<T>,P>
inline constexpr basic_unsigned_extension<T> operator-(basic_unsigned_extension<T> a,P&& b)
{
 return a-=std::forward<P>(b);
}

template<typename T>
inline constexpr basic_unsigned_extension<T>& operator|=(basic_unsigned_extension<T>& a,basic_unsigned_extension<T> const& b)
{
 a.low|=b.low;
 a.high|=b.high;
 return a;
}

template<typename T,typename P>
requires std::constructible_from<basic_unsigned_extension<T>,P>
inline constexpr basic_unsigned_extension<T>& operator|=(basic_unsigned_extension<T>& a,P const& b)
{
 a.low|=b;
 return a;
}

template<typename T>
inline constexpr basic_unsigned_extension<T>& operator^=(basic_unsigned_extension<T>& a,basic_unsigned_extension<T> const& b)
{
 a.low^=b.low;
 a.high^=b.high;
 return a;
}

template<typename T,typename P>
requires std::constructible_from<basic_unsigned_extension<T>,P>
inline constexpr basic_unsigned_extension<T>& operator^=(basic_unsigned_extension<T>& a,P const& b)
{
 a.low^=b;
 return a;
}

template<typename T>
inline constexpr basic_unsigned_extension<T>& operator&=(basic_unsigned_extension<T>& a,basic_unsigned_extension<T> const& b)
{
 a.low&=b.low;
 a.high&=b.high;
 return a;
}

template<typename T,typename P>
requires std::constructible_from<basic_unsigned_extension<T>,P>
inline constexpr basic_unsigned_extension<T>& operator&=(basic_unsigned_extension<T>& a,P const& b)
{
 a.low&=b;
 return a;
}

template<typename T,typename P>
requires std::constructible_from<basic_unsigned_extension<T>,P>
inline constexpr basic_unsigned_extension<T> operator|(basic_unsigned_extension<T> a,P&& b)
{
 return a|=std::forward<P>(b);
}
template<typename T,typename P>
requires std::constructible_from<basic_unsigned_extension<T>,P>
inline constexpr basic_unsigned_extension<T> operator^(basic_unsigned_extension<T> a,P&& b)
{
 return a^=std::forward<P>(b);
}
template<typename T,typename P>
requires std::constructible_from<basic_unsigned_extension<T>,P>
inline constexpr basic_unsigned_extension<T> operator&(basic_unsigned_extension<T> a,P&& b)
{
 return a&=std::forward<P>(b);
}
# 382 "fast_io/fast_io_core_impl/unsigned_extension.h"
template<typename T>
inline constexpr basic_unsigned_extension<T>& operator<<=(basic_unsigned_extension<T>& a,std::size_t shift)
{
 constexpr std::size_t total_bytes(sizeof(T)*8);
 if(!shift)
  return a;
 if(shift<total_bytes)
 {
  a.high<<=shift;
  a.high|=a.low>>(total_bytes-shift);
  a.low<<=shift;
 }
 else if(shift<(total_bytes<<1))
 {
  a.high=a.low<<(shift-total_bytes);
  a.low=T();
 }
 else
  a=basic_unsigned_extension<T>();
 return a;
}

template<typename T>
inline constexpr basic_unsigned_extension<T> operator<<(basic_unsigned_extension<T> a,std::size_t shift)
{
 return a<<=shift;
}

template<typename T>
inline constexpr basic_unsigned_extension<T>& operator>>=(basic_unsigned_extension<T>& a,std::size_t shift)
{
 constexpr std::size_t total_bytes(sizeof(T)*8);
 if(!shift)
  return a;
 if(shift<total_bytes)
 {
  a.low>>=shift;
  a.low|=a.high<<(total_bytes-shift);
  a.high>>=shift;
 }
 else if(shift<(total_bytes<<1))
 {
  a.low=a.high>>(shift-total_bytes);
  a.high=T();
 }
 else
  a=basic_unsigned_extension<T>();
 return a;
}

template<typename T>
inline constexpr basic_unsigned_extension<T> operator>>(basic_unsigned_extension<T> a,std::size_t shift)
{
 return a>>=shift;
}


template<typename T>
requires std::same_as<std::uint32_t,T>
inline constexpr std::uint64_t mul_extend(T const& a,T const& b)
{
 return static_cast<std::uint64_t>(a)*b;
}


template<typename T>
requires std::same_as<std::uint64_t,T>
inline constexpr __uint128_t mul_extend(T const& a,T const& b)
{
 return static_cast<__uint128_t>(a)*b;
}
# 465 "fast_io/fast_io_core_impl/unsigned_extension.h"
template<typename T>
inline constexpr basic_unsigned_extension<T> mul_extend(T const& a,T const& b)
{
 decltype(auto) a0(low(a));
 decltype(auto) a1(high(a));
 decltype(auto) b0(low(b));
 decltype(auto) b1(high(b));
 decltype(auto) c0(mul_extend(a0,b0));
 decltype(auto) c1(mul_extend(a1,b0)+mul_extend(a0,b1));
 c1+=reset_high(c0);
 T c2(mul_extend(a1,b1));
 c2+=reset_high(c1);
 return {merge(c0,c1),c2};
}
template<typename T>
inline constexpr T mul_high(T const& a,T const& b)
{
 decltype(auto) a0(low(a));
 decltype(auto) a1(high(a));
 decltype(auto) b0(low(b));
 decltype(auto) b1(high(b));
 T c1(mul_extend(a0,b1));
 c1+=mul_extend(a1,b0);
 c1+=high(mul_extend(a0,b0));
 return mul_extend(a1,b1)+reset_high(c1);
}

template<typename T,typename U>
requires std::unsigned_integral<U>&&std::same_as<std::common_type_t<U,std::uint32_t>,std::uint32_t>
inline constexpr basic_unsigned_extension<T>& operator*=(basic_unsigned_extension<T>& a,U b)
{
 T c0(low(a.low));
 c0*=b;
 T c1(high(a.low));
 c1*=b;
 c1+=reset_high(c0);
 T c2(low(a.high));
 c2*=b;
 c2+=reset_high(c1);
 T c3(high(a.high));
 c3*=b;
 c3+=reset_high(c2);
 return a=basic_unsigned_extension<T>(merge(c0,c1),merge(c2,c3));
}

template<typename T>
inline constexpr basic_unsigned_extension<T>& operator*=(basic_unsigned_extension<T>& a,T const& b)
{
 decltype(auto) a0(low(a.low));
 decltype(auto) a1(high(a.low));
 decltype(auto) a2(low(a.high));
 decltype(auto) a3(high(a.high));
 decltype(auto) b0(low(b));
 decltype(auto) b1(high(b));
 T c0(mul_extend(a0,b0));
 T c1(mul_extend(a0,b1)+mul_extend(a1,b0)+reset_high(c0));
 T c2(mul_extend(a1,b1)+mul_extend(a2,b0)+reset_high(c1));
 T c3(mul_extend(a2,b1)+mul_extend(a3,b0)+reset_high(c2));
 return a={merge(c0,c1),merge(c2,c3)};
}

template<typename T>
inline constexpr basic_unsigned_extension<T>& operator*=(basic_unsigned_extension<T>& a,basic_unsigned_extension<T> const& b)
{
 decltype(auto) a0(low(a.low));
 decltype(auto) a1(high(a.low));
 decltype(auto) a2(low(a.high));
 decltype(auto) a3(high(a.high));
 decltype(auto) b0(low(b.low));
 decltype(auto) b1(high(b.low));
 decltype(auto) b2(low(b.high));
 decltype(auto) b3(high(b.high));
 T c0(mul_extend(a0,b0));
 T c1(mul_extend(a0,b1)+mul_extend(a1,b0)+reset_high(c0));
 T c2(mul_extend(a0,b2)+mul_extend(a1,b1)+mul_extend(a2,b0)+reset_high(c1));
 T c3(mul_extend(a0,b3)+mul_extend(a1,b2)+mul_extend(a2,b1)+mul_extend(a3,b0)+reset_high(c2));
 return a={merge(c0,c1),merge(c2,c3)};
}

template<typename T,typename P>
requires std::constructible_from<basic_unsigned_extension<T>,P>
inline constexpr basic_unsigned_extension<T> operator*(basic_unsigned_extension<T> a,P&& b)
{
 return a*=std::forward<P>(b);
}

template<typename T>
inline constexpr auto div_mod(basic_unsigned_extension<T> const& lhs, basic_unsigned_extension<T> const& rhs)
{
 std::pair<basic_unsigned_extension<T>, basic_unsigned_extension<T>> value;
 auto& quotient(value.first);
 auto& remainder(value.second);
 for (std::size_t i(sizeof(T)*16); i--;)
 {
  quotient <<= 1;
  remainder <<= 1;
  if (lhs[i])
   ++remainder;
  if (remainder >= rhs) {
   remainder -= rhs;
   ++quotient;
  }
 }
 return value;
}

template<typename T>
inline uint32_t in_place_div_mod(basic_unsigned_extension<T>& a,std::uint32_t value)
{
 std::array<std::uint32_t,sizeof(T)/2> v;
 memcpy(v.data(),std::addressof(a),sizeof(v));
 std::uint64_t quo(0);
 for(std::size_t i(v.size());i--;)
 {
  auto const tot(v[i]+(quo<<32));
  v[i]=tot/value;
  quo=tot%value;
 }
 memcpy(static_cast<void*>(std::addressof(a)),v.data(),sizeof(v));
 return quo;
}

template<typename T>
inline constexpr basic_unsigned_extension<T> operator/(basic_unsigned_extension<T> a,basic_unsigned_extension<T> const& b)
{
 return div_mod(a,b).first;
}

template<typename T>
inline constexpr std::uint32_t operator%(basic_unsigned_extension<T> const& a,std::uint32_t value)
{
 std::array<std::uint32_t,sizeof(T)/2> v;
 memcpy(v.data(),std::addressof(a),sizeof(v));
 std::uint64_t quo(0);
 for(std::size_t i(v.size());i--;)
 {
  auto const tot(v[i]+(quo<<32));
  v[i]=tot/value;
  quo=tot%value;
 }
 return quo;
}

template<typename T>
inline constexpr basic_unsigned_extension<T> operator%(basic_unsigned_extension<T> a,basic_unsigned_extension<T> const& b)
{
 return div_mod(a,b).second;
}

template<typename T>
inline constexpr basic_unsigned_extension<T>& operator/=(basic_unsigned_extension<T>& a,basic_unsigned_extension<T> const& b)
{
 return a=a/b;
}

template<typename T>
inline constexpr basic_unsigned_extension<T>& operator%=(basic_unsigned_extension<T>& a,basic_unsigned_extension<T> const& b)
{
 return a=a%b;
}

template<typename T>
inline constexpr auto pow(basic_unsigned_extension<T> lhs, basic_unsigned_extension<T> rhs)
{
 basic_unsigned_extension<T> ans(1);
 while(rhs)
 {
  if(rhs.front())
   ans *= lhs;
  rhs >>= 1;
  lhs *=lhs;
 }
 return ans;
}

template<typename T,typename P>
requires

(std::unsigned_integral<P>||std::same_as<P,__uint128_t>)



inline constexpr auto pow(basic_unsigned_extension<T> lhs, P rhs)
{
 basic_unsigned_extension<T> ans(1);
 while(rhs)
 {
  if(rhs&1)
   ans *= lhs;
  rhs >>= 1;
  lhs *=lhs;
 }
 return ans;
}

namespace details
{

template<std::uint8_t base,bool uppercase,character_output_stream output,typename T>
inline void output_base_extension_number(output& out,basic_unsigned_extension<T> a)
{



 if(!a)
 {
  put(out,0x30);
  return;
 }
 std::array<typename output::char_type,sizeof(a)*512*8/base+3> v;
 auto iter(v.data()+v.size());
 while(a)
 {
  std::uint32_t rem(in_place_div_mod(a,base));
  if constexpr(10 < base)
  {
   if(rem<10)
    *--iter = static_cast<typename output::char_type>(rem+48);
   else
   {
    if constexpr (uppercase)
     *--iter = static_cast<typename output::char_type>(rem+55);
    else
     *--iter = static_cast<typename output::char_type>(rem+87);
   }
  }
  else
   *--iter = static_cast<typename output::char_type>(rem+48);
 }
 send(out,iter,v.data()+v.size());
}
}

template<output_stream output,typename T>
inline constexpr void print_define(output& out,basic_unsigned_extension<T> const& a)
{
 details::output_base_extension_number<10,false>(out,a);
}

template<std::size_t base,bool uppercase,character_output_stream output,typename T>
inline constexpr void print_define(output& out,manip::base_t<base,uppercase,basic_unsigned_extension<T> const> v)
{
 details::output_base_extension_number<base,uppercase>(out,v.reference);
}
template<std::size_t base,bool uppercase,character_output_stream output,typename T>
inline constexpr void print_define(output& out,manip::base_t<base,uppercase,basic_unsigned_extension<T>> v)
{
 details::output_base_extension_number<base,uppercase>(out,v.reference);
}

namespace details
{
template<std::uint8_t base,character_input_stream input,typename T>
inline constexpr void input_base_number_phase2_extension(input& in,basic_unsigned_extension<T>& a)
{
 using unsigned_char_type = std::make_unsigned_t<decltype(get(in))>;
 unsigned_char_type constexpr baseed(std::min(static_cast<unsigned_char_type>(base),static_cast<unsigned_char_type>(10)));
 while(true)
 {
  unsigned_char_type ch(get<true>(in).first);
  if((ch-=48)<baseed)
  {
   a*=base;
   a+=ch;
  }
  else if constexpr (10 < base)
  {
   unsigned_char_type constexpr bm10(base-10);
   if((ch-=17)<bm10||(ch-=32)<bm10)
    a=a*base+(ch+10);
   else
    return;
  }
  else
   return;
 }
}

template<std::uint8_t base,character_input_stream input,typename T>
inline constexpr void input_base_extension_number(input& in,basic_unsigned_extension<T>& a)
{
 using unsigned_char_type = std::make_unsigned_t<decltype(get(in))>;
 unsigned_char_type constexpr baseed(std::min(static_cast<unsigned_char_type>(base),static_cast<unsigned_char_type>(10)));
 while(true)
 {
  unsigned_char_type ch(get(in));
  if((ch-=48)<baseed)
  {
   a=static_cast<basic_unsigned_extension<T>>(ch);
   break;
  }
  else if constexpr (10 < base)
  {
   unsigned_char_type constexpr bm10(base-10);
   if((ch-=17)<bm10||(ch-=32)<bm10)
   {
    a=static_cast<basic_unsigned_extension<T>>(ch+10);
    break;
   }
  }
 }
 input_base_number_phase2_extension<base>(in,a);
}
}

template<std::size_t base,bool uppercase,character_input_stream input,typename T>
inline constexpr void scan_define(input& in,manip::base_t<base,uppercase,basic_unsigned_extension<T>> v)
{
 details::input_base_extension_number<base>(in,v.reference);
}

template<character_input_stream input,typename T>
inline constexpr void scan_define(input& in,basic_unsigned_extension<T>& a)
{
 details::input_base_extension_number<10>(in,a);
}

template<character_output_stream output,typename T>
inline constexpr void write_define(output& out,basic_unsigned_extension<T> const& n)
{
 send(out,std::addressof(n),std::addressof(n)+1);
}

template<character_input_stream input,typename T>
inline constexpr void read_define(input& in,basic_unsigned_extension<T>& n)
{
 receive(in,std::addressof(n),std::addressof(n)+1);
}

using uint128_t = __uint128_t;



using uint256_t = basic_unsigned_extension<uint128_t>;
# 992 "fast_io/fast_io_core_impl/unsigned_extension.h"
}
# 57 "fast_io/fast_io_core.h" 2
# 1 "fast_io/fast_io_core_impl/wrapper.h" 1
       

namespace fast_io
{

template<stream T,std::size_t interface_mode>
class basic_file_wrapper:public T
{
public:
 using char_type = typename T::char_type;
 using native_handle_type = typename T::native_handle_type;
 template<typename ntinf,typename ...Args>
 constexpr basic_file_wrapper(native_interface_t,Args&& ...args):T(native_interface,std::forward<Args>(args)...){}
 template<std::size_t om,perms pm>
 constexpr basic_file_wrapper(std::string_view file,open::interface_t<om>,perms_interface_t<pm>):T(file,open::interface<fast_io::open::mode(om|interface_mode)>,perms_interface<pm>){}
 template<std::size_t om>
 constexpr basic_file_wrapper(std::string_view file,open::interface_t<om>):T(file,open::interface<fast_io::open::mode(om|interface_mode)>){}
 template<perms pm>
 constexpr basic_file_wrapper(std::string_view file,perms_interface_t<pm>):T(file,open::interface<fast_io::open::mode(interface_mode)>,perms_interface<pm>){}
 constexpr basic_file_wrapper(std::string_view file):T(file,open::interface<fast_io::open::mode(interface_mode)>){}
 constexpr basic_file_wrapper(std::string_view file,open::mode const& m,perms p=static_cast<perms>(420)):T(file,m|fast_io::open::mode(interface_mode),p){}
 constexpr basic_file_wrapper(std::string_view file,std::string_view mode,perms p=static_cast<perms>(420)):basic_file_wrapper(file,fast_io::open::c_style(mode),p){}
 constexpr basic_file_wrapper(std::string_view file,perms pm):T(file,open::interface<fast_io::open::mode(interface_mode)>,pm){}
};

template<input_stream T>
using input_file_wrapper = basic_file_wrapper<T,fast_io::open::in|fast_io::open::binary>;
template<output_stream T>
using output_file_wrapper = basic_file_wrapper<T,fast_io::open::out|fast_io::open::binary>;
template<io_stream T>
using io_file_wrapper = basic_file_wrapper<T,fast_io::open::in|fast_io::open::out|fast_io::open::binary>;



template<stream T,std::size_t interface_mode>
class basic_wrapper:public T
{
public:
 using char_type = typename T::char_type;
 using native_handle_type = typename T::native_handle_type;
 template<std::size_t om>
 constexpr basic_wrapper(open::interface_t<om>):T(open::interface<fast_io::open::mode(om|interface_mode)>){}
 constexpr basic_wrapper():T(open::interface<fast_io::open::mode(interface_mode)>){}
 constexpr basic_wrapper(open::mode const& m):T(m|fast_io::open::mode(interface_mode)){}
 constexpr basic_wrapper(std::string_view mode):basic_wrapper(fast_io::open::c_style(mode)){}
};

template<input_stream T>
using input_wrapper = basic_wrapper<T,fast_io::open::in|fast_io::open::binary>;
template<output_stream T>
using output_wrapper = basic_wrapper<T,fast_io::open::out|fast_io::open::binary>;
template<io_stream T>
using io_wrapper = basic_wrapper<T,fast_io::open::in|fast_io::open::out|fast_io::open::binary>;

}
# 58 "fast_io/fast_io_core.h" 2
# 1 "fast_io/fast_io_core_impl/flush.h" 1
       

namespace fast_io
{

template<output_stream Ohandler,typename Ohandler::char_type flush_character>
class char_flush:public Ohandler
{
public:
 using char_type = typename Ohandler::char_type;
 template<typename... Args>
 requires std::constructible_from<Ohandler,Args...>
 constexpr char_flush(Args&&... args):Ohandler(std::forward<Args>(args)...){}
};

template<output_stream Ohandler,typename Ohandler::char_type flush_character,std::contiguous_iterator Iter>
inline constexpr void send(char_flush<Ohandler,flush_character>& ob,Iter b,Iter e)
{
 using char_type = typename Ohandler::char_type;
 auto pb(std::to_address(b)),pe(pb+(e-b)*sizeof(*b)/sizeof(char_type));
 for(auto pi(pb);pi!=pe;++pi)
  if(*pi==flush_character)
  {
   send(static_cast<Ohandler&>(ob),pb,pi+1);
   flush(ob);
   pb=pi+1;
  }
 send(static_cast<Ohandler&>(ob),pb,pe);
}

template<character_output_stream Ohandler,typename Ohandler::char_type flush_character>
inline constexpr void put(char_flush<Ohandler,flush_character>& ob,typename Ohandler::char_type ch)
{
 put(static_cast<Ohandler&>(ob),ch);
 if(ch==flush_character)
  flush(ob);
}

template<typename T>
using line_flush = char_flush<T,0xA>;

}
# 59 "fast_io/fast_io_core.h" 2
# 6 "fast_io/fast_io_freestanding.h" 2


# 1 "/usr/local/include/c++/10.0.0/bitset" 1 3
# 45 "/usr/local/include/c++/10.0.0/bitset" 3
       
# 46 "/usr/local/include/c++/10.0.0/bitset" 3
# 64 "/usr/local/include/c++/10.0.0/bitset" 3

# 64 "/usr/local/include/c++/10.0.0/bitset" 3
namespace std __attribute__ ((__visibility__ ("default")))
{








  template<size_t _Nw>
    struct _Base_bitset
    {
      typedef unsigned long _WordT;


      _WordT _M_w[_Nw];

      constexpr _Base_bitset() noexcept
      : _M_w() { }


      constexpr _Base_bitset(unsigned long long __val) noexcept
      : _M_w{ _WordT(__val)



       } { }






      static constexpr size_t
      _S_whichword(size_t __pos) noexcept
      { return __pos / (8 * 8); }

      static constexpr size_t
      _S_whichbyte(size_t __pos) noexcept
      { return (__pos % (8 * 8)) / 8; }

      static constexpr size_t
      _S_whichbit(size_t __pos) noexcept
      { return __pos % (8 * 8); }

      static constexpr _WordT
      _S_maskbit(size_t __pos) noexcept
      { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }

      _WordT&
      _M_getword(size_t __pos) noexcept
      { return _M_w[_S_whichword(__pos)]; }

      constexpr _WordT
      _M_getword(size_t __pos) const noexcept
      { return _M_w[_S_whichword(__pos)]; }


      const _WordT*
      _M_getdata() const noexcept
      { return _M_w; }


      _WordT&
      _M_hiword() noexcept
      { return _M_w[_Nw - 1]; }

      constexpr _WordT
      _M_hiword() const noexcept
      { return _M_w[_Nw - 1]; }

      void
      _M_do_and(const _Base_bitset<_Nw>& __x) noexcept
      {
 for (size_t __i = 0; __i < _Nw; __i++)
   _M_w[__i] &= __x._M_w[__i];
      }

      void
      _M_do_or(const _Base_bitset<_Nw>& __x) noexcept
      {
 for (size_t __i = 0; __i < _Nw; __i++)
   _M_w[__i] |= __x._M_w[__i];
      }

      void
      _M_do_xor(const _Base_bitset<_Nw>& __x) noexcept
      {
 for (size_t __i = 0; __i < _Nw; __i++)
   _M_w[__i] ^= __x._M_w[__i];
      }

      void
      _M_do_left_shift(size_t __shift) noexcept;

      void
      _M_do_right_shift(size_t __shift) noexcept;

      void
      _M_do_flip() noexcept
      {
 for (size_t __i = 0; __i < _Nw; __i++)
   _M_w[__i] = ~_M_w[__i];
      }

      void
      _M_do_set() noexcept
      {
 for (size_t __i = 0; __i < _Nw; __i++)
   _M_w[__i] = ~static_cast<_WordT>(0);
      }

      void
      _M_do_reset() noexcept
      { __builtin_memset(_M_w, 0, _Nw * sizeof(_WordT)); }

      bool
      _M_is_equal(const _Base_bitset<_Nw>& __x) const noexcept
      {
 for (size_t __i = 0; __i < _Nw; ++__i)
   if (_M_w[__i] != __x._M_w[__i])
     return false;
 return true;
      }

      template<size_t _Nb>
        bool
        _M_are_all() const noexcept
        {
   for (size_t __i = 0; __i < _Nw - 1; __i++)
     if (_M_w[__i] != ~static_cast<_WordT>(0))
       return false;
   return _M_hiword() == (~static_cast<_WordT>(0)
     >> (_Nw * (8 * 8)
         - _Nb));
 }

      bool
      _M_is_any() const noexcept
      {
 for (size_t __i = 0; __i < _Nw; __i++)
   if (_M_w[__i] != static_cast<_WordT>(0))
     return true;
 return false;
      }

      size_t
      _M_do_count() const noexcept
      {
 size_t __result = 0;
 for (size_t __i = 0; __i < _Nw; __i++)
   __result += __builtin_popcountl(_M_w[__i]);
 return __result;
      }

      unsigned long
      _M_do_to_ulong() const;


      unsigned long long
      _M_do_to_ullong() const;



      size_t
      _M_do_find_first(size_t) const noexcept;


      size_t
      _M_do_find_next(size_t, size_t) const noexcept;
    };


  template<size_t _Nw>
    void
    _Base_bitset<_Nw>::_M_do_left_shift(size_t __shift) noexcept
    {
      if (__builtin_expect(__shift != 0, 1))
 {
   const size_t __wshift = __shift / (8 * 8);
   const size_t __offset = __shift % (8 * 8);

   if (__offset == 0)
     for (size_t __n = _Nw - 1; __n >= __wshift; --__n)
       _M_w[__n] = _M_w[__n - __wshift];
   else
     {
       const size_t __sub_offset = ((8 * 8)
        - __offset);
       for (size_t __n = _Nw - 1; __n > __wshift; --__n)
  _M_w[__n] = ((_M_w[__n - __wshift] << __offset)
        | (_M_w[__n - __wshift - 1] >> __sub_offset));
       _M_w[__wshift] = _M_w[0] << __offset;
     }

   std::fill(_M_w + 0, _M_w + __wshift, static_cast<_WordT>(0));
 }
    }

  template<size_t _Nw>
    void
    _Base_bitset<_Nw>::_M_do_right_shift(size_t __shift) noexcept
    {
      if (__builtin_expect(__shift != 0, 1))
 {
   const size_t __wshift = __shift / (8 * 8);
   const size_t __offset = __shift % (8 * 8);
   const size_t __limit = _Nw - __wshift - 1;

   if (__offset == 0)
     for (size_t __n = 0; __n <= __limit; ++__n)
       _M_w[__n] = _M_w[__n + __wshift];
   else
     {
       const size_t __sub_offset = ((8 * 8)
        - __offset);
       for (size_t __n = 0; __n < __limit; ++__n)
  _M_w[__n] = ((_M_w[__n + __wshift] >> __offset)
        | (_M_w[__n + __wshift + 1] << __sub_offset));
       _M_w[__limit] = _M_w[_Nw-1] >> __offset;
     }

   std::fill(_M_w + __limit + 1, _M_w + _Nw, static_cast<_WordT>(0));
 }
    }

  template<size_t _Nw>
    unsigned long
    _Base_bitset<_Nw>::_M_do_to_ulong() const
    {
      for (size_t __i = 1; __i < _Nw; ++__i)
 if (_M_w[__i])
   __throw_overflow_error(("_Base_bitset::_M_do_to_ulong"));
      return _M_w[0];
    }


  template<size_t _Nw>
    unsigned long long
    _Base_bitset<_Nw>::_M_do_to_ullong() const
    {
      const bool __dw = sizeof(unsigned long long) > sizeof(unsigned long);
      for (size_t __i = 1 + __dw; __i < _Nw; ++__i)
 if (_M_w[__i])
   __throw_overflow_error(("_Base_bitset::_M_do_to_ullong"));

      if (__dw)
 return _M_w[0] + (static_cast<unsigned long long>(_M_w[1])
     << (8 * 8));
      return _M_w[0];
    }


  template<size_t _Nw>
    size_t
    _Base_bitset<_Nw>::
    _M_do_find_first(size_t __not_found) const noexcept
    {
      for (size_t __i = 0; __i < _Nw; __i++)
 {
   _WordT __thisword = _M_w[__i];
   if (__thisword != static_cast<_WordT>(0))
     return (__i * (8 * 8)
      + __builtin_ctzl(__thisword));
 }

      return __not_found;
    }

  template<size_t _Nw>
    size_t
    _Base_bitset<_Nw>::
    _M_do_find_next(size_t __prev, size_t __not_found) const noexcept
    {

      ++__prev;


      if (__prev >= _Nw * (8 * 8))
 return __not_found;


      size_t __i = _S_whichword(__prev);
      _WordT __thisword = _M_w[__i];


      __thisword &= (~static_cast<_WordT>(0)) << _S_whichbit(__prev);

      if (__thisword != static_cast<_WordT>(0))
 return (__i * (8 * 8)
  + __builtin_ctzl(__thisword));


      __i++;
      for (; __i < _Nw; __i++)
 {
   __thisword = _M_w[__i];
   if (__thisword != static_cast<_WordT>(0))
     return (__i * (8 * 8)
      + __builtin_ctzl(__thisword));
 }

      return __not_found;
    }






  template<>
    struct _Base_bitset<1>
    {
      typedef unsigned long _WordT;
      _WordT _M_w;

      constexpr _Base_bitset() noexcept
      : _M_w(0)
      { }


      constexpr _Base_bitset(unsigned long long __val) noexcept



      : _M_w(__val)
      { }

      static constexpr size_t
      _S_whichword(size_t __pos) noexcept
      { return __pos / (8 * 8); }

      static constexpr size_t
      _S_whichbyte(size_t __pos) noexcept
      { return (__pos % (8 * 8)) / 8; }

      static constexpr size_t
      _S_whichbit(size_t __pos) noexcept
      { return __pos % (8 * 8); }

      static constexpr _WordT
      _S_maskbit(size_t __pos) noexcept
      { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }

      _WordT&
      _M_getword(size_t) noexcept
      { return _M_w; }

      constexpr _WordT
      _M_getword(size_t) const noexcept
      { return _M_w; }


      const _WordT*
      _M_getdata() const noexcept
      { return &_M_w; }


      _WordT&
      _M_hiword() noexcept
      { return _M_w; }

      constexpr _WordT
      _M_hiword() const noexcept
      { return _M_w; }

      void
      _M_do_and(const _Base_bitset<1>& __x) noexcept
      { _M_w &= __x._M_w; }

      void
      _M_do_or(const _Base_bitset<1>& __x) noexcept
      { _M_w |= __x._M_w; }

      void
      _M_do_xor(const _Base_bitset<1>& __x) noexcept
      { _M_w ^= __x._M_w; }

      void
      _M_do_left_shift(size_t __shift) noexcept
      { _M_w <<= __shift; }

      void
      _M_do_right_shift(size_t __shift) noexcept
      { _M_w >>= __shift; }

      void
      _M_do_flip() noexcept
      { _M_w = ~_M_w; }

      void
      _M_do_set() noexcept
      { _M_w = ~static_cast<_WordT>(0); }

      void
      _M_do_reset() noexcept
      { _M_w = 0; }

      bool
      _M_is_equal(const _Base_bitset<1>& __x) const noexcept
      { return _M_w == __x._M_w; }

      template<size_t _Nb>
        bool
        _M_are_all() const noexcept
        { return _M_w == (~static_cast<_WordT>(0)
     >> ((8 * 8) - _Nb)); }

      bool
      _M_is_any() const noexcept
      { return _M_w != 0; }

      size_t
      _M_do_count() const noexcept
      { return __builtin_popcountl(_M_w); }

      unsigned long
      _M_do_to_ulong() const noexcept
      { return _M_w; }


      unsigned long long
      _M_do_to_ullong() const noexcept
      { return _M_w; }


      size_t
      _M_do_find_first(size_t __not_found) const noexcept
      {
        if (_M_w != 0)
          return __builtin_ctzl(_M_w);
        else
          return __not_found;
      }


      size_t
      _M_do_find_next(size_t __prev, size_t __not_found) const
 noexcept
      {
 ++__prev;
 if (__prev >= ((size_t) (8 * 8)))
   return __not_found;

 _WordT __x = _M_w >> __prev;
 if (__x != 0)
   return __builtin_ctzl(__x) + __prev;
 else
   return __not_found;
      }
    };






  template<>
    struct _Base_bitset<0>
    {
      typedef unsigned long _WordT;

      constexpr _Base_bitset() noexcept
      { }


      constexpr _Base_bitset(unsigned long long) noexcept



      { }

      static constexpr size_t
      _S_whichword(size_t __pos) noexcept
      { return __pos / (8 * 8); }

      static constexpr size_t
      _S_whichbyte(size_t __pos) noexcept
      { return (__pos % (8 * 8)) / 8; }

      static constexpr size_t
      _S_whichbit(size_t __pos) noexcept
      { return __pos % (8 * 8); }

      static constexpr _WordT
      _S_maskbit(size_t __pos) noexcept
      { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }
# 560 "/usr/local/include/c++/10.0.0/bitset" 3
      _WordT&
      _M_getword(size_t) noexcept
      {
 __throw_out_of_range(("_Base_bitset::_M_getword"));
 return *new _WordT;
      }

      constexpr _WordT
      _M_getword(size_t) const noexcept
      { return 0; }

      constexpr _WordT
      _M_hiword() const noexcept
      { return 0; }

      void
      _M_do_and(const _Base_bitset<0>&) noexcept
      { }

      void
      _M_do_or(const _Base_bitset<0>&) noexcept
      { }

      void
      _M_do_xor(const _Base_bitset<0>&) noexcept
      { }

      void
      _M_do_left_shift(size_t) noexcept
      { }

      void
      _M_do_right_shift(size_t) noexcept
      { }

      void
      _M_do_flip() noexcept
      { }

      void
      _M_do_set() noexcept
      { }

      void
      _M_do_reset() noexcept
      { }




      bool
      _M_is_equal(const _Base_bitset<0>&) const noexcept
      { return true; }

      template<size_t _Nb>
        bool
        _M_are_all() const noexcept
        { return true; }

      bool
      _M_is_any() const noexcept
      { return false; }

      size_t
      _M_do_count() const noexcept
      { return 0; }

      unsigned long
      _M_do_to_ulong() const noexcept
      { return 0; }


      unsigned long long
      _M_do_to_ullong() const noexcept
      { return 0; }




      size_t
      _M_do_find_first(size_t) const noexcept
      { return 0; }

      size_t
      _M_do_find_next(size_t, size_t) const noexcept
      { return 0; }
    };



  template<size_t _Extrabits>
    struct _Sanitize
    {
      typedef unsigned long _WordT;

      static void
      _S_do_sanitize(_WordT& __val) noexcept
      { __val &= ~((~static_cast<_WordT>(0)) << _Extrabits); }
    };

  template<>
    struct _Sanitize<0>
    {
      typedef unsigned long _WordT;

      static void
      _S_do_sanitize(_WordT) noexcept { }
    };


  template<size_t _Nb, bool = (_Nb < (8 * 8))>
    struct _Sanitize_val
    {
      static constexpr unsigned long long
      _S_do_sanitize_val(unsigned long long __val)
      { return __val; }
    };

  template<size_t _Nb>
    struct _Sanitize_val<_Nb, true>
    {
      static constexpr unsigned long long
      _S_do_sanitize_val(unsigned long long __val)
      { return __val & ~((~static_cast<unsigned long long>(0)) << _Nb); }
    };
# 750 "/usr/local/include/c++/10.0.0/bitset" 3
  template<size_t _Nb>
    class bitset
    : private _Base_bitset<((_Nb) / (8 * 8) + ((_Nb) % (8 * 8) == 0 ? 0 : 1))>
    {
    private:
      typedef _Base_bitset<((_Nb) / (8 * 8) + ((_Nb) % (8 * 8) == 0 ? 0 : 1))> _Base;
      typedef unsigned long _WordT;

      template<class _CharT, class _Traits, class _Alloc>
      void
      _M_check_initial_position(const std::basic_string<_CharT, _Traits, _Alloc>& __s,
    size_t __position) const
      {
 if (__position > __s.size())
   __throw_out_of_range_fmt(("bitset::bitset: __position " "(which is %zu) > __s.size() " "(which is %zu)")

                            ,
       __position, __s.size());
      }

      void _M_check(size_t __position, const char *__s) const
      {
 if (__position >= _Nb)
   __throw_out_of_range_fmt(("%s: __position (which is %zu) " ">= _Nb (which is %zu)")
                                   ,
       __s, __position, _Nb);
      }

      void
      _M_do_sanitize() noexcept
      {
 typedef _Sanitize<_Nb % (8 * 8)> __sanitize_type;
 __sanitize_type::_S_do_sanitize(this->_M_hiword());
      }


      friend struct std::hash<bitset>;


    public:
# 802 "/usr/local/include/c++/10.0.0/bitset" 3
      class reference
      {
 friend class bitset;

 _WordT* _M_wp;
 size_t _M_bpos;


 reference();

      public:
 reference(bitset& __b, size_t __pos) noexcept
 {
   _M_wp = &__b._M_getword(__pos);
   _M_bpos = _Base::_S_whichbit(__pos);
 }


 reference(const reference&) = default;


 ~reference() noexcept
 { }


 reference&
 operator=(bool __x) noexcept
 {
   if (__x)
     *_M_wp |= _Base::_S_maskbit(_M_bpos);
   else
     *_M_wp &= ~_Base::_S_maskbit(_M_bpos);
   return *this;
 }


 reference&
 operator=(const reference& __j) noexcept
 {
   if ((*(__j._M_wp) & _Base::_S_maskbit(__j._M_bpos)))
     *_M_wp |= _Base::_S_maskbit(_M_bpos);
   else
     *_M_wp &= ~_Base::_S_maskbit(_M_bpos);
   return *this;
 }


 bool
 operator~() const noexcept
 { return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) == 0; }


 operator bool() const noexcept
 { return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) != 0; }


 reference&
 flip() noexcept
 {
   *_M_wp ^= _Base::_S_maskbit(_M_bpos);
   return *this;
 }
      };
      friend class reference;



      constexpr bitset() noexcept
      { }



      constexpr bitset(unsigned long long __val) noexcept
      : _Base(_Sanitize_val<_Nb>::_S_do_sanitize_val(__val)) { }
# 891 "/usr/local/include/c++/10.0.0/bitset" 3
      template<class _CharT, class _Traits, class _Alloc>
 explicit
 bitset(const std::basic_string<_CharT, _Traits, _Alloc>& __s,
        size_t __position = 0)
 : _Base()
 {
   _M_check_initial_position(__s, __position);
   _M_copy_from_string(__s, __position,
         std::basic_string<_CharT, _Traits, _Alloc>::npos,
         _CharT('0'), _CharT('1'));
 }
# 913 "/usr/local/include/c++/10.0.0/bitset" 3
      template<class _CharT, class _Traits, class _Alloc>
 bitset(const std::basic_string<_CharT, _Traits, _Alloc>& __s,
        size_t __position, size_t __n)
 : _Base()
 {
   _M_check_initial_position(__s, __position);
   _M_copy_from_string(__s, __position, __n, _CharT('0'), _CharT('1'));
 }



      template<class _CharT, class _Traits, class _Alloc>
 bitset(const std::basic_string<_CharT, _Traits, _Alloc>& __s,
        size_t __position, size_t __n,
        _CharT __zero, _CharT __one = _CharT('1'))
 : _Base()
 {
   _M_check_initial_position(__s, __position);
   _M_copy_from_string(__s, __position, __n, __zero, __one);
 }
# 944 "/usr/local/include/c++/10.0.0/bitset" 3
      template<typename _CharT>
        explicit
        bitset(const _CharT* __str,
        typename std::basic_string<_CharT>::size_type __n
        = std::basic_string<_CharT>::npos,
        _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'))
        : _Base()
        {
   if (!__str)
     __throw_logic_error(("bitset::bitset(const _CharT*, ...)"));

   if (__n == std::basic_string<_CharT>::npos)
     __n = std::char_traits<_CharT>::length(__str);
   _M_copy_from_ptr<_CharT, std::char_traits<_CharT>>(__str, __n, 0,
            __n, __zero,
            __one);
 }
# 971 "/usr/local/include/c++/10.0.0/bitset" 3
      bitset<_Nb>&
      operator&=(const bitset<_Nb>& __rhs) noexcept
      {
 this->_M_do_and(__rhs);
 return *this;
      }

      bitset<_Nb>&
      operator|=(const bitset<_Nb>& __rhs) noexcept
      {
 this->_M_do_or(__rhs);
 return *this;
      }

      bitset<_Nb>&
      operator^=(const bitset<_Nb>& __rhs) noexcept
      {
 this->_M_do_xor(__rhs);
 return *this;
      }
# 1000 "/usr/local/include/c++/10.0.0/bitset" 3
      bitset<_Nb>&
      operator<<=(size_t __position) noexcept
      {
 if (__builtin_expect(__position < _Nb, 1))
   {
     this->_M_do_left_shift(__position);
     this->_M_do_sanitize();
   }
 else
   this->_M_do_reset();
 return *this;
      }

      bitset<_Nb>&
      operator>>=(size_t __position) noexcept
      {
 if (__builtin_expect(__position < _Nb, 1))
   {
     this->_M_do_right_shift(__position);
     this->_M_do_sanitize();
   }
 else
   this->_M_do_reset();
 return *this;
      }
# 1033 "/usr/local/include/c++/10.0.0/bitset" 3
      bitset<_Nb>&
      _Unchecked_set(size_t __pos) noexcept
      {
 this->_M_getword(__pos) |= _Base::_S_maskbit(__pos);
 return *this;
      }

      bitset<_Nb>&
      _Unchecked_set(size_t __pos, int __val) noexcept
      {
 if (__val)
   this->_M_getword(__pos) |= _Base::_S_maskbit(__pos);
 else
   this->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);
 return *this;
      }

      bitset<_Nb>&
      _Unchecked_reset(size_t __pos) noexcept
      {
 this->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);
 return *this;
      }

      bitset<_Nb>&
      _Unchecked_flip(size_t __pos) noexcept
      {
 this->_M_getword(__pos) ^= _Base::_S_maskbit(__pos);
 return *this;
      }

      constexpr bool
      _Unchecked_test(size_t __pos) const noexcept
      { return ((this->_M_getword(__pos) & _Base::_S_maskbit(__pos))
  != static_cast<_WordT>(0)); }






      bitset<_Nb>&
      set() noexcept
      {
 this->_M_do_set();
 this->_M_do_sanitize();
 return *this;
      }







      bitset<_Nb>&
      set(size_t __position, bool __val = true)
      {
 this->_M_check(__position, ("bitset::set"));
 return _Unchecked_set(__position, __val);
      }




      bitset<_Nb>&
      reset() noexcept
      {
 this->_M_do_reset();
 return *this;
      }
# 1112 "/usr/local/include/c++/10.0.0/bitset" 3
      bitset<_Nb>&
      reset(size_t __position)
      {
 this->_M_check(__position, ("bitset::reset"));
 return _Unchecked_reset(__position);
      }




      bitset<_Nb>&
      flip() noexcept
      {
 this->_M_do_flip();
 this->_M_do_sanitize();
 return *this;
      }






      bitset<_Nb>&
      flip(size_t __position)
      {
 this->_M_check(__position, ("bitset::flip"));
 return _Unchecked_flip(__position);
      }


      bitset<_Nb>
      operator~() const noexcept
      { return bitset<_Nb>(*this).flip(); }
# 1162 "/usr/local/include/c++/10.0.0/bitset" 3
      reference
      operator[](size_t __position)
      { return reference(*this, __position); }

      constexpr bool
      operator[](size_t __position) const
      { return _Unchecked_test(__position); }
# 1177 "/usr/local/include/c++/10.0.0/bitset" 3
      unsigned long
      to_ulong() const
      { return this->_M_do_to_ulong(); }


      unsigned long long
      to_ullong() const
      { return this->_M_do_to_ullong(); }
# 1195 "/usr/local/include/c++/10.0.0/bitset" 3
      template<class _CharT, class _Traits, class _Alloc>
 std::basic_string<_CharT, _Traits, _Alloc>
 to_string() const
 {
   std::basic_string<_CharT, _Traits, _Alloc> __result;
   _M_copy_to_string(__result, _CharT('0'), _CharT('1'));
   return __result;
 }



      template<class _CharT, class _Traits, class _Alloc>
 std::basic_string<_CharT, _Traits, _Alloc>
 to_string(_CharT __zero, _CharT __one = _CharT('1')) const
 {
   std::basic_string<_CharT, _Traits, _Alloc> __result;
   _M_copy_to_string(__result, __zero, __one);
   return __result;
 }



      template<class _CharT, class _Traits>
 std::basic_string<_CharT, _Traits, std::allocator<_CharT> >
 to_string() const
 { return to_string<_CharT, _Traits, std::allocator<_CharT> >(); }



      template<class _CharT, class _Traits>
 std::basic_string<_CharT, _Traits, std::allocator<_CharT> >
 to_string(_CharT __zero, _CharT __one = _CharT('1')) const
 { return to_string<_CharT, _Traits,
                    std::allocator<_CharT> >(__zero, __one); }

      template<class _CharT>
 std::basic_string<_CharT, std::char_traits<_CharT>,
                   std::allocator<_CharT> >
 to_string() const
 {
   return to_string<_CharT, std::char_traits<_CharT>,
                    std::allocator<_CharT> >();
 }

      template<class _CharT>
 std::basic_string<_CharT, std::char_traits<_CharT>,
                   std::allocator<_CharT> >
 to_string(_CharT __zero, _CharT __one = _CharT('1')) const
 {
   return to_string<_CharT, std::char_traits<_CharT>,
                    std::allocator<_CharT> >(__zero, __one);
 }

      std::basic_string<char, std::char_traits<char>, std::allocator<char> >
      to_string() const
      {
 return to_string<char, std::char_traits<char>,
                  std::allocator<char> >();
      }

      std::basic_string<char, std::char_traits<char>, std::allocator<char> >
      to_string(char __zero, char __one = '1') const
      {
 return to_string<char, std::char_traits<char>,
                  std::allocator<char> >(__zero, __one);
      }


      template<class _CharT, class _Traits>
        void
        _M_copy_from_ptr(const _CharT*, size_t, size_t, size_t,
    _CharT, _CharT);

      template<class _CharT, class _Traits, class _Alloc>
 void
 _M_copy_from_string(const std::basic_string<_CharT,
       _Traits, _Alloc>& __s, size_t __pos, size_t __n,
       _CharT __zero, _CharT __one)
 { _M_copy_from_ptr<_CharT, _Traits>(__s.data(), __s.size(), __pos, __n,
         __zero, __one); }

      template<class _CharT, class _Traits, class _Alloc>
 void
        _M_copy_to_string(std::basic_string<_CharT, _Traits, _Alloc>&,
     _CharT, _CharT) const;


      template<class _CharT, class _Traits, class _Alloc>
 void
 _M_copy_from_string(const std::basic_string<_CharT,
       _Traits, _Alloc>& __s, size_t __pos, size_t __n)
 { _M_copy_from_string(__s, __pos, __n, _CharT('0'), _CharT('1')); }

      template<class _CharT, class _Traits, class _Alloc>
 void
        _M_copy_to_string(std::basic_string<_CharT, _Traits,_Alloc>& __s) const
 { _M_copy_to_string(__s, _CharT('0'), _CharT('1')); }


      size_t
      count() const noexcept
      { return this->_M_do_count(); }


      constexpr size_t
      size() const noexcept
      { return _Nb; }



      bool
      operator==(const bitset<_Nb>& __rhs) const noexcept
      { return this->_M_is_equal(__rhs); }

      bool
      operator!=(const bitset<_Nb>& __rhs) const noexcept
      { return !this->_M_is_equal(__rhs); }
# 1320 "/usr/local/include/c++/10.0.0/bitset" 3
      bool
      test(size_t __position) const
      {
 this->_M_check(__position, ("bitset::test"));
 return _Unchecked_test(__position);
      }







      bool
      all() const noexcept
      { return this->template _M_are_all<_Nb>(); }





      bool
      any() const noexcept
      { return this->_M_is_any(); }





      bool
      none() const noexcept
      { return !this->_M_is_any(); }



      bitset<_Nb>
      operator<<(size_t __position) const noexcept
      { return bitset<_Nb>(*this) <<= __position; }

      bitset<_Nb>
      operator>>(size_t __position) const noexcept
      { return bitset<_Nb>(*this) >>= __position; }
# 1370 "/usr/local/include/c++/10.0.0/bitset" 3
      size_t
      _Find_first() const noexcept
      { return this->_M_do_find_first(_Nb); }
# 1381 "/usr/local/include/c++/10.0.0/bitset" 3
      size_t
      _Find_next(size_t __prev) const noexcept
      { return this->_M_do_find_next(__prev, _Nb); }
    };


  template<size_t _Nb>
    template<class _CharT, class _Traits>
      void
      bitset<_Nb>::
      _M_copy_from_ptr(const _CharT* __s, size_t __len,
         size_t __pos, size_t __n, _CharT __zero, _CharT __one)
      {
 reset();
 const size_t __nbits = std::min(_Nb, std::min(__n, size_t(__len - __pos)));
 for (size_t __i = __nbits; __i > 0; --__i)
   {
     const _CharT __c = __s[__pos + __nbits - __i];
     if (_Traits::eq(__c, __zero))
       ;
     else if (_Traits::eq(__c, __one))
       _Unchecked_set(__i - 1);
     else
       __throw_invalid_argument(("bitset::_M_copy_from_ptr"));
   }
      }

  template<size_t _Nb>
    template<class _CharT, class _Traits, class _Alloc>
      void
      bitset<_Nb>::
      _M_copy_to_string(std::basic_string<_CharT, _Traits, _Alloc>& __s,
   _CharT __zero, _CharT __one) const
      {
 __s.assign(_Nb, __zero);
 for (size_t __i = _Nb; __i > 0; --__i)
   if (_Unchecked_test(__i - 1))
     _Traits::assign(__s[_Nb - __i], __one);
      }
# 1431 "/usr/local/include/c++/10.0.0/bitset" 3
  template<size_t _Nb>
    inline bitset<_Nb>
    operator&(const bitset<_Nb>& __x, const bitset<_Nb>& __y) noexcept
    {
      bitset<_Nb> __result(__x);
      __result &= __y;
      return __result;
    }

  template<size_t _Nb>
    inline bitset<_Nb>
    operator|(const bitset<_Nb>& __x, const bitset<_Nb>& __y) noexcept
    {
      bitset<_Nb> __result(__x);
      __result |= __y;
      return __result;
    }

  template <size_t _Nb>
    inline bitset<_Nb>
    operator^(const bitset<_Nb>& __x, const bitset<_Nb>& __y) noexcept
    {
      bitset<_Nb> __result(__x);
      __result ^= __y;
      return __result;
    }
# 1468 "/usr/local/include/c++/10.0.0/bitset" 3
  template<class _CharT, class _Traits, size_t _Nb>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is, bitset<_Nb>& __x)
    {
      typedef typename _Traits::char_type char_type;
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;

      std::basic_string<_CharT, _Traits> __tmp;
      __tmp.reserve(_Nb);



      const char_type __zero = __is.widen('0');
      const char_type __one = __is.widen('1');

      typename __ios_base::iostate __state = __ios_base::goodbit;
      typename __istream_type::sentry __sentry(__is);
      if (__sentry)
 {
   try
     {
       for (size_t __i = _Nb; __i > 0; --__i)
  {
    static typename _Traits::int_type __eof = _Traits::eof();

    typename _Traits::int_type __c1 = __is.rdbuf()->sbumpc();
    if (_Traits::eq_int_type(__c1, __eof))
      {
        __state |= __ios_base::eofbit;
        break;
      }
    else
      {
        const char_type __c2 = _Traits::to_char_type(__c1);
        if (_Traits::eq(__c2, __zero))
   __tmp.push_back(__zero);
        else if (_Traits::eq(__c2, __one))
   __tmp.push_back(__one);
        else if (_Traits::
          eq_int_type(__is.rdbuf()->sputbackc(__c2),
        __eof))
   {
     __state |= __ios_base::failbit;
     break;
   }
      }
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __is._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __is._M_setstate(__ios_base::badbit); }
 }

      if (__tmp.empty() && _Nb)
 __state |= __ios_base::failbit;
      else
 __x._M_copy_from_string(__tmp, static_cast<size_t>(0), _Nb,
    __zero, __one);
      if (__state)
 __is.setstate(__state);
      return __is;
    }

  template <class _CharT, class _Traits, size_t _Nb>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const bitset<_Nb>& __x)
    {
      std::basic_string<_CharT, _Traits> __tmp;



      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__os.getloc());
      __x._M_copy_to_string(__tmp, __ct.widen('0'), __ct.widen('1'));
      return __os << __tmp;
    }



}







namespace std __attribute__ ((__visibility__ ("default")))
{




  template<size_t _Nb>
    struct hash<std::bitset<_Nb>>
    : public __hash_base<size_t, std::bitset<_Nb>>
    {
      size_t
      operator()(const std::bitset<_Nb>& __b) const noexcept
      {
 const size_t __clength = (_Nb + 8 - 1) / 8;
 return std::_Hash_impl::hash(__b._M_getdata(), __clength);
      }
    };

  template<>
    struct hash<std::bitset<0>>
    : public __hash_base<size_t, std::bitset<0>>
    {
      size_t
      operator()(const std::bitset<0>&) const noexcept
      { return 0; }
    };


}
# 9 "fast_io/fast_io_freestanding.h" 2


# 1 "fast_io/fast_io_freestanding_impl/concat.h" 1
       


# 3 "fast_io/fast_io_freestanding_impl/concat.h"
namespace fast_io
{


template<typename T=std::string,typename... Args>
inline constexpr T concat(Args&& ...args)
{
 basic_ostring<T> t;
 print(t,std::forward<Args>(args)...);
 return std::move(t.str());
}

template<typename T=std::string,typename... Args>
inline constexpr T concatln(Args&& ...args)
{
 basic_ostring<T> t;
 println(t,std::forward<Args>(args)...);
 return std::move(t.str());
}

template<typename T=std::string,typename... Args>
inline constexpr T format(std::string_view format,Args&& ...args)
{
 basic_ostring<T> t;
 fprint(t,format,std::forward<Args>(args)...);
 return std::move(t.str());
}

template<typename T,typename... Args>
inline constexpr void in_place_to(T& t,Args&& ...args)
{
 basic_ostring<std::string> os;
 print(os,std::forward<Args>(args)...);
 basic_istring_view<std::string_view> is(os.str());
 scan(is,t);
}

template<typename... Args>
inline constexpr void in_place_to(std::string& t,Args&& ...args)
{
 basic_ostring<std::string> os(std::move(t));
 os.clear();
 print(os,std::forward<Args>(args)...);
 t=std::move(os.str());
}

template<typename T,typename... Args>
inline constexpr auto to(Args&& ...args)
{
 T t;
 in_place_to(t,std::forward<Args>(args)...);
 return t;
}
}
# 12 "fast_io/fast_io_freestanding.h" 2
# 1 "fast_io/fast_io_freestanding_impl/manip.h" 1
       

namespace fast_io
{

template<character_input_stream input>
inline void scan_define(input& in,std::basic_string<typename input::char_type> &str)
{
 str.clear();
 str.push_back(eat_space_get(in));
 for(decltype(get<true>(in)) ch;!(ch=get<true>(in)).second&&!details::isspace(ch.first);str.push_back(ch.first));
}

template<character_input_stream input>
inline void getline(input& in,std::basic_string<typename input::char_type> &str)
{
 str.clear();
 for(decltype(get<true>(in)) ch;!(ch=get<true>(in)).second&&ch.first!=0xA;str.push_back(ch.first));
}


template<character_input_stream input>
inline void getcarriage(input& in,std::basic_string<typename input::char_type> &str)
{
 str.clear();
 for(decltype(get<true>(in)) ch;!(ch=get<true>(in)).second&&ch.first!=0xD;str.push_back(ch.first));
}

template<character_input_stream input>
inline void getwhole(input& in,std::basic_string<typename input::char_type> &str)
{
 str.clear();
 for(decltype(get<true>(in)) ch;!(ch=get<true>(in)).second;str.push_back(ch.first));
}

template<character_output_stream output,std::size_t indent_width,bool left,char ch,typename T>
inline constexpr void print_define(output& out,manip::width<indent_width,left,ch,T const> a)
{
 basic_ostring<std::basic_string<typename output::char_type>> bas;
 print(bas,a.reference);
 std::size_t const size(bas.str().size());
 if(size<indent_width)
 {
  if constexpr(left)
  {
   print(out,bas.str());
   fill_nc(out,indent_width-size,ch);
  }
  else
  {
   fill_nc(out,indent_width-size,ch);
   print(out,bas.str());
  }
 }
 else
  print(out,bas.str());
}

template<output_stream output>
inline constexpr void print_define(output& out,std::endian e)
{
 switch(e)
 {
 case std::endian::little:
  print(out,u8"little");
 break;
 case std::endian::big:
  print(out,u8"big");
 break;
 default:
  print(out,u8"unknown");
 }
}

}
# 13 "fast_io/fast_io_freestanding.h" 2
# 1 "fast_io/fast_io_freestanding_impl/scan_print.h" 1
       

namespace fast_io
{
inline namespace print_scan_details
{
template<typename output,typename T>
concept weak_printable=output_stream<output>&&requires(basic_ostring<std::basic_string<typename output::char_type>>& ostr,T const& t)
{
 print_define(ostr,t);
};

template<typename output,typename T>
concept weak_writeable=output_stream<output>&&requires(basic_ostring<std::basic_string<typename output::char_type>>& ostr,T const& t)
{
 write_define(ostr,t);
};

template<output_stream output,typename ...Args>
requires(weak_printable<output,Args>||...)
inline constexpr void buffer_print(output &out,Args&& ...args)
{
 basic_ostring<std::basic_string<typename output::char_type>> ostr;
 (print_define(ostr,std::forward<Args>(args)),...);
 send(out,ostr.str().cbegin(),ostr.str().cend());
}

template<output_stream output,typename ...Args>
requires (weak_printable<output,Args>||...)
inline constexpr void buffer_println(output &out,Args&& ...args)
{
 basic_ostring<std::basic_string<typename output::char_type>> ostr;
 (print_define(ostr,std::forward<Args>(args)),...);
 put(ostr,0xA);
 send(out,ostr.str().cbegin(),ostr.str().cend());
}

template<output_stream output,typename ...Args>
requires(weak_printable<output,Args>||...)
inline constexpr void buffer_fprint(output &out,std::basic_string_view<typename output::char_type> format,Args&& ...args)
{
 basic_ostring<std::basic_string<typename output::char_type>> ostr;
 print_scan_details::fprint_impl(ostr,format,std::forward<Args>(args)...);
 send(out,ostr.str().cbegin(),ostr.str().cend());
}

template<output_stream output,typename ...Args>
requires(weak_printable<output,Args>||...)
inline constexpr void buffer_fprint(output &out,std::basic_string_view<char8_t> format,Args&& ...args)
{
 basic_ostring<std::basic_string<typename output::char_type>> ostr;
 print_scan_details::fprint_impl(ostr,format,std::forward<Args>(args)...);
 send(out,ostr.str().cbegin(),ostr.str().cend());
}

template<output_stream output,typename ...Args>
requires(weak_writeable<output,Args>||...)
inline constexpr void buffer_write(output &out,Args&& ...args)
{
 basic_ostring<std::basic_string<typename output::char_type>> ostr;
 (write_define(ostr,std::forward<Args>(args)),...);
 send(out,ostr.str().cbegin(),ostr.str().cend());
}
}
}
# 14 "fast_io/fast_io_freestanding.h" 2
# 1 "fast_io/fast_io_freestanding_impl/exception.h" 1
       

namespace fast_io
{

template<character_output_stream output>
inline void print_define(output& out,std::exception const &e)
{
 print(out,e.what());
}

template<character_output_stream output>
inline void print_define(output& out,std::system_error const &e)
{
 auto const& code(e.code());
 print(out,"std::system_error, value:",code.value(),"\tmessage:",code.message());
}

}
# 15 "fast_io/fast_io_freestanding.h" 2

# 1 "fast_io/fast_io_freestanding_impl/floating.h" 1
       
# 1 "fast_io/fast_io_freestanding_impl/ryu/ryu.h" 1
       
# 1 "fast_io/fast_io_freestanding_impl/ryu/fixed_table.h" 1
       

namespace fast_io::details::ryu
{

template<bool controller=true>
requires (controller)
struct fixed_pow10
{
inline static constexpr std::array<std::uint16_t,64> offset={0,2,5,8,12,16,21,26,32,39,46,54,62,71,80,90,100,111,122,134,146,159,173,187,202,217,233,249,266,283,301,319,338,357,377,397,418,440,462,485,508,532,556,581,606,632,658,685,712,740,769,798,828,858,889,920,952,984,1017,1050,1084,1118,1153,1188};
inline static constexpr std::array<std::array<std::uint64_t,3>,1224> split={{{1,0x100000000000000},{0x9B5A52CB98B4055,0x44B82FA},{1,0,256},{0xA52CB98B405447C5,0x44B82FA09B5},{0x5DD1D243ABA0E760,4722},{1,0,0x1000000},{0xB98B405447C4A982,0x44B82FA09B5A52C},{0xD243ABA0E75FE646,0x12725DD1},{1,0,0x1194D80000},{0x405447C4A98187EF,0x82FA09B5A52CB98B,1099},{0xABA0E75FE645CC49,0x12725DD1D243},{0x68DBC8F03F243BB0,20282},{1,0,0x3A376C0000},{0x47C4A98187EEBB23,0x9B5A52CB98B4054,0x44B82FA},{0xE75FE645CC4873FA,0x12725DD1D243ABA0},{0xC8F03F243BAF5133,0x4F3A68DB},{1,0,0x2A4AE60000},{0xA98187EEBB22F009,0xA52CB98B405447C4,0x1AA0C609B5},{0xE645CC4873F9E65B,0x5DD1D243ABA0E75F,4722},{0x3F243BAF513267AB,0x4F3A68DBC8F0},{0x4932D2E725A5BBCB,87112},{1,0,0xA69CE0000},{0x87EEBB22F008D5D7,0xB98B405447C4A981,0x30DA53A52C},{0xCC4873F9E65AFE69,0xD243ABA0E75FE645,0x12725DD1},{0x3BAF513267AA9A3F,0x4F3A68DBC8F03F24},{0xD2E725A5BBCA17A4,0x154484932},{1,0,0x206C060000},{0xBB22F008D5D64F9D,0x405447C4A98187EE,0xFC178B98B},{0x73F9E65AFE688C93,0xABA0E75FE645CC48,0xD997BD243},{0x513267AA9A3EE525,0x68DBC8F03F243BAF,20282},{0x25A5BBCA17A3ABA2,0x154484932D2E7},{0x6B4DDAAE4689EB04,374144},{1,0,0x139F800000},{0xF008D5D64F9C394B,0x47C4A98187EEBB22,0x25769D4054},{0xE65AFE688C928E20,0xE75FE645CC4873F9,0x332C33ABA0},{0x67AA9A3EE524F8E1,0xC8F03F243BAF5132,0x4F3A68DB},{0xBBCA17A3ABA173D4,0x54484932D2E725A5,1},{0xDAAE4689EB03DCBF,0x5B5806B4D},{0x851A0B548EA3C996,24},{1,0,0x2DC9FA0000},{0xD5D64F9C394AE922,0xA98187EEBB22F008,0x16540E47C4},{0xFE688C928E1F2196,0xE645CC4873F9E65A,0x37EFD0E75F},{0x9A3EE524F8E02891,0x3F243BAF513267AA,0x10D493C8F0},{0x17A3ABA173D3D5FD,0x4932D2E725A5BBCA,87112},{0x4689EB03DCBE2FE9,0x5B5806B4DDAAE},{0xB548EA3C99552FD,1606938},{1,0,0x1E28A60000},{0x4F9C394AE9213016,0x87EEBB22F008D5D6,0x104048A981},{0x8C928E1F2195818B,0xCC4873F9E65AFE68,0x86FA9E645},{0xE524F8E0289064E4,0x3BAF513267AA9A3E,0xBD5563F24},{0xABA173D3D5FC130D,0xD2E725A5BBCA17A3,0x154484932},{0xEB03DCBE2FE86913,0xB5806B4DDAAE4689,5},{0x8EA3C99552FC2988,0x18851A0B54},{0x4FF258C744320748,105},{1,0,0x37957A0000},{0x394AE92130153561,0xBB22F008D5D64F9C,0x10DE8987EE},{0x8E1F2195818AE780,0x73F9E65AFE688C92,0x28D1B7CC48},{0xF8E0289064E3CFFB,0x513267AA9A3EE524,0x35D1703BAF},{0x73D3D5FC130C23B8,0x25A5BBCA17A3ABA1,0x1DE660D2E7},{0xDCBE2FE869126827,0x6B4DDAAE4689EB03,374144},{0xC99552FC298784D8,0x18851A0B548EA3},{0x58C7443207477640,0x694FF2},{1,0,0x822720000},{0xE9213015356022F0,0xF008D5D64F9C394A,0x3A2F30BB22},{0x2195818AE77F3C37,0xE65AFE688C928E1F,0xBBC5E73F9},{0x289064E3CFFA15AC,0x67AA9A3EE524F8E0,0x26967D5132},{0xD5FC130C23B7AA2E,0xBBCA17A3ABA173D3,0x12207925A5},{0x2FE8691268269AA8,0xDAAE4689EB03DCBE,0x5B5806B4D},{0x52FC298784D710D3,0x851A0B548EA3C995,24},{0x44320747763F868D,0x694FF258C7},{0x5016D841BAA4644C,452},{1,0,0x20EA00000},{0x3015356022EF3217,0xD5D64F9C394AE921,0x152FA6F008},{0x818AE77F3C36A08D,0xFE688C928E1F2195,0x27B8B3E65A},{0x64E3CFFA15AB8BBA,0x9A3EE524F8E02890,0x2F0DA467AA},{0x130C23B7AA2DA19C,0x17A3ABA173D3D5FC,0x2893A1BBCA},{0x691268269AA7ACC6,0x4689EB03DCBE2FE8,0x6105BDAAE},{0x298784D710D2D086,0xB548EA3C99552FC,1606938},{0x747763F868CD01E,0x694FF258C74432},{0xD841BAA4644B8DB5,0x1C45016},{1,0,0x31E5EE0000},{0x356022EF3216417A,0x4F9C394AE9213015,0x18579CD5D6},{0xE77F3C36A08CCE4F,0x8C928E1F2195818A,0xEA4D6FE68},{0xCFFA15AB8BB9CCC3,0xE524F8E0289064E3,0x261B849A3E},{0x23B7AA2DA19B9A3D,0xABA173D3D5FC130C,0x201C8E17A3},{0x68269AA7ACC51B40,0xEB03DCBE2FE86912,0x13B0004689},{0x84D710D2D085B92B,0x8EA3C99552FC2987,0x18851A0B54},{0x763F868CD01D569B,0x4FF258C744320747,105},{0xBAA4644B8DB4C788,0x1C45016D841},{0xAB3C855A0E1517D8,1942},{1,0,0x245FAA0000},{0x22EF32164179B6C0,0x394AE92130153560,0x221F5E4F9C},{0x3C36A08CCE4E0A37,0x8E1F2195818AE77F,0x89BB68C92},{0x15AB8BB9CCC2933C,0xF8E0289064E3CFFA,0x259750E524},{0xAA2DA19B9A3CAB82,0x73D3D5FC130C23B7,0xE635ABA1},{0x9AA7ACC51B3FD35C,0xDCBE2FE869126826,0x26227DEB03},{0x10D2D085B92A647F,0xC99552FC298784D7,0x386CFE8EA3},{0x868CD01D569A53F5,0x58C744320747763F,0x694FF2},{0x644B8DB4C7871BC4,0x1C45016D841BAA4},{0x855A0E1517D71395,0x796AB3C},{1,0,0x1171060000},{0x32164179B6BF082D,0xE9213015356022EF,0x73F90394A},{0xA08CCE4E0A366281,0x2195818AE77F3C36,0x3430E28E1F},{0x8BB9CCC2933B76B5,0x289064E3CFFA15AB,0x315266F8E0},{0xA19B9A3CAB811D57,0xD5FC130C23B7AA2D,0x2C480973D3},{0xACC51B3FD35B883F,0x2FE8691268269AA7,0x22C469DCBE},{0xD085B92A647EB512,0x52FC298784D710D2,0x2E6533C995},{0xD01D569A53F4E888,0x44320747763F868C,0x2DB52858C7},{0x8DB4C7871BC3602D,0x5016D841BAA4644B,452},{0xE1517D71394CA12,0x796AB3C855A},{0xB309321CDE0BE3B6,8343},{1,0,0x7BA260000},{0x4179B6BF082CE3FE,0x3015356022EF3216,0x22CF40E921},{0xCE4E0A36628033A5,0x818AE77F3C36A08C,0x219E8F2195},{0xCCC2933B76B4FA42,0x64E3CFFA15AB8BB9,0x3AB0CE2890},{0x9A3CAB811D56FA9D,0x130C23B7AA2DA19B,0x361CBDD5FC},{0x1B3FD35B883ED9C6,0x691268269AA7ACC5,0x3AB60A2FE8},{0xB92A647EB5110568,0x298784D710D2D085,0xBA5ED52FC},{0x569A53F4E887A6AB,0x747763F868CD01D,0x551A74432},{0xC7871BC3602CBB46,0xD841BAA4644B8DB4,0x1C45016},{0x17D71394CA11FDCF,0x796AB3C855A0E15},{0x321CDE0BE3B5001A,0x2097B309},{1,0,0x4F0200000},{0xB6BF082CE3FD84C0,0x356022EF32164179,0x2057573015},{0xA36628033A40BE8,0xE77F3C36A08CCE4E,0x350AAD818A},{0x933B76B4FA414024,0xCFFA15AB8BB9CCC2,0x2D39264E3},{0xAB811D56FA9C85A6,0x23B7AA2DA19B9A3C,0x44922130C},{0xD35B883ED9C580D8,0x68269AA7ACC51B3F,0x1F8D8E6912},{0x647EB51105677CA6,0x84D710D2D085B92A,0x10A3762987},{0x53F4E887A6AAFEA9,0x763F868CD01D569A,0xF4DC20747},{0x1BC3602CBB453D3A,0xBAA4644B8DB4C787,0x231490D841},{0x1394CA11FDCE19B5,0xAB3C855A0E1517D7,1942},{0xDE0BE3B50019A304,0x2097B309321C},{0xEA76C619EF3657EC,35835},{1,0,0x16622E0000},{0x82CE3FD84BF5BBA,0x22EF32164179B6BF,0x1D9FCF3560},{0x628033A40BE73648,0x3C36A08CCE4E0A36,0x3A3A34E77F},{0x76B4FA41402348EC,0x15AB8BB9CCC2933B,0x2AC345CFFA},{0x1D56FA9C85A535E0,0xAA2DA19B9A3CAB81,0x8FCFC23B7},{0x883ED9C580D75888,0x9AA7ACC51B3FD35B,0x3212EA6826},{0xB51105677CA5CA8F,0x10D2D085B92A647E,0xECA6B84D7},{0xE887A6AAFEA8CB98,0x868CD01D569A53F4,0x264683763F},{0x602CBB453D393824,0x644B8DB4C7871BC3,0xE1753BAA4},{0xCA11FDCE19B4AED7,0x855A0E1517D71394,0x796AB3C},{0xE3B50019A3030A33,0x2097B309321CDE0B},{0xC619EF3657EB4EDC,0x8BFBEA76},{1,0,0x37B12C0000},{0xE3FD84BF5BB9D3E6,0x32164179B6BF082C,0xCB80822EF},{0x33A40BE73647459E,0xA08CCE4E0A366280,0x27F0ED3C36},{0xFA41402348EBC591,0x8BB9CCC2933B76B4,0xA9FD615AB},{0xFA9C85A535DF608F,0xA19B9A3CAB811D56,0x270A33AA2D},{0xD9C580D75887FFE6,0xACC51B3FD35B883E,0x3115869AA7},{0x5677CA5CA8E7681,0xD085B92A647EB511,0x20C91B10D2},{0xA6AAFEA8CB971A7D,0xD01D569A53F4E887,0x119757868C},{0xBB453D39382309EC,0x8DB4C7871BC3602C,0x14F7B2644B},{0xFDCE19B4AED6BF45,0xE1517D71394CA11,0x2351FC855A},{0x19A3030A3231C0,0xB309321CDE0BE3B5,8343},{0xEF3657EB4EDB3C56,0x8BFBEA76C619},{0x163246E89954E9A9,153914},{1,0,0x52E8C0000},{0x84BF5BB9D3E589A1,0x4179B6BF082CE3FD,0x20C8AF3216},{0xBE73647459D41EF,0xCE4E0A36628033A4,0x2B4288A08C},{0x402348EBC590999C,0xCCC2933B76B4FA41,0x243AA18BB9},{0x85A535DF608EED90,0x9A3CAB811D56FA9C,0x2DE475A19B},{0x80D75887FFE5CAB7,0x1B3FD35B883ED9C5,0x1F2287ACC5},{0x7CA5CA8E7680A354,0xB92A647EB5110567,0x6D4B2D085},{0xFEA8CB971A7C381E,0x569A53F4E887A6AA,0x2A174AD01D},{0x3D39382309EB172F,0xC7871BC3602CBB45,0x4E93F8DB4},{0x19B4AED6BF442C49,0x17D71394CA11FDCE,0x2241C0E15},{0xA3030A3231BF90B0,0x321CDE0BE3B50019,0x2097B309},{0x57EB4EDB3C55B65B,0x8BFBEA76C619EF36},{0x46E89954E9A81FE4,0x2593A1632},{0x163FF802A3426A8D,10},{1,0,0x1C56B60000},{0x5BB9D3E589A0ECE4,0xB6BF082CE3FD84BF,0x122B8A4179},{0x3647459D41EEFC20,0xA36628033A40BE7,0x2D4D94CE4E},{0x48EBC590999B3443,0x933B76B4FA414023,0xE2035CCC2},{0x35DF608EED8F8E22,0xAB811D56FA9C85A5,0xEDC4D9A3C},{0x5887FFE5CAB6B936,0xD35B883ED9C580D7,0x9DECB1B3F},{0xCA8E7680A3538142,0x647EB51105677CA5,0x23EEA9B92A},{0xCB971A7C381D07A6,0x53F4E887A6AAFEA8,0x1F7517569A},{0x382309EB172E3E61,0x1BC3602CBB453D39,0x32138EC787},{0xAED6BF442C480FBE,0x1394CA11FDCE19B4,0x6B8A117D7},{0xA3231BF90AFF414,0xDE0BE3B50019A303,0x3AA75B321C},{0x4EDB3C55B65A883E,0xEA76C619EF3657EB,35835},{0x9954E9A81FE35444,0x2593A163246E8},{0xF802A3426A8CA07D,661055},{1,0,0x2C7A640000},{0xD3E589A0ECE3DD4F,0x82CE3FD84BF5BB9,0xCA995B6BF},{0x459D41EEFC1FA7AE,0x628033A40BE73647,0xDD8500A36},{0xC590999B34429EE6,0x76B4FA41402348EB,0x1E0FD4933B},{0x608EED8F8E21F320,0x1D56FA9C85A535DF,0x154FBEAB81},{0xFFE5CAB6B9358329,0x883ED9C580D75887,0x1D8057D35B},{0x7680A3538141B711,0xB51105677CA5CA8E,0x3905AC647E},{0x1A7C381D07A5741F,0xE887A6AAFEA8CB97,0x2D7D4C53F4},{0x9EB172E3E605AD2,0x602CBB453D393823,0x22A4891BC3},{0xBF442C480FBDDFA1,0xCA11FDCE19B4AED6,0x2C4AB1394},{0x31BF90AFF4138EDC,0xE3B50019A3030A32,0x1BA778DE0B},{0x3C55B65A883D7EAB,0xC619EF3657EB4EDB,0x8BFBEA76},{0xE9A81FE35443E1C0,0x593A163246E89954,2},{0xA3426A8CA07C2DCC,0xA163FF802},{0x52ADC44BACE4A762,43},{1,0,0xA73B00000},{0x89A0ECE3DD4E6909,0xE3FD84BF5BB9D3E5,0x1DD96B082C},{0x41EEFC1FA7ADE5D7,0x33A40BE73647459D,0x2A231A6280},{0x999B34429EE53C15,0xFA41402348EBC590,0x14405976B4},{0xED8F8E21F31F1482,0xFA9C85A535DF608E,0xEA2311D56},{0xCAB6B9358328EA6B,0xD9C580D75887FFE5,0x3F689883E},{0xA3538141B7104103,0x5677CA5CA8E7680,0x1F956EB511},{0x381D07A5741ECC62,0xA6AAFEA8CB971A7C,0xA6A34E887},{0x172E3E605AD1DC29,0xBB453D39382309EB,0x4305F602C},{0x2C480FBDDFA0185D,0xFDCE19B4AED6BF44,0x2A2476CA11},{0x90AFF4138EDBF1B6,0x19A3030A3231BF,0x609CFE3B5},{0xB65A883D7EAA3B8D,0xEF3657EB4EDB3C55,0xD863CC619},{0x1FE35443E1BFA421,0x163246E89954E9A8,153914},{0x6A8CA07C2DCB0CF3,0xA163FF802A342},{0xC44BACE4A761B05C,0x2B52AD},{1,0,0x3B06E20000},{0xECE3DD4E69087102,0x84BF5BB9D3E589A0,0x2631EEE3FD},{0xFC1FA7ADE5D649F3,0xBE73647459D41EE,0xF313C33A4},{0x34429EE53C141AD0,0x402348EBC590999B,0x247170FA41},{0x8E21F31F148122DB,0x85A535DF608EED8F,0x2DFC1CFA9C},{0xB9358328EA6AF230,0x80D75887FFE5CAB6,0x18184CD9C5},{0x8141B710410283B1,0x7CA5CA8E7680A353,0x27D0150567},{0x7A5741ECC617A2B,0xFEA8CB971A7C381D,0x101EF9A6AA},{0x3E605AD1DC28E0CE,0x3D39382309EB172E,0x2FFC8ABB45},{0xFBDDFA0185CBE13,0x19B4AED6BF442C48,0x5F811FDCE},{0xF4138EDBF1B5E3B9,0xA3030A3231BF90AF,0xCA71F0019},{0x883D7EAA3B8CA1BA,0x57EB4EDB3C55B65A,0xBB4BDEF36},{0x5443E1BFA420BC98,0x46E89954E9A81FE3,0x2593A1632},{0xA07C2DCB0CF26F7B,0x163FF802A3426A8C,10},{0xACE4A761B05B2635,0x2B52ADC44B},{0x121A4650E4DDEB93,186},{1,0,0x2C8DD80000},{0xDD4E690871018EBB,0x5BB9D3E589A0ECE3,0x35D54F84BF},{0xA7ADE5D649F2497A,0x3647459D41EEFC1F,0x837240BE7},{0x9EE53C141ACFDBBB,0x48EBC590999B3442,0x26774F4023},{0xF31F148122DA8F9E,0x35DF608EED8F8E21,0x32239C85A5},{0x8328EA6AF22FBD8D,0x5887FFE5CAB6B935,0x2699ED80D7},{0xB710410283B0A5EE,0xCA8E7680A3538141,0x274CFB7CA5},{0x741ECC617A2ABA2F,0xCB971A7C381D07A5,0xD5288FEA8},{0x5AD1DC28E0CD47A3,0x382309EB172E3E60,0x2A118B3D39},{0xDFA0185CBE12D3FA,0xAED6BF442C480FBD,0xB53019B4},{0x8EDBF1B5E3B8C588,0xA3231BF90AFF413,0x36C973A303},{0x7EAA3B8CA1B93B53,0x4EDB3C55B65A883D,0x3627FA57EB},{0xE1BFA420BC97A718,0x9954E9A81FE35443,0xEE4D646E8},{0x2DCB0CF26F7AB7B8,0xF802A3426A8CA07C,661055},{0xA761B05B2634B255,0x2B52ADC44BACE4},{0x4650E4DDEB92F34E,0xBA121A},{1,0,0x2B44320000},{0x690871018EBA3159,0xD3E589A0ECE3DD4E,0x1098235BB9},{0xE5D649F24979C251,0x459D41EEFC1FA7AD,0x36E5173647},{0x3C141ACFDBBAFC05,0xC590999B34429EE5,0x34025148EB},{0x148122DA8F9D4D83,0x608EED8F8E21F31F,0x1FAA3535DF},{0xEA6AF22FBD8CC194,0xFFE5CAB6B9358328,0x212B735887},{0x410283B0A5ED881C,0x7680A3538141B710,0x232E77CA8E},{0xCC617A2ABA2EDB85,0x1A7C381D07A5741E,0x82878CB97},{0xDC28E0CD47A24E22,0x9EB172E3E605AD1,0x31FFED3823},{0x185CBE12D3F98416,0xBF442C480FBDDFA0,0xBAFD0AED6},{0xF1B5E3B8C5870899,0x31BF90AFF4138EDB,0x330B770A32},{0x3B8CA1B93B52A16F,0x3C55B65A883D7EAA,0x13C5314EDB},{0xA420BC97A717A7B1,0xE9A81FE35443E1BF,0x9D389954},{0xCF26F7AB7B7EA44,0xA3426A8CA07C2DCB,0xA163FF802},{0xB05B2634B254F189,0x52ADC44BACE4A761,43},{0xE4DDEB92F34D6262,0xBA121A4650},{0x2AE9B9F14E0B23FA,799},{1,0,0x3571820000},{0x71018EBA31588166,0x89A0ECE3DD4E6908,0x249D47D3E5},{0x49F24979C250A8B3,0x41EEFC1FA7ADE5D6,0x21AAD5459D},{0x1ACFDBBAFC04F170,0x999B34429EE53C14,0x21472BC590},{0x22DA8F9D4D82A4CB,0xED8F8E21F31F1481,0x3580A9608E},{0xF22FBD8CC193BA96,0xCAB6B9358328EA6A,0x1DF36BFFE5},{0x83B0A5ED881BEBD9,0xA3538141B7104102,0x1CEC0A7680},{0x7A2ABA2EDB84DC61,0x381D07A5741ECC61,0x36BC7D1A7C},{0xE0CD47A24E213AC5,0x172E3E605AD1DC28,0xFDF6D09EB},{0xBE12D3F984156EBA,0x2C480FBDDFA0185C,0x2C9A2CBF44},{0xE3B8C587089854DB,0x90AFF4138EDBF1B5,0x13F4DA31BF},{0xA1B93B52A16E782A,0xB65A883D7EAA3B8C,0x2725013C55},{0xBC97A717A7B08E4D,0x1FE35443E1BFA420,0xF76B6E9A8},{0x6F7AB7B7EA43B86E,0x6A8CA07C2DCB0CF2,0x28754EA342},{0x2634B254F1883939,0xC44BACE4A761B05B,0x2B52AD},{0xEB92F34D62616CE5,0xBA121A4650E4DD},{0xB9F14E0B23F99295,0x31F2AE9},{1,0,0x2577E60000},{0x8EBA315881653427,0xECE3DD4E69087101,0x37A49B89A0},{0x4979C250A8B22FEB,0xFC1FA7ADE5D649F2,0x2422E341EE},{0xDBBAFC04F16F2B1B,0x34429EE53C141ACF,0x216C8E999B},{0x8F9D4D82A4CAE9F8,0x8E21F31F148122DA,0x2A8B2AED8F},{0xBD8CC193BA95AA4F,0xB9358328EA6AF22F,0x137147CAB6},{0xA5ED881BEBD84B5A,0x8141B710410283B0,0x6C250A353},{0xBA2EDB84DC600205,0x7A5741ECC617A2A,0xAC456381D},{0x47A24E213AC47D9A,0x3E605AD1DC28E0CD,0x10C733172E},{0xD3F984156EB9A53F,0xFBDDFA0185CBE12,0x28F7A42C48},{0xC587089854DA2251,0xF4138EDBF1B5E3B8,0x15142390AF},{0x3B52A16E78299289,0x883D7EAA3B8CA1B9,0x34EDDFB65A},{0xA717A7B08E4CDCE6,0x5443E1BFA420BC97,0x20BE041FE3},{0xB7B7EA43B86DAA11,0xA07C2DCB0CF26F7A,0x119E9A6A8C},{0xB254F18839386D37,0xACE4A761B05B2634,0x2B52ADC44B},{0xF34D62616CE41322,0x121A4650E4DDEB92,186},{0x4E0B23F99294BBA6,0x31F2AE9B9F1},{0x6619BA27255A2C81,3432},{1,0,0x350DC80000},{0x3158816534261126,0xDD4E690871018EBA,0x75EC8ECE3},{0xC250A8B22FEAA6BE,0xA7ADE5D649F24979,0xF82E6FC1F},{0xFC04F16F2B1A15AC,0x9EE53C141ACFDBBA,0x7E78F3442},{0x4D82A4CAE9F7B11B,0xF31F148122DA8F9D,0xC75958E21},{0xC193BA95AA4E8740,0x8328EA6AF22FBD8C,0xF4CECB935},{0x881BEBD84B59F310,0xB710410283B0A5ED,0x2685CD8141},{0xDB84DC60020421B6,0x741ECC617A2ABA2E,0x166F3107A5},{0x4E213AC47D9900FF,0x5AD1DC28E0CD47A2,0x2C35583E60},{0x84156EB9A53E3833,0xDFA0185CBE12D3F9,0x48DC00FBD},{0x89854DA2250FFA9,0x8EDBF1B5E3B8C587,0xE515FF413},{0xA16E782992882873,0x7EAA3B8CA1B93B52,0xFCE12883D},{0xA7B08E4CDCE5B08C,0xE1BFA420BC97A717,0x1CE9A35443},{0xEA43B86DAA102472,0x2DCB0CF26F7AB7B7,0x353CD4A07C},{0xF18839386D363B24,0xA761B05B2634B254,0x61E17ACE4},{0x62616CE41321A019,0x4650E4DDEB92F34D,0xBA121A},{0x23F99294BBA5AE40,0x31F2AE9B9F14E0B},{0xBA27255A2C80A538,0xD686619},{1,0,0x12419E0000},{0x8165342611258611,0x690871018EBA3158,0x287D1DDD4E},{0xA8B22FEAA6BDCDAC,0xE5D649F24979C250,0x355F73A7AD},{0xF16F2B1A15ABAFE4,0x3C141ACFDBBAFC04,0x73C849EE5},{0xA4CAE9F7B11AD589,0x148122DA8F9D4D82,0x986C3F31F},{0xBA95AA4E873F4ED2,0xEA6AF22FBD8CC193,0x3C8CF8328},{0xEBD84B59F30F134F,0x410283B0A5ED881B,0x72BB9B710},{0xDC60020421B52EB2,0xCC617A2ABA2EDB84,0x30DCA1741E},{0x3AC47D9900FE9C7F,0xDC28E0CD47A24E21,0x25466A5AD1},{0x6EB9A53E383249C8,0x185CBE12D3F98415,0x3335B1DFA0},{0x54DA2250FFA8F276,0xF1B5E3B8C5870898,0x27A2A78EDB},{0x7829928828726654,0x3B8CA1B93B52A16E,0x2C9EB37EAA},{0x8E4CDCE5B08B69B5,0xA420BC97A717A7B0,0x2F46C1E1BF},{0xB86DAA102471B0CF,0xCF26F7AB7B7EA43,0x16BEB62DCB},{0x39386D363B23FEE4,0xB05B2634B254F188,0x12D5A8A761},{0x6CE41321A0183E11,0xE4DDEB92F34D6261,0x741BC4650},{0x9294BBA5AE3F0330,0x2AE9B9F14E0B23F9,799},{0x255A2C80A537B0F0,0xD686619BA27},{0xA6CC11AC2BE832E,14742},{1,0,0x1F7260000},{0x3426112586103EAC,0x71018EBA31588165,0x31E49C6908},{0x2FEAA6BDCDABB8A9,0x49F24979C250A8B2,0x4AE55E5D6},{0x2B1A15ABAFE33DDB,0x1ACFDBBAFC04F16F,0x1E111D3C14},{0xE9F7B11AD5887E24,0x22DA8F9D4D82A4CA,0x18E67B1481},{0xAA4E873F4ED1AC9B,0xF22FBD8CC193BA95,0x95DEEA6A},{0x4B59F30F134E2FA5,0x83B0A5ED881BEBD8,0x16B2184102},{0x20421B52EB172D9,0x7A2ABA2EDB84DC60,0x98486CC61},{0x7D9900FE9C7E3562,0xE0CD47A24E213AC4,0x1597E1DC28},{0xA53E383249C75632,0xBE12D3F984156EB9,0x2A5976185C},{0x2250FFA8F27564EF,0xE3B8C587089854DA,0x20BE4DF1B5},{0x9288287266533380,0xA1B93B52A16E7829,0x79F423B8C},{0xDCE5B08B69B4592A,0xBC97A717A7B08E4C,0x387247A420},{0xAA102471B0CE9F66,0x6F7AB7B7EA43B86D,0x1538EB0CF2},{0x6D363B23FEE36616,0x2634B254F1883938,0x33AB79B05B},{0x1321A0183E10583D,0xEB92F34D62616CE4,0x366B2CE4DD},{0xBBA5AE3F032FAD21,0xB9F14E0B23F99294,0x31F2AE9},{0x2C80A537B0EFEFEC,0xD686619BA27255A},{0xC11AC2BE832D2969,0x39960A6C},{1,0,0x5CD60000},{0x112586103EAB5040,0x8EBA315881653426,0x38696E7101},{0xA6BDCDABB8A8F616,0x4979C250A8B22FEA,0x30655249F2},{0x15ABAFE33DDA325D,0xDBBAFC04F16F2B1A,0x32E3401ACF},{0xB11AD5887E232C41,0x8F9D4D82A4CAE9F7,0xB1D8D22DA},{0x873F4ED1AC9A47B9,0xBD8CC193BA95AA4E,0x29210CF22F},{0xF30F134E2FA4AE41,0xA5ED881BEBD84B59,0x9F2BE83B0},{0x21B52EB172D8D161,0xBA2EDB84DC600204,0x2FCBA17A2A},{0xFE9C7E35618EB1,0x47A24E213AC47D99,0x4623CE0CD},{0x383249C75631C599,0xD3F984156EB9A53E,0x2B053EBE12},{0xFFA8F27564EE62A5,0xC587089854DA2250,0x2B20ABE3B8},{0x28726653337F3560,0x3B52A16E78299288,0x234F34A1B9},{0xB08B69B4592909EA,0xA717A7B08E4CDCE5,0x1C928ABC97},{0x2471B0CE9F65E8AE,0xB7B7EA43B86DAA10,0xC44F66F7A},{0x3B23FEE366150B47,0xB254F18839386D36,0x2236ED2634},{0xA0183E10583CD332,0xF34D62616CE41321,0x382EE3EB92},{0xAE3F032FAD207090,0x4E0B23F99294BBA5,0x184EA7B9F1},{0xA537B0EFEFEBDD3B,0x6619BA27255A2C80,3432},{0xC2BE832D2968C44B,0x39960A6CC11A},{0x9530E188C128D12C,63316},{1,0,0x2B59F40000},{0x86103EAB503F216D,0x3158816534261125,0x1C59678EBA},{0xCDABB8A8F615373F,0xC250A8B22FEAA6BD,0x2B89244979},{0xAFE33DDA325C3A53,0xFC04F16F2B1A15AB,0x249FF9DBBA},{0xD5887E232C4082BA,0x4D82A4CAE9F7B11A,0x20C5B88F9D},{0x4ED1AC9A47B8E308,0xC193BA95AA4E873F,0x374DFDBD8C},{0x134E2FA4AE40AE6A,0x881BEBD84B59F30F,0xAE8ECA5ED},{0x2EB172D8D1601CB5,0xDB84DC60020421B5,0x25CA24BA2E},{0x9C7E35618EB04EF4,0x4E213AC47D9900FE,0x3A184F47A2},{0x49C75631C5982B14,0x84156EB9A53E3832,0x1F70A0D3F9},{0xF27564EE62A46E67,0x89854DA2250FFA8,0x133D2AC587},{0x6653337F355F140F,0xA16E782992882872,0x581F33B52},{0x69B4592909E9AE01,0xA7B08E4CDCE5B08B,0x2AD231A717},{0xB0CE9F65E8AD6934,0xEA43B86DAA102471,0x13C706B7B7},{0xFEE366150B46715C,0xF18839386D363B23,0x120476B254},{0x3E10583CD33148DB,0x62616CE41321A018,0x29806F34D},{0x32FAD20708F579D,0x23F99294BBA5AE3F,0x5FD754E0B},{0xB0EFEFEBDD3A7F74,0xBA27255A2C80A537,0xD686619},{0x832D2968C44A9445,0x39960A6CC11AC2BE},{0xE188C128D12BEE5A,0xF7549530},{1,0,0x149B560000},{0x3EAB503F216CD0FE,0x8165342611258610,0x12C7A63158},{0xB8A8F615373E3962,0xA8B22FEAA6BDCDAB,0x126A1C250},{0x3DDA325C3A52E281,0xF16F2B1A15ABAFE3,0x1E6AF8FC04},{0x7E232C4082B91525,0xA4CAE9F7B11AD588,0x2265534D82},{0xAC9A47B8E3076F40,0xBA95AA4E873F4ED1,0x6803CC193},{0x2FA4AE40AE69892C,0xEBD84B59F30F134E,0x1EEF1F881B},{0x72D8D1601CB4642C,0xDC60020421B52EB1,0x7BCA2DB84},{0x35618EB04EF3DEE9,0x3AC47D9900FE9C7E,0x4FD7A4E21},{0x5631C5982B13D7EA,0x6EB9A53E383249C7,0x2377A98415},{0x64EE62A46E66747F,0x54DA2250FFA8F275,0x19B87D0898},{0x337F355F140E4F03,0x7829928828726653,0x291B8CA16E},{0x592909E9AE00A388,0x8E4CDCE5B08B69B4,0xFC473A7B0},{0x9F65E8AD6933B9A6,0xB86DAA102471B0CE,0x1FB78DEA43},{0x66150B46715BB234,0x39386D363B23FEE3,0x16AF00F188},{0x583CD33148DA6149,0x6CE41321A0183E10,0x3A1BAF6261},{0xAD20708F579C45AA,0x9294BBA5AE3F032F,0x91D4723F9},{0xEFEBDD3A7F737777,0x255A2C80A537B0EF,0x22EF1FBA27},{0x2968C44A9444A8EE,0xA6CC11AC2BE832D,14742},{0xC128D12BEE59E68F,0xF7549530E188},{0xA6FE9631F9D94F67,271942},{1,0,0x1790360000},{0x503F216CD0FD77D5,0x3426112586103EAB,0x297CC88165},{0xF615373E3961AF3A,0x2FEAA6BDCDABB8A8,0x19E226A8B2},{0x325C3A52E28042A9,0x2B1A15ABAFE33DDA,0x2F3E9CF16F},{0x2C4082B91524BCEC,0xE9F7B11AD5887E23,0x22D8BEA4CA},{0x47B8E3076F3FDF88,0xAA4E873F4ED1AC9A,0x325C25BA95},{0xAE40AE69892BCDDA,0x4B59F30F134E2FA4,0x165A83EBD8},{0xD1601CB4642BBF28,0x20421B52EB172D8,0x2DBFC0DC60},{0x8EB04EF3DEE8863E,0x7D9900FE9C7E3561,0x2B39553AC4},{0xC5982B13D7E94AD4,0xA53E383249C75631,0x32C9CD6EB9},{0x62A46E66747EE530,0x2250FFA8F27564EE,0x9ADE854DA},{0x355F140E4F02A6E2,0x928828726653337F,0x11E5627829},{0x9E9AE00A38761FA,0xDCE5B08B69B45929,0x1988808E4C},{0xE8AD6933B9A5B136,0xAA102471B0CE9F65,0xD2349B86D},{0xB46715BB2337397,0x6D363B23FEE36615,0x351A503938},{0xD33148DA61480E1C,0x1321A0183E10583C,0x22A12D6CE4},{0x708F579C45A9861A,0xBBA5AE3F032FAD20,0x14FEC79294},{0xDD3A7F737776BE8B,0x2C80A537B0EFEFEB,0x195243255A},{0xC44A9444A8ED586D,0xC11AC2BE832D2968,0x39960A6C},{0xD12BEE59E68EF47D,0xF7549530E188C128},{0x9631F9D94F66CFA1,0x42646A6FE},{0xD270CC51055EA7CB,17},{1,0,0x8DCF80000},{0x216CD0FD77D43BC6,0x112586103EAB503F,0x36A24F3426},{0x373E3961AF39D458,0xA6BDCDABB8A8F615,0x612C42FEA},{0x3A52E28042A8DE27,0x15ABAFE33DDA325C,0x39AB952B1A},{0x82B91524BCEB6312,0xB11AD5887E232C40,0x1248A6E9F7},{0xE3076F3FDF87720F,0x873F4ED1AC9A47B8,0x14F167AA4E},{0xAE69892BCDD91F49,0xF30F134E2FA4AE40,0xF6444B59},{0x1CB4642BBF272A6F,0x21B52EB172D8D160,0x239FBE0204},{0x4EF3DEE8863D720C,0xFE9C7E35618EB0,0xE7C927D99},{0x2B13D7E94AD3A2F1,0x383249C75631C598,0x12DBE5A53E},{0x6E66747EE52F1050,0xFFA8F27564EE62A4,0x1FB3A62250},{0x140E4F02A6E182DA,0x28726653337F355F,0x357A919288},{0xAE00A38761F9AFBB,0xB08B69B4592909E9,0x3C228DCE5},{0x6933B9A5B135596B,0x2471B0CE9F65E8AD,0xCA06BAA10},{0x715BB23373961AAB,0x3B23FEE366150B46,0x7D43A6D36},{0x48DA61480E1B914C,0xA0183E10583CD331,0x2693561321},{0x579C45A98619CBB7,0xAE3F032FAD20708F,0x1DF3DCBBA5},{0x7F737776BE8AA47F,0xA537B0EFEFEBDD3A,0x63B102C80},{0x9444A8ED586C72C9,0xC2BE832D2968C44A,0x13B186C11A},{0xEE59E68EF47CE570,0x9530E188C128D12B,63316},{0xF9D94F66CFA00210,0x42646A6FE9631},{0xCC51055EA7CA8FD7,1167984},{1,0,0x8BC960000},{0xD0FD77D43BC5C2B2,0x86103EAB503F216C,0x2C312A1125},{0x3961AF39D4573798,0xCDABB8A8F615373E,0x27F958A6BD},{0xE28042A8DE262F94,0xAFE33DDA325C3A52,0x63F7015AB},{0x1524BCEB63110E05,0xD5887E232C4082B9,0xEBD71B11A},{0x6F3FDF87720E1BED,0x4ED1AC9A47B8E307,0x38290873F},{0x892BCDD91F48989E,0x134E2FA4AE40AE69,0x2A2F4FF30F},{0x642BBF272A6E1A9E,0x2EB172D8D1601CB4,0x3B480421B5},{0xDEE8863D720B8781,0x9C7E35618EB04EF3,0xBB56900FE},{0xD7E94AD3A2F0DC52,0x49C75631C5982B13,0x2756083832},{0x747EE52F104F9831,0xF27564EE62A46E66,0x1AA2C0FFA8},{0x4F02A6E182D9FAD2,0x6653337F355F140E,0x2075A82872},{0xA38761F9AFBA3D8E,0x69B4592909E9AE00,0x1A787DB08B},{0xB9A5B135596A4BD6,0xB0CE9F65E8AD6933,0x861822471},{0xB23373961AAA21F2,0xFEE366150B46715B,0x5A4F63B23},{0x61480E1B914B0C21,0x3E10583CD33148DA,0xEABD5A018},{0x45A98619CBB6E76D,0x32FAD20708F579C,0xCF773AE3F},{0x7776BE8AA47E9438,0xB0EFEFEBDD3A7F73,0x2C5B6CA537},{0xA8ED586C72C820E6,0x832D2968C44A9444,0xB6188C2BE},{0xE68EF47CE56FD516,0xE188C128D12BEE59,0xF7549530},{0x4F66CFA0020F039C,0x2646A6FE9631F9D9,4},{0x55EA7CA8FD68F6F,0x11D270CC51},{0x8B888296C5F9E2BB,76},{1,0,0x3C8440000},{0x77D43BC5C2B12ED1,0x3EAB503F216CD0FD,0x27FB638610},{0xAF39D4573797BD4B,0xB8A8F615373E3961,0x34E8A7CDAB},{0x42A8DE262F93DCA5,0x3DDA325C3A52E280,0x1FC799AFE3},{0xBCEB63110E043F11,0x7E232C4082B91524,0x30D18ED588},{0xDF87720E1BEC494D,0xAC9A47B8E3076F3F,0x1234414ED1},{0xCDD91F48989DBDCA,0x2FA4AE40AE69892B,0x2950C3134E},{0xBF272A6E1A9D3725,0x72D8D1601CB4642B,0x1D629D2EB1},{0x863D720B87803E55,0x35618EB04EF3DEE8,0x2E69649C7E},{0x4AD3A2F0DC51D033,0x5631C5982B13D7E9,0x1B553E49C7},{0xE52F104F9830F070,0x64EE62A46E66747E,0x135F2CF275},{0xA6E182D9FAD10FC9,0x337F355F140E4F02,0x29FD986653},{0x61F9AFBA3D8D245A,0x592909E9AE00A387,0x301BAB69B4},{0xB135596A4BD572EE,0x9F65E8AD6933B9A5,0x34F205B0CE},{0x73961AAA21F19D71,0x66150B46715BB233,0x3CE37FEE3},{0xE1B914B0C20EFDD,0x583CD33148DA6148,0xB19BA3E10},{0x8619CBB6E76C9969,0xAD20708F579C45A9,0x37DD5F032F},{0xBE8AA47E943758D0,0xEFEBDD3A7F737776,0xA83D9B0EF},{0x586C72C820E5B373,0x2968C44A9444A8ED,0x1FD734832D},{0xF47CE56FD515C9ED,0xC128D12BEE59E68E,0x107334E188},{0xCFA0020F039BAD4D,0xA6FE9631F9D94F66,271942},{0xA7CA8FD68F6E505E,0x11D270CC51055E},{0x8296C5F9E2BA8DEF,0x4C8B88},{1,0,0x27E3140000},{0x3BC5C2B12ED066D0,0x503F216CD0FD77D4,0x2756E03EAB},{0xD4573797BD4A732D,0xF615373E3961AF39,0x32CD89B8A8},{0xDE262F93DCA414C7,0x325C3A52E28042A8,0x830773DDA},{0x63110E043F10E8C2,0x2C4082B91524BCEB,0x23EBD07E23},{0x720E1BEC494C01FC,0x47B8E3076F3FDF87,0x2657BBAC9A},{0x1F48989DBDC9A450,0xAE40AE69892BCDD9,0x327B5A2FA4},{0x2A6E1A9D3724538B,0xD1601CB4642BBF27,0x16B6DF72D8},{0x720B87803E544002,0x8EB04EF3DEE8863D,0xB96A23561},{0xA2F0DC51D032E441,0xC5982B13D7E94AD3,0x3780DF5631},{0x104F9830F06F1D55,0x62A46E66747EE52F,0x1D9E3764EE},{0x82D9FAD10FC83114,0x355F140E4F02A6E1,0x98E19337F},{0xAFBA3D8D2459FFF8,0x9E9AE00A38761F9,0x17BA3E5929},{0x596A4BD572ED41B4,0xE8AD6933B9A5B135,0x4E6529F65},{0x1AAA21F19D708A6F,0xB46715BB2337396,0xE29736615},{0x914B0C20EFDCA4A7,0xD33148DA61480E1B,0x78D8E583C},{0xCBB6E76C996871E6,0x708F579C45A98619,0x36EA99AD20},{0xA47E943758CF6EEC,0xDD3A7F737776BE8A,0x186495EFEB},{0x72C820E5B3727874,0xC44A9444A8ED586C,0x980E32968},{0xE56FD515C9EC542E,0xD12BEE59E68EF47C,0x3B468CC128},{0x20F039BAD4CFBCB,0x9631F9D94F66CFA0,0x42646A6FE},{0x8FD68F6E505DD389,0xD270CC51055EA7CA,17},{0xC5F9E2BA8DEE8A97,0x4C8B888296},{0xC22CA71A1BD6F0A6,328},{1,0,0xEB2E00000},{0xC2B12ED066CF05D1,0x216CD0FD77D43BC5,0x4F08F503F},{0x3797BD4A732C0EE5,0x373E3961AF39D457,0x157934F615},{0x2F93DCA414C699B8,0x3A52E28042A8DE26,0xF0522325C},{0xE043F10E8C11944,0x82B91524BCEB6311,0x2B0C1D2C40},{0x1BEC494C01FBFF9A,0xE3076F3FDF87720E,0xF0F4E47B8},{0x989DBDC9A44F8E44,0xAE69892BCDD91F48,0x1660BAAE40},{0x1A9D3724538A14DA,0x1CB4642BBF272A6E,0x290CCCD160},{0x87803E5440010475,0x4EF3DEE8863D720B,0x236DEF8EB0},{0xDC51D032E440212F,0x2B13D7E94AD3A2F0,0x2648DDC598},{0x9830F06F1D54944A,0x6E66747EE52F104F,0x16231C62A4},{0xFAD10FC8311352D1,0x140E4F02A6E182D9,0x366865355F},{0x3D8D2459FFF79B95,0xAE00A38761F9AFBA,0x28601909E9},{0x4BD572ED41B3AB13,0x6933B9A5B135596A,0x1066B7E8AD},{0x21F19D708A6E17BC,0x715BB23373961AAA,0xB79970B46},{0xC20EFDCA4A6E67B,0x48DA61480E1B914B,0x215FDCD331},{0xE76C996871E5FE69,0x579C45A98619CBB6,0xD9EBE708F},{0x943758CF6EEB28E3,0x7F737776BE8AA47E,0x115D43DD3A},{0x20E5B372787342F4,0x9444A8ED586C72C8,0xA3A7EC44A},{0xD515C9EC542DEC0A,0xEE59E68EF47CE56F,0xBA2CCD12B},{0x39BAD4CFBCA189D,0xF9D94F66CFA0020F,0x1A434A9631},{0x8F6E505DD3883605,0xCC51055EA7CA8FD6,1167984},{0xE2BA8DEE8A96A68F,0x4C8B888296C5F9},{0xA71A1BD6F0A5B37E,0x148C22C},{1,0,0x1955F60000},{0x2ED066CF05D0E92B,0xD0FD77D43BC5C2B1,0xE7CD9216C},{0xBD4A732C0EE4919D,0x3961AF39D4573797,0x134C51373E},{0xDCA414C699B76A7F,0xE28042A8DE262F93,0x2B17C83A52},{0x3F10E8C1194353EB,0x1524BCEB63110E04,0x1BB2282B9},{0x494C01FBFF9933AF,0x6F3FDF87720E1BEC,0x18926CE307},{0xBDC9A44F8E43E9C3,0x892BCDD91F48989D,0x2A0028AE69},{0x3724538A14D99369,0x642BBF272A6E1A9D,0x38C7D41CB4},{0x3E5440010474794F,0xDEE8863D720B8780,0x49EC24EF3},{0xD032E440212E5F24,0xD7E94AD3A2F0DC51,0x17DACC2B13},{0xF06F1D5494498ADC,0x747EE52F104F9830,0x354DC6E66},{0xFC8311352D07BF6,0x4F02A6E182D9FAD1,0x2613140E},{0x2459FFF79B947DC6,0xA38761F9AFBA3D8D,0xC0B0FAE00},{0x72ED41B3AB12BDA4,0xB9A5B135596A4BD5,0x1559836933},{0x9D708A6E17BB0EF8,0xB23373961AAA21F1,0x32D876715B},{0xEFDCA4A6E67A5AF7,0x61480E1B914B0C20,0x24628B48DA},{0x996871E5FE68A8FF,0x45A98619CBB6E76C,0x1AE259579C},{0x58CF6EEB28E2E695,0x7776BE8AA47E9437,0xFFC727F73},{0xB372787342F3E342,0xA8ED586C72C820E5,0x14EE7E9444},{0xC9EC542DEC09BC14,0xE68EF47CE56FD515,0x3298B1EE59},{0xAD4CFBCA189C739C,0x4F66CFA0020F039B,0x12DD39F9D9},{0x505DD388360461C3,0x55EA7CA8FD68F6E,0x11D270CC51},{0x8DEE8A96A68E2551,0x8B888296C5F9E2BA,76},{0x1BD6F0A5B37D0BE1,0x148C22CA71A},{0x1C96621A4EF65ED,1412},{1,0,0x3B03E00000},{0x66CF05D0E92AEB2A,0x77D43BC5C2B12ED0,0x16BE72D0FD},{0x732C0EE4919C857A,0xAF39D4573797BD4A,0x1DDCEA3961},{0x14C699B76A7EFDB1,0x42A8DE262F93DCA4,0x88DC0E280},{0xE8C1194353EA47E3,0xBCEB63110E043F10,0xEDF231524},{0x1FBFF9933AE18F8,0xDF87720E1BEC494C,0xA32ED6F3F},{0xA44F8E43E9C257D1,0xCDD91F48989DBDC9,0xA2F81892B},{0x538A14D99368FF15,0xBF272A6E1A9D3724,0x362388642B},{0x40010474794EFA04,0x863D720B87803E54,0x36514DDEE8},{0xE440212E5F238F29,0x4AD3A2F0DC51D032,0x1D8B8BD7E9},{0x1D5494498ADB6AD5,0xE52F104F9830F06F,0x9E10747E},{0x311352D07BF52B5C,0xA6E182D9FAD10FC8,0x1F85704F02},{0xFFF79B947DC5675E,0x61F9AFBA3D8D2459,0x269406A387},{0x41B3AB12BDA3C0CE,0xB135596A4BD572ED,0xBFABFB9A5},{0x8A6E17BB0EF7993E,0x73961AAA21F19D70,0x10C6D1B233},{0xA4A6E67A5AF691EA,0xE1B914B0C20EFDC,0x2778686148},{0x71E5FE68A8FE824B,0x8619CBB6E76C9968,0x1BA5B645A9},{0x6EEB28E2E6949834,0xBE8AA47E943758CF,0x3742E37776},{0x787342F3E3412013,0x586C72C820E5B372,0x2148C8A8ED},{0x542DEC09BC13453D,0xF47CE56FD515C9EC,0x17F003E68E},{0xFBCA189C739BE1D0,0xCFA0020F039BAD4C,0x1609E74F66},{0xD388360461C2842A,0xA7CA8FD68F6E505D,0x1FC8A3055E},{0x8A96A68E2550B653,0x8296C5F9E2BA8DEE,0x4C8B88},{0xF0A5B37D0BE0E9CD,0x148C22CA71A1BD6},{0x6621A4EF65EC6BCB,0x58401C9},{1,0,0x316A1A0000},{0x5D0E92AEB29F3DF,0x3BC5C2B12ED066CF,0xD76E777D4},{0xEE4919C8579F95E,0xD4573797BD4A732C,0x27514DAF39},{0x99B76A7EFDB0D4DE,0xDE262F93DCA414C6,0x36CE2842A8},{0x194353EA47E2F859,0x63110E043F10E8C1,0x1F892EBCEB},{0xFF9933AE18F70B4D,0x720E1BEC494C01FB,0x328D7DDF87},{0x8E43E9C257D063ED,0x1F48989DBDC9A44F,0x91E75CDD9},{0x14D99368FF140A8C,0x2A6E1A9D3724538A,0xE4E6FBF27},{0x474794EFA03BA1B,0x720B87803E544001,0x314684863D},{0x212E5F238F285722,0xA2F0DC51D032E440,0xAF5374AD3},{0x94498ADB6AD47DE7,0x104F9830F06F1D54,0x348182E52F},{0x52D07BF52B5B263F,0x82D9FAD10FC83113,0x3A2278A6E1},{0x9B947DC5675D75E9,0xAFBA3D8D2459FFF7,0xC6BDD61F9},{0xAB12BDA3C0CD3935,0x596A4BD572ED41B3,0x22F2E7B135},{0x17BB0EF7993D8DDD,0x1AAA21F19D708A6E,0x66B277396},{0xE67A5AF691E91CA7,0x914B0C20EFDCA4A6,0x6018C0E1B},{0xFE68A8FE824A6E21,0xCBB6E76C996871E5,0x2047BD8619},{0x28E2E69498336C52,0xA47E943758CF6EEB,0x194006BE8A},{0x42F3E34120124F3B,0x72C820E5B3727873,0x1D1465586C},{0xEC09BC13453CE19E,0xE56FD515C9EC542D,0x254138F47C},{0x189C739BE1CFCFC5,0x20F039BAD4CFBCA,0x2F29A0CFA0},{0x360461C284290FBB,0x8FD68F6E505DD388,0x231ACAA7CA},{0xA68E2550B652834C,0xC5F9E2BA8DEE8A96,0x10F0BE8296},{0xB37D0BE0E9CC11AE,0xC22CA71A1BD6F0A5,328},{0xA4EF65EC6BCA6CB6,0x58401C96621},{0x8617A104EE462A19,6064},{1,0,0x2E0B720000},{0xE92AEB29F3DE227A,0xC2B12ED066CF05D0,0x144E8C3BC5},{0x919C8579F95DFF5C,0x3797BD4A732C0EE4,0x8E40DD457},{0x6A7EFDB0D4DD06BD,0x2F93DCA414C699B7,0x3F88ADE26},{0x53EA47E2F858F3EF,0xE043F10E8C11943,0x348F76311},{0x33AE18F70B4C27BF,0x1BEC494C01FBFF99,0x10E711720E},{0xE9C257D063ECB50B,0x989DBDC9A44F8E43,0x19A2B51F48},{0x9368FF140A8BA6FB,0x1A9D3724538A14D9,0x2AF332A6E},{0x794EFA03BA1A7ACE,0x87803E5440010474,0x381469720B},{0x5F238F2857218B37,0xDC51D032E440212E,0x128833A2F0},{0x8ADB6AD47DE6A0E0,0x9830F06F1D549449,0x32C09B104F},{0x7BF52B5B263EDC95,0xFAD10FC8311352D0,0x2B5CCB82D9},{0x7DC5675D75E81D07,0x3D8D2459FFF79B94,0x18BFBFAFBA},{0xBDA3C0CD39345161,0x4BD572ED41B3AB12,0x279CB1596A},{0xEF7993D8DDC9CDD,0x21F19D708A6E17BB,0x11792C1AAA},{0x5AF691E91CA6B7B9,0xC20EFDCA4A6E67A,0x2A95ED914B},{0xA8FE824A6E20EF83,0xE76C996871E5FE68,0x1D78B1CBB6},{0xE69498336C517461,0x943758CF6EEB28E2,0x2E9896A47E},{0xE34120124F3A8445,0x20E5B372787342F3,0x1A09BA72C8},{0xBC13453CE19DC829,0xD515C9EC542DEC09,0x37EE8E56F},{0x739BE1CFCFC49802,0x39BAD4CFBCA189C,0x31F4CA020F},{0x61C284290FBAA9B4,0x8F6E505DD3883604,0x3A2E588FD6},{0x2550B652834B9C88,0xE2BA8DEE8A96A68E,0xA6582C5F9},{0xBE0E9CC11ADCB2D,0xA71A1BD6F0A5B37D,0x148C22C},{0x65EC6BCA6CB5567E,0x58401C96621A4EF},{0xA104EE462A18DFF0,0x17B08617},{1,0,0x2940EC0000},{0xEB29F3DE22796B6B,0x2ED066CF05D0E92A,0x23545FC2B1},{0x8579F95DFF5BD979,0xBD4A732C0EE4919C,0x226D413797},{0xFDB0D4DD06BCD248,0xDCA414C699B76A7E,0xFD1A2F93},{0x47E2F858F3EE38C3,0x3F10E8C1194353EA,0x3703C30E04},{0x18F70B4C27BEC88A,0x494C01FBFF9933AE,0x24BA1E1BEC},{0x57D063ECB50A3DFB,0xBDC9A44F8E43E9C2,0x249AC4989D},{0xFF140A8BA6FA9115,0x3724538A14D99368,0x1DDBE81A9D},{0xFA03BA1A7ACD1F79,0x3E5440010474794E,0x130C738780},{0x8F2857218B364C56,0xD032E440212E5F23,0xB6500DC51},{0x6AD47DE6A0DFD2A6,0xF06F1D5494498ADB,0x30AD0B9830},{0x2B5B263EDC946203,0xFC8311352D07BF5,0x20DCB7FAD1},{0x675D75E81D06AAA9,0x2459FFF79B947DC5,0x31B28C3D8D},{0xC0CD393451606F71,0x72ED41B3AB12BDA3,0x3841604BD5},{0x993D8DDC9CDC5A94,0x9D708A6E17BB0EF7,0x7AB3221F1},{0x91E91CA6B7B856CC,0xEFDCA4A6E67A5AF6,0x1949050C20},{0x824A6E20EF825C2E,0x996871E5FE68A8FE,0xCE2EEE76C},{0x98336C5174601C24,0x58CF6EEB28E2E694,0x357B3E9437},{0x20124F3A84440D16,0xB372787342F3E341,0x512B620E5},{0x453CE19DC828CADB,0xC9EC542DEC09BC13,0x243F11D515},{0xE1CFCFC498015ECF,0xAD4CFBCA189C739B,0x19AF39039B},{0x84290FBAA9B3CAA9,0x505DD388360461C2,0x2B6F828F6E},{0xB652834B9C87897A,0x8DEE8A96A68E2550,0x61433E2BA},{0xE9CC11ADCB2C1361,0x1BD6F0A5B37D0BE0,0x1EBC3AA71A},{0x6BCA6CB5567D9FF1,0x1C96621A4EF65EC,1412},{0xEE462A18DFEF0551,0x17B08617A104},{0xEE6ED136D13454CB,26046},{1,0,0x3085B40000},{0xF3DE22796B6AA0F8,0x66CF05D0E92AEB29,0x11558F2ED0},{0xF95DFF5BD978C889,0x732C0EE4919C8579,0x2633FFBD4A},{0xD4DD06BCD247A209,0x14C699B76A7EFDB0,0x3EFDDDCA4},{0xF858F3EE38C2DC1D,0xE8C1194353EA47E2,0x11B26A3F10},{0xB4C27BEC889E08D,0x1FBFF9933AE18F7,0x2EF2CA494C},{0x63ECB50A3DFABEEB,0xA44F8E43E9C257D0,0x87537BDC9},{0xA8BA6FA91147A8D,0x538A14D99368FF14,0x139DB13724},{0xBA1A7ACD1F78E7C3,0x40010474794EFA03,0xBD9603E54},{0x57218B364C558B52,0xE440212E5F238F28,0x19DEF1D032},{0x7DE6A0DFD2A5D15A,0x1D5494498ADB6AD4,0x2E9C5AF06F},{0x263EDC9462028AE3,0x311352D07BF52B5B,0x14F4690FC8},{0x75E81D06AAA8F435,0xFFF79B947DC5675D,0x373D992459},{0x393451606F70BBC7,0x41B3AB12BDA3C0CD,0x1A33F372ED},{0x8DDC9CDC5A9357F5,0x8A6E17BB0EF7993D,0x335F5B9D70},{0x1CA6B7B856CBB135,0xA4A6E67A5AF691E9,0x185166EFDC},{0x6E20EF825C2D264D,0x71E5FE68A8FE824A,0x304BFC9968},{0x6C5174601C23750D,0x6EEB28E2E6949833,0x1AA6F958CF},{0x4F3A84440D153559,0x787342F3E3412012,0x37064BB372},{0xE19DC828CADA40B2,0x542DEC09BC13453C,0x11EC93C9EC},{0xCFC498015ECED44E,0xFBCA189C739BE1CF,0x15D87BAD4C},{0xFBAA9B3CAA86B86,0xD388360461C28429,0x378A2C505D},{0x834B9C8789798F9F,0x8A96A68E2550B652,0x320B6C8DEE},{0x11ADCB2C136039F2,0xF0A5B37D0BE0E9CC,0x2EE4501BD6},{0x6CB5567D9FF09D2F,0x6621A4EF65EC6BCA,0x58401C9},{0x2A18DFEF0550706B,0x17B08617A104EE46},{0xD136D13454CA17AF,0x65BEEE6E},{1,0,0x3033840000},{0x22796B6AA0F775B2,0x5D0E92AEB29F3DE,0xA421266CF},{0xFF5BD978C88897ED,0xEE4919C8579F95D,0x2E3D82732C},{0x6BCD247A2080C0E,0x99B76A7EFDB0D4DD,0x2CF59414C6},{0xF3EE38C2DC1CDE4B,0x194353EA47E2F858,0x3AAC46E8C1},{0x27BEC889E08C5BBF,0xFF9933AE18F70B4C,0x1285E401FB},{0xB50A3DFABEEAA810,0x8E43E9C257D063EC,0x20264BA44F},{0xA6FA91147A8C6BA6,0x14D99368FF140A8B,0x3CA4538A},{0x7ACD1F78E7C228D4,0x474794EFA03BA1A,0xEEE6C4001},{0x8B364C558B51A26C,0x212E5F238F285721,0x13B150E440},{0xA0DFD2A5D1590B33,0x94498ADB6AD47DE6,0x47FC51D54},{0xDC9462028AE2CA54,0x52D07BF52B5B263E,0x39A6923113},{0x1D06AAA8F434C5BB,0x9B947DC5675D75E8,0x29D50FFFF7},{0x51606F70BBC686CD,0xAB12BDA3C0CD3934,0x19A20941B3},{0x9CDC5A9357F41F2D,0x17BB0EF7993D8DDC,0x26DC088A6E},{0xB7B856CBB1343144,0xE67A5AF691E91CA6,0x358CB2A4A6},{0xEF825C2D264CAF7D,0xFE68A8FE824A6E20,0x36C09C71E5},{0x74601C23750CE1EB,0x28E2E69498336C51,0x1AD61F6EEB},{0x84440D15355804C4,0x42F3E34120124F3A,0xAB12A7873},{0xC828CADA40B18BD9,0xEC09BC13453CE19D,0x2F0DDE542D},{0x98015ECED44D9217,0x189C739BE1CFCFC4,0x1FB6CEFBCA},{0xA9B3CAA86B859EBF,0x360461C284290FBA,0x231379D388},{0x9C8789798F9E45F5,0xA68E2550B652834B,0x26948E8A96},{0xCB2C136039F1E6FB,0xB37D0BE0E9CC11AD,0x7D55AF0A5},{0x567D9FF09D2E4358,0xA4EF65EC6BCA6CB5,0x2919A36621},{0xDFEF0550706A6D68,0x8617A104EE462A18,6064},{0xD13454CA17AEE7BF,0x65BEEE6ED136},{0xB7EB212CD0915E74,111870},{1,0,0x30A40E0000},{0x6B6AA0F775B1A1BD,0xE92AEB29F3DE2279,0x3537C305D0},{0xD978C88897EC498A,0x919C8579F95DFF5B,0x2AB4720EE4},{0xD247A2080C0DCF0A,0x6A7EFDB0D4DD06BC,0xFAD0C99B7},{0x38C2DC1CDE4A5666,0x53EA47E2F858F3EE,0x23AB8B1943},{0xC889E08C5BBE8F90,0x33AE18F70B4C27BE,0xFCFEFFF99},{0x3DFABEEAA80FB408,0xE9C257D063ECB50A,0x32A8878E43},{0x91147A8C6BA5B331,0x9368FF140A8BA6FA,0x1B1E6214D9},{0x1F78E7C228D3603C,0x794EFA03BA1A7ACD,0xACBF70474},{0x4C558B51A26B8A71,0x5F238F2857218B36,0x111F78212E},{0xD2A5D1590B321B85,0x8ADB6AD47DE6A0DF,0x308AA09449},{0x62028AE2CA531D16,0x7BF52B5B263EDC94,0x2292C552D0},{0xAAA8F434C5BA62B0,0x7DC5675D75E81D06,0x45D099B94},{0x6F70BBC686CCDB94,0xBDA3C0CD39345160,0x2B8D8DAB12},{0x5A9357F41F2CEAFB,0xEF7993D8DDC9CDC,0x1C7CF217BB},{0x56CBB13431435D8A,0x5AF691E91CA6B7B8,0x185E3AE67A},{0x5C2D264CAF7C2B90,0xA8FE824A6E20EF82,0x34D455FE68},{0x1C23750CE1EAA8AE,0xE69498336C517460,0x38C8D728E2},{0xD15355804C3DAFF,0xE34120124F3A8444,0x2443B42F3},{0xCADA40B18BD8E3E6,0xBC13453CE19DC828,0x246D3DEC09},{0x5ECED44D921667E4,0x739BE1CFCFC49801,0x1052E189C},{0xCAA86B859EBE7B7A,0x61C284290FBAA9B3,0x21188C3604},{0x89798F9E45F4EE8F,0x2550B652834B9C87,0x1D1D58A68E},{0x136039F1E6FA8507,0xBE0E9CC11ADCB2C,0x37BD3DB37D},{0x9FF09D2E4357B221,0x65EC6BCA6CB5567D,0x58065A4EF},{0x550706A6D675E0A,0xA104EE462A18DFEF,0x17B08617},{0x54CA17AEE7BEFE85,0x65BEEE6ED136D134},{0x212CD0915E7348EB,0x1B4FEB7EB},{0x54E113B91F745E5B,7},{1,0,0x9FE260000},{0xA0F775B1A1BCED76,0xEB29F3DE22796B6A,0x247166E92A},{0xC88897EC4989E071,0x8579F95DFF5BD978,0x1D9140919C},{0xA2080C0DCF095686,0xFDB0D4DD06BCD247,0x368C396A7E},{0xDC1CDE4A56659B29,0x47E2F858F3EE38C2,0x28890553EA},{0xE08C5BBE8F8FCE1E,0x18F70B4C27BEC889,0x2D3FBF33AE},{0xBEEAA80FB4073E32,0x57D063ECB50A3DFA,0x187245E9C2},{0x7A8C6BA5B3303B42,0xFF140A8BA6FA9114,0x12635F9368},{0xE7C228D3603B9FE0,0xFA03BA1A7ACD1F78,0x8477E794E},{0x8B51A26B8A70E8DA,0x8F2857218B364C55,0x33164A5F23},{0xD1590B321B848672,0x6AD47DE6A0DFD2A5,0x39153B8ADB},{0x8AE2CA531D158C15,0x2B5B263EDC946202,0x2DF62E7BF5},{0xF434C5BA62AF1A90,0x675D75E81D06AAA8,0x2620727DC5},{0xBBC686CCDB93B045,0xC0CD393451606F70,0x39A606BDA3},{0x57F41F2CEAFA7C8D,0x993D8DDC9CDC5A93,0x3968B70EF7},{0xB13431435D898941,0x91E91CA6B7B856CB,0x3B41EA5AF6},{0x264CAF7C2B8F3B92,0x824A6E20EF825C2D,0x2298ECA8FE},{0x750CE1EAA8ADCB3C,0x98336C5174601C23,0xF29C4E694},{0x355804C3DAFE461A,0x20124F3A84440D15,0x47C9BE341},{0x40B18BD8E3E50962,0x453CE19DC828CADA,0x244B4BBC13},{0xD44D921667E33D81,0xE1CFCFC498015ECE,0x2D4A12739B},{0x6B859EBE7B797369,0x84290FBAA9B3CAA8,0x12CAD261C2},{0x8F9E45F4EE8E8586,0xB652834B9C878979,0x345DE02550},{0x39F1E6FA8506D41A,0xE9CC11ADCB2C1360,0x370BCB0BE0},{0x9D2E4357B220C209,0x6BCA6CB5567D9FF0,0x125E565EC},{0x706A6D675E093F43,0xEE462A18DFEF0550,0x2C7465A104},{0x17AEE7BEFE84D32E,0xEE6ED136D13454CA,26046},{0xD0915E7348EAA0D6,0x1B4FEB7EB212C},{0x13B91F745E5A32F1,480481},{1,0,0x9C4920000},{0x75B1A1BCED757DA0,0xF3DE22796B6AA0F7,0x1C6638EB29},{0x97EC4989E0700E09,0xF95DFF5BD978C888,0x292BFA8579},{0xC0DCF095685F1A5,0xD4DD06BCD247A208,0x34D878FDB0},{0xDE4A56659B28583F,0xF858F3EE38C2DC1C,0x3984FA47E2},{0x5BBE8F8FCE1DD3CF,0xB4C27BEC889E08C,0x30850818F7},{0xA80FB4073E319AAC,0x63ECB50A3DFABEEA,0x4AA8C57D0},{0x6BA5B3303B411637,0xA8BA6FA91147A8C,0xDE24FF14},{0x28D3603B9FDF5E07,0xBA1A7ACD1F78E7C2,0x96478FA03},{0xA26B8A70E8D9DAE2,0x57218B364C558B51,0x31797F8F28},{0xB321B848671397A,0x7DE6A0DFD2A5D159,0x1538ED6AD4},{0xCA531D158C14FD37,0x263EDC9462028AE2,0x15C2AF2B5B},{0xC5BA62AF1A8F0D56,0x75E81D06AAA8F434,0x2FC845675D},{0x86CCDB93B0449D99,0x393451606F70BBC6,0xE54E9C0CD},{0x1F2CEAFA7C8C15D5,0x8DDC9CDC5A9357F4,0x36468D993D},{0x31435D89894056AC,0x1CA6B7B856CBB134,0x11546291E9},{0xAF7C2B8F3B916869,0x6E20EF825C2D264C,0xBF90E824A},{0xE1EAA8ADCB3BC89A,0x6C5174601C23750C,0x443549833},{0x4C3DAFE46196432,0x4F3A84440D153558,0xE2CCF2012},{0x8BD8E3E509619311,0xE19DC828CADA40B1,0x306289453C},{0x921667E33D806012,0xCFC498015ECED44D,0x98F73E1CF},{0x9EBE7B797368C6B3,0xFBAA9B3CAA86B85,0x1336268429},{0x45F4EE8E85853851,0x834B9C8789798F9E,0x2F8376B652},{0xE6FA8506D419D324,0x11ADCB2C136039F1,0x2F2172E9CC},{0x4357B220C2087472,0x6CB5567D9FF09D2E,0x1056206BCA},{0x6D675E093F429439,0x2A18DFEF0550706A,0x19CD38EE46},{0xE7BEFE84D32DA8F2,0xD136D13454CA17AE,0x65BEEE6E},{0x5E7348EAA0D5133E,0xB4FEB7EB212CD091,1},{0x1F745E5A32F0AD4C,0x754E113B9},{0x7D228322BAF5244A,31},{1,0,0x33B8420000},{0xA1BCED757D9F56E2,0x22796B6AA0F775B1,0x15E2AFF3DE},{0x4989E0700E08F749,0xFF5BD978C88897EC,0x337631F95D},{0xCF095685F1A41E8C,0x6BCD247A2080C0D,0x14B600D4DD},{0x56659B28583E904E,0xF3EE38C2DC1CDE4A,0x11BB34F858},{0x8F8FCE1DD3CEC609,0x27BEC889E08C5BBE,0x371CD90B4C},{0xB4073E319AABE8D1,0xB50A3DFABEEAA80F,0x2083EC63EC},{0xB3303B41163656B1,0xA6FA91147A8C6BA5,0x62A500A8B},{0x603B9FDF5E06289C,0x7ACD1F78E7C228D3,0x7CF5DBA1A},{0x8A70E8D9DAE1DA3D,0x8B364C558B51A26B,0x35B2865721},{0x1B84867139797707,0xA0DFD2A5D1590B32,0xEA2D87DE6},{0x1D158C14FD36D76F,0xDC9462028AE2CA53,0x360B09263E},{0x62AF1A8F0D554245,0x1D06AAA8F434C5BA,0xC2E6375E8},{0xDB93B0449D988CBF,0x51606F70BBC686CC,0x335D8B3934},{0xEAFA7C8C15D4B24D,0x9CDC5A9357F41F2C,0x26D1258DDC},{0x5D89894056ABBE3E,0xB7B856CBB1343143,0x7AB1D1CA6},{0x2B8F3B9168681B16,0xEF825C2D264CAF7C,0x12F7126E20},{0xA8ADCB3BC8998A7E,0x74601C23750CE1EA,0xD9FDD6C51},{0xDAFE46196431D576,0x84440D15355804C3,0x24BC884F3A},{0xE3E5096193108B4D,0xC828CADA40B18BD8,0x2DC5E6E19D},{0x67E33D80601123E0,0x98015ECED44D9216,0x2B75F9CFC4},{0x7B797368C6B20FA3,0xA9B3CAA86B859EBE,0x119ACB0FBA},{0xEE8E8585385014D5,0x9C8789798F9E45F4,0x2876E8834B},{0x8506D419D3234870,0xCB2C136039F1E6FA,0x2A389411AD},{0xB220C20874714A11,0x567D9FF09D2E4357,0x5CAA66CB5},{0x5E093F429438A930,0xDFEF0550706A6D67,0xCC35C2A18},{0xFE84D32DA8F13373,0xD13454CA17AEE7BE,0x3B4E66D136},{0x48EAA0D5133D4606,0xB7EB212CD0915E73,111870},{0x5E5A32F0AD4BCE0F,0x754E113B91F74},{0x8322BAF524497E40,0x1F7D22},{1,0,0x1C452C0000},{0xED757D9F56E1A7EB,0x6B6AA0F775B1A1BC,0x1562A82279},{0xE0700E08F74849D5,0xD978C88897EC4989,0x2BF6A1FF5B},{0x5685F1A41E8BA048,0xD247A2080C0DCF09,0x37771F06BC},{0x9B28583E904D1BBE,0x38C2DC1CDE4A5665,0x2C6B92F3EE},{0xCE1DD3CEC608ECF8,0xC889E08C5BBE8F8F,0x2627A27BE},{0x3E319AABE8D0D25E,0x3DFABEEAA80FB407,0x3A56F0B50A},{0x3B41163656B012E0,0x91147A8C6BA5B330,0x2FC247A6FA},{0x9FDF5E06289B559A,0x1F78E7C228D3603B,0xCA46C7ACD},{0xE8D9DAE1DA3C3261,0x4C558B51A26B8A70,0x341CE18B36},{0x8671397977061F98,0xD2A5D1590B321B84,0x228C4EA0DF},{0x8C14FD36D76E05A6,0x62028AE2CA531D15,0x18D5CDC94},{0x1A8F0D554244C5A8,0xAAA8F434C5BA62AF,0x1673FE1D06},{0xB0449D988CBEF908,0x6F70BBC686CCDB93,0x334E1C5160},{0x7C8C15D4B24C0DB4,0x5A9357F41F2CEAFA,0x2AEB769CDC},{0x894056ABBE3D4D6C,0x56CBB13431435D89,0x1E5A10B7B8},{0x3B9168681B15434C,0x5C2D264CAF7C2B8F,0x166098EF82},{0xCB3BC8998A7D960C,0x1C23750CE1EAA8AD,0xFD8297460},{0x46196431D57561DE,0xD15355804C3DAFE,0x97F6A8444},{0x96193108B4C1C2F,0xCADA40B18BD8E3E5,0x51ADC828},{0x3D80601123DF543C,0x5ECED44D921667E3,0x29DC6A9801},{0x7368C6B20FA2933A,0xCAA86B859EBE7B79,0x1F8EA2A9B3},{0x8585385014D4D9E2,0x89798F9E45F4EE8E,0xA431D9C87},{0xD419D323486FF678,0x136039F1E6FA8506,0x1D3FD1CB2C},{0xC20874714A10D2C5,0x9FF09D2E4357B220,0x37A6BF567D},{0x3F429438A92F9937,0x550706A6D675E09,0xC2F2EDFEF},{0xD32DA8F1337226DF,0x54CA17AEE7BEFE84,0x36BED0D134},{0xA0D5133D46052999,0x212CD0915E7348EA,0x1B4FEB7EB},{0x32F0AD4BCE0E56E1,0x54E113B91F745E5A,7},{0xBAF524497E3FF3E1,0x1F7D228322},{0x3E4F75E2224E685B,135},{1,0,0x18D3920000},{0x7D9F56E1A7EA032E,0xA0F775B1A1BCED75,0x1C1F3F6B6A},{0xE08F74849D41E7A,0xC88897EC4989E070,0x10ADA7D978},{0xF1A41E8BA0470D54,0xA2080C0DCF095685,0x2D5E8CD247},{0x583E904D1BBD2234,0xDC1CDE4A56659B28,0x201A1E38C2},{0xD3CEC608ECF73267,0xE08C5BBE8F8FCE1D,0x3A619CC889},{0x9AABE8D0D25D15E8,0xBEEAA80FB4073E31,0x4C4A03DFA},{0x163656B012DFFC72,0x7A8C6BA5B3303B41,0x1C26849114},{0x5E06289B559911A4,0xE7C228D3603B9FDF,0x13EAD51F78},{0xDAE1DA3C3260FDDE,0x8B51A26B8A70E8D9,0x269B824C55},{0x397977061F97EE42,0xD1590B321B848671,0x978BD2A5},{0xFD36D76E05A5FA73,0x8AE2CA531D158C14,0x2756706202},{0xD554244C5A7CE33,0xF434C5BA62AF1A8F,0x1A3F70AAA8},{0x9D988CBEF907A59D,0xBBC686CCDB93B044,0x224E5C6F70},{0x15D4B24C0DB33059,0x57F41F2CEAFA7C8C,0x2F6D005A93},{0x56ABBE3D4D6B6667,0xB13431435D898940,0xA832056CB},{0x68681B15434BDB26,0x264CAF7C2B8F3B91,0x8416A5C2D},{0xC8998A7D960BEC89,0x750CE1EAA8ADCB3B,0x4F01E1C23},{0x6431D57561DD7DF4,0x355804C3DAFE4619,0x32D0E00D15},{0x93108B4C1C2EF72F,0x40B18BD8E3E50961,0x3027FCCADA},{0x601123DF543B3D9A,0xD44D921667E33D80,0x27369D5ECE},{0xC6B20FA29339AD96,0x6B859EBE7B797368,0x1C4D99CAA8},{0x385014D4D9E1CB6D,0x8F9E45F4EE8E8585,0x1667898979},{0xD323486FF677328D,0x39F1E6FA8506D419,0x3805B61360},{0x74714A10D2C43481,0x9D2E4357B220C208,0x12BA8B9FF0},{0x9438A92F993683CF,0x706A6D675E093F42,0x2F0DA70550},{0xA8F1337226DE2F1F,0x17AEE7BEFE84D32D,0xA6F2A54CA},{0x133D46052998526A,0xD0915E7348EAA0D5,0x3467A3212C},{0xAD4BCE0E56E05068,0x13B91F745E5A32F0,480481},{0x24497E3FF3E00C58,0x1F7D228322BAF5},{0x75E2224E685A7745,0x873E4F},{1,0,0x399DC00000},{0x56E1A7EA032D4AD6,0x75B1A1BCED757D9F,0x1FCD9AA0F7},{0xF74849D41E794511,0x97EC4989E0700E08,0x1DFA4C888},{0x1E8BA0470D53578E,0xC0DCF095685F1A4,0x6B8AFA208},{0x904D1BBD2233430F,0xDE4A56659B28583E,0x20AE02DC1C},{0xC608ECF73266FBBD,0x5BBE8F8FCE1DD3CE,0x36A29DE08C},{0xE8D0D25D15E74387,0xA80FB4073E319AAB,0x20B1B6BEEA},{0x56B012DFFC71C668,0x6BA5B3303B411636,0x2D34CE7A8C},{0x289B559911A38070,0x28D3603B9FDF5E06,0x1301CAE7C2},{0xDA3C3260FDDDA8F6,0xA26B8A70E8D9DAE1,0x14BB6B8B51},{0x77061F97EE4109CB,0xB321B8486713979,0x34CDC1D159},{0xD76E05A5FA72F687,0xCA531D158C14FD36,0xC497A8AE2},{0x4244C5A7CE323746,0xC5BA62AF1A8F0D55,0x2E391AF434},{0x8CBEF907A59CB0AE,0x86CCDB93B0449D98,0x38D6CABBC6},{0xB24C0DB33058F04A,0x1F2CEAFA7C8C15D4,0xC26E957F4},{0xBE3D4D6B6666DD5F,0x31435D89894056AB,0x11DACFB134},{0x1B15434BDB2563D4,0xAF7C2B8F3B916868,0x2FFDB264C},{0x8A7D960BEC88F427,0xE1EAA8ADCB3BC899,0x147E51750C},{0xD57561DD7DF33154,0x4C3DAFE46196431,0x2956953558},{0x8B4C1C2EF72E1EB9,0x8BD8E3E509619310,0x120F9240B1},{0x23DF543B3D9935DC,0x921667E33D806011,0x1F1C60D44D},{0xFA29339AD953ED8,0x9EBE7B797368C6B2,0x24D9D26B85},{0x14D4D9E1CB6CA21C,0x45F4EE8E85853850,0x38527F8F9E},{0x486FF677328C887D,0xE6FA8506D419D323,0xAC57E39F1},{0x4A10D2C4348044E4,0x4357B220C2087471,0x18C7909D2E},{0xA92F993683CE2E92,0x6D675E093F429438,0x28B92A706A},{0x337226DE2F1E19B8,0xE7BEFE84D32DA8F1,0x21D8AA17AE},{0x460529985269CCC6,0x5E7348EAA0D5133D,0x2B1A2ED091},{0xCE0E56E050674140,0x1F745E5A32F0AD4B,0x754E113B9},{0x7E3FF3E00C57550F,0x7D228322BAF52449,31},{0x224E685A7744A6E9,0x873E4F75E2},{0xDDB0DB666656F88D,580},{1,0,0x295BAE0000},{0xA7EA032D4AD5AB07,0xA1BCED757D9F56E1,0x3703D175B1},{0x49D41E7945106308,0x4989E0700E08F748,0x3371097EC},{0xA0470D53578DD4E8,0xCF095685F1A41E8B,0x114EDC0C0D},{0x1BBD2233430E2AEC,0x56659B28583E904D,0x2C5E4EDE4A},{0xECF73266FBBC7A4A,0x8F8FCE1DD3CEC608,0x3A7FC5BBE},{0xD25D15E74386EA22,0xB4073E319AABE8D0,0x26947CA80F},{0x12DFFC71C667F233,0xB3303B41163656B0,0x3136FC6BA5},{0x559911A3806F8F26,0x603B9FDF5E06289B,0x1909EE28D3},{0x3260FDDDA8F54475,0x8A70E8D9DAE1DA3C,0xBAAA3A26B},{0x1F97EE4109CAFBCD,0x1B84867139797706,0x1359F50B32},{0x5A5FA72F686272F,0x1D158C14FD36D76E,0x2B6570CA53},{0xC5A7CE323745E0C2,0x62AF1A8F0D554244,0x2FB278C5BA},{0xF907A59CB0AD0FF8,0xDB93B0449D988CBE,0xA755086CC},{0xDB33058F0496BCC,0xEAFA7C8C15D4B24C,0xFAF4A1F2C},{0x4D6B6666DD5ED301,0x5D89894056ABBE3D,0x1CE91E3143},{0x434BDB2563D3EF40,0x2B8F3B9168681B15,0x36A2C2AF7C},{0x960BEC88F426B2D6,0xA8ADCB3BC8998A7D,0x2D99E4E1EA},{0x61DD7DF33153FC0E,0xDAFE46196431D575,0x327FAA04C3},{0x1C2EF72E1EB8EC53,0xE3E5096193108B4C,0x5377D8BD8},{0x543B3D9935DBDF18,0x67E33D80601123DF,0x2C59A19216},{0x9339AD953ED7880F,0x7B797368C6B20FA2,0x3907139EBE},{0xD9E1CB6CA21BF25D,0xEE8E8585385014D4,0x3A542245F4},{0xF677328C887CF566,0x8506D419D323486F,0x146B13E6FA},{0xD2C4348044E3FBDA,0xB220C20874714A10,0x18112C4357},{0x993683CE2E915C7A,0x5E093F429438A92F,0x2C78246D67},{0x26DE2F1E19B782B1,0xFE84D32DA8F13372,0x1AD782E7BE},{0x29985269CCC580FF,0x48EAA0D5133D4605,0x1B181B5E73},{0x56E05067413F5609,0x5E5A32F0AD4BCE0E,0x809171F74},{0xF3E00C57550E0C52,0x8322BAF524497E3F,0x1F7D22},{0x685A7744A6E804A3,0x873E4F75E2224E},{0xDB666656F88C4021,0x244DDB0},{1,0,0x2BFCF60000},{0x32D4AD5AB06983A,0xED757D9F56E1A7EA,0x201A17A1BC},{0x1E7945106307C35C,0xE0700E08F74849D4,0x22C964989},{0xD53578DD4E72FB8,0x5685F1A41E8BA047,0x17A831CF09},{0x2233430E2AEBCB3F,0x9B28583E904D1BBD,0x217B745665},{0x3266FBBC7A49AA4D,0xCE1DD3CEC608ECF7,0x1AFB68F8F},{0x15E74386EA215683,0x3E319AABE8D0D25D,0xB3AD1B407},{0xFC71C667F2321B3D,0x3B41163656B012DF,0xDE1E5B330},{0x11A3806F8F25791D,0x9FDF5E06289B5599,0x1A49EF603B},{0xFDDDA8F544743EE2,0xE8D9DAE1DA3C3260,0x1EDB1D8A70},{0xEE4109CAFBCC06AF,0x8671397977061F97,0x504501B84},{0xFA72F686272E0DC5,0x8C14FD36D76E05A5,0x28C4FF1D15},{0xCE323745E0C19AF4,0x1A8F0D554244C5A7,0x2262EC62AF},{0xA59CB0AD0FF78E1F,0xB0449D988CBEF907,0x3A5228DB93},{0x3058F0496BCB8B9A,0x7C8C15D4B24C0DB3,0x2005CAEAFA},{0x6666DD5ED300CD47,0x894056ABBE3D4D6B,0x2159555D89},{0xDB2563D3EF3FD56D,0x3B9168681B15434B,0x2876EC2B8F},{0xEC88F426B2D5CC61,0xCB3BC8998A7D960B,0x3B33E6A8AD},{0x7DF33153FC0D46A4,0x46196431D57561DD,0x3553A5DAFE},{0xF72E1EB8EC52EE7F,0x96193108B4C1C2E,0x34E892E3E5},{0x3D9935DBDF1788D1,0x3D80601123DF543B,0x1C470867E3},{0xAD953ED7880E4DA9,0x7368C6B20FA29339,0x212EF27B79},{0xCB6CA21BF25CD7E0,0x8585385014D4D9E1,0x19702EE8E},{0x328C887CF565951F,0xD419D323486FF677,0x7A0868506},{0x348044E3FBD98A69,0xC20874714A10D2C4,0x2272BB220},{0x83CE2E915C793CB6,0x3F429438A92F9936,0x1EECFB5E09},{0x2F1E19B782B0DD81,0xD32DA8F1337226DE,0x36A0EEFE84},{0x5269CCC580FE85BC,0xA0D5133D46052998,0x15004748EA},{0x5067413F5608F96F,0x32F0AD4BCE0E56E0,0x816165E5A},{0xC57550E0C51663C,0xBAF524497E3FF3E0,0x1F7D228322},{0x7744A6E804A291CD,0x3E4F75E2224E685A,135},{0x6656F88C402026E8,0x244DDB0DB66},{0xCCE62836AC5774EF,2494},{1,0,0x1B5AFE0000},{0x4AD5AB069839610F,0x7D9F56E1A7EA032D,0x1A16FCED75},{0x45106307C35B386C,0xE08F74849D41E79,0x1F2FADE070},{0x578DD4E72FB75FC1,0xF1A41E8BA0470D53,0x964BB5685},{0x430E2AEBCB3EF5D3,0x583E904D1BBD2233,0x6F1D99B28},{0xFBBC7A49AA4C5975,0xD3CEC608ECF73266,0xB8CA3CE1D},{0x4386EA215682BC3A,0x9AABE8D0D25D15E7,0xF27793E31},{0xC667F2321B3CB6BD,0x163656B012DFFC71,0x3401BA3B41},{0x806F8F25791C4C68,0x5E06289B559911A3,0x32B92B9FDF},{0xA8F544743EE1A847,0xDAE1DA3C3260FDDD,0x1A5CB4E8D9},{0x9CAFBCC06AEADFF,0x397977061F97EE41,0x4E30C8671},{0xF686272E0DC4D294,0xFD36D76E05A5FA72,0x214E918C14},{0x3745E0C19AF3BBD8,0xD554244C5A7CE32,0xFF9CF1A8F},{0xB0AD0FF78E1E947B,0x9D988CBEF907A59C,0x209DBBB044},{0xF0496BCB8B99EB44,0x15D4B24C0DB33058,0xEFAE07C8C},{0xDD5ED300CD46BBBF,0x56ABBE3D4D6B6666,0x21DAFB8940},{0x63D3EF3FD56CC3FD,0x68681B15434BDB25,0xDEB613B91},{0xF426B2D5CC60B566,0xC8998A7D960BEC88,0x5E971CB3B},{0x3153FC0D46A3B494,0x6431D57561DD7DF3,0x16B7E44619},{0x1EB8EC52EE7E2B40,0x93108B4C1C2EF72E,0x1DE3C30961},{0x35DBDF1788D07D9C,0x601123DF543B3D99,0x1865253D80},{0x3ED7880E4DA8A673,0xC6B20FA29339AD95,0x1F04877368},{0xA21BF25CD7DF13A3,0x385014D4D9E1CB6C,0x603468585},{0x887CF565951EBFC9,0xD323486FF677328C,0x1F7F2D419},{0x44E3FBD98A685448,0x74714A10D2C43480,0xF806AC208},{0x2E915C793CB55EC6,0x9438A92F993683CE,0xAA18B3F42},{0x19B782B0DD803F1F,0xA8F1337226DE2F1E,0x319C44D32D},{0xCCC580FE85BB90A5,0x133D460529985269,0x380976A0D5},{0x413F5608F96E19CD,0xAD4BCE0E56E05067,0x39139632F0},{0x550E0C51663B0C5B,0x24497E3FF3E00C57,0x128036BAF5},{0xA6E804A291CC35EE,0x75E2224E685A7744,0x873E4F},{0xF88C402026E7087F,0x244DDB0DB666656},{0x2836AC5774EE3680,0x9BECCE6},{1,0,0x25195E0000},{0xAB069839610E7C8A,0x56E1A7EA032D4AD5,0x216697D9F},{0x6307C35B386B12A4,0xF74849D41E794510,0x2636460E08},{0xD4E72FB75FC0F1D3,0x1E8BA0470D53578D,0xE9115F1A4},{0x2AEBCB3EF5D2FF36,0x904D1BBD2233430E,0x3024AA583E},{0x7A49AA4C597403C9,0xC608ECF73266FBBC,0x280699D3CE},{0xEA215682BC399CB9,0xE8D0D25D15E74386,0xCA6D59AAB},{0xF2321B3CB6BCC241,0x56B012DFFC71C667,0x16F151636},{0x8F25791C4C6755DC,0x289B559911A3806F,0x3495DB5E06},{0x44743EE1A8463D17,0xDA3C3260FDDDA8F5,0x1C47DFDAE1},{0xFBCC06AEADFEE2C0,0x77061F97EE4109CA,0xCC4CF3979},{0x272E0DC4D293B91A,0xD76E05A5FA72F686,0x13D9D2FD36},{0xE0C19AF3BBD7CACB,0x4244C5A7CE323745,0x2384AD0D55},{0xFF78E1E947A2CB0,0x8CBEF907A59CB0AD,0x3185B29D98},{0x6BCB8B99EB439718,0xB24C0DB33058F049,0x27FCB015D4},{0xD300CD46BBBE0500,0xBE3D4D6B6666DD5E,0x183D3056AB},{0xEF3FD56CC3FC0476,0x1B15434BDB2563D3,0x23BFC16868},{0xB2D5CC60B5658BBE,0x8A7D960BEC88F426,0xB9A53C899},{0xFC0D46A3B49382D8,0xD57561DD7DF33153,0x3DA1B6431},{0xEC52EE7E2B3FCC84,0x8B4C1C2EF72E1EB8,0x3FDA19310},{0xDF1788D07D9B96ED,0x23DF543B3D9935DB,0x2975446011},{0x880E4DA8A6724000,0xFA29339AD953ED7,0x12A538C6B2},{0xF25CD7DF13A29519,0x14D4D9E1CB6CA21B,0x837073850},{0xF565951EBFC881D8,0x486FF677328C887C,0x1A6091D323},{0xFBD98A685447DAA8,0x4A10D2C4348044E3,0xD31407471},{0x5C793CB55EC511B3,0xA92F993683CE2E91,0x3828B29438},{0x82B0DD803F1EAF7D,0x337226DE2F1E19B7,0xE442FA8F1},{0x80FE85BB90A43F33,0x460529985269CCC5,0x11A653133D},{0x5608F96E19CC7B17,0xCE0E56E05067413F,0x111C88AD4B},{0xC51663B0C5AE5F8,0x7E3FF3E00C57550E,0x34A6A32449},{0x4A291CC35EDDFD0,0x224E685A7744A6E8,0x1008BB75E2},{0x402026E7087E866F,0xDDB0DB666656F88C,580},{0xAC5774EE367F9431,0x9BECCE62836},{0x1608CE3B49886BCB,10715},{1,0,0x348A240000},{0x9839610E7C895746,0xA7EA032D4AD5AB06,0x10D4B956E1},{0xC35B386B12A37DD4,0x49D41E7945106307,0x20825CF748},{0x2FB75FC0F1D2752A,0xA0470D53578DD4E7,0x11F4041E8B},{0xCB3EF5D2FF35A10C,0x1BBD2233430E2AEB,0x21402904D},{0xAA4C597403C835CF,0xECF73266FBBC7A49,0x309EBEC608},{0x5682BC399CB8E416,0xD25D15E74386EA21,0x28FECFE8D0},{0x1B3CB6BCC240D017,0x12DFFC71C667F232,0x242AA656B0},{0x791C4C6755DB3D34,0x559911A3806F8F25,0xE0402289B},{0x3EE1A8463D16404B,0x3260FDDDA8F54474,0x16CFBDA3C},{0x6AEADFEE2BF7E87,0x1F97EE4109CAFBCC,0x199DD37706},{0xDC4D293B919082D,0x5A5FA72F686272E,0x100322D76E},{0x9AF3BBD7CACA0481,0xC5A7CE323745E0C1,0x2C76DD4244},{0x8E1E947A2CAF8230,0xF907A59CB0AD0FF7,0x11B5248CBE},{0x8B99EB4397173DF2,0xDB33058F0496BCB,0xE45E8B24C},{0xCD46BBBE04FFE34E,0x4D6B6666DD5ED300,0x4F35DBE3D},{0xD56CC3FC0475FCBB,0x434BDB2563D3EF3F,0x1D3D841B15},{0xCC60B5658BBD1598,0x960BEC88F426B2D5,0x1B54878A7D},{0x46A3B49382D73B5C,0x61DD7DF33153FC0D,0x11B883D575},{0xEE7E2B3FCC83A0A1,0x1C2EF72E1EB8EC52,0x33FF728B4C},{0x88D07D9B96ECF15A,0x543B3D9935DBDF17,0x25DA3B23DF},{0x4DA8A6723FFF505F,0x9339AD953ED7880E,0x318EEA0FA2},{0xD7DF13A295189C30,0xD9E1CB6CA21BF25C,0x1A118014D4},{0x951EBFC881D7E2FB,0xF677328C887CF565,0x3EABF486F},{0x8A685447DAA72178,0xD2C4348044E3FBD9,0xB15174A10},{0x3CB55EC511B2B120,0x993683CE2E915C79,0x1A93FAA92F},{0xDD803F1EAF7C0FED,0x26DE2F1E19B782B0,0x133B53372},{0x85BB90A43F3274BA,0x29985269CCC580FE,0x356B14605},{0xF96E19CC7B1670E5,0x56E05067413F5608,0xEE3DFCE0E},{0x663B0C5AE5F77B82,0xF3E00C57550E0C51,0x1241757E3F},{0x91CC35EDDFCF0997,0x685A7744A6E804A2,0x292D80224E},{0x26E7087E866EAA71,0xDB666656F88C4020,0x244DDB0},{0x74EE367F9430AEC4,0x9BECCE62836AC57},{0xCE3B49886BCABCAF,0x29DB1608},{1,0,0x367C3A0000},{0x610E7C895745FBD2,0x32D4AD5AB069839,0x316347A7EA},{0x386B12A37DD3B17C,0x1E7945106307C35B,0x108B0849D4},{0x5FC0F1D27529582B,0xD53578DD4E72FB7,0x2C093DA047},{0xF5D2FF35A10BECCB,0x2233430E2AEBCB3E,0x398E151BBD},{0x597403C835CEC08E,0x3266FBBC7A49AA4C,0x15AC54ECF7},{0xBC399CB8E41556AB,0x15E74386EA215682,0x34269CD25D},{0xB6BCC240D016F615,0xFC71C667F2321B3C,0x23A39E12DF},{0x4C6755DB3D33D7F8,0x11A3806F8F25791C,0x1695275599},{0xA8463D16404A362C,0xFDDDA8F544743EE1,0x235FC63260},{0xADFEE2BF7E869D62,0xEE4109CAFBCC06AE,0x26A5141F97},{0xD293B919082C552D,0xFA72F686272E0DC4,0x2711FC05A5},{0xBBD7CACA04807A9C,0xCE323745E0C19AF3,0x1C7CAC5A7},{0x947A2CAF822FAF35,0xA59CB0AD0FF78E1E,0x29B87CF907},{0xEB4397173DF121A5,0x3058F0496BCB8B99,0x19018A0DB3},{0xBBBE04FFE34DD889,0x6666DD5ED300CD46,0x11A95F4D6B},{0xC3FC0475FCBA1873,0xDB2563D3EF3FD56C,0x2C6B9434B},{0xB5658BBD15972099,0xEC88F426B2D5CC60,0x3391F3960B},{0xB49382D73B5B2759,0x7DF33153FC0D46A3,0xAEF5D61DD},{0x2B3FCC83A0A0A28E,0xF72E1EB8EC52EE7E,0xDCB041C2E},{0x7D9B96ECF15998A2,0x3D9935DBDF1788D0,0xD6DE1543B},{0xA6723FFF505E84FE,0xAD953ED7880E4DA8,0x3492689339},{0x13A295189C2F3155,0xCB6CA21BF25CD7DF,0x1BC0B8D9E1},{0xBFC881D7E2FA5436,0x328C887CF565951E,0x2DAEBBF677},{0x5447DAA7217750F8,0x348044E3FBD98A68,0xCB156D2C4},{0x5EC511B2B11FB126,0x83CE2E915C793CB5,0x33BB339936},{0x3F1EAF7C0FECE459,0x2F1E19B782B0DD80,0x23771826DE},{0x90A43F3274B915E2,0x5269CCC580FE85BB,0x343A292998},{0x19CC7B1670E45A0A,0x5067413F5608F96E,0x342A5056E0},{0xC5AE5F77B81C16C,0xC57550E0C51663B,0x15102FF3E0},{0x35EDDFCF0996D779,0x7744A6E804A291CC,0x17D780685A},{0x87E866EAA70E7B5,0x6656F88C402026E7,0x2C6C96DB66},{0x367F9430AEC32BF0,0xCCE62836AC5774EE,2494},{0x49886BCABCAE02BE,0x29DB1608CE3B},{0xF1BA87BC86968F49,46020},{1,0,0xA8BA20000},{0x7C895745FBD18BE9,0x4AD5AB069839610E,0x1C3C3E032D},{0x12A37DD3B17BCF2F,0x45106307C35B386B,0x1367921E79},{0xF1D27529582AA77B,0x578DD4E72FB75FC0,0xBEF730D53},{0xFF35A10BECCA36FF,0x430E2AEBCB3EF5D2,0x17FA492233},{0x3C835CEC08DB159,0xFBBC7A49AA4C5974,0x35D8653266},{0x9CB8E41556AA411C,0x4386EA215682BC39,0x1A7D8515E7},{0xC240D016F6149185,0xC667F2321B3CB6BC,0x261175FC71},{0x55DB3D33D7F74520,0x806F8F25791C4C67,0x339BF711A3},{0x3D16404A362BCC6A,0xA8F544743EE1A846,0xF2494FDDD},{0xE2BF7E869D610340,0x9CAFBCC06AEADFE,0x1AC453EE41},{0xB919082C552C95B0,0xF686272E0DC4D293,0xBB119FA72},{0xCACA04807A9BC215,0x3745E0C19AF3BBD7,0x247B75CE32},{0x2CAF822FAF340CC7,0xB0AD0FF78E1E947A,0x14B527A59C},{0x97173DF121A4E393,0xF0496BCB8B99EB43,0x17F3373058},{0x4FFE34DD888ED66,0xDD5ED300CD46BBBE,0x8B49D6666},{0x475FCBA18724AE5,0x63D3EF3FD56CC3FC,0x1FE313DB25},{0x8BBD159720986DD4,0xF426B2D5CC60B565,0x389F69EC88},{0x82D73B5B2758E63F,0x3153FC0D46A3B493,0xABCF77DF3},{0xCC83A0A0A28DDC38,0x1EB8EC52EE7E2B3F,0x23AC0CF72E},{0x96ECF15998A10A10,0x35DBDF1788D07D9B,0x22BFB93D99},{0x3FFF505E84FD38C7,0x3ED7880E4DA8A672,0x194B0BAD95},{0x95189C2F31542EE2,0xA21BF25CD7DF13A2,0x20B86DCB6C},{0x81D7E2FA5435EB9C,0x887CF565951EBFC8,0x1DDD6F328C},{0xDAA7217750F77623,0x44E3FBD98A685447,0x3001663480},{0x11B2B11FB1252436,0x2E915C793CB55EC5,0x7022083CE},{0xAF7C0FECE458897B,0x19B782B0DD803F1E,0x18A22A2F1E},{0x3F3274B915E10155,0xCCC580FE85BB90A4,0x180A785269},{0x7B1670E45A0927CC,0x413F5608F96E19CC,0x1455685067},{0xE5F77B81C16B2ED8,0x550E0C51663B0C5A,0xFFBFA0C57},{0xDFCF0996D778CB29,0xA6E804A291CC35ED,0x143FDE7744},{0x866EAA70E7B457F6,0xF88C402026E7087E,0x35966E6656},{0x9430AEC32BEFA783,0x2836AC5774EE367F,0x9BECCE6},{0x6BCABCAE02BDBC94,0x29DB1608CE3B4988},{0x87BC86968F48A48A,0xB3C4F1BA},{1,0,0x31BF9C0000},{0x5745FBD18BE819F5,0xAB069839610E7C89,0x3D0BB4AD5},{0x7DD3B17BCF2E3F01,0x6307C35B386B12A3,0x2105D34510},{0x7529582AA77ABCBD,0xD4E72FB75FC0F1D2,0x34C75578D},{0xA10BECCA36FEB44B,0x2AEBCB3EF5D2FF35,0x2BE225430E},{0x35CEC08DB158AB72,0x7A49AA4C597403C8,0x1F6988FBBC},{0xE41556AA411B1983,0xEA215682BC399CB8,0x1833AB4386},{0xD016F6149184A517,0xF2321B3CB6BCC240,0x19F971C667},{0x3D33D7F7451F88F9,0x8F25791C4C6755DB,0x391B13806F},{0x404A362BCC69830A,0x44743EE1A8463D16,0x2F42C3A8F5},{0x7E869D61033FD137,0xFBCC06AEADFEE2BF,0x1F3C2509CA},{0x82C552C95AF4069,0x272E0DC4D293B919,0x10450CF686},{0x4807A9BC2144D53,0xE0C19AF3BBD7CACA,0x284B523745},{0x822FAF340CC66497,0xFF78E1E947A2CAF,0x11183CB0AD},{0x3DF121A4E3922189,0x6BCB8B99EB439717,0x1613F6F049},{0xE34DD888ED650270,0xD300CD46BBBE04FF,0x315848DD5E},{0xFCBA18724AE445F2,0xEF3FD56CC3FC0475,0x9029D63D3},{0x159720986DD388D5,0xB2D5CC60B5658BBD,0x138DDEF426},{0x3B5B2758E63ECC8B,0xFC0D46A3B49382D7,0x2B0E473153},{0xA0A0A28DDC374B28,0xEC52EE7E2B3FCC83,0x33315C1EB8},{0xF15998A10A0F3EAF,0xDF1788D07D9B96EC,0x322EAD35DB},{0x505E84FD38C6031A,0x880E4DA8A6723FFF,0x681C13ED7},{0x9C2F31542EE12970,0xF25CD7DF13A29518,0x1D181CA21B},{0xE2FA5435EB9BD33A,0xF565951EBFC881D7,0x3514E4887C},{0x217750F77622B6B9,0xFBD98A685447DAA7,0x21D83444E3},{0xB11FB12524350F18,0x5C793CB55EC511B2,0x2ABA142E91},{0xFECE458897A0E13,0x82B0DD803F1EAF7C,0x2DFC2619B7},{0x74B915E10154D174,0x80FE85BB90A43F32,0xEBF1FCCC5},{0x70E45A0927CB97E2,0x5608F96E19CC7B16,0x34555413F},{0x7B81C16B2ED736B9,0xC51663B0C5AE5F7,0x36055B550E},{0x996D778CB280D1E,0x4A291CC35EDDFCF,0x20A794A6E8},{0xAA70E7B457F5B30A,0x402026E7087E866E,0xCBAC6F88C},{0xAEC32BEFA7825303,0xAC5774EE367F9430,0x33028C2836},{0xBCAE02BDBC939960,0x1608CE3B49886BCA,10715},{0x86968F48A4899878,0xB3C4F1BA87BC},{0x7353AAFA27E2667C,197658}}};
inline static constexpr std::array<std::uint8_t,69> min_block_2={0,0,0,0,0,0,1,1,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,19,19,20,20,21,21,22,22,23,23,24,24,25,26,26,27,27,28,28,29,29,30,30,31,31,32,32,33,34,0};
inline static constexpr std::array<std::uint16_t,69> offset_2={0,2,6,12,20,29,40,52,66,80,95,112,130,150,170,192,215,240,265,292,320,350,381,413,446,480,516,552,590,629,670,712,755,799,845,892,940,989,1040,1092,1145,1199,1254,1311,1369,1428,1488,1550,1613,1678,1743,1810,1878,1947,2017,2088,2161,2235,2311,2387,2465,2544,2625,2706,2789,2873,2959,3046,3133};
inline static constexpr std::array<std::array<std::uint64_t,3>,3133> split_2={{{0,0,0x3B9ACA},{0,0,0x2F08236400},{0,0x9ACA000000000000,59},{0,0x6400000000000000,0xDE0B6B3A7},{0,0,0x26F9423CE8},{0,0,0x3604471000},{0,0x3B9ACA00000000},{0,0xB3A7640000000000,909494},{0,0x3CE8000000000000,0x2A89DFD080},{0,0x1000000000000000,0x1DDB934B9F},{0,0,0x2508DD22A0},{0,0,0x2540BE4000},{0,0x3B9ACA0000},{0,0xE0B6B3A764000000,13},{0,0xD0803CE800000000,0x33B2E3C9F},{0,0x4B9F100000000000,0x2535AF15B3},{0,0x22A0000000000000,0x29BED6A00B},{0,0x4000000000000000,0x297B67D92},{0,0,0x220D2DE680},{0,0,0x1DCD650000},{0,0x3B9ACA},{0,0xDE0B6B3A76400},{0,0x3C9FD0803CE80000,211758},{0,0x15B34B9F10000000,0xAC3EDC907},{0,0xA00B22A000000000,0x1A648F768},{0,0x7D92400000000000,0x185C2565F6},{0,0xE680000000000000,0x3963FABDCF},{0,0,0x3067D434E1},{0,0,0x34630B8A00},{0x9ACA000000000000,59},{0x6400000000000000,0xDE0B6B3A7},{0,0x3B2E3C9FD0803CE8,3},{0,0xC90715B34B9F1000,0xC097CE7B},{0,0xF768A00B22A00000,0x1CD22D3CE2},{0,0x65F67D9240000000,0x34D841090B},{0,0xBDCFE68000000000,0x2A76423AC},{0,0x34E1000000000000,0x28383166F6},{0,0x8A00000000000000,0x39530DF013},{0,0,0x48C9E6EE4},{0,0,0x3515DBE800},{0xB3A7640000000000,909494},{0x3CE8000000000000,0x33B2E3C9FD080},{0x1000000000000000,0xCE7BC90715B34B9F,49303},{0,0x3CE2F768A00B22A0,0x23586086B9},{0,0x90B65F67D924000,0x2B21091999},{0,0x23ACBDCFE6800000,0x23A19DD27E},{0,0x66F634E100000000,0x1D5E7DCDCF},{0,0xF0138A0000000000,0x304A225589},{0,0x6EE4000000000000,0x201DBBC3FE},{0,0xE800000000000000,0x3B3D6604A7},{0,0,0x2717FE0D10},{0,0,0x3B9ACA000},{0xE0B6B3A764000000,13},{0xD0803CE800000000,0x33B2E3C9F},{0x4B9F100000000000,0xC097CE7BC90715B3},{0x22A0000000000000,0x86B93CE2F768A00B,0x2CD76FE0},{0x4000000000000000,0x1999090B65F67D92,0x3446CEE6C5},{0,0xD27E23ACBDCFE680,0x2DE4133157},{0,0xCDCF66F634E10000,0x14729CFE31},{0,0x5589F0138A000000,0xB988BE7E4},{0,0xC3FE6EE400000000,0x3529C66ACD},{0,0x4A7E80000000000,0x2FE895E744},{0,0xD10000000000000,0xFD6332B26},{0,0xA000000000000000,0x8DC0491EE},{0,0,0x378F288A40},{0,0,0xEE6B28000},{0x3C9FD0803CE80000,211758},{0x15B34B9F10000000,0xC097CE7BC907},{0xA00B22A000000000,0x6FE086B93CE2F768,11479},{0x7D92400000000000,0xE6C51999090B65F6,0x32290C0A64},{0xE680000000000000,0x3157D27E23ACBDCF,0x177E31DD8F},{0,0xFE31CDCF66F634E1,0x2156F3E946},{0,0xE7E45589F0138A00,0x10878268F7},{0,0x6ACDC3FE6EE40000,0x39B856BC0C},{0,0xE74404A7E8000000,0x2E41F7839},{0,0x2B260D1000000000,0xD7B4F7C79},{0,0x91EEA00000000000,0x1C363555F2},{0,0x8A40000000000000,0x387A4D2F92},{0,0x8000000000000000,0x221E778B96},{0,0,0x230A7FC100},{0xC90715B34B9F1000,0xC097CE7B},{0xF768A00B22A00000,0x2CD76FE086B93CE2},{0x65F67D9240000000,0xA64E6C51999090B,0xA70C3C4},{0xBDCFE68000000000,0xDD8F3157D27E23AC,0x2DA4EE3215},{0x34E1000000000000,0xE946FE31CDCF66F6,0x517488955},{0x8A00000000000000,0x68F7E7E45589F013,0x1400B57B5C},{0,0xBC0C6ACDC3FE6EE4,0x1584113266},{0,0x7839E74404A7E800,0x17EB750C77},{0,0x7C792B260D100000,0x1BD0F1EFFF},{0,0x55F291EEA0000000,0x3B7C2A660D},{0,0x2F928A4000000000,0x31ADF215F},{0,0x8B96800000000000,0x1629847F8D},{0,0xC100000000000000,0x20F4C1582D},{0,0,0xAA725344A},{0,0,0x113ABE6400},{0xCE7BC90715B34B9F,49303},{0x3CE2F768A00B22A0,0x2CD76FE086B9},{0x90B65F67D924000,0xC3C40A64E6C51999,2672},{0x23ACBDCFE6800000,0x3215DD8F3157D27E,0x1A414CECCC},{0x66F634E100000000,0x8955E946FE31CDCF,0x2F8B024ABC},{0xF0138A0000000000,0x7B5C68F7E7E45589,0x2BE5A62ECF},{0x6EE4000000000000,0x3266BC0C6ACDC3FE,0x304EE2391F},{0xE800000000000000,0xC777839E74404A7,0x7437A9CE9},{0,0xEFFF7C792B260D10,0x3642C8EC69},{0,0x660D55F291EEA000,0x18AA5DD8C0},{0,0x215F2F928A400000,0x2CCBDA475B},{0,0x7F8D8B9680000000,0x1537CAEB8E},{0,0x582DC10000000000,0x212D8ECAF7},{0,0x344A000000000000,0x3996E0C295},{0,0x6400000000000000,0x22BD443DC6},{0,0,0x2E3100B2E8},{0,0,0x3604471000},{0x86B93CE2F768A00B,0x2CD76FE0},{0x1999090B65F67D92,0xA70C3C40A64E6C5},{0xD27E23ACBDCFE680,0xECCC3215DD8F3157,0x26E4D30},{0xCDCF66F634E10000,0x4ABC8955E946FE31,0xB64281D3A},{0x5589F0138A000000,0x2ECF7B5C68F7E7E4,0xD9278680A},{0xC3FE6EE400000000,0x391F3266BC0C6ACD,0x25EF2032E},{0x4A7E80000000000,0x9CE90C777839E744,0xAC31D0674},{0xD10000000000000,0xEC69EFFF7C792B26,0x1B26AC1DE0},{0xA000000000000000,0xD8C0660D55F291EE,0x345E7C1C95},{0,0x475B215F2F928A40,0x22E38EF84A},{0,0xEB8E7F8D8B968000,0x114B5B89D0},{0,0xCAF7582DC1000000,0x30A49C64FC},{0,0xC295344A00000000,0x3ADBA09244},{0,0x3DC6640000000000,0x10026BB258},{0,0xB2E8000000000000,0x148B978322},{0,0x1000000000000000,0x8143678BB},{0,0,0x2B8DCB3AA0},{0,0,0x2540BE4000},{0x6FE086B93CE2F768,11479},{0xE6C51999090B65F6,0xA70C3C40A64},{0x3157D27E23ACBDCF,0x4D30ECCC3215DD8F,622},{0xFE31CDCF66F634E1,0x1D3A4ABC8955E946,0x19AE7BBEEA},{0xE7E45589F0138A00,0x680A2ECF7B5C68F7,0x36824ABF5A},{0x6ACDC3FE6EE40000,0x32E391F3266BC0C,0x150CA44502},{0xE74404A7E8000000,0x6749CE90C777839,0x77F3277B},{0x2B260D1000000000,0x1DE0EC69EFFF7C79,0x1CA4DFD568},{0x91EEA00000000000,0x1C95D8C0660D55F2,0x183DD6F75E},{0x8A40000000000000,0xF84A475B215F2F92,0x15E97DFDA6},{0x8000000000000000,0x89D0EB8E7F8D8B96,0x26E02E3B0B},{0,0x64FCCAF7582DC100,0x2AFBD28B6},{0,0x9244C295344A0000,0x2A778EEE88},{0,0xB2583DC664000000,0x1FCC49999F},{0,0x8322B2E800000000,0x252EA9A20B},{0,0x78BB100000000000,0x2AE2EF794},{0,0x3AA0000000000000,0x229198E47B},{0,0x4000000000000000,0x1CB1056082},{0,0,0x1E53814680},{0,0,0x1DCD650000},{0xA64E6C51999090B,0xA70C3C4},{0xDD8F3157D27E23AC,0x26E4D30ECCC3215},{0xE946FE31CDCF66F6,0xBEEA1D3A4ABC8955,0x90E40F},{0x68F7E7E45589F013,0xBF5A680A2ECF7B5C,0x3AA853A36},{0xBC0C6ACDC3FE6EE4,0x4502032E391F3266,0xCBF34255A},{0x7839E74404A7E800,0x277B06749CE90C77,0x15047C3465},{0x7C792B260D100000,0xD5681DE0EC69EFFF,0x178D42EBA5},{0x55F291EEA0000000,0xF75E1C95D8C0660D,0x269C7439E8},{0x2F928A4000000000,0xFDA6F84A475B215F,0x363DDF5263},{0x8B96800000000000,0x3B0B89D0EB8E7F8D,0x1747EAF7D0},{0xC100000000000000,0x28B664FCCAF7582D,0x307B837C4B},{0,0xEE889244C295344A,0x117FD3D51E},{0,0x999FB2583DC66400,0x733AD6015},{0,0xA20B8322B2E80000,0x507774363},{0,0xF79478BB10000000,0x173296C002},{0,0xE47B3AA000000000,0xB0DA7E7E},{0,0x6082400000000000,0x1D8B61F8ED},{0,0x4680000000000000,0x3744C56141},{0,0,0xF32B76AA1},{0,0,0x257C590A00},{0xC3C40A64E6C51999,2672},{0x3215DD8F3157D27E,0x26E4D30ECCC},{0x8955E946FE31CDCF,0xE40FBEEA1D3A4ABC,144},{0x7B5C68F7E7E45589,0x3A36BF5A680A2ECF,0x21BC2B266D},{0x3266BC0C6ACDC3FE,0x255A4502032E391F,0x196E75D2F8},{0xC777839E74404A7,0x3465277B06749CE9,0x39C6A613AE},{0xEFFF7C792B260D10,0xEBA5D5681DE0EC69,0x288F684A4A},{0x660D55F291EEA000,0x39E8F75E1C95D8C0,0x11719C17E2},{0x215F2F928A400000,0x5263FDA6F84A475B,0x34AC2208D9},{0x7F8D8B9680000000,0xF7D03B0B89D0EB8E,0x329964169E},{0x582DC10000000000,0x7C4B28B664FCCAF7,0x25033B8069},{0x344A000000000000,0xD51EEE889244C295,0x188F6D53AB},{0x6400000000000000,0x6015999FB2583DC6,0x280203EBBF},{0,0x4363A20B8322B2E8,0x2C8EDBC937},{0,0xC002F79478BB1000,0xCDDF21B74},{0,0x7E7EE47B3AA00000,0x1B2ED8505A},{0,0xF8ED608240000000,0x1511DEBECD},{0,0x6141468000000000,0x2FF4E8FA75},{0,0x6AA1000000000000,0x1B54632B41},{0,0xA00000000000000,0xF3B20DDFD},{0,0,0x3AEA4DADE4},{0,0,0x3515DBE800},{0xECCC3215DD8F3157,0x26E4D30},{0x4ABC8955E946FE31,0x90E40FBEEA1D3A},{0x2ECF7B5C68F7E7E4,0x266D3A36BF5A680A,0x21BC2B},{0x391F3266BC0C6ACD,0xD2F8255A4502032E,0xA0BF25671},{0x9CE90C777839E744,0x13AE3465277B0674,0x1A8071EA5A},{0xEC69EFFF7C792B26,0x4A4AEBA5D5681DE0,0x14F9001066},{0xD8C0660D55F291EE,0x17E239E8F75E1C95,0x17D0F8AC00},{0x475B215F2F928A40,0x8D95263FDA6F84A,0x58F9448},{0xEB8E7F8D8B968000,0x169EF7D03B0B89D0,0x10C5983FB4},{0xCAF7582DC1000000,0x80697C4B28B664FC,0x29EE1A5897},{0xC295344A00000000,0x53ABD51EEE889244,0x2346331A6D},{0x3DC6640000000000,0xEBBF6015999FB258,0x1974633381},{0xB2E8000000000000,0xC9374363A20B8322,0x1E3FE37049},{0x1000000000000000,0x1B74C002F79478BB,0x112DFD008C},{0,0x505A7E7EE47B3AA0,0x209F0AFA26},{0,0xBECDF8ED60824000,0x8EBAF6CFE},{0,0xFA75614146800000,0x3B500142D4},{0,0x2B416AA100000000,0x31967FC5A7},{0,0xDDFD0A0000000000,0x26EC0C010E},{0,0xADE4000000000000,0x3762696AF},{0,0xE800000000000000,0x28E74CC65D},{0,0,0x15DD3FA910},{0,0,0x3B9ACA000},{0x4D30ECCC3215DD8F,622},{0x1D3A4ABC8955E946,0x90E40FBEEA},{0x680A2ECF7B5C68F7,0xBC2B266D3A36BF5A,33},{0x32E391F3266BC0C,0x5671D2F8255A4502,0x7DAC3C24A},{0x6749CE90C777839,0xEA5A13AE3465277B,0x114EDEE44D},{0x1DE0EC69EFFF7C79,0x10664A4AEBA5D568,0x12241F37A4},{0x1C95D8C0660D55F2,0xAC0017E239E8F75E,0x2632FAE598},{0xF84A475B215F2F92,0x944808D95263FDA6,0x238BF3F547},{0x89D0EB8E7F8D8B96,0x3FB4169EF7D03B0B,0x10AA744860},{0x64FCCAF7582DC100,0x589780697C4B28B6,0x1668E0C5D0},{0x9244C295344A0000,0x1A6D53ABD51EEE88,0x3082649BA3},{0xB2583DC664000000,0x3381EBBF6015999F,0x25F9B5CAE7},{0x8322B2E800000000,0x7049C9374363A20B,0x35D4AA5C21},{0x78BB100000000000,0x8C1B74C002F794,0x7C918F05D},{0x3AA0000000000000,0xFA26505A7E7EE47B,0x15A75C010A},{0x4000000000000000,0x6CFEBECDF8ED6082,0x28E49F8F3},{0,0x42D4FA7561414680,0x38AD4E5B39},{0,0xC5A72B416AA10000,0xD55067893},{0,0x10EDDFD0A000000,0x2267E7077E},{0,0x96AFADE400000000,0x1D566E7CF0},{0,0xC65DE80000000000,0x380432F9A8},{0,0xA910000000000000,0x274BC4257B},{0,0xA000000000000000,0x1CCABBF706},{0,0,0x18AE17A40},{0,0,0xEE6B28000},{0xBEEA1D3A4ABC8955,0x90E40F},{0xBF5A680A2ECF7B5C,0x21BC2B266D3A36},{0x4502032E391F3266,0xC24A5671D2F8255A,514755},{0x277B06749CE90C77,0xE44DEA5A13AE3465,0x2D942479F2},{0xD5681DE0EC69EFFF,0x37A410664A4AEBA5,0x388D7AF407},{0xF75E1C95D8C0660D,0xE598AC0017E239E8,0x1AE2FFA60},{0xFDA6F84A475B215F,0xF547944808D95263,0x168F80C2A5},{0x3B0B89D0EB8E7F8D,0x48603FB4169EF7D0,0x26A3DFFFC6},{0x28B664FCCAF7582D,0xC5D0589780697C4B,0x2E2A922DB0},{0xEE889244C295344A,0x9BA31A6D53ABD51E,0x2928797FD6},{0x999FB2583DC66400,0xCAE73381EBBF6015,0x31F7A18E03},{0xA20B8322B2E80000,0x5C217049C9374363,0xE20E560E},{0xF79478BB10000000,0xF05D008C1B74C002,0x357EA75B0},{0xE47B3AA000000000,0x10AFA26505A7E7E,0x293261A4BC},{0x6082400000000000,0xF8F36CFEBECDF8ED,0x2BC5EA8113},{0x4680000000000000,0x5B3942D4FA756141,0x4A6739EFE},{0,0x7893C5A72B416AA1,0x3B38D1C6D4},{0,0x77E010EDDFD0A00,0x3178423E97},{0,0x7CF096AFADE40000,0x232A0BB7F4},{0,0xF9A8C65DE8000000,0x38EC9F860A},{0,0x257BA91000000000,0x28E2CBE3E},{0,0xF706A00000000000,0xE783715ED},{0,0x7A40000000000000,0x3767D0E5C7},{0,0x8000000000000000,0x2E71C9B0F6},{0,0,0x39648B8100},{0xE40FBEEA1D3A4ABC,144},{0x3A36BF5A680A2ECF,0x21BC2B266D},{0x255A4502032E391F,0xDAC3C24A5671D2F8,7},{0x3465277B06749CE9,0x79F2E44DEA5A13AE,0x1D42AEA28},{0xEBA5D5681DE0EC69,0xF40737A410664A4A,0x96C9446F4},{0x39E8F75E1C95D8C0,0xFA60E598AC0017E2,0x390859BEB7},{0x5263FDA6F84A475B,0xC2A5F547944808D9,0x2AD5F21EC4},{0xF7D03B0B89D0EB8E,0xFFC648603FB4169E,0x2DCFD498F3},{0x7C4B28B664FCCAF7,0x2DB0C5D058978069,0x38CF7B17C8},{0xD51EEE889244C295,0x7FD69BA31A6D53AB,0x2E9B912DFB},{0x6015999FB2583DC6,0x8E03CAE73381EBBF,0x3A8E87CFD7},{0x4363A20B8322B2E8,0x560E5C217049C937,0x323010641A},{0xC002F79478BB1000,0x75B0F05D008C1B74,0x621C1DBC6},{0x7E7EE47B3AA00000,0xA4BC010AFA26505A,0x2E351F2CB3},{0xF8ED608240000000,0x8113F8F36CFEBECD,0x29D3962D52},{0x6141468000000000,0x9EFE5B3942D4FA75,0x1335A25A3D},{0x6AA1000000000000,0xC6D47893C5A72B41,0xE58E6E37D},{0xA00000000000000,0x3E97077E010EDDFD,0x1D48DFD27E},{0,0xB7F47CF096AFADE4,0x1D64C212F7},{0,0x860AF9A8C65DE800,0x39AD2D7905},{0,0xBE3E257BA9100000,0x1493B85E8},{0,0x15EDF706A0000000,0x3630926A23},{0,0xE5C77A4000000000,0x82B44B862},{0,0xB0F6800000000000,0x1706C13C7B},{0,0x8100000000000000,0x1CCC92DD6B},{0,0,0x1907BB6DCA},{0,0,0x2F08236400},{0x266D3A36BF5A680A,0x21BC2B},{0xD2F8255A4502032E,0x7DAC3C24A5671},{0x13AE3465277B0674,0xEA2879F2E44DEA5A,119850},{0x4A4AEBA5D5681DE0,0x46F4F40737A41066,0x9FDEA0D38},{0x17E239E8F75E1C95,0xBEB7FA60E598AC00,0xD1A618B95},{0x8D95263FDA6F84A,0x1EC4C2A5F5479448,0x22DD7F49DE},{0x169EF7D03B0B89D0,0x98F3FFC648603FB4,0x33B7651F80},{0x80697C4B28B664FC,0x17C82DB0C5D05897,0x1DF101B76B},{0x53ABD51EEE889244,0x2DFB7FD69BA31A6D,0x18EF3BF1B7},{0xEBBF6015999FB258,0xCFD78E03CAE73381,0x2AA65B2A09},{0xC9374363A20B8322,0x641A560E5C217049,0x248D57366},{0x1B74C002F79478BB,0xDBC675B0F05D008C,0x17D6FB14A9},{0x505A7E7EE47B3AA0,0x2CB3A4BC010AFA26,0x278C5AF9ED},{0xBECDF8ED60824000,0x2D528113F8F36CFE,0x3738B5704E},{0xFA75614146800000,0x5A3D9EFE5B3942D4,0x1233B6F724},{0x2B416AA100000000,0xE37DC6D47893C5A7,0x876C72BEA},{0xDDFD0A0000000000,0xD27E3E97077E010E,0x36B0742DFD},{0xADE4000000000000,0x12F7B7F47CF096AF,0x3B18FC0076},{0xE800000000000000,0x7905860AF9A8C65D,0x1B7DC3AB61},{0,0x85E8BE3E257BA910,0x16B1D3FCB5},{0,0x6A2315EDF706A000,0x2A439E6D84},{0,0xB862E5C77A400000,0x1ED4866AE8},{0,0x3C7BB0F680000000,0x362F3557F1},{0,0xDD6B810000000000,0x382ACD3DEA},{0,0x6DCA000000000000,0x36AF0A4C1D},{0,0x6400000000000000,0x6DA18D225},{0,0,0x8B4A7A8E8},{0,0,0x3604471000},{0xBC2B266D3A36BF5A,33},{0x5671D2F8255A4502,0x7DAC3C24A},{0xEA5A13AE3465277B,0xD42AEA2879F2E44D,1},{0x10664A4AEBA5D568,0xD3846F4F40737A4,0x6D00F732},{0xAC0017E239E8F75E,0x8B95BEB7FA60E598,0xBA74F6AA3},{0x944808D95263FDA6,0x49DE1EC4C2A5F547,0x26140E872D},{0x3FB4169EF7D03B0B,0x1F8098F3FFC64860,0xA8B685CFF},{0x589780697C4B28B6,0xB76B17C82DB0C5D0,0x3B6684E577},{0x1A6D53ABD51EEE88,0xF1B72DFB7FD69BA3,0x1BDFA87BA1},{0x3381EBBF6015999F,0x2A09CFD78E03CAE7,0x25B4A06885},{0x7049C9374363A20B,0x7366641A560E5C21,0x1F01349FF9},{0x8C1B74C002F794,0x14A9DBC675B0F05D,0x3A146CD9B9},{0xFA26505A7E7EE47B,0xF9ED2CB3A4BC010A,0x2B17AB9E22},{0x6CFEBECDF8ED6082,0x704E2D528113F8F3,0x824BF9B2F},{0x42D4FA7561414680,0xF7245A3D9EFE5B39,0xB0B910216},{0xC5A72B416AA10000,0x2BEAE37DC6D47893,0x558D82BAD},{0x10EDDFD0A000000,0x2DFDD27E3E97077E,0x2851D43262},{0x96AFADE400000000,0x7612F7B7F47CF0,0x16DBF6A27E},{0xC65DE80000000000,0xAB617905860AF9A8,0x1D564AE9C3},{0xA910000000000000,0xFCB585E8BE3E257B,0x2D8ECEF4C1},{0xA000000000000000,0x6D846A2315EDF706,0x2D2A88EC76},{0,0x6AE8B862E5C77A40,0x1B92D8D888},{0,0x57F13C7BB0F68000,0x1FC31F96D9},{0,0x3DEADD6B81000000,0x329AAEFF73},{0,0x4C1D6DCA00000000,0x1AD4F34F2C},{0,0xD225640000000000,0xA50538610},{0,0xA8E8000000000000,0x3EA9A4E5B},{0,0x1000000000000000,0x15575966D7},{0,0,0x3212B952A0},{0,0,0x2540BE4000},{0xC24A5671D2F8255A,514755},{0xE44DEA5A13AE3465,0x1D42AEA2879F2},{0x37A410664A4AEBA5,0xF7320D3846F4F407,27904},{0xE598AC0017E239E8,0x6AA38B95BEB7FA60,0x398E0035},{0xF547944808D95263,0x872D49DE1EC4C2A5,0xC6FDFFDB2},{0x48603FB4169EF7D0,0x5CFF1F8098F3FFC6,0x2991199FEE},{0xC5D0589780697C4B,0xE577B76B17C82DB0,0x377F8ED31C},{0x9BA31A6D53ABD51E,0x7BA1F1B72DFB7FD6,0x6BA5B6E5A},{0xCAE73381EBBF6015,0x68852A09CFD78E03,0x15113417AE},{0x5C217049C9374363,0x9FF97366641A560E,0x289B8B2F44},{0xF05D008C1B74C002,0xD9B914A9DBC675B0,0xFFA5CDFE2},{0x10AFA26505A7E7E,0x9E22F9ED2CB3A4BC,0x34D157A0E5},{0xF8F36CFEBECDF8ED,0x9B2F704E2D528113,0x3576485F6B},{0x5B3942D4FA756141,0x216F7245A3D9EFE,0x190DD431DF},{0x7893C5A72B416AA1,0x2BAD2BEAE37DC6D4,0x33EC52846C},{0x77E010EDDFD0A00,0x32622DFDD27E3E97,0x192F7889C2},{0x7CF096AFADE40000,0xA27E007612F7B7F4,0x2D37082B6A},{0xF9A8C65DE8000000,0xE9C3AB617905860A,0x18D3ECEE1E},{0x257BA91000000000,0xF4C1FCB585E8BE3E,0x732911CA8},{0xF706A00000000000,0xEC766D846A2315ED,0x2756914310},{0x7A40000000000000,0xD8886AE8B862E5C7,0x3F0BAE510},{0x8000000000000000,0x96D957F13C7BB0F6,0x3EC16FD8F},{0,0xFF733DEADD6B8100,0x216E96230A},{0,0x4F2C4C1D6DCA0000,0x28F85E829},{0,0x8610D22564000000,0x99E396EA9},{0,0x4E5BA8E800000000,0x2778664A56},{0,0x66D7100000000000,0x14183E5CE5},{0,0x52A0000000000000,0x3569687135},{0,0x4000000000000000,0xC6A48A772},{0,0,0x1A99D4A680},{0,0,0x1DCD650000},{0xDAC3C24A5671D2F8,7},{0x79F2E44DEA5A13AE,0x1D42AEA28},{0xF40737A410664A4A,0x6D00F7320D3846F4},{0xFA60E598AC0017E2,0x356AA38B95BEB7,0x19612190},{0xC2A5F547944808D9,0xFDB2872D49DE1EC4,0x21871E0FDF},{0xFFC648603FB4169E,0x9FEE5CFF1F8098F3,0x3426E780BB},{0x2DB0C5D058978069,0xD31CE577B76B17C8,0x2BAF4E3104},{0x7FD69BA31A6D53AB,0x6E5A7BA1F1B72DFB,0x11F9276D9},{0x8E03CAE73381EBBF,0x17AE68852A09CFD7,0x329FE6CE00},{0x560E5C217049C937,0x2F449FF97366641A,0x58383B1},{0x75B0F05D008C1B74,0xDFE2D9B914A9DBC6,0x2941070F72},{0xA4BC010AFA26505A,0xA0E59E22F9ED2CB3,0x1ABF0E9B4D},{0x8113F8F36CFEBECD,0x5F6B9B2F704E2D52,0x121304F688},{0x9EFE5B3942D4FA75,0x31DF0216F7245A3D,0x1FC072CECA},{0xC6D47893C5A72B41,0x846C2BAD2BEAE37D,0x2F13BFF0FC},{0x3E97077E010EDDFD,0x89C232622DFDD27E,0x3ACB33D7A0},{0xB7F47CF096AFADE4,0x2B6AA27E007612F7,0x2560D14D22},{0x860AF9A8C65DE800,0xEE1EE9C3AB617905,0x7F4AAA7DA},{0xBE3E257BA9100000,0x1CA8F4C1FCB585E8,0x32F9411E5D},{0x15EDF706A0000000,0x4310EC766D846A23,0x15ADE7A6A9},{0xE5C77A4000000000,0xE510D8886AE8B862,0x2768CCCD98},{0xB0F6800000000000,0xFD8F96D957F13C7B,0x23993D52C8},{0x8100000000000000,0x230AFF733DEADD6B,0x2ECBF73838},{0,0xE8294F2C4C1D6DCA,0xD1204E923},{0,0x6EA98610D2256400,0x85C378349},{0,0x4A564E5BA8E80000,0x1118E79532},{0,0x5CE566D710000000,0xBB58A4AA2},{0,0x713552A000000000,0x25CD94DE00},{0,0xA772400000000000,0x1A5BBD72},{0,0xA680000000000000,0x1AB1EA879A},{0,0,0x2401E1B061},{0,0,0x1695A68A00},{0xEA2879F2E44DEA5A,119850},{0x46F4F40737A41066,0x6D00F7320D38},{0xBEB7FA60E598AC00,0x219000356AA38B95,6497},{0x1EC4C2A5F5479448,0xFDFFDB2872D49DE,0x169D770528},{0x98F3FFC648603FB4,0x80BB9FEE5CFF1F80,0x953E1C8BD},{0x17C82DB0C5D05897,0x3104D31CE577B76B,0x2C1F40364E},{0x2DFB7FD69BA31A6D,0x76D96E5A7BA1F1B7,0x1234934C3C},{0xCFD78E03CAE73381,0xCE0017AE68852A09,0xE13F35102},{0x641A560E5C217049,0x83B12F449FF97366,0xA72C280F},{0xDBC675B0F05D008C,0xF72DFE2D9B914A9,0x39CBB4C65},{0x2CB3A4BC010AFA26,0x9B4DA0E59E22F9ED,0x1787AA82E4},{0x2D528113F8F36CFE,0xF6885F6B9B2F704E,0x353A04B352},{0x5A3D9EFE5B3942D4,0xCECA31DF0216F724,0x1350FB328E},{0xE37DC6D47893C5A7,0xF0FC846C2BAD2BEA,0x214001AE4B},{0xD27E3E97077E010E,0xD7A089C232622DFD,0x11AE751693},{0x12F7B7F47CF096AF,0x4D222B6AA27E0076,0x226C165E77},{0x7905860AF9A8C65D,0xA7DAEE1EE9C3AB61,0x1BC6E9696C},{0x85E8BE3E257BA910,0x1E5D1CA8F4C1FCB5,0x194C622B07},{0x6A2315EDF706A000,0xA6A94310EC766D84,0x1A84D5793},{0xB862E5C77A400000,0xCD98E510D8886AE8,0x2260AFC5C8},{0x3C7BB0F680000000,0x52C8FD8F96D957F1,0x2EC0CC5CFF},{0xDD6B810000000000,0x3838230AFF733DEA,0x3B727596AB},{0x6DCA000000000000,0xE923E8294F2C4C1D,0x27DD7BDC34},{0x6400000000000000,0x83496EA98610D225,0xC51B94611},{0,0x95324A564E5BA8E8,0x413D8B845},{0,0x4AA25CE566D71000,0x1033753F1C},{0,0xDE00713552A00000,0x6964EA3F8},{0,0xBD72A77240000000,0x39F1A40587},{0,0x879AA68000000000,0x1F9ABC7F0C},{0,0xB061000000000000,0x2EAD41A67},{0,0x8A00000000000000,0x1824584686},{0,0,0x1F53272CE4},{0,0,0x3515DBE800},{0xD3846F4F40737A4,0x6D00F732},{0x8B95BEB7FA60E598,0x1961219000356AA3},{0x49DE1EC4C2A5F547,0x5280FDFFDB2872D,0x5E8BB31},{0x1F8098F3FFC64860,0xC8BD80BB9FEE5CFF,0xB69D403D3},{0xB76B17C82DB0C5D0,0x364E3104D31CE577,0x314F518B10},{0xF1B72DFB7FD69BA3,0x4C3C76D96E5A7BA1,0x3C6517B2F},{0x2A09CFD78E03CAE7,0x5102CE0017AE6885,0xB032B1DEB},{0x7366641A560E5C21,0x280F83B12F449FF9,0x36C9F40F16},{0x14A9DBC675B0F05D,0x4C650F72DFE2D9B9,0x528A1284B},{0xF9ED2CB3A4BC010A,0x82E49B4DA0E59E22,0x118822A9A2},{0x704E2D528113F8F3,0xB352F6885F6B9B2F,0x25D66DA898},{0xF7245A3D9EFE5B39,0x328ECECA31DF0216,0x238DA87C39},{0x2BEAE37DC6D47893,0xAE4BF0FC846C2BAD,0xD513C7575},{0x2DFDD27E3E97077E,0x1693D7A089C23262,0x1B665335C1},{0x7612F7B7F47CF0,0x5E774D222B6AA27E,0x2CF4F40372},{0xAB617905860AF9A8,0x696CA7DAEE1EE9C3,0x1AA0EC9115},{0xFCB585E8BE3E257B,0x2B071E5D1CA8F4C1,0x4FC3E5B3C},{0x6D846A2315EDF706,0x5793A6A94310EC76,0xE024C003B},{0x6AE8B862E5C77A40,0xC5C8CD98E510D888,0xDD1108955},{0x57F13C7BB0F68000,0x5CFF52C8FD8F96D9,0x13F871F03E},{0x3DEADD6B81000000,0x96AB3838230AFF73,0xE8523FF0D},{0x4C1D6DCA00000000,0xDC34E923E8294F2C,0x329F0D1D7},{0xD225640000000000,0x461183496EA98610,0x324244FD51},{0xA8E8000000000000,0xB84595324A564E5B,0x12EC4A5114},{0x1000000000000000,0x3F1C4AA25CE566D7,0x4D2FF3CA5},{0,0xA3F8DE00713552A0,0x267975E004},{0,0x587BD72A7724000,0x11498A842},{0,0x7F0C879AA6800000,0xF5F31B4AE},{0,0x1A67B06100000000,0x28A0CA010A},{0,0x46868A0000000000,0x25A31C0DC},{0,0x2CE4000000000000,0x3349713E63},{0,0xE800000000000000,0x17174FCE93},{0,0,0x226FE64510},{0,0,0x3B9ACA000},{0xF7320D3846F4F407,27904},{0x6AA38B95BEB7FA60,0x196121900035},{0x872D49DE1EC4C2A5,0xBB3105280FDFFDB2,1512},{0x5CFF1F8098F3FFC6,0x3D3C8BD80BB9FEE,0x362FDC8B62},{0xE577B76B17C82DB0,0x8B10364E3104D31C,0x16D22573AF},{0x7BA1F1B72DFB7FD6,0x7B2F4C3C76D96E5A,0x28DF30E7FF},{0x68852A09CFD78E03,0x1DEB5102CE0017AE,0x3B7BDD9839},{0x9FF97366641A560E,0xF16280F83B12F44,0xD4C6E4CD6},{0xD9B914A9DBC675B0,0x284B4C650F72DFE2,0x31D6E81677},{0x9E22F9ED2CB3A4BC,0xA9A282E49B4DA0E5,0x1BBE559DB2},{0x9B2F704E2D528113,0xA898B352F6885F6B,0x29991F79C7},{0x216F7245A3D9EFE,0x7C39328ECECA31DF,0x2E7C942838},{0x2BAD2BEAE37DC6D4,0x7575AE4BF0FC846C,0xD26C87B14},{0x32622DFDD27E3E97,0x35C11693D7A089C2,0x4C370ECA5},{0xA27E007612F7B7F4,0x3725E774D222B6A,0x26774832C6},{0xE9C3AB617905860A,0x9115696CA7DAEE1E,0x2E1A85AD4A},{0xF4C1FCB585E8BE3E,0x5B3C2B071E5D1CA8,0x115C860CA8},{0xEC766D846A2315ED,0x3B5793A6A94310,0x2732D2981A},{0xD8886AE8B862E5C7,0x8955C5C8CD98E510,0x60DC65510},{0x96D957F13C7BB0F6,0xF03E5CFF52C8FD8F,0x3D9A66E8B},{0xFF733DEADD6B8100,0xFF0D96AB3838230A,0x2094FB5083},{0x4F2C4C1D6DCA0000,0xD1D7DC34E923E829,0x1EBB97B726},{0x8610D22564000000,0xFD51461183496EA9,0x909D59D2E},{0x4E5BA8E800000000,0x5114B84595324A56,0xAF0CB31EC},{0x66D7100000000000,0x3CA53F1C4AA25CE5,0x37059304E9},{0x52A0000000000000,0xE004A3F8DE007135,0x364E009ACD},{0x4000000000000000,0xA8420587BD72A772,0x2FEF1C4758},{0,0xB4AE7F0C879AA680,0x14A46263C1},{0,0x10A1A67B0610000,0x2D19C3C0D2},{0,0xC0DC46868A000000,0x30E537A8FB},{0,0x3E632CE400000000,0x3A9DAB6EF1},{0,0xCE93E80000000000,0x382B3EBE3B},{0,0x4510000000000000,0xDECC58C72},{0,0xA000000000000000,0x1A9B02661E},{0,0,0x721646A40},{0,0,0xEE6B28000},{0x356AA38B95BEB7,0x19612190},{0xFDB2872D49DE1EC4,0x5E8BB3105280FDF},{0x9FEE5CFF1F8098F3,0x8B6203D3C8BD80BB,0x16035CE},{0xD31CE577B76B17C8,0x73AF8B10364E3104,0x30170269D3},{0x6E5A7BA1F1B72DFB,0xE7FF7B2F4C3C76D9,0x313B83E5EE},{0x17AE68852A09CFD7,0x98391DEB5102CE00,0x379FEBF423},{0x2F449FF97366641A,0x4CD60F16280F83B1,0x8499AD25E},{0xDFE2D9B914A9DBC6,0x1677284B4C650F72,0x15F4B9F6E0},{0xA0E59E22F9ED2CB3,0x9DB2A9A282E49B4D,0x342CABCBB1},{0x5F6B9B2F704E2D52,0x79C7A898B352F688,0x295ABD3101},{0x31DF0216F7245A3D,0x28387C39328ECECA,0x57F5700E},{0x846C2BAD2BEAE37D,0x7B147575AE4BF0FC,0x34BD46258},{0x89C232622DFDD27E,0xECA535C11693D7A0,0x1499DD927E},{0x2B6AA27E007612F7,0x32C603725E774D22,0x1D8D489580},{0xEE1EE9C3AB617905,0xAD4A9115696CA7DA,0x1DD93755F9},{0x1CA8F4C1FCB585E8,0xCA85B3C2B071E5D,0x3A21E77108},{0x4310EC766D846A23,0x981A003B5793A6A9,0x1DFC8C44A},{0xE510D8886AE8B862,0x55108955C5C8CD98,0x115E2859B6},{0xFD8F96D957F13C7B,0x6E8BF03E5CFF52C8,0x2A73D9DAB8},{0x230AFF733DEADD6B,0x5083FF0D96AB3838,0x2AF0FE47C7},{0xE8294F2C4C1D6DCA,0xB726D1D7DC34E923,0x2E681220B7},{0x6EA98610D2256400,0x9D2EFD5146118349,0x2AC64B163B},{0x4A564E5BA8E80000,0x31EC5114B8459532,0xDE1456CAD},{0x5CE566D710000000,0x4E93CA53F1C4AA2,0x28533A283D},{0x713552A000000000,0x9ACDE004A3F8DE00,0xE3506DB28},{0xA772400000000000,0x4758A8420587BD72,0x9743A9CA0},{0xA680000000000000,0x63C1B4AE7F0C879A,0x25515AD268},{0,0xC0D2010A1A67B061,0x184E1C05E1},{0,0xA8FBC0DC46868A00,0x348FF086B7},{0,0x6EF13E632CE40000,0x2AC2FE983B},{0,0xBE3BCE93E8000000,0xDD6813C0A},{0,0x8C72451000000000,0x28056B2B1},{0,0x661EA00000000000,0x2956B8EB7A},{0,0x6A40000000000000,0x1C7F8B11E0},{0,0x8000000000000000,0x34402DBE56},{0,0,0x1423CD4100},{0x219000356AA38B95,6497},{0xFDFFDB2872D49DE,0x5E8BB310528},{0x80BB9FEE5CFF1F80,0x35CE8B6203D3C8BD,352},{0x3104D31CE577B76B,0x69D373AF8B10364E,0x166692E2D4},{0x76D96E5A7BA1F1B7,0xE5EEE7FF7B2F4C3C,0x3174D3005D},{0xCE0017AE68852A09,0xF42398391DEB5102,0x15DCC4789D},{0x83B12F449FF97366,0xD25E4CD60F16280F,0x24C6C5B422},{0xF72DFE2D9B914A9,0xF6E01677284B4C65,0x81B89C26D},{0x9B4DA0E59E22F9ED,0xCBB19DB2A9A282E4,0x199A62ECC7},{0xF6885F6B9B2F704E,0x310179C7A898B352,0x2E84C01EEB},{0xCECA31DF0216F724,0x700E28387C39328E,0x36C280669F},{0xF0FC846C2BAD2BEA,0x62587B147575AE4B,0x251F3A7A34},{0xD7A089C232622DFD,0x927EECA535C11693,0xC3256E331},{0x4D222B6AA27E0076,0x958032C603725E77,0xB8ABC7E7C},{0xA7DAEE1EE9C3AB61,0x55F9AD4A9115696C,0x1D01C8C8C9},{0x1E5D1CA8F4C1FCB5,0x71080CA85B3C2B07,0x2EE08D20F9},{0xA6A94310EC766D84,0xC44A981A003B5793,0x3A13DFACF2},{0xCD98E510D8886AE8,0x59B655108955C5C8,0x388606D4D0},{0x52C8FD8F96D957F1,0xDAB86E8BF03E5CFF,0x3082A76413},{0x3838230AFF733DEA,0x47C75083FF0D96AB,0x49F69BF02},{0xE923E8294F2C4C1D,0x20B7B726D1D7DC34,0x87EBEA18},{0x83496EA98610D225,0x163B9D2EFD514611,0x59E210F8B},{0x95324A564E5BA8E8,0x6CAD31EC5114B845,0x206238DCA1},{0x4AA25CE566D71000,0x283D04E93CA53F1C,0x2595A6AA72},{0xDE00713552A00000,0xDB289ACDE004A3F8,0x1A944C5896},{0xBD72A77240000000,0x9CA04758A8420587,0x231FB93B08},{0x879AA68000000000,0xD26863C1B4AE7F0C,0x2014DF472},{0xB061000000000000,0x5E1C0D2010A1A67,0x1ABBEB3BD0},{0x8A00000000000000,0x86B7A8FBC0DC4686,0x306F22B5E2},{0,0x983B6EF13E632CE4,0x34BE041CBA},{0,0x3C0ABE3BCE93E800,0x2B71E88271},{0,0xB2B18C7245100000,0x1A5D4DF1AE},{0,0xEB7A661EA0000000,0x28ACD0432C},{0,0x11E06A4000000000,0xA756E4EF9},{0,0xBE56800000000000,0x39FDB80197},{0,0x4100000000000000,0x23549E2BB9},{0,0,0x2B21FE474A},{0,0,0x113ABE6400},{0x5280FDFFDB2872D,0x5E8BB31},{0xC8BD80BB9FEE5CFF,0x16035CE8B6203D3},{0x364E3104D31CE577,0xE2D469D373AF8B10,0x52015C},{0x4C3C76D96E5A7BA1,0x5DE5EEE7FF7B2F,0x15A070B327},{0x5102CE0017AE6885,0x789DF42398391DEB,0x914AAA2C4},{0x280F83B12F449FF9,0xB422D25E4CD60F16,0x2DBE97FD75},{0x4C650F72DFE2D9B9,0xC26DF6E01677284B,0x1B67AF4391},{0x82E49B4DA0E59E22,0xECC7CBB19DB2A9A2,0x21EFF15176},{0xB352F6885F6B9B2F,0x1EEB310179C7A898,0x1BB07A52F8},{0x328ECECA31DF0216,0x669F700E28387C39,0x39C526962C},{0xAE4BF0FC846C2BAD,0x7A3462587B147575,0xA567F83B6},{0x1693D7A089C23262,0xE331927EECA535C1,0x2A7C7F929A},{0x5E774D222B6AA27E,0x7E7C958032C60372,0x2410034FDA},{0x696CA7DAEE1EE9C3,0xC8C955F9AD4A9115,0x32DF433534},{0x2B071E5D1CA8F4C1,0x20F971080CA85B3C,0xC4A30D65D},{0x5793A6A94310EC76,0xACF2C44A981A003B,0x15AEE8CF1F},{0xC5C8CD98E510D888,0xD4D059B655108955,0x76002FBBE},{0x5CFF52C8FD8F96D9,0x6413DAB86E8BF03E,0x2C6E6E9DEF},{0x96AB3838230AFF73,0xBF0247C75083FF0D,0x37BCCFAC51},{0xDC34E923E8294F2C,0xEA1820B7B726D1D7,0x130872EEA1},{0x461183496EA98610,0xF8B163B9D2EFD51,0x25B2DA24C5},{0xB84595324A564E5B,0xDCA16CAD31EC5114,0x2DE1BBE60E},{0x3F1C4AA25CE566D7,0xAA72283D04E93CA5,0x375D5A73E},{0xA3F8DE00713552A0,0x5896DB289ACDE004,0xE972C4A70},{0x587BD72A7724000,0x3B089CA04758A842,0x1A2858B529},{0x7F0C879AA6800000,0xF472D26863C1B4AE,0x9998907DB},{0x1A67B06100000000,0x3BD005E1C0D2010A,0x3336551273},{0x46868A0000000000,0xB5E286B7A8FBC0DC,0x1AD475D9B0},{0x2CE4000000000000,0x1CBA983B6EF13E63,0x2924C40ED6},{0xE800000000000000,0x82713C0ABE3BCE93,0x31DA153C00},{0,0xF1AEB2B18C724510,0x1E5EF7E1},{0,0x432CEB7A661EA000,0x349B50EEFA},{0,0x4EF911E06A400000,0x3A44CD3C4C},{0,0x197BE5680000000,0x11C4571F44},{0,0x2BB9410000000000,0xFD57C9768},{0,0x474A000000000000,0x18411031EC},{0,0x6400000000000000,0x37034B60C4},{0,0,0x2DB9CB1EE8},{0,0,0x3604471000},{0xBB3105280FDFFDB2,1512},{0x3D3C8BD80BB9FEE,0x16035CE8B62},{0x8B10364E3104D31C,0x15CE2D469D373AF,82},{0x7B2F4C3C76D96E5A,0xB327005DE5EEE7FF,0x1317E5EF3A},{0x1DEB5102CE0017AE,0xA2C4789DF4239839,0xDAAC813E8},{0xF16280F83B12F44,0xFD75B422D25E4CD6,0x362A2CC26B},{0x284B4C650F72DFE2,0x4391C26DF6E01677,0x1924B5CF51},{0xA9A282E49B4DA0E5,0x5176ECC7CBB19DB2,0x12EBB55CCF},{0xA898B352F6885F6B,0x52F81EEB310179C7,0x3045210064},{0x7C39328ECECA31DF,0x962C669F700E2838,0x175BC841DA},{0x7575AE4BF0FC846C,0x83B67A3462587B14,0x32E4C70CDB},{0x35C11693D7A089C2,0x929AE331927EECA5,0x331C157FDD},{0x3725E774D222B6A,0x4FDA7E7C958032C6,0x3396C2B937},{0x9115696CA7DAEE1E,0x3534C8C955F9AD4A,0xCE0D90999},{0x5B3C2B071E5D1CA8,0xD65D20F971080CA8,0x23ABE61002},{0x3B5793A6A94310,0xCF1FACF2C44A981A,0xA91EA7C4},{0x8955C5C8CD98E510,0xFBBED4D059B65510,0x2DD2BC3158},{0xF03E5CFF52C8FD8F,0x9DEF6413DAB86E8B,0x14B7D2A27C},{0xFF0D96AB3838230A,0xAC51BF0247C75083,0x1D03BF82B1},{0xD1D7DC34E923E829,0xEEA1EA1820B7B726,0x295E24B22A},{0xFD51461183496EA9,0x24C50F8B163B9D2E,0x9FEF4BEA6},{0x5114B84595324A56,0xE60EDCA16CAD31EC,0x26AEEEA223},{0x3CA53F1C4AA25CE5,0xA73EAA72283D04E9,0x85BBA2551},{0xE004A3F8DE007135,0x4A705896DB289ACD,0x1302EA7AF2},{0xA8420587BD72A772,0xB5293B089CA04758,0x3869A7DABC},{0xB4AE7F0C879AA680,0x7DBF472D26863C1,0x2BEFDA625B},{0x10A1A67B0610000,0x12733BD005E1C0D2,0x1531DA3FDB},{0xC0DC46868A000000,0xD9B0B5E286B7A8FB,0x3301B684A9},{0x3E632CE400000000,0xED61CBA983B6EF1,0x278BDEB3FE},{0xCE93E80000000000,0x3C0082713C0ABE3B,0x3B2708BD21},{0x4510000000000000,0xF7E1F1AEB2B18C72,0x7BCEC6FB6},{0xA000000000000000,0xEEFA432CEB7A661E,0x2A99C29036},{0,0x3C4C4EF911E06A40,0xCCA4AC899},{0,0x1F440197BE568000,0x23AD8CC5AF},{0,0x97682BB941000000,0x28C617A9F2},{0,0x31EC474A00000000,0x387B938236},{0,0x60C4640000000000,0xC9E463FF5},{0,0x1EE8000000000000,0x3921AB178B},{0,0x1000000000000000,0x20643DD5F3},{0,0,0x3897A76AA0},{0,0,0x2540BE4000},{0x8B6203D3C8BD80BB,0x16035CE},{0x73AF8B10364E3104,0x52015CE2D469D3},{0xE7FF7B2F4C3C76D9,0xEF3AB327005DE5EE,1251301},{0x98391DEB5102CE00,0x13E8A2C4789DF423,0x358929DF5E},{0x4CD60F16280F83B1,0xC26BFD75B422D25E,0x15E778D32A},{0x1677284B4C650F72,0xCF514391C26DF6E0,0x9F4A995C9},{0x9DB2A9A282E49B4D,0x5CCF5176ECC7CBB1,0x2EFCCDAF0B},{0x79C7A898B352F688,0x6452F81EEB3101,0x2A54293B9},{0x28387C39328ECECA,0x41DA962C669F700E,0x2B12F355C8},{0x7B147575AE4BF0FC,0xCDB83B67A346258,0x2EA0430211},{0xECA535C11693D7A0,0x7FDD929AE331927E,0x3F845C78D},{0x32C603725E774D22,0xB9374FDA7E7C9580,0x20F206A2F8},{0xAD4A9115696CA7DA,0x9993534C8C955F9,0x39E9136CD3},{0xCA85B3C2B071E5D,0x1002D65D20F97108,0x3122D09B00},{0x981A003B5793A6A9,0xA7C4CF1FACF2C44A,0x3BA55BE},{0x55108955C5C8CD98,0x3158FBBED4D059B6,0x2C63F1B882},{0x6E8BF03E5CFF52C8,0xA27C9DEF6413DAB8,0x1E5017EC7C},{0x5083FF0D96AB3838,0x82B1AC51BF0247C7,0x1D04CECF93},{0xB726D1D7DC34E923,0xB22AEEA1EA1820B7,0x22584FF6B8},{0x9D2EFD5146118349,0xBEA624C50F8B163B,0x2B00BCCF68},{0x31EC5114B8459532,0xA223E60EDCA16CAD,0x186345A0DA},{0x4E93CA53F1C4AA2,0x2551A73EAA72283D,0x32E790538E},{0x9ACDE004A3F8DE00,0x7AF24A705896DB28,0x21188C6E1C},{0x4758A8420587BD72,0xDABCB5293B089CA0,0x6A18E45EB},{0x63C1B4AE7F0C879A,0x625B07DBF472D268,0x36EA052DDE},{0xC0D2010A1A67B061,0x3FDB12733BD005E1,0x33C7219F2E},{0xA8FBC0DC46868A00,0x84A9D9B0B5E286B7,0xAC4AE656C},{0x6EF13E632CE40000,0xB3FE0ED61CBA983B,0x1944309406},{0xBE3BCE93E8000000,0xBD213C0082713C0A,0x18F891E46},{0x8C72451000000000,0x6FB6F7E1F1AEB2B1,0x10785C400E},{0x661EA00000000000,0x9036EEFA432CEB7A,0x35C79C358},{0x6A40000000000000,0xC8993C4C4EF911E0,0x149EC94BEA},{0x8000000000000000,0xC5AF1F440197BE56,0x36AA313F5C},{0,0xA9F297682BB94100,0x1599A77B89},{0,0x823631EC474A0000,0x200D67C4ED},{0,0x3FF560C464000000,0x374C9E3ADA},{0,0x178B1EE800000000,0x32D0B43D61},{0,0xD5F3100000000000,0x169B21D663},{0,0x6AA0000000000000,0x173EAC7FB9},{0,0x4000000000000000,0x2B2BAF5262},{0,0,0x16E0280680},{0,0,0x1DCD650000},{0x35CE8B6203D3C8BD,352},{0x69D373AF8B10364E,0x52015CE2D4},{0xE5EEE7FF7B2F4C3C,0x17E5EF3AB327005D,19},{0xF42398391DEB5102,0xDF5E13E8A2C4789D,0x4720D6F4F},{0xD25E4CD60F16280F,0xD32AC26BFD75B422,0x1298C6136E},{0xF6E01677284B4C65,0x95C9CF514391C26D,0x19CDAD5527},{0xCBB19DB2A9A282E4,0xAF0B5CCF5176ECC7,0x93774DA5F},{0x310179C7A898B352,0x93B9006452F81EEB,0x1647326B58},{0x700E28387C39328E,0x55C841DA962C669F,0x149F9A64F1},{0x62587B147575AE4B,0x2110CDB83B67A34,0x3830B12F55},{0x927EECA535C11693,0xC78D7FDD929AE331,0x13CAE03FD9},{0x958032C603725E77,0xA2F8B9374FDA7E7C,0x32B4AB7F0C},{0x55F9AD4A9115696C,0x6CD309993534C8C9,0x2F13354E7},{0x71080CA85B3C2B07,0x9B001002D65D20F9,0x35E202B608},{0xC44A981A003B5793,0x55BEA7C4CF1FACF2,0x200ED0C08},{0x59B655108955C5C8,0xB8823158FBBED4D0,0x1F0CD1903},{0xDAB86E8BF03E5CFF,0xEC7CA27C9DEF6413,0xDDC5EF47},{0x47C75083FF0D96AB,0xCF9382B1AC51BF02,0x10BEFDBD06},{0x20B7B726D1D7DC34,0xF6B8B22AEEA1EA18,0x195F53DA5},{0x163B9D2EFD514611,0xCF68BEA624C50F8B,0x26A435F0D8},{0x6CAD31EC5114B845,0xA0DAA223E60EDCA1,0x327AE4FC9B},{0x283D04E93CA53F1C,0x538E2551A73EAA72,0x243C2BF3D0},{0xDB289ACDE004A3F8,0x6E1C7AF24A705896,0x308138680A},{0x9CA04758A8420587,0x45EBDABCB5293B08,0x26DAF085A},{0xD26863C1B4AE7F0C,0x2DDE625B07DBF472,0x1504B2A677},{0x5E1C0D2010A1A67,0x9F2E3FDB12733BD0,0x1BBFA1E2A3},{0x86B7A8FBC0DC4686,0x656C84A9D9B0B5E2,0x26189E8624},{0x983B6EF13E632CE4,0x9406B3FE0ED61CBA,0x87961BDE2},{0x3C0ABE3BCE93E800,0x1E46BD213C008271,0x34C11D6051},{0xB2B18C7245100000,0x400E6FB6F7E1F1AE,0x12E3068608},{0xEB7A661EA0000000,0xC3589036EEFA432C,0x1EBC05EF9},{0x11E06A4000000000,0x4BEAC8993C4C4EF9,0x3A270A00A7},{0xBE56800000000000,0x3F5CC5AF1F440197,0x26F3A6C95F},{0x4100000000000000,0x7B89A9F297682BB9,0x162D31A75D},{0,0xC4ED823631EC474A,0x15C3FECE75},{0,0x3ADA3FF560C46400,0x1B6B982146},{0,0x3D61178B1EE80000,0x105A071E78},{0,0xD663D5F310000000,0x1BFED92D43},{0,0x7FB96AA000000000,0xFCB6D8188},{0,0x5262400000000000,0x1FC7F845E5},{0,0x680000000000000,0x3564A526DC},{0,0,0x333A890621},{0,0,0x7AEF40A00},{0xE2D469D373AF8B10,0x52015C},{0x5DE5EEE7FF7B2F,0x1317E5EF3AB327},{0x789DF42398391DEB,0x6F4FDF5E13E8A2C4,291341},{0xB422D25E4CD60F16,0x136ED32AC26BFD75,0x320C6F85C},{0xC26DF6E01677284B,0x552795C9CF514391,0x157026E2AB},{0xECC7CBB19DB2A9A2,0xDA5FAF0B5CCF5176,0x27E4388A86},{0x1EEB310179C7A898,0x6B5893B9006452F8,0x1F65DDD336},{0x669F700E28387C39,0x64F155C841DA962C,0xCABA4EE08},{0x7A3462587B147575,0x2F5502110CDB83B6,0x1F456F799},{0xE331927EECA535C1,0x3FD9C78D7FDD929A,0x23AA87EFF6},{0x7E7C958032C60372,0x7F0CA2F8B9374FDA,0x39559BE861},{0xC8C955F9AD4A9115,0x54E76CD309993534,0x16B33B4569},{0x20F971080CA85B3C,0xB6089B001002D65D,0x188641864A},{0xACF2C44A981A003B,0xC0855BEA7C4CF1F,0x1165207089},{0xD4D059B655108955,0x1903B8823158FBBE,0x1FE8A34C45},{0x6413DAB86E8BF03E,0xEF47EC7CA27C9DEF,0x10168B6D7F},{0xBF0247C75083FF0D,0xBD06CF9382B1AC51,0x1DC9807793},{0xEA1820B7B726D1D7,0x3DA5F6B8B22AEEA1,0x2265E4DB17},{0xF8B163B9D2EFD51,0xF0D8CF68BEA624C5,0x56942AC57},{0xDCA16CAD31EC5114,0xFC9BA0DAA223E60E,0x1479AE3E44},{0xAA72283D04E93CA5,0xF3D0538E2551A73E,0x100FEE4303},{0x5896DB289ACDE004,0x680A6E1C7AF24A70,0xEB94CCF6},{0x3B089CA04758A842,0x85A45EBDABCB529,0x395EF76BBF},{0xF472D26863C1B4AE,0xA6772DDE625B07DB,0x2C7A6E9102},{0x3BD005E1C0D2010A,0xE2A39F2E3FDB1273,0x9DF7B29D},{0xB5E286B7A8FBC0DC,0x8624656C84A9D9B0,0x24C2B2A0F2},{0x1CBA983B6EF13E63,0xBDE29406B3FE0ED6,0x38778E731D},{0x82713C0ABE3BCE93,0x60511E46BD213C00,0x6ECBEEA3F},{0xF1AEB2B18C724510,0x8608400E6FB6F7E1,0xEC184A4C6},{0x432CEB7A661EA000,0x5EF9C3589036EEFA,0x2E38ED2D7C},{0x4EF911E06A400000,0xA74BEAC8993C4C,0x1CF516D536},{0x197BE5680000000,0xC95F3F5CC5AF1F44,0xC92CD8FA6},{0x2BB9410000000000,0xA75D7B89A9F29768,0x26D541B1CB},{0x474A000000000000,0xCE75C4ED823631EC,0x2F6AB5EBC4},{0x6400000000000000,0x21463ADA3FF560C4,0x2DD294A224},{0,0x1E783D61178B1EE8,0x86983B611},{0,0x2D43D663D5F31000,0x3FC5F8C85},{0,0x81887FB96AA00000,0x1F01F4F2EF},{0,0x45E5526240000000,0x37C3AB5DC2},{0,0x26DC068000000000,0x2D3B933117},{0,0x621000000000000,0x563F45A85},{0,0xA00000000000000,0x1EF8D841B0},{0,0,0x28FCBEEBE4},{0,0,0x3515DBE800},{0x15CE2D469D373AF,82},{0xB327005DE5EEE7FF,0x1317E5EF3A},{0xA2C4789DF4239839,0x720D6F4FDF5E13E8,4},{0xFD75B422D25E4CD6,0xF85C136ED32AC26B,0x108F936BA},{0x4391C26DF6E01677,0xE2AB552795C9CF51,0x2B884A27D6},{0x5176ECC7CBB19DB2,0x8A86DA5FAF0B5CCF,0x32082B668C},{0x52F81EEB310179C7,0xD3366B5893B90064,0x20B8E74EC1},{0x962C669F700E2838,0xEE0864F155C841DA,0x2D20DF8A22},{0x83B67A3462587B14,0xF7992F5502110CDB,0x821FAB022},{0x929AE331927EECA5,0xEFF63FD9C78D7FDD,0x82434D76D},{0x4FDA7E7C958032C6,0xE8617F0CA2F8B937,0x1998C6DA31},{0x3534C8C955F9AD4A,0x456954E76CD30999,0xB9EBBA44B},{0xD65D20F971080CA8,0x864AB6089B001002,0x1186826CB3},{0xCF1FACF2C44A981A,0x70890C0855BEA7C4,0x29CC7FA8DC},{0xFBBED4D059B65510,0x4C451903B8823158,0x3353393903},{0x9DEF6413DAB86E8B,0x6D7FEF47EC7CA27C,0xC4926883},{0xAC51BF0247C75083,0x7793BD06CF9382B1,0x1E99B40F82},{0xEEA1EA1820B7B726,0xDB173DA5F6B8B22A,0x1E6071EDCA},{0x24C50F8B163B9D2E,0xAC57F0D8CF68BEA6,0x2F3B263810},{0xE60EDCA16CAD31EC,0x3E44FC9BA0DAA223,0x3E1CD1966},{0xA73EAA72283D04E9,0x4303F3D0538E2551,0x17CE2C08DA},{0x4A705896DB289ACD,0xCCF6680A6E1C7AF2,0x32D16A7272},{0xB5293B089CA04758,0x6BBF085A45EBDABC,0x1ABAA6ABEF},{0x7DBF472D26863C1,0x9102A6772DDE625B,0x37BE98C2DC},{0x12733BD005E1C0D2,0xB29DE2A39F2E3FDB,0x335AC8E261},{0xD9B0B5E286B7A8FB,0xA0F28624656C84A9,0x16BF3CED26},{0xED61CBA983B6EF1,0x731DBDE29406B3FE,0x8FE7331CE},{0x3C0082713C0ABE3B,0xEA3F60511E46BD21,0x30115C017C},{0xF7E1F1AEB2B18C72,0xA4C68608400E6FB6,0x1D15841628},{0xEEFA432CEB7A661E,0x2D7C5EF9C3589036,0x9768CF255},{0x3C4C4EF911E06A40,0xD53600A74BEAC899,0x13D4FC3C98},{0x1F440197BE568000,0x8FA6C95F3F5CC5AF,0x23958C4CDF},{0x97682BB941000000,0xB1CBA75D7B89A9F2,0x340D484217},{0x31EC474A00000000,0xEBC4CE75C4ED8236,0x5844D965F},{0x60C4640000000000,0xA22421463ADA3FF5,0x165555E002},{0x1EE8000000000000,0xB6111E783D61178B,0x9CF5F157},{0x1000000000000000,0x8C852D43D663D5F3,0x146BFEADFB},{0,0xF2EF81887FB96AA0,0x3A917BB66C},{0,0x5DC245E552624000,0x195DDD4E9F},{0,0x311726DC06800000,0x251AF7ECF5},{0,0x5A85062100000000,0x391691569E},{0,0x41B00A0000000000,0x24DE9C0FDC},{0,0xEBE4000000000000,0x334850E208},{0,0xE800000000000000,0x213C27D49},{0,0,0x113527E110},{0,0,0x3B9ACA000},{0xEF3AB327005DE5EE,1251301},{0x13E8A2C4789DF423,0x4720D6F4FDF5E},{0xC26BFD75B422D25E,0x36BAF85C136ED32A,67833},{0xCF514391C26DF6E0,0x27D6E2AB552795C9,0x3A064CA8E6},{0x5CCF5176ECC7CBB1,0x668C8A86DA5FAF0B,0x35965818F1},{0x6452F81EEB3101,0x4EC1D3366B5893B9,0x3834988F63},{0x41DA962C669F700E,0x8A22EE0864F155C8,0x171F32686B},{0xCDB83B67A346258,0xB022F7992F550211,0x1909DC00DE},{0x7FDD929AE331927E,0xD76DEFF63FD9C78D,0x33D93DBB14},{0xB9374FDA7E7C9580,0xDA31E8617F0CA2F8,0x4DA40606C},{0x9993534C8C955F9,0xA44B456954E76CD3,0x19581AA6BF},{0x1002D65D20F97108,0x6CB3864AB6089B00,0x2C9EBD65EA},{0xA7C4CF1FACF2C44A,0xA8DC70890C0855BE,0x3694CBBDB7},{0x3158FBBED4D059B6,0x39034C451903B882,0x2AC2F74DC9},{0xA27C9DEF6413DAB8,0x68836D7FEF47EC7C,0x2ED9CED58C},{0x82B1AC51BF0247C7,0xF827793BD06CF93,0x20B0FBF3C4},{0xB22AEEA1EA1820B7,0xEDCADB173DA5F6B8,0x2DA61F1A47},{0xBEA624C50F8B163B,0x3810AC57F0D8CF68,0x10BF4B8E28},{0xA223E60EDCA16CAD,0x19663E44FC9BA0DA,0x95D3D4DFD},{0x2551A73EAA72283D,0x8DA4303F3D0538E,0x3AEDE38DE6},{0x7AF24A705896DB28,0x7272CCF6680A6E1C,0x358F2123BA},{0xDABCB5293B089CA0,0xABEF6BBF085A45EB,0x2B691C6C9A},{0x625B07DBF472D268,0xC2DC9102A6772DDE,0x240325A786},{0x3FDB12733BD005E1,0xE261B29DE2A39F2E,0x1F606463DC},{0x84A9D9B0B5E286B7,0xED26A0F28624656C,0x336DBAFD90},{0xB3FE0ED61CBA983B,0x31CE731DBDE29406,0x21BE48EB75},{0xBD213C0082713C0A,0x17CEA3F60511E46,0x1B49570406},{0x6FB6F7E1F1AEB2B1,0x1628A4C68608400E,0x165F96C4E},{0x9036EEFA432CEB7A,0xF2552D7C5EF9C358,0x122E524FE8},{0xC8993C4C4EF911E0,0x3C98D53600A74BEA,0x363CB337F0},{0xC5AF1F440197BE56,0x4CDF8FA6C95F3F5C,0x37EF393CE4},{0xA9F297682BB94100,0x4217B1CBA75D7B89,0x3527C1E940},{0x823631EC474A0000,0x965FEBC4CE75C4ED,0xEF615EC61},{0x3FF560C464000000,0xE002A22421463ADA,0x16B8A991B1},{0x178B1EE800000000,0xF157B6111E783D61,0x296A2DB7B5},{0xD5F3100000000000,0xADFB8C852D43D663,0x2A5CA1F628},{0x6AA0000000000000,0xB66CF2EF81887FB9,0x978B1BBFD},{0x4000000000000000,0x4E9F5DC245E55262,0x3B12730B79},{0,0xECF5311726DC0680,0x1C3E77BE83},{0,0x569E5A8506210000,0x1EB76126C9},{0,0xFDC41B00A000000,0x2EE0B37878},{0,0xE208EBE400000000,0x1BF4400A26},{0,0x7D49E80000000000,0x90D9AB616},{0,0xE110000000000000,0x53C7925C9},{0,0xA000000000000000,0x2F00EF5F36},{0,0,0xCB7E75A40},{0,0,0xEE6B28000},{0x17E5EF3AB327005D,19},{0xDF5E13E8A2C4789D,0x4720D6F4F},{0xD32AC26BFD75B422,0x8F936BAF85C136E,1},{0x95C9CF514391C26D,0xA8E627D6E2AB5527,0x3DB1A69C},{0xAF0B5CCF5176ECC7,0x18F1668C8A86DA5F,0x2479A642E8},{0x93B9006452F81EEB,0x8F634EC1D3366B58,0x360A15C788},{0x55C841DA962C669F,0x686B8A22EE0864F1,0x1FCB9DE608},{0x2110CDB83B67A34,0xDEB022F7992F55,0x1F5263BEC},{0xC78D7FDD929AE331,0xBB14D76DEFF63FD9,0x36F2E6113D},{0xA2F8B9374FDA7E7C,0x606CDA31E8617F0C,0xE5F710DCE},{0x6CD309993534C8C9,0xA6BFA44B456954E7,0x300D01EFDA},{0x9B001002D65D20F9,0x65EA6CB3864AB608,0x32E8A301B9},{0x55BEA7C4CF1FACF2,0xBDB7A8DC70890C08,0x2B2A96A07D},{0xB8823158FBBED4D0,0x4DC939034C451903,0x1D46C0AC19},{0xEC7CA27C9DEF6413,0xD58C68836D7FEF47,0x5E43A2290},{0xCF9382B1AC51BF02,0xF3C40F827793BD06,0x21B8CA1B0D},{0xF6B8B22AEEA1EA18,0x1A47EDCADB173DA5,0x33F9DD5DD},{0xCF68BEA624C50F8B,0x8E283810AC57F0D8,0x337ABED9CF},{0xA0DAA223E60EDCA1,0x4DFD19663E44FC9B,0x3053428F49},{0x538E2551A73EAA72,0x8DE608DA4303F3D0,0x11114C16A5},{0x6E1C7AF24A705896,0x23BA7272CCF6680A,0x268BCE0263},{0x45EBDABCB5293B08,0x6C9AABEF6BBF085A,0x17152DB0BA},{0x2DDE625B07DBF472,0xA786C2DC9102A677,0x2B67C0145D},{0x9F2E3FDB12733BD0,0x63DCE261B29DE2A3,0x15CE3CBC2A},{0x656C84A9D9B0B5E2,0xFD90ED26A0F28624,0x9DEA56DD8},{0x9406B3FE0ED61CBA,0xEB7531CE731DBDE2,0x3285A427EA},{0x1E46BD213C008271,0x406017CEA3F6051,0x36B24F04C5},{0x400E6FB6F7E1F1AE,0x6C4E1628A4C68608,0x2DDF0D4321},{0xC3589036EEFA432C,0x4FE8F2552D7C5EF9,0x7C82B858A},{0x4BEAC8993C4C4EF9,0x37F03C98D53600A7,0x20340BE509},{0x3F5CC5AF1F440197,0x3CE44CDF8FA6C95F,0x225774A9F},{0x7B89A9F297682BB9,0xE9404217B1CBA75D,0x251350E519},{0xC4ED823631EC474A,0xEC61965FEBC4CE75,0x6086C91EF},{0x3ADA3FF560C46400,0x91B1E002A2242146,0x37DC8C00E1},{0x3D61178B1EE80000,0xB7B5F157B6111E78,0x3484F7A097},{0xD663D5F310000000,0xF628ADFB8C852D43,0x2353132907},{0x7FB96AA000000000,0xBBFDB66CF2EF8188,0x1DA8BBCCD},{0x5262400000000000,0xB794E9F5DC245E5,0x2FE6B8E601},{0x680000000000000,0xBE83ECF5311726DC,0x3E46AF25},{0,0x26C9569E5A850621,0x8C9BACB4D},{0,0x78780FDC41B00A00,0x11F6969CAF},{0,0xA26E208EBE40000,0x28DADC98F0},{0,0xB6167D49E8000000,0x37E37A797E},{0,0x25C9E11000000000,0x1D8094B415},{0,0x5F36A00000000000,0x4EC7EF221},{0,0x5A40000000000000,0x7C51F32DD},{0,0x8000000000000000,0x3389A3B3B6},{0,0,0x2A7DD90100},{0x6F4FDF5E13E8A2C4,291341},{0x136ED32AC26BFD75,0x108F936BAF85C},{0x552795C9CF514391,0xA69CA8E627D6E2AB,15793},{0xDA5FAF0B5CCF5176,0x42E818F1668C8A86,0x295CD082A2},{0x6B5893B9006452F8,0xC7888F634EC1D336,0x25C787C629},{0x64F155C841DA962C,0xE608686B8A22EE08,0x9BA3F78A3},{0x2F5502110CDB83B6,0x3BEC00DEB022F799,0x26291DA4A2},{0x3FD9C78D7FDD929A,0x113DBB14D76DEFF6,0x25C5E77374},{0x7F0CA2F8B9374FDA,0xDCE606CDA31E861,0x1B06272EDB},{0x54E76CD309993534,0xEFDAA6BFA44B4569,0x3300A1B743},{0xB6089B001002D65D,0x1B965EA6CB3864A,0xFD15B4939},{0xC0855BEA7C4CF1F,0xA07DBDB7A8DC7089,0xD45DDBF60},{0x1903B8823158FBBE,0xAC194DC939034C45,0x167F69C500},{0xEF47EC7CA27C9DEF,0x2290D58C68836D7F,0x2811E3F2},{0xBD06CF9382B1AC51,0x1B0DF3C40F827793,0x38605F3B9E},{0x3DA5F6B8B22AEEA1,0xD5DD1A47EDCADB17,0x24CFD53EEB},{0xF0D8CF68BEA624C5,0xD9CF8E283810AC57,0x36E8E2B2D0},{0xFC9BA0DAA223E60E,0x8F494DFD19663E44,0x30A07AA87C},{0xF3D0538E2551A73E,0x16A58DE608DA4303,0x1D00566022},{0x680A6E1C7AF24A70,0x26323BA7272CCF6,0x7EFD4AD2A},{0x85A45EBDABCB529,0xB0BA6C9AABEF6BBF,0x9C7F36EC1},{0xA6772DDE625B07DB,0x145DA786C2DC9102,0x2D18D81CA0},{0xE2A39F2E3FDB1273,0xBC2A63DCE261B29D,0x25457C2604},{0x8624656C84A9D9B0,0x6DD8FD90ED26A0F2,0x11A3AB2FD},{0xBDE29406B3FE0ED6,0x27EAEB7531CE731D,0x3B018D0FA6},{0x60511E46BD213C00,0x4C50406017CEA3F,0x26AFAA4315},{0x8608400E6FB6F7E1,0x43216C4E1628A4C6,0x4E4CEDC35},{0x5EF9C3589036EEFA,0x858A4FE8F2552D7C,0xC66AD1D09},{0xA74BEAC8993C4C,0xE50937F03C98D536,0x23788B8FD},{0xC95F3F5CC5AF1F44,0x4A9F3CE44CDF8FA6,0x3B1D4D3E29},{0xA75D7B89A9F29768,0xE519E9404217B1CB,0x99D2A2BB4},{0xCE75C4ED823631EC,0x91EFEC61965FEBC4,0x2A1E2D871E},{0x21463ADA3FF560C4,0xE191B1E002A224,0x71E1E34F6},{0x1E783D61178B1EE8,0xA097B7B5F157B611,0x3946F2A0F7},{0x2D43D663D5F31000,0x2907F628ADFB8C85,0x39A7BCF753},{0x81887FB96AA00000,0xBCCDBBFDB66CF2EF,0x135CBD22E5},{0x45E5526240000000,0xE6010B794E9F5DC2,0x357D6C4510},{0x26DC068000000000,0xAF25BE83ECF53117,0x3EF39EFC2},{0x621000000000000,0xCB4D26C9569E5A85,0x2D5414ADD0},{0xA00000000000000,0x9CAF78780FDC41B0,0x309D19D4C4},{0,0x98F00A26E208EBE4,0x2DC6FDD5F4},{0,0x797EB6167D49E800,0x38F324536A},{0,0xB41525C9E1100000,0x18CA614E0E},{0,0xF2215F36A0000000,0x36C64CE86},{0,0x32DD5A4000000000,0x1F6B65D413},{0,0xB3B6800000000000,0x47854C317},{0,0x100000000000000,0x584BFDF17},{0,0,0x55B23C0CA},{0,0,0x2F08236400},{0x720D6F4FDF5E13E8,4},{0xF85C136ED32AC26B,0x108F936BA},{0xE2AB552795C9CF51,0x3DB1A69CA8E627D6},{0x8A86DA5FAF0B5CCF,0x82A242E818F1668C,0xE5D3EF2},{0xD3366B5893B90064,0xC629C7888F634EC1,0x3876BD561B},{0xEE0864F155C841DA,0x78A3E608686B8A22,0x67776C07B},{0xF7992F5502110CDB,0xA4A23BEC00DEB022,0x1CBF75C5CD},{0xEFF63FD9C78D7FDD,0x7374113DBB14D76D,0x2FE148B14F},{0xE8617F0CA2F8B937,0x2EDB0DCE606CDA31,0x127FA5E4E5},{0x456954E76CD30999,0xB743EFDAA6BFA44B,0x355C5F82ED},{0x864AB6089B001002,0x493901B965EA6CB3,0x3758F879C1},{0x70890C0855BEA7C4,0xBF60A07DBDB7A8DC,0x2D00BEB377},{0x4C451903B8823158,0xC500AC194DC93903,0x1BE182E21F},{0x6D7FEF47EC7CA27C,0xE3F22290D58C6883,0x7659CBB83},{0x7793BD06CF9382B1,0x3B9E1B0DF3C40F82,0x1EB547FF7D},{0xDB173DA5F6B8B22A,0x3EEBD5DD1A47EDCA,0x1D28761E63},{0xAC57F0D8CF68BEA6,0xB2D0D9CF8E283810,0x171B8283CE},{0x3E44FC9BA0DAA223,0xA87C8F494DFD1966,0x302030CCEE},{0x4303F3D0538E2551,0x602216A58DE608DA,0x37912260E6},{0xCCF6680A6E1C7AF2,0xAD2A026323BA7272,0x35A3737794},{0x6BBF085A45EBDABC,0x6EC1B0BA6C9AABEF,0x229DCE2A75},{0x9102A6772DDE625B,0x1CA0145DA786C2DC,0x1B5787EDA4},{0xB29DE2A39F2E3FDB,0x2604BC2A63DCE261,0x2635D39B94},{0xA0F28624656C84A9,0xB2FD6DD8FD90ED26,0x227E56DC36},{0x731DBDE29406B3FE,0xFA627EAEB7531CE,0xCBC533E01},{0xEA3F60511E46BD21,0x431504C50406017C,0x3F3F8B80},{0xA4C68608400E6FB6,0xDC3543216C4E1628,0x1DDD0367AC},{0x2D7C5EF9C3589036,0x1D09858A4FE8F255,0x283F452445},{0xD53600A74BEAC899,0xB8FDE50937F03C98,0x10177B326A},{0x8FA6C95F3F5CC5AF,0x3E294A9F3CE44CDF,0x18D92A027D},{0xB1CBA75D7B89A9F2,0x2BB4E519E9404217,0x1D290DBC16},{0xEBC4CE75C4ED8236,0x871E91EFEC61965F,0x5297A7A1B},{0xA22421463ADA3FF5,0x34F600E191B1E002,0x668C90CA4},{0xB6111E783D61178B,0xA0F7A097B7B5F157,0x263B7E1FFA},{0x8C852D43D663D5F3,0xF7532907F628ADFB,0x3A5AA3A9FC},{0xF2EF81887FB96AA0,0x22E5BCCDBBFDB66C,0x3AE5F48DA3},{0x5DC245E552624000,0x4510E6010B794E9F,0x25FBAEAA40},{0x311726DC06800000,0xEFC2AF25BE83ECF5,0xEF6C727AB},{0x5A85062100000000,0xADD0CB4D26C9569E,0x280837C4AA},{0x41B00A0000000000,0xD4C49CAF78780FDC,0x27BD425B9B},{0xEBE4000000000000,0xD5F498F00A26E208,0x2448424445},{0xE800000000000000,0x536A797EB6167D49,0x1042892F36},{0,0x4E0EB41525C9E110,0xCA61295DF},{0,0xCE86F2215F36A000,0x33FE028BF0},{0,0xD41332DD5A400000,0x38113359F1},{0,0xC317B3B680000000,0x384E18D19C},{0,0xDF17010000000000,0x247FBF849D},{0,0xC0CA000000000000,0x24C1DF1319},{0,0x6400000000000000,0x5FF00D9A3},{0,0,0x260AD714E8},{0,0,0x3604471000},{0x36BAF85C136ED32A,67833},{0x27D6E2AB552795C9,0x3DB1A69CA8E6},{0x668C8A86DA5FAF0B,0x3EF282A242E818F1,3677},{0x4EC1D3366B5893B9,0x561BC629C7888F63,0x15B5E355A9},{0x8A22EE0864F155C8,0xC07B78A3E608686B,0x276D3BD152},{0xB022F7992F550211,0xC5CDA4A23BEC00DE,0x1344658AF5},{0xD76DEFF63FD9C78D,0xB14F7374113DBB14,0x39393150BA},{0xDA31E8617F0CA2F8,0xE4E52EDB0DCE606C,0x2B77BF494F},{0xA44B456954E76CD3,0x82EDB743EFDAA6BF,0x129A0F8E47},{0x6CB3864AB6089B00,0x79C1493901B965EA,0x10A669F98C},{0xA8DC70890C0855BE,0xB377BF60A07DBDB7,0x20B4FFA238},{0x39034C451903B882,0xE21FC500AC194DC9,0xD33A54CC0},{0x68836D7FEF47EC7C,0xBB83E3F22290D58C,0x2CE8BD8BF0},{0xF827793BD06CF93,0xFF7D3B9E1B0DF3C4,0x380CC626D5},{0xEDCADB173DA5F6B8,0x1E633EEBD5DD1A47,0x31D34669AC},{0x3810AC57F0D8CF68,0x83CEB2D0D9CF8E28,0x281312F72E},{0x19663E44FC9BA0DA,0xCCEEA87C8F494DFD,0xAD480A18E},{0x8DA4303F3D0538E,0x60E6602216A58DE6,0x213F92F61A},{0x7272CCF6680A6E1C,0x7794AD2A026323BA,0x624483333},{0xABEF6BBF085A45EB,0x2A756EC1B0BA6C9A,0xBFBADCFB4},{0xC2DC9102A6772DDE,0xEDA41CA0145DA786,0x29F2B8C4AB},{0xE261B29DE2A39F2E,0x9B942604BC2A63DC,0x2807B970D5},{0xED26A0F28624656C,0xDC36B2FD6DD8FD90,0x31BC0348A4},{0x31CE731DBDE29406,0x3E010FA627EAEB75,0x26626F29EB},{0x17CEA3F60511E46,0x8B80431504C50406,0x36C5872A2B},{0x1628A4C68608400E,0x67ACDC3543216C4E,0xA237AD6B1},{0xF2552D7C5EF9C358,0x24451D09858A4FE8,0x294E29308B},{0x3C98D53600A74BEA,0x326AB8FDE50937F0,0x20657D89E3},{0x4CDF8FA6C95F3F5C,0x27D3E294A9F3CE4,0x34E5FE329E},{0x4217B1CBA75D7B89,0xBC162BB4E519E940,0x24CA1D0AA1},{0x965FEBC4CE75C4ED,0x7A1B871E91EFEC61,0x25A823DFD2},{0xE002A22421463ADA,0xCA434F600E191B1,0x310167E10D},{0xF157B6111E783D61,0x1FFAA0F7A097B7B5,0x309CDBEF6},{0xADFB8C852D43D663,0xA9FCF7532907F628,0x394E303519},{0xB66CF2EF81887FB9,0x8DA322E5BCCDBBFD,0x5F9B1CF4E},{0x4E9F5DC245E55262,0xAA404510E6010B79,0x124A23C8F0},{0xECF5311726DC0680,0x27ABEFC2AF25BE83,0x3808C120EB},{0x569E5A8506210000,0xC4AAADD0CB4D26C9,0x36C0540AFD},{0xFDC41B00A000000,0x5B9BD4C49CAF7878,0x3B15C3E1EA},{0xE208EBE400000000,0x4445D5F498F00A26,0x3690D0F210},{0x7D49E80000000000,0x2F36536A797EB616,0x3C9920031},{0xE110000000000000,0x95DF4E0EB41525C9,0xB739EBB28},{0xA000000000000000,0x8BF0CE86F2215F36,0x97314A594},{0,0x59F1D41332DD5A40,0x229611E4E1},{0,0xD19CC317B3B68000,0x3477FCA852},{0,0x849DDF1701000000,0x13486292A9},{0,0x1319C0CA00000000,0x27780FEC07},{0,0xD9A3640000000000,0x1A5AE01FE},{0,0x14E8000000000000,0x3B5640AC11},{0,0x1000000000000000,0x3FA25860F},{0,0,0x381CB82A0},{0,0,0x2540BE4000},{0xA8E627D6E2AB5527,0x3DB1A69C},{0x18F1668C8A86DA5F,0xE5D3EF282A242E8},{0x8F634EC1D3366B58,0x55A9561BC629C788,0x3582CEF},{0x686B8A22EE0864F1,0xD152C07B78A3E608,0x37B974684D},{0xDEB022F7992F55,0x8AF5C5CDA4A23BEC,0x121E4B654F},{0xBB14D76DEFF63FD9,0x50BAB14F7374113D,0x12851F0015},{0x606CDA31E8617F0C,0x494FE4E52EDB0DCE,0x4F67E68DF},{0xA6BFA44B456954E7,0x8E4782EDB743EFDA,0x33FCE7B3A9},{0x65EA6CB3864AB608,0xF98C79C1493901B9,0x277A4FDC75},{0xBDB7A8DC70890C08,0xA238B377BF60A07D,0x1B77D89579},{0x4DC939034C451903,0x4CC0E21FC500AC19,0x1C51EEA179},{0xD58C68836D7FEF47,0x8BF0BB83E3F22290,0x1C3E0856B5},{0xF3C40F827793BD06,0x26D5FF7D3B9E1B0D,0x2A4505EA74},{0x1A47EDCADB173DA5,0x69AC1E633EEBD5DD,0x1B0B2E5542},{0x8E283810AC57F0D8,0xF72E83CEB2D0D9CF,0xF7682A3EC},{0x4DFD19663E44FC9B,0xA18ECCEEA87C8F49,0x372C3F6566},{0x8DE608DA4303F3D0,0xF61A60E6602216A5,0x17E54A149C},{0x23BA7272CCF6680A,0x33337794AD2A0263,0x248B9FFA64},{0x6C9AABEF6BBF085A,0xCFB42A756EC1B0BA,0x175462B9EB},{0xA786C2DC9102A677,0xC4ABEDA41CA0145D,0x36E7738A0E},{0x63DCE261B29DE2A3,0x70D59B942604BC2A,0x370419661},{0xFD90ED26A0F28624,0x48A4DC36B2FD6DD8,0x16AFEBFE63},{0xEB7531CE731DBDE2,0x29EB3E010FA627EA,0x171DC6093F},{0x406017CEA3F6051,0x2A2B8B80431504C5,0xEB4DA45E1},{0x6C4E1628A4C68608,0xD6B167ACDC354321,0x346CDD129E},{0x4FE8F2552D7C5EF9,0x308B24451D09858A,0x24FB855F05},{0x37F03C98D53600A7,0x89E3326AB8FDE509,0x135535D5D},{0x3CE44CDF8FA6C95F,0x329E027D3E294A9F,0x15C7561E18},{0xE9404217B1CBA75D,0xAA1BC162BB4E519,0x5A24BF591},{0xEC61965FEBC4CE75,0xDFD27A1B871E91EF,0x21C5261E07},{0x91B1E002A2242146,0xE10D0CA434F600E1,0x1D5585D5D},{0xB7B5F157B6111E78,0xBEF61FFAA0F7A097,0x15DBA17757},{0xF628ADFB8C852D43,0x3519A9FCF7532907,0x146E10D61C},{0xBBFDB66CF2EF8188,0xCF4E8DA322E5BCCD,0x6914B1D83},{0xB794E9F5DC245E5,0xC8F0AA404510E601,0x1EB079D179},{0xBE83ECF5311726DC,0x20EB27ABEFC2AF25,0x1C5AF27091},{0x26C9569E5A850621,0xAFDC4AAADD0CB4D,0x21CA568394},{0x78780FDC41B00A00,0xE1EA5B9BD4C49CAF,0x22780BE9A7},{0xA26E208EBE40000,0xF2104445D5F498F0,0x271693625A},{0xB6167D49E8000000,0x312F36536A797E,0x152CC72086},{0x25C9E11000000000,0xBB2895DF4E0EB415,0x1F33112F9E},{0x5F36A00000000000,0xA5948BF0CE86F221,0x24F51C30A2},{0x5A40000000000000,0xE4E159F1D41332DD,0x25DE812E43},{0x8000000000000000,0xA852D19CC317B3B6,0xFCECD31E4},{0,0x92A9849DDF170100,0x353D0CC4F2},{0,0xEC071319C0CA0000,0x387A78B343},{0,0x1FED9A364000000,0xFD07735E6},{0,0xAC1114E800000000,0x358D886D0A},{0,0x860F100000000000,0x27C1BDDDD},{0,0x82A0000000000000,0x3393D6E987},{0,0x4000000000000000,0x1F8D0A6152},{0,0,0x13267B6680},{0,0,0x1DCD650000},{0xA69CA8E627D6E2AB,15793},{0x42E818F1668C8A86,0xE5D3EF282A2},{0xC7888F634EC1D336,0x2CEF55A9561BC629,856},{0xE608686B8A22EE08,0x684DD152C07B78A3,0x1487ABC42C},{0x3BEC00DEB022F799,0x654F8AF5C5CDA4A2,0xA56E3B85B},{0x113DBB14D76DEFF6,0x1550BAB14F7374,0x15479C64D1},{0xDCE606CDA31E861,0x68DF494FE4E52EDB,0x30A963E07E},{0xEFDAA6BFA44B4569,0xB3A98E4782EDB743,0x1D6E9A4AF7},{0x1B965EA6CB3864A,0xDC75F98C79C14939,0x39AC2D9B8D},{0xA07DBDB7A8DC7089,0x9579A238B377BF60,0x210795BF70},{0xAC194DC939034C45,0xA1794CC0E21FC500,0x1A3685C980},{0x2290D58C68836D7F,0x56B58BF0BB83E3F2,0x1DF2FD9712},{0x1B0DF3C40F827793,0xEA7426D5FF7D3B9E,0x4451278E1},{0xD5DD1A47EDCADB17,0x554269AC1E633EEB,0x3499A211D2},{0xD9CF8E283810AC57,0xA3ECF72E83CEB2D0,0x30F8D38F94},{0x8F494DFD19663E44,0x6566A18ECCEEA87C,0x229BA782DD},{0x16A58DE608DA4303,0x149CF61A60E66022,0x338C3C58FC},{0x26323BA7272CCF6,0xFA6433337794AD2A,0x3AB12B7B67},{0xB0BA6C9AABEF6BBF,0xB9EBCFB42A756EC1,0x183593C3A6},{0x145DA786C2DC9102,0x8A0EC4ABEDA41CA0,0x26D1A8BF6D},{0xBC2A63DCE261B29D,0x966170D59B942604,0x19810CE325},{0x6DD8FD90ED26A0F2,0xFE6348A4DC36B2FD,0x8C0629447},{0x27EAEB7531CE731D,0x93F29EB3E010FA6,0x10C328B832},{0x4C50406017CEA3F,0x45E12A2B8B804315,0xBA66299F4},{0x43216C4E1628A4C6,0x129ED6B167ACDC35,0x38DFCDAD4F},{0x858A4FE8F2552D7C,0x5F05308B24451D09,0x12691A33B9},{0xE50937F03C98D536,0x5D5D89E3326AB8FD,0x2B28FBA049},{0x4A9F3CE44CDF8FA6,0x1E18329E027D3E29,0x1114E09CB8},{0xE519E9404217B1CB,0xF5910AA1BC162BB4,0x2ADE42F5F7},{0x91EFEC61965FEBC4,0x1E07DFD27A1B871E,0x39BB85CE78},{0xE191B1E002A224,0x5D5DE10D0CA434F6,0x1BF78CA904},{0xA097B7B5F157B611,0x7757BEF61FFAA0F7,0x104283F03},{0x2907F628ADFB8C85,0xD61C3519A9FCF753,0xCE99BFF6},{0xBCCDBBFDB66CF2EF,0x1D83CF4E8DA322E5,0x3978981227},{0xE6010B794E9F5DC2,0xD179C8F0AA404510,0x91B73FF5B},{0xAF25BE83ECF53117,0x709120EB27ABEFC2,0x1560CB87DC},{0xCB4D26C9569E5A85,0x83940AFDC4AAADD0,0x33533B1AB6},{0x9CAF78780FDC41B0,0xE9A7E1EA5B9BD4C4,0x2A7EAE4969},{0x98F00A26E208EBE4,0x625AF2104445D5F4,0x18A8E3D26D},{0x797EB6167D49E800,0x208600312F36536A,0x1977CE701B},{0xB41525C9E1100000,0x2F9EBB2895DF4E0E,0x650E5DA51},{0xF2215F36A0000000,0x30A2A5948BF0CE86,0x12E7104A32},{0x32DD5A4000000000,0x2E43E4E159F1D413,0xBAF8E5861},{0xB3B6800000000000,0x31E4A852D19CC317,0x16A06C2919},{0x100000000000000,0xC4F292A9849DDF17,0x5DDBB97B6},{0,0xB343EC071319C0CA,0x2A8DE69920},{0,0x35E601FED9A36400,0x79D164BB5},{0,0x6D0AAC1114E80000,0x2A30FD6B5A},{0,0xDDDD860F10000000,0x150DCE681D},{0,0xE98782A000000000,0x6F4311638},{0,0x6152400000000000,0xD403B9EE4},{0,0x6680000000000000,0x352C84B505},{0,0,0x141E36BE1},{0,0,0x34630B8A00},{0x82A242E818F1668C,0xE5D3EF2},{0xC629C7888F634EC1,0x3582CEF55A9561B},{0x78A3E608686B8A22,0xC42C684DD152C07B,0xC75809},{0xA4A23BEC00DEB022,0xB85B654F8AF5C5CD,0x2461DF38B},{0x7374113DBB14D76D,0x64D1001550BAB14F,0x2087F836CC},{0x2EDB0DCE606CDA31,0xE07E68DF494FE4E5,0x2F96D2184B},{0xB743EFDAA6BFA44B,0x4AF7B3A98E4782ED,0x11AA9E0D5A},{0x493901B965EA6CB3,0x9B8DDC75F98C79C1,0x1505DF6E91},{0xBF60A07DBDB7A8DC,0xBF709579A238B377,0x21E6E429E3},{0xC500AC194DC93903,0xC980A1794CC0E21F,0x3506D3D13B},{0xE3F22290D58C6883,0x971256B58BF0BB83,0xDEB970997},{0x3B9E1B0DF3C40F82,0x78E1EA7426D5FF7D,0x234B79B838},{0x3EEBD5DD1A47EDCA,0x11D2554269AC1E63,0xD26015852},{0xB2D0D9CF8E283810,0x8F94A3ECF72E83CE,0x131BBAF43D},{0xA87C8F494DFD1966,0x82DD6566A18ECCEE,0xE5550347D},{0x602216A58DE608DA,0x58FC149CF61A60E6,0x1D390CC8D0},{0xAD2A026323BA7272,0x7B67FA6433337794,0x30827C069B},{0x6EC1B0BA6C9AABEF,0xC3A6B9EBCFB42A75,0x243373E2A1},{0x1CA0145DA786C2DC,0xBF6D8A0EC4ABEDA4,0x25A9E6C386},{0x2604BC2A63DCE261,0xE325966170D59B94,0x1F5F97B9C2},{0xB2FD6DD8FD90ED26,0x9447FE6348A4DC36,0x2D60301580},{0xFA627EAEB7531CE,0xB832093F29EB3E01,0x1DEFEB3FF0},{0x431504C50406017C,0x99F445E12A2B8B80,0x380C004792},{0xDC3543216C4E1628,0xAD4F129ED6B167AC,0x22221F9687},{0x1D09858A4FE8F255,0x33B95F05308B2445,0x1F96FA899C},{0xB8FDE50937F03C98,0xA0495D5D89E3326A,0x245E5E1739},{0x3E294A9F3CE44CDF,0x9CB81E18329E027D,0xD6AC8CD20},{0x2BB4E519E9404217,0xF5F7F5910AA1BC16,0x797D6715A},{0x871E91EFEC61965F,0xCE781E07DFD27A1B,0x152DAFE2D7},{0x34F600E191B1E002,0xA9045D5DE10D0CA4,0x323F122C18},{0xA0F7A097B7B5F157,0x3F037757BEF61FFA,0x5BDDD2382},{0xF7532907F628ADFB,0xBFF6D61C3519A9FC,0x1E53467A4F},{0x22E5BCCDBBFDB66C,0x12271D83CF4E8DA3,0x1291764B4E},{0x4510E6010B794E9F,0xFF5BD179C8F0AA40,0x122D6389A7},{0xEFC2AF25BE83ECF5,0x87DC709120EB27AB,0x271D6E5601},{0xADD0CB4D26C9569E,0x1AB683940AFDC4AA,0x5B3CBDC1},{0xD4C49CAF78780FDC,0x4969E9A7E1EA5B9B,0x2CF5EA8132},{0xD5F498F00A26E208,0xD26D625AF2104445,0xBB553407D},{0x536A797EB6167D49,0x701B208600312F36,0x1D4B931382},{0x4E0EB41525C9E110,0xDA512F9EBB2895DF,0x1E5EB49D45},{0xCE86F2215F36A000,0x4A3230A2A5948BF0,0x10438D2914},{0xD41332DD5A400000,0x58612E43E4E159F1,0x4B95E35F2},{0xC317B3B680000000,0x291931E4A852D19C,0x386CE6C9DC},{0xDF17010000000000,0x97B6C4F292A9849D,0x3342974015},{0xC0CA000000000000,0x9920B343EC071319,0x507056D0C},{0x6400000000000000,0x4BB535E601FED9A3,0x2EEE897D0},{0,0x6B5A6D0AAC1114E8,0x307F64AA2B},{0,0x681DDDDD860F1000,0xA1BFEAE3C},{0,0x1638E98782A00000,0xE10852E41},{0,0x9EE4615240000000,0xF2779D797},{0,0xB505668000000000,0x234D4BDB30},{0,0x6BE1000000000000,0xB572B92B5},{0,0x8A00000000000000,0x2A3D8EE779},{0,0,0x1C4C4AEAE4},{0,0,0x3515DBE800},{0x3EF282A242E818F1,3677},{0x561BC629C7888F63,0x3582CEF55A9},{0xC07B78A3E608686B,0x5809C42C684DD152,199},{0xC5CDA4A23BEC00DE,0xF38BB85B654F8AF5,0x2E69D2818D},{0xB14F7374113DBB14,0x36CC64D1001550BA,0x210CF5B7B6},{0xE4E52EDB0DCE606C,0x184BE07E68DF494F,0x2A6CCDD96E},{0x82EDB743EFDAA6BF,0xD5A4AF7B3A98E47,0x19A22AF98E},{0x79C1493901B965EA,0x6E919B8DDC75F98C,0x2112F7EE21},{0xB377BF60A07DBDB7,0x29E3BF709579A238,0x7C8B273B0},{0xE21FC500AC194DC9,0xD13BC980A1794CC0,0x29042BB12D},{0xBB83E3F22290D58C,0x997971256B58BF0,0xAAAECCC81},{0xFF7D3B9E1B0DF3C4,0xB83878E1EA7426D5,0x1E0B3B8693},{0x1E633EEBD5DD1A47,0x585211D2554269AC,0x2264C66531},{0x83CEB2D0D9CF8E28,0xF43D8F94A3ECF72E,0xB7D30FB2A},{0xCCEEA87C8F494DFD,0x347D82DD6566A18E,0xA004301D8},{0x60E6602216A58DE6,0xC8D058FC149CF61A,0x3256D31A14},{0x7794AD2A026323BA,0x69B7B67FA643333,0x4D6D9384C},{0x2A756EC1B0BA6C9A,0xE2A1C3A6B9EBCFB4,0x11B37DCC2F},{0xEDA41CA0145DA786,0xC386BF6D8A0EC4AB,0xB262F663A},{0x9B942604BC2A63DC,0xB9C2E325966170D5,0xDAE980B75},{0xDC36B2FD6DD8FD90,0x15809447FE6348A4,0x1B68FE8E2A},{0x3E010FA627EAEB75,0x3FF0B832093F29EB,0x9CC66C67D},{0x8B80431504C50406,0x479299F445E12A2B,0x1D2977C5B6},{0x67ACDC3543216C4E,0x9687AD4F129ED6B1,0x2A70B5AC25},{0x24451D09858A4FE8,0x899C33B95F05308B,0x8C06B7B56},{0x326AB8FDE50937F0,0x1739A0495D5D89E3,0x14260A1078},{0x27D3E294A9F3CE4,0xCD209CB81E18329E,0x1BF5F702EE},{0xBC162BB4E519E940,0x715AF5F7F5910AA1,0x3799AA5798},{0x7A1B871E91EFEC61,0xE2D7CE781E07DFD2,0x237E4C70D9},{0xCA434F600E191B1,0x2C18A9045D5DE10D,0x32BB061F66},{0x1FFAA0F7A097B7B5,0x23823F037757BEF6,0x17C9F0D495},{0xA9FCF7532907F628,0x7A4FBFF6D61C3519,0x22B95C0EE4},{0x8DA322E5BCCDBBFD,0x4B4E12271D83CF4E,0x3532563DBA},{0xAA404510E6010B79,0x89A7FF5BD179C8F0,0x2B5FFF4A91},{0x27ABEFC2AF25BE83,0x560187DC709120EB,0x21E2B95D88},{0xC4AAADD0CB4D26C9,0xBDC11AB683940AFD,0x1FBE41AB18},{0x5B9BD4C49CAF7878,0x81324969E9A7E1EA,0x5C2B12D0C},{0x4445D5F498F00A26,0x407DD26D625AF210,0x2E9562D1D},{0x2F36536A797EB616,0x1382701B20860031,0x6CF8CE013},{0x95DF4E0EB41525C9,0x9D45DA512F9EBB28,0x47107D9B2},{0x8BF0CE86F2215F36,0x29144A3230A2A594,0x29963EA56F},{0x59F1D41332DD5A40,0x35F258612E43E4E1,0x19E1AE19B8},{0xD19CC317B3B68000,0xC9DC291931E4A852,0x2AE3D0A8B8},{0x849DDF1701000000,0x401597B6C4F292A9,0x2B0640FB31},{0x1319C0CA00000000,0x6D0C9920B343EC07,0xB778C6385},{0xD9A3640000000000,0x97D04BB535E601FE,0x1F10CEC8EA},{0x14E8000000000000,0xAA2B6B5A6D0AAC11,0x369ED5708A},{0x1000000000000000,0xAE3C681DDDDD860F,0x20490FCA22},{0,0x2E411638E98782A0,0x8132019D1},{0,0xD7979EE461524000,0x30B423E1C5},{0,0xDB30B50566800000,0x2E104FBEF1},{0,0x92B56BE100000000,0x384FC0EBF9},{0,0xE7798A0000000000,0x3A1BB6FEC2},{0,0xEAE4000000000000,0x2D61320C90},{0,0xE800000000000000,0x21BDC2327F},{0,0,0x1DC7CE7D10},{0,0,0x3B9ACA000},{0x55A9561BC629C788,0x3582CEF},{0xD152C07B78A3E608,0xC75809C42C684D},{0x8AF5C5CDA4A23BEC,0x818DF38BB85B654F,0x2E69D2},{0x50BAB14F7374113D,0xB7B636CC64D10015,0x310323C0BF},{0x494FE4E52EDB0DCE,0xD96E184BE07E68DF,0x2CA342C933},{0x8E4782EDB743EFDA,0xF98E0D5A4AF7B3A9,0xC12761564},{0xF98C79C1493901B9,0xEE216E919B8DDC75,0x1782918971},{0xA238B377BF60A07D,0x73B029E3BF709579,0x1A86C4DA7E},{0x4CC0E21FC500AC19,0xB12DD13BC980A179,0x1D711EF8E9},{0x8BF0BB83E3F22290,0xCC810997971256B5,0x3669228A96},{0x26D5FF7D3B9E1B0D,0x8693B83878E1EA74,0x231C4FC033},{0x69AC1E633EEBD5DD,0x6531585211D25542,0xBFF2BA882},{0xF72E83CEB2D0D9CF,0xFB2AF43D8F94A3EC,0x1E5C2A22E2},{0xA18ECCEEA87C8F49,0x1D8347D82DD6566,0x34D9211851},{0xF61A60E6602216A5,0x1A14C8D058FC149C,0x12DC67DB9D},{0x33337794AD2A0263,0x384C069B7B67FA64,0x249400715D},{0xCFB42A756EC1B0BA,0xCC2FE2A1C3A6B9EB,0x15B456F1AD},{0xC4ABEDA41CA0145D,0x663AC386BF6D8A0E,0x2877250127},{0x70D59B942604BC2A,0xB75B9C2E3259661,0x92C622114},{0x48A4DC36B2FD6DD8,0x8E2A15809447FE63,0x4AAC2D7AC},{0x29EB3E010FA627EA,0xC67D3FF0B832093F,0x282D196072},{0x2A2B8B80431504C5,0xC5B6479299F445E1,0x1AB924D5B3},{0xD6B167ACDC354321,0xAC259687AD4F129E,0x29DB43CC27},{0x308B24451D09858A,0x7B56899C33B95F05,0x93CA98623},{0x89E3326AB8FDE509,0x10781739A0495D5D,0x842E12318},{0x329E027D3E294A9F,0x2EECD209CB81E18,0x59A589297},{0xAA1BC162BB4E519,0x5798715AF5F7F591,0x2328FBF53E},{0xDFD27A1B871E91EF,0x70D9E2D7CE781E07,0xE83E204F2},{0xE10D0CA434F600E1,0x1F662C18A9045D5D,0x3872996766},{0xBEF61FFAA0F7A097,0xD49523823F037757,0x17C6FC0466},{0x3519A9FCF7532907,0xEE47A4FBFF6D61C,0x17F12B64A4},{0xCF4E8DA322E5BCCD,0x3DBA4B4E12271D83,0x2632A11162},{0xC8F0AA404510E601,0x4A9189A7FF5BD179,0x16DFA09621},{0x20EB27ABEFC2AF25,0x5D88560187DC7091,0x7C050AB1D},{0xAFDC4AAADD0CB4D,0xAB18BDC11AB68394,0x6D64FDBA3},{0xE1EA5B9BD4C49CAF,0x2D0C81324969E9A7,0x261B64C59F},{0xF2104445D5F498F0,0x2D1D407DD26D625A,0x250FA094D8},{0x312F36536A797E,0xE0131382701B2086,0x32551B750E},{0xBB2895DF4E0EB415,0xD9B29D45DA512F9E,0x376A2EDC7},{0xA5948BF0CE86F221,0xA56F29144A3230A2,0x2E8802D178},{0xE4E159F1D41332DD,0x19B835F258612E43,0x1C171355E0},{0xA852D19CC317B3B6,0xA8B8C9DC291931E4,0x342D6DC18A},{0x92A9849DDF170100,0xFB31401597B6C4F2,0x2048B97ED0},{0xEC071319C0CA0000,0x63856D0C9920B343,0x30A8405B9A},{0x1FED9A364000000,0xC8EA97D04BB535E6,0x23F24970EC},{0xAC1114E800000000,0x708AAA2B6B5A6D0A,0x372179C4A5},{0x860F100000000000,0xCA22AE3C681DDDDD,0x2684F8336F},{0x82A0000000000000,0x19D12E411638E987,0x1A072DCC84},{0x4000000000000000,0xE1C5D7979EE46152,0x1EC1D2F9DD},{0,0xBEF1DB30B5056680,0x33A9317DD9},{0,0xEBF992B56BE10000,0x32B2AA6BAC},{0,0xFEC2E7798A000000,0x2842F0EB24},{0,0xC90EAE400000000,0x89D155D9E},{0,0x327FE80000000000,0x24CC75AB3A},{0,0x7D10000000000000,0xD8CD3C742},{0,0xA000000000000000,0xF7B06624E},{0,0,0x124E6A4A40},{0,0,0xEE6B28000},{0x2CEF55A9561BC629,856},{0x684DD152C07B78A3,0xC75809C42C},{0x654F8AF5C5CDA4A2,0x69D2818DF38BB85B,46},{0x1550BAB14F7374,0xC0BFB7B636CC64D1,0xACE73CBFD},{0x68DF494FE4E52EDB,0xC933D96E184BE07E,0x3B14DA5CC2},{0xB3A98E4782EDB743,0x1564F98E0D5A4AF7,0x2D5A25AF10},{0xDC75F98C79C14939,0x8971EE216E919B8D,0x3BEA7D523},{0x9579A238B377BF60,0xDA7E73B029E3BF70,0x84629FADE},{0xA1794CC0E21FC500,0xF8E9B12DD13BC980,0x33E31A6D22},{0x56B58BF0BB83E3F2,0x8A96CC8109979712,0x8248330D2},{0xEA7426D5FF7D3B9E,0xC0338693B83878E1,0x31053E4133},{0x554269AC1E633EEB,0xA8826531585211D2,0xC0C9654AB},{0xA3ECF72E83CEB2D0,0x22E2FB2AF43D8F94,0x27F7A0DEBA},{0x6566A18ECCEEA87C,0x185101D8347D82DD,0x2B56962BF5},{0x149CF61A60E66022,0xDB9D1A14C8D058FC,0x3910CCB157},{0xFA6433337794AD2A,0x715D384C069B7B67,0x1474BCA4CE},{0xB9EBCFB42A756EC1,0xF1ADCC2FE2A1C3A6,0x3010F39380},{0x8A0EC4ABEDA41CA0,0x127663AC386BF6D,0x1E05AA2F4F},{0x966170D59B942604,0x21140B75B9C2E325,0x1265091D2C},{0xFE6348A4DC36B2FD,0xD7AC8E2A15809447,0xA464E56CC},{0x93F29EB3E010FA6,0x6072C67D3FF0B832,0x2FB19024BF},{0x45E12A2B8B804315,0xD5B3C5B6479299F4,0x2C8EF17AE4},{0x129ED6B167ACDC35,0xCC27AC259687AD4F,0x35479D8D55},{0x5F05308B24451D09,0x86237B56899C33B9,0x13F9EDA7A1},{0x5D5D89E3326AB8FD,0x231810781739A049,0x259B94529D},{0x1E18329E027D3E29,0x929702EECD209CB8,0x249619A5F6},{0xF5910AA1BC162BB4,0xF53E5798715AF5F7,0x3968DF8C2F},{0x1E07DFD27A1B871E,0x4F270D9E2D7CE78,0xB2A84BD34},{0x5D5DE10D0CA434F6,0x67661F662C18A904,0xC1C97E5C1},{0x7757BEF61FFAA0F7,0x466D49523823F03,0x2D07C55842},{0xD61C3519A9FCF753,0x64A40EE47A4FBFF6,0xF5EEE7053},{0x1D83CF4E8DA322E5,0x11623DBA4B4E1227,0x136A9E2789},{0xD179C8F0AA404510,0x96214A9189A7FF5B,0x1FE9E2410A},{0x709120EB27ABEFC2,0xAB1D5D88560187DC,0x2770056AC},{0x83940AFDC4AAADD0,0xDBA3AB18BDC11AB6,0x2833D6F33D},{0xE9A7E1EA5B9BD4C4,0xC59F2D0C81324969,0xE6705A832},{0x625AF2104445D5F4,0x94D82D1D407DD26D,0xBD23EA112},{0x208600312F36536A,0x750EE0131382701B,0x4538A05E3},{0x2F9EBB2895DF4E0E,0xEDC7D9B29D45DA51,0x34F58252F4},{0x30A2A5948BF0CE86,0xD178A56F29144A32,0x3906E55D04},{0x2E43E4E159F1D413,0x55E019B835F25861,0x11F309DFD},{0x31E4A852D19CC317,0xC18AA8B8C9DC2919,0x3AFBF8347F},{0xC4F292A9849DDF17,0x7ED0FB31401597B6,0x1DBEDA3103},{0xB343EC071319C0CA,0x5B9A63856D0C9920,0xD05735AC},{0x35E601FED9A36400,0x70ECC8EA97D04BB5,0x282153B017},{0x6D0AAC1114E80000,0xC4A5708AAA2B6B5A,0x57532FFD9},{0xDDDD860F10000000,0x336FCA22AE3C681D,0x32B3FE41A0},{0xE98782A000000000,0xCC8419D12E411638,0x254CB81D6B},{0x6152400000000000,0xF9DDE1C5D7979EE4,0x19195088CA},{0x6680000000000000,0x7DD9BEF1DB30B505,0x2F42509BAB},{0,0x6BACEBF992B56BE1,0x27EDB2354C},{0,0xEB24FEC2E7798A00,0x11CB05ED5E},{0,0x5D9E0C90EAE40000,0x161995E083},{0,0xAB3A327FE8000000,0x1E960165D7},{0,0xC7427D1000000000,0x3236DD97C1},{0,0x624EA00000000000,0x2D1E17180C},{0,0x4A40000000000000,0x2E22507BE},{0,0x8000000000000000,0x2C4E2B9116},{0,0,0x53D1AC100},{0xC42C684DD152C07B,0xC75809},{0xB85B654F8AF5C5CD,0x2E69D2818DF38B},{0x64D1001550BAB14F,0xCBFDC0BFB7B636CC,708211},{0xE07E68DF494FE4E5,0x5CC2C933D96E184B,0x1AF6079108},{0x4AF7B3A98E4782ED,0xAF101564F98E0D5A,0x1F26F4ABD},{0x9B8DDC75F98C79C1,0xD5238971EE216E91,0x2C2A09B0BD},{0xBF709579A238B377,0xFADEDA7E73B029E3,0x2C32E7323B},{0xC980A1794CC0E21F,0x6D22F8E9B12DD13B,0xDF7159A5E},{0x971256B58BF0BB83,0x30D28A96CC810997,0x15FC3F3885},{0x78E1EA7426D5FF7D,0x4133C0338693B838,0x1F02C8FD1E},{0x11D2554269AC1E63,0x54ABA88265315852,0x70B5205E0},{0x8F94A3ECF72E83CE,0xDEBA22E2FB2AF43D,0x343B2781E8},{0x82DD6566A18ECCEE,0x2BF5185101D8347D,0x363822A1C2},{0x58FC149CF61A60E6,0xB157DB9D1A14C8D0,0x2D358924BA},{0x7B67FA6433337794,0xA4CE715D384C069B,0x2B77C13E66},{0xC3A6B9EBCFB42A75,0x9380F1ADCC2FE2A1,0x17E60BB65B},{0xBF6D8A0EC4ABEDA4,0x2F4F0127663AC386,0x15525DB5A8},{0xE325966170D59B94,0x1D2C21140B75B9C2,0x272898601F},{0x9447FE6348A4DC36,0x56CCD7AC8E2A1580,0x73E894530},{0xB832093F29EB3E01,0x24BF6072C67D3FF0,0xB413B916C},{0x99F445E12A2B8B80,0x7AE4D5B3C5B64792,0x192DDB8B59},{0xAD4F129ED6B167AC,0x8D55CC27AC259687,0x14D56D45E1},{0x33B95F05308B2445,0xA7A186237B56899C,0x3483F3C52F},{0xA0495D5D89E3326A,0x529D231810781739,0xB1872AB5A},{0x9CB81E18329E027D,0xA5F6929702EECD20,0x1507A72ECD},{0xF5F7F5910AA1BC16,0x8C2FF53E5798715A,0x2FE197EF11},{0xCE781E07DFD27A1B,0xBD3404F270D9E2D7,0x415EB3AFC},{0xA9045D5DE10D0CA4,0xE5C167661F662C18,0x3AD86C3BB9},{0x3F037757BEF61FFA,0x58420466D4952382,0x2B485A7877},{0xBFF6D61C3519A9FC,0x705364A40EE47A4F,0x1BC9807A5E},{0x12271D83CF4E8DA3,0x278911623DBA4B4E,0x15FCFD4EFE},{0xFF5BD179C8F0AA40,0x410A96214A9189A7,0x3B2CC8EAA8},{0x87DC709120EB27AB,0x56ACAB1D5D885601,0x272CB9544A},{0x1AB683940AFDC4AA,0xF33DDBA3AB18BDC1,0x114EEC97B2},{0x4969E9A7E1EA5B9B,0xA832C59F2D0C8132,0x29AA42C8C3},{0xD26D625AF2104445,0xA11294D82D1D407D,0x2D8E1144CE},{0x701B208600312F36,0x5E3750EE0131382,0x301C0F3894},{0xDA512F9EBB2895DF,0x52F4EDC7D9B29D45,0x2276DBC374},{0x4A3230A2A5948BF0,0x5D04D178A56F2914,0x1B15742399},{0x58612E43E4E159F1,0x9DFD55E019B835F2,0x23B52B1492},{0x291931E4A852D19C,0x347FC18AA8B8C9DC,0x2223101DDA},{0x97B6C4F292A9849D,0x31037ED0FB314015,0x32CE0933E2},{0x9920B343EC071319,0x35AC5B9A63856D0C,0x34AA0FC501},{0x4BB535E601FED9A3,0xB01770ECC8EA97D0,0x4819F725},{0x6B5A6D0AAC1114E8,0xFFD9C4A5708AAA2B,0x8C65F1212},{0x681DDDDD860F1000,0x41A0336FCA22AE3C,0x46C741734},{0x1638E98782A00000,0x1D6BCC8419D12E41,0xC2AB8A202},{0x9EE4615240000000,0x88CAF9DDE1C5D797,0x7E0F3632},{0xB505668000000000,0x9BAB7DD9BEF1DB30,0xBC414F1A0},{0x6BE1000000000000,0x354C6BACEBF992B5,0x2564FCE600},{0x8A00000000000000,0xED5EEB24FEC2E779,0xC68D6D7},{0,0xE0835D9E0C90EAE4,0x3246440C97},{0,0x65D7AB3A327FE800,0x235C932CC1},{0,0x97C1C7427D100000,0x2D0768928F},{0,0x180C624EA0000000,0x216ECC413D},{0,0x7BE4A4000000000,0xE397B8715},{0,0x9116800000000000,0x4E5801BB1},{0,0xC100000000000000,0x2957CD9384},{0,0,0x1EE8BFDA4A},{0,0,0x113ABE6400},{0x5809C42C684DD152,199},{0xF38BB85B654F8AF5,0x2E69D2818D},{0x36CC64D1001550BA,0xCE73CBFDC0BFB7B6,10},{0x184BE07E68DF494F,0x91085CC2C933D96E,0x2841D6893},{0xD5A4AF7B3A98E47,0x4ABDAF101564F98E,0x225BA69CD9},{0x6E919B8DDC75F98C,0xB0BDD5238971EE21,0x32979C226D},{0x29E3BF709579A238,0x323BFADEDA7E73B0,0x198A0E9FC7},{0xD13BC980A1794CC0,0x9A5E6D22F8E9B12D,0x2E61053889},{0x997971256B58BF0,0x388530D28A96CC81,0x2009C733C3},{0xB83878E1EA7426D5,0xFD1E4133C0338693,0x2D7410BCF8},{0x585211D2554269AC,0x5E054ABA8826531,0x39F8E2B4F4},{0xF43D8F94A3ECF72E,0x81E8DEBA22E2FB2A,0x38D0E6C919},{0x347D82DD6566A18E,0xA1C22BF5185101D8,0x5F05CF1EC},{0xC8D058FC149CF61A,0x24BAB157DB9D1A14,0x37185BC693},{0x69B7B67FA643333,0x3E66A4CE715D384C,0x22426F3A29},{0xE2A1C3A6B9EBCFB4,0xB65B9380F1ADCC2F,0x99A51BCF7},{0xC386BF6D8A0EC4AB,0xB5A82F4F0127663A,0x39ACCE43F9},{0xB9C2E325966170D5,0x601F1D2C21140B75,0x3A23DA136A},{0x15809447FE6348A4,0x453056CCD7AC8E2A,0x18C478EE49},{0x3FF0B832093F29EB,0x916C24BF6072C67D,0x110F3F93AD},{0x479299F445E12A2B,0x8B597AE4D5B3C5B6,0x2869765C45},{0x9687AD4F129ED6B1,0x45E18D55CC27AC25,0x10312A531B},{0x899C33B95F05308B,0xC52FA7A186237B56,0x659988A65},{0x1739A0495D5D89E3,0xAB5A529D23181078,0x17B1FAE7E4},{0xCD209CB81E18329E,0x2ECDA5F6929702EE,0x353DC15495},{0x715AF5F7F5910AA1,0xEF118C2FF53E5798,0x22BBFD43E3},{0xE2D7CE781E07DFD2,0x3AFCBD3404F270D9,0x3511EAB681},{0x2C18A9045D5DE10D,0x3BB9E5C167661F66,0x1E16BBB430},{0x23823F037757BEF6,0x787758420466D495,0xB3AEDD4E8},{0x7A4FBFF6D61C3519,0x7A5E705364A40EE4,0x3620536830},{0x4B4E12271D83CF4E,0x4EFE278911623DBA,0xB4983A141},{0x89A7FF5BD179C8F0,0xEAA8410A96214A91,0xF34B1A054},{0x560187DC709120EB,0x544A56ACAB1D5D88,0x13C56CF15D},{0xBDC11AB683940AFD,0x97B2F33DDBA3AB18,0x15BADB7B34},{0x81324969E9A7E1EA,0xC8C3A832C59F2D0C,0xC3EC2FF68},{0x407DD26D625AF210,0x44CEA11294D82D1D,0x1865A08BE1},{0x1382701B20860031,0x389405E3750EE013,0x347310C3B7},{0x9D45DA512F9EBB28,0xC37452F4EDC7D9B2,0x2AA8D2B90B},{0x29144A3230A2A594,0x23995D04D178A56F,0x2BD28AB52},{0x35F258612E43E4E1,0x14929DFD55E019B8,0x131FDE92C9},{0xC9DC291931E4A852,0x1DDA347FC18AA8B8,0x2ED152D4D8},{0x401597B6C4F292A9,0x33E231037ED0FB31,0x32518DC6EB},{0x6D0C9920B343EC07,0xC50135AC5B9A6385,0x36C32BEE4D},{0x97D04BB535E601FE,0xF725B01770ECC8EA,0x121B6D278B},{0xAA2B6B5A6D0AAC11,0x1212FFD9C4A5708A,0x209696CD45},{0xAE3C681DDDDD860F,0x173441A0336FCA22,0x1014EDC0A8},{0x2E411638E98782A0,0xA2021D6BCC8419D1,0x2722FBA2DE},{0xD7979EE461524000,0x363288CAF9DDE1C5,0x33D5F39DE3},{0xDB30B50566800000,0xF1A09BAB7DD9BEF1,0x34E6DF88B0},{0x92B56BE100000000,0xE600354C6BACEBF9,0x2932ACFD26},{0xE7798A0000000000,0xD6D7ED5EEB24FEC2,0x90E8719E4},{0xEAE4000000000000,0xC97E0835D9E0C90,0x3547E19320},{0xE800000000000000,0x2CC165D7AB3A327F,0x77647DE0B},{0,0x928F97C1C7427D10,0x29A125020},{0,0x413D180C624EA000,0x79578F600},{0,0x871507BE4A400000,0xF3086C5},{0,0x1BB1911680000000,0x2DFD90F806},{0,0x9384C10000000000,0x16C13671B},{0,0xDA4A000000000000,0x66BAC18BD},{0,0x6400000000000000,0x2C341A2CC2},{0,0,0x2D42958AE8},{0,0,0x3604471000},{0x818DF38BB85B654F,0x2E69D2},{0xB7B636CC64D10015,0xACE73CBFDC0BF},{0xD96E184BE07E68DF,0x689391085CC2C933,164893},{0xF98E0D5A4AF7B3A9,0x9CD94ABDAF101564,0x6D8E21FB6},{0xEE216E919B8DDC75,0x226DB0BDD5238971,0x2A849086B4},{0x73B029E3BF709579,0x9FC7323BFADEDA7E,0x29F0DA20E2},{0xB12DD13BC980A179,0x38899A5E6D22F8E9,0x34C3D9D87B},{0xCC810997971256B5,0x33C3388530D28A96,0x1CB088F3F7},{0x8693B83878E1EA74,0xBCF8FD1E4133C033,0x398E66304E},{0x6531585211D25542,0xB4F405E054ABA882,0x125529313A},{0xFB2AF43D8F94A3EC,0xC91981E8DEBA22E2,0xDAB336AEE},{0x1D8347D82DD6566,0xF1ECA1C22BF51851,0x3798BA44F6},{0x1A14C8D058FC149C,0xC69324BAB157DB9D,0x397F11EC85},{0x384C069B7B67FA64,0x3A293E66A4CE715D,0x1F25A6ECAB},{0xCC2FE2A1C3A6B9EB,0xBCF7B65B9380F1AD,0x27DDEF9A15},{0x663AC386BF6D8A0E,0x43F9B5A82F4F0127,0x50FB1EB26},{0xB75B9C2E3259661,0x136A601F1D2C2114,0x8E8CDA2B8},{0x8E2A15809447FE63,0xEE49453056CCD7AC,0x2ADBC67176},{0xC67D3FF0B832093F,0x93AD916C24BF6072,0x1BB0D4130B},{0xC5B6479299F445E1,0x5C458B597AE4D5B3,0x2B208F974},{0xAC259687AD4F129E,0x531B45E18D55CC27,0x1B179F59C2},{0x7B56899C33B95F05,0x8A65C52FA7A18623,0x2D3EA69D16},{0x10781739A0495D5D,0xE7E4AB5A529D2318,0x53F867EDE},{0x2EECD209CB81E18,0x54952ECDA5F69297,0x33E6391607},{0x5798715AF5F7F591,0x43E3EF118C2FF53E,0x1B4ED0C45},{0x70D9E2D7CE781E07,0xB6813AFCBD3404F2,0x10208706C8},{0x1F662C18A9045D5D,0xB4303BB9E5C16766,0x2EBB6BF257},{0xD49523823F037757,0xD4E8787758420466,0x146B8EB6F5},{0xEE47A4FBFF6D61C,0x68307A5E705364A4,0x393CB5A19B},{0x3DBA4B4E12271D83,0xA1414EFE27891162,0x242EFA7993},{0x4A9189A7FF5BD179,0xA054EAA8410A9621,0x225F6D8BBB},{0x5D88560187DC7091,0xF15D544A56ACAB1D,0x2BAF6611AC},{0xAB18BDC11AB68394,0x7B3497B2F33DDBA3,0x2844322B05},{0x2D0C81324969E9A7,0xFF68C8C3A832C59F,0x146B58FD0},{0x2D1D407DD26D625A,0x8BE144CEA11294D8,0x30A93BB4D6},{0xE0131382701B2086,0xC3B7389405E3750E,0x31F3F65ABE},{0xD9B29D45DA512F9E,0xB90BC37452F4EDC7,0x2C6A737CB0},{0xA56F29144A3230A2,0xAB5223995D04D178,0x2925807922},{0x19B835F258612E43,0x92C914929DFD55E0,0x8127258CC},{0xA8B8C9DC291931E4,0xD4D81DDA347FC18A,0x2FA1861086},{0xFB31401597B6C4F2,0xC6EB33E231037ED0,0x1F64943CD5},{0x63856D0C9920B343,0xEE4DC50135AC5B9A,0x31C61A8D67},{0xC8EA97D04BB535E6,0x278BF725B01770EC,0x1832C34939},{0x708AAA2B6B5A6D0A,0xCD451212FFD9C4A5,0xD4EAC255C},{0xCA22AE3C681DDDDD,0xC0A8173441A0336F,0x159B6BA0AF},{0x19D12E411638E987,0xA2DEA2021D6BCC84,0x28EBAB507B},{0xE1C5D7979EE46152,0x9DE3363288CAF9DD,0x1CC94AD7C7},{0xBEF1DB30B5056680,0x88B0F1A09BAB7DD9,0x2E7A15DAC1},{0xEBF992B56BE10000,0xFD26E600354C6BAC,0x2D0F85B7FC},{0xFEC2E7798A000000,0x19E4D6D7ED5EEB24,0x3AE74FE029},{0xC90EAE400000000,0x93200C97E0835D9E,0x991D1BF9B},{0x327FE80000000000,0xDE0B2CC165D7AB3A,0x2438F9A645},{0x7D10000000000000,0x5020928F97C1C742,0x10446B473E},{0xA000000000000000,0xF600413D180C624E,0xE8224E098},{0,0x86C5871507BE4A40,0x239D2EBD4C},{0,0xF8061BB191168000,0x11D154FB4C},{0,0x671B9384C1000000,0x11EBB357C3},{0,0x18BDDA4A00000000,0x2D7EE990F2},{0,0x2CC2640000000000,0x385E15AB0A},{0,0x8AE8000000000000,0x25E77C14D},{0,0x1000000000000000,0x120DE6372B},{0,0,0xA06B99AA0},{0,0,0x2540BE4000},{0x69D2818DF38BB85B,46},{0xC0BFB7B636CC64D1,0xACE73CBFD},{0xC933D96E184BE07E,0x841D689391085CC2,2},{0x1564F98E0D5A4AF7,0x1FB69CD94ABDAF10,0x95F83D0A},{0x8971EE216E919B8D,0x86B4226DB0BDD523,0x25B6E2706},{0xDA7E73B029E3BF70,0x20E29FC7323BFADE,0x184FDB296},{0xF8E9B12DD13BC980,0xD87B38899A5E6D22,0x22F45A7919},{0x8A96CC8109979712,0xF3F733C3388530D2,0x6048504F8},{0xC0338693B83878E1,0x304EBCF8FD1E4133,0x39F6C12C24},{0xA8826531585211D2,0x313AB4F405E054AB,0x86D03C309},{0x22E2FB2AF43D8F94,0x6AEEC91981E8DEBA,0x223E765DD},{0x185101D8347D82DD,0x44F6F1ECA1C22BF5,0x338D86125E},{0xDB9D1A14C8D058FC,0xEC85C69324BAB157,0x15F2E4C8B9},{0x715D384C069B7B67,0xECAB3A293E66A4CE,0x2B49EDD1DE},{0xF1ADCC2FE2A1C3A6,0x9A15BCF7B65B9380,0x33E755BC27},{0x127663AC386BF6D,0xEB2643F9B5A82F4F,0x93874F335},{0x21140B75B9C2E325,0xA2B8136A601F1D2C,0xC8DCBD23B},{0xD7AC8E2A15809447,0x7176EE49453056CC,0xDE28F5D9A},{0x6072C67D3FF0B832,0x130B93AD916C24BF,0x23F58887FE},{0xD5B3C5B6479299F4,0xF9745C458B597AE4,0x3B28039B06},{0xCC27AC259687AD4F,0x59C2531B45E18D55,0x19FB56219},{0x86237B56899C33B9,0x9D168A65C52FA7A1,0x5E703C8E0},{0x231810781739A049,0x7EDEE7E4AB5A529D,0x344C03ED68},{0x929702EECD209CB8,0x160754952ECDA5F6,0x18546C25A5},{0xF53E5798715AF5F7,0xC4543E3EF118C2F,0x266FE53449},{0x4F270D9E2D7CE78,0x6C8B6813AFCBD34,0x1101FEFBFF},{0x67661F662C18A904,0xF257B4303BB9E5C1,0x3B60C39227},{0x466D49523823F03,0xB6F5D4E878775842,0x94D018482},{0x64A40EE47A4FBFF6,0xA19B68307A5E7053,0x1E6F33DC51},{0x11623DBA4B4E1227,0x7993A1414EFE2789,0x13019A7204},{0x96214A9189A7FF5B,0x8BBBA054EAA8410A,0x10AB9B0E7},{0xAB1D5D88560187DC,0x11ACF15D544A56AC,0x35E9350114},{0xDBA3AB18BDC11AB6,0x2B057B3497B2F33D,0x4AC35539C},{0xC59F2D0C81324969,0x8FD0FF68C8C3A832,0x245C575EA3},{0x94D82D1D407DD26D,0xB4D68BE144CEA112,0x26150ABE11},{0x750EE0131382701B,0x5ABEC3B7389405E3,0x41F6233FE},{0xEDC7D9B29D45DA51,0x7CB0B90BC37452F4,0x3B38B54177},{0xD178A56F29144A32,0x7922AB5223995D04,0x1BD1FC0558},{0x55E019B835F25861,0x58CC92C914929DFD,0x149969ABEC},{0xC18AA8B8C9DC2919,0x1086D4D81DDA347F,0x37075F0EF6},{0x7ED0FB31401597B6,0x3CD5C6EB33E23103,0x394A972D34},{0x5B9A63856D0C9920,0x8D67EE4DC50135AC,0xC299B1572},{0x70ECC8EA97D04BB5,0x4939278BF725B017,0x1AABDA6805},{0xC4A5708AAA2B6B5A,0x255CCD451212FFD9,0x13B126446},{0x336FCA22AE3C681D,0xA0AFC0A8173441A0,0x105506369D},{0xCC8419D12E411638,0x507BA2DEA2021D6B,0x24B3578BEB},{0xF9DDE1C5D7979EE4,0xD7C79DE3363288CA,0x36C9D4966A},{0x7DD9BEF1DB30B505,0xDAC188B0F1A09BAB,0x18E0551DBB},{0x6BACEBF992B56BE1,0xB7FCFD26E600354C,0x2BBD006D89},{0xEB24FEC2E7798A00,0xE02919E4D6D7ED5E,0x2010ACA7B5},{0x5D9E0C90EAE40000,0xBF9B93200C97E083,0x2A58A1D491},{0xAB3A327FE8000000,0xA645DE0B2CC165D7,0x21EF491FAF},{0xC7427D1000000000,0x473E5020928F97C1,0x28E586B967},{0x624EA00000000000,0xE098F600413D180C,0x180BDDB62A},{0x4A40000000000000,0xBD4C86C5871507BE,0x9FBB031EE},{0x8000000000000000,0xFB4CF8061BB19116,0x3795FAE476},{0,0x57C3671B9384C100,0x1BB3DBCBC1},{0,0x90F218BDDA4A0000,0x2D0421638F},{0,0xAB0A2CC264000000,0x216D3645B5},{0,0xC14D8AE800000000,0x2A4C439565},{0,0x372B100000000000,0x17B1137230},{0,0x9AA0000000000000,0xB39DE281F},{0,0x4000000000000000,0x75BBED442},{0,0,0xF6CCEC680},{0,0,0x1DCD650000},{0xCBFDC0BFB7B636CC,708211},{0x5CC2C933D96E184B,0x2841D68939108},{0xAF101564F98E0D5A,0x3D0A1FB69CD94ABD,38392},{0xD5238971EE216E91,0x270686B4226DB0BD,0x39CC29ED90},{0xFADEDA7E73B029E3,0xB29620E29FC7323B,0x219027B9C3},{0x6D22F8E9B12DD13B,0x7919D87B38899A5E,0x2D907C72CE},{0x30D28A96CC810997,0x4F8F3F733C33885,0x3012C0B9FF},{0x4133C0338693B838,0x2C24304EBCF8FD1E,0x3B605797E9},{0x54ABA88265315852,0xC309313AB4F405E0,0x364A28E1BB},{0xDEBA22E2FB2AF43D,0x65DD6AEEC91981E8,0x2BB77A99C5},{0x2BF5185101D8347D,0x125E44F6F1ECA1C2,0x2DF5D51138},{0xB157DB9D1A14C8D0,0xC8B9EC85C69324BA,0xD0E230518},{0xA4CE715D384C069B,0xD1DEECAB3A293E66,0x5C53F27BD},{0x9380F1ADCC2FE2A1,0xBC279A15BCF7B65B,0x2C3224683F},{0x2F4F0127663AC386,0xF335EB2643F9B5A8,0xED6E69ACC},{0x1D2C21140B75B9C2,0xD23BA2B8136A601F,0x2FB7F97389},{0x56CCD7AC8E2A1580,0x5D9A7176EE494530,0x2016C8F643},{0x24BF6072C67D3FF0,0x87FE130B93AD916C,0xFAF4E0EEA},{0x7AE4D5B3C5B64792,0x9B06F9745C458B59,0x369B266C89},{0x8D55CC27AC259687,0x621959C2531B45E1,0x2009EE7203},{0xA7A186237B56899C,0xC8E09D168A65C52F,0xC9A78657},{0x529D231810781739,0xED687EDEE7E4AB5A,0x14705FDFD3},{0xA5F6929702EECD20,0x25A5160754952ECD,0x3157DB1F6E},{0x8C2FF53E5798715A,0x34490C4543E3EF11,0x19A5469B17},{0xBD3404F270D9E2D7,0xFBFF06C8B6813AFC,0x567149906},{0xE5C167661F662C18,0x9227F257B4303BB9,0x1A04CE0D1},{0x58420466D4952382,0x8482B6F5D4E87877,0x30CB667E35},{0x705364A40EE47A4F,0xDC51A19B68307A5E,0xC75E6115B},{0x278911623DBA4B4E,0x72047993A1414EFE,0x156351D532},{0x410A96214A9189A7,0xB0E78BBBA054EAA8,0xBBEC76CAD},{0x56ACAB1D5D885601,0x11411ACF15D544A,0x2870CAD615},{0xF33DDBA3AB18BDC1,0x539C2B057B3497B2,0x4E3F2D8FF},{0xA832C59F2D0C8132,0x5EA38FD0FF68C8C3,0x3B72A6C1D5},{0xA11294D82D1D407D,0xBE11B4D68BE144CE,0x31ADD2FD36},{0x5E3750EE0131382,0x33FE5ABEC3B73894,0xCBEE79D4E},{0x52F4EDC7D9B29D45,0x41777CB0B90BC374,0x1235449AF3},{0x5D04D178A56F2914,0x5587922AB522399,0x38A32BDD46},{0x9DFD55E019B835F2,0xABEC58CC92C91492,0x104D91DB5B},{0x347FC18AA8B8C9DC,0xEF61086D4D81DDA,0x15580D3A4D},{0x31037ED0FB314015,0x2D343CD5C6EB33E2,0x11F10A83A3},{0x35AC5B9A63856D0C,0x15728D67EE4DC501,0x25FE14FD1D},{0xB01770ECC8EA97D0,0x68054939278BF725,0x6C587406C},{0xFFD9C4A5708AAA2B,0x6446255CCD451212,0x193D855522},{0x41A0336FCA22AE3C,0x369DA0AFC0A81734,0x801E79FEE},{0x1D6BCC8419D12E41,0x8BEB507BA2DEA202,0x37769F25F3},{0x88CAF9DDE1C5D797,0x966AD7C79DE33632,0x38B4819382},{0x9BAB7DD9BEF1DB30,0x1DBBDAC188B0F1A0,0x1E67A026B1},{0x354C6BACEBF992B5,0x6D89B7FCFD26E600,0x293CF1EFE2},{0xED5EEB24FEC2E779,0xA7B5E02919E4D6D7,0x34B8274CAE},{0xE0835D9E0C90EAE4,0xD491BF9B93200C97,0x28AA419E67},{0x65D7AB3A327FE800,0x1FAFA645DE0B2CC1,0x182CC56491},{0x97C1C7427D100000,0xB967473E5020928F,0x21CA0D0DFC},{0x180C624EA0000000,0xB62AE098F600413D,0x3AD789BFD7},{0x7BE4A4000000000,0x31EEBD4C86C58715,0x323969AD4C},{0x9116800000000000,0xE476FB4CF8061BB1,0x11BD942EA4},{0xC100000000000000,0xCBC157C3671B9384,0x26645AF7C3},{0,0x638F90F218BDDA4A,0x2D9658A04F},{0,0x45B5AB0A2CC26400,0x127BF29F54},{0,0x9565C14D8AE80000,0x139F054CB5},{0,0x7230372B10000000,0x2A47399AA5},{0,0x281F9AA000000000,0x26855A59D2},{0,0xD442400000000000,0x30EE513F4E},{0,0xC680000000000000,0x125A952816},{0,0,0x54D84E1A1},{0,0,0x257C590A00},{0xCE73CBFDC0BFB7B6,10},{0x91085CC2C933D96E,0x2841D6893},{0x4ABDAF101564F98E,0x95F83D0A1FB69CD9},{0xB0BDD5238971EE21,0xED90270686B4226D,0x22EAE3BB},{0x323BFADEDA7E73B0,0xB9C3B29620E29FC7,0x2BC1616B29},{0x9A5E6D22F8E9B12D,0x72CE7919D87B3889,0x9B70AC676},{0x388530D28A96CC81,0xB9FF04F8F3F733C3,0x1B94141CB4},{0xFD1E4133C0338693,0x97E92C24304EBCF8,0x2A14244451},{0x5E054ABA8826531,0xE1BBC309313AB4F4,0x12FF58814E},{0x81E8DEBA22E2FB2A,0x99C565DD6AEEC919,0x125DB84F04},{0xA1C22BF5185101D8,0x1138125E44F6F1EC,0x11238A08F},{0x24BAB157DB9D1A14,0x518C8B9EC85C693,0x214F792B8D},{0x3E66A4CE715D384C,0x27BDD1DEECAB3A29,0x20D5710D31},{0xB65B9380F1ADCC2F,0x683FBC279A15BCF7,0xB71E170EA},{0xB5A82F4F0127663A,0x9ACCF335EB2643F9,0x3693C25CF6},{0x601F1D2C21140B75,0x7389D23BA2B8136A,0x396AC8F17D},{0x453056CCD7AC8E2A,0xF6435D9A7176EE49,0x1D357B4186},{0x916C24BF6072C67D,0xEEA87FE130B93AD,0x1F6C5C296A},{0x8B597AE4D5B3C5B6,0x6C899B06F9745C45,0x18B190B632},{0x45E18D55CC27AC25,0x7203621959C2531B,0xBBD80CB26},{0xC52FA7A186237B56,0x8657C8E09D168A65,0x8F385B39B},{0xAB5A529D23181078,0xDFD3ED687EDEE7E4,0x2435FFC41B},{0x2ECDA5F6929702EE,0x1F6E25A516075495,0x67D707BD1},{0xEF118C2FF53E5798,0x9B1734490C4543E3,0x30B0B04DBC},{0x3AFCBD3404F270D9,0x9906FBFF06C8B681,0x2BE9C87762},{0x3BB9E5C167661F66,0xE0D19227F257B430,0x16F4E27706},{0x787758420466D495,0x7E358482B6F5D4E8,0x199F8F826},{0x7A5E705364A40EE4,0x115BDC51A19B6830,0x8F65CA152},{0x4EFE278911623DBA,0xD53272047993A141,0x131B9F5EBB},{0xEAA8410A96214A91,0x6CADB0E78BBBA054,0x2BBBB516D9},{0x544A56ACAB1D5D88,0xD615011411ACF15D,0x329F82F802},{0x97B2F33DDBA3AB18,0xD8FF539C2B057B34,0xA90DDCCE},{0xC8C3A832C59F2D0C,0xC1D55EA38FD0FF68,0x3029149916},{0x44CEA11294D82D1D,0xFD36BE11B4D68BE1,0x54C6EBC1C},{0x389405E3750EE013,0x9D4E33FE5ABEC3B7,0x6BFE2D089},{0xC37452F4EDC7D9B2,0x9AF341777CB0B90B,0x200A763D26},{0x23995D04D178A56F,0xDD4605587922AB52,0x8FD0DBCAF},{0x14929DFD55E019B8,0xDB5BABEC58CC92C9,0x28F25503F3},{0x1DDA347FC18AA8B8,0x3A4D0EF61086D4D8,0x38C70080DB},{0x33E231037ED0FB31,0x83A32D343CD5C6EB,0x330AFDD0CE},{0xC50135AC5B9A6385,0xFD1D15728D67EE4D,0x301534BF72},{0xF725B01770ECC8EA,0x406C68054939278B,0x1AC5DCB329},{0x1212FFD9C4A5708A,0x55226446255CCD45,0x99ACA4A05},{0x173441A0336FCA22,0x9FEE369DA0AFC0A8,0x13DD858F9},{0xA2021D6BCC8419D1,0x25F38BEB507BA2DE,0x3A1ECB1415},{0x363288CAF9DDE1C5,0x9382966AD7C79DE3,0x4EC88A5B3},{0xF1A09BAB7DD9BEF1,0x26B11DBBDAC188B0,0x29CF93879E},{0xE600354C6BACEBF9,0xEFE26D89B7FCFD26,0x24D28AE2ED},{0xD6D7ED5EEB24FEC2,0x4CAEA7B5E02919E4,0x3766273CBD},{0xC97E0835D9E0C90,0x9E67D491BF9B9320,0x2C1321C039},{0x2CC165D7AB3A327F,0x64911FAFA645DE0B,0xD6A58AF71},{0x928F97C1C7427D10,0xDFCB967473E5020,0x1A66BD6AF5},{0x413D180C624EA000,0xBFD7B62AE098F600,0x390E6505CB},{0x871507BE4A400000,0xAD4C31EEBD4C86C5,0x2F7068E41F},{0x1BB1911680000000,0x2EA4E476FB4CF806,0x76017CE16},{0x9384C10000000000,0xF7C3CBC157C3671B,0x52A2990A6},{0xDA4A000000000000,0xA04F638F90F218BD,0x26E00EEB3E},{0x6400000000000000,0x9F5445B5AB0A2CC2,0xE94D02632},{0,0x4CB59565C14D8AE8,0xBC954367B},{0,0x9AA57230372B1000,0x1CB53B4931},{0,0x59D2281F9AA00000,0xB8CA24CDE},{0,0x3F4ED44240000000,0x33C524EA8B},{0,0x2816C68000000000,0x206BC9204B},{0,0xE1A1000000000000,0x117FAEAB14},{0,0xA00000000000000,0x4DCA04FE3},{0,0,0x34DC9529E4},{0,0,0x3515DBE800},{0x689391085CC2C933,164893},{0x9CD94ABDAF101564,0x95F83D0A1FB6},{0x226DB0BDD5238971,0xE3BBED90270686B4,8938},{0x9FC7323BFADEDA7E,0x6B29B9C3B29620E2,0x36B082A67F},{0x38899A5E6D22F8E9,0xC67672CE7919D87B,0x1DAABD9F78},{0x33C3388530D28A96,0x1CB4B9FF04F8F3F7,0x1C1EC3FC50},{0xBCF8FD1E4133C033,0x445197E92C24304E,0x12A70E223C},{0xB4F405E054ABA882,0x814EE1BBC309313A,0xE082F7500},{0xC91981E8DEBA22E2,0x4F0499C565DD6AEE,0x1E1B5D82},{0xF1ECA1C22BF51851,0xA08F1138125E44F6,0x1E57006A8E},{0xC69324BAB157DB9D,0x2B8D0518C8B9EC85,0x21353E19B9},{0x3A293E66A4CE715D,0xD3127BDD1DEECAB,0x2B1CFFCF5F},{0xBCF7B65B9380F1AD,0x70EA683FBC279A15,0x1621834423},{0x43F9B5A82F4F0127,0x5CF69ACCF335EB26,0x84073EA22},{0x136A601F1D2C2114,0xF17D7389D23BA2B8,0x80033DF60},{0xEE49453056CCD7AC,0x4186F6435D9A7176,0x169245ADA5},{0x93AD916C24BF6072,0x296A0EEA87FE130B,0x267A05EBA6},{0x5C458B597AE4D5B3,0xB6326C899B06F974,0x26B00377EA},{0x531B45E18D55CC27,0xCB267203621959C2,0x36A5E86D1C},{0x8A65C52FA7A18623,0xB39B8657C8E09D16,0x6B43AC9B3},{0xE7E4AB5A529D2318,0xC41BDFD3ED687EDE,0x29D70CAF3D},{0x54952ECDA5F69297,0x7BD11F6E25A51607,0xE618B2218},{0x43E3EF118C2FF53E,0x4DBC9B1734490C45,0x5B356FFBE},{0xB6813AFCBD3404F2,0x77629906FBFF06C8,0x2C4EFB648A},{0xB4303BB9E5C16766,0x7706E0D19227F257,0x203D3CCCC8},{0xD4E8787758420466,0xF8267E358482B6F5,0x2EACA45DDE},{0x68307A5E705364A4,0xA152115BDC51A19B,0x33EA02160C},{0xA1414EFE27891162,0x5EBBD53272047993,0x2F0D0ECA9},{0xA054EAA8410A9621,0x16D96CADB0E78BBB,0x276F3DEBE1},{0xF15D544A56ACAB1D,0xF802D615011411AC,0x34685D76DE},{0x7B3497B2F33DDBA3,0xDCCED8FF539C2B05,0x33E9F9C8BD},{0xFF68C8C3A832C59F,0x9916C1D55EA38FD0,0x2C34B050AC},{0x8BE144CEA11294D8,0xBC1CFD36BE11B4D6,0x282FA48728},{0xC3B7389405E3750E,0xD0899D4E33FE5ABE,0x97BFBFC3A},{0xB90BC37452F4EDC7,0x3D269AF341777CB0,0xDB19F9296},{0xAB5223995D04D178,0xBCAFDD4605587922,0x22FAEF3B2F},{0x92C914929DFD55E0,0x3F3DB5BABEC58CC,0xB1D59B4AD},{0xD4D81DDA347FC18A,0x80DB3A4D0EF61086,0x284886195E},{0xC6EB33E231037ED0,0xD0CE83A32D343CD5,0x1600D69BFD},{0xEE4DC50135AC5B9A,0xBF72FD1D15728D67,0x3B18977B54},{0x278BF725B01770EC,0xB329406C68054939,0x13BB5D8A92},{0xCD451212FFD9C4A5,0x4A0555226446255C,0x2227FE0A08},{0xC0A8173441A0336F,0x58F99FEE369DA0AF,0x1EE124C3C},{0xA2DEA2021D6BCC84,0x141525F38BEB507B,0xE0CFEAC3B},{0x9DE3363288CAF9DD,0xA5B39382966AD7C7,0xDC1599250},{0x88B0F1A09BAB7DD9,0x879E26B11DBBDAC1,0x12C6F3B3C5},{0xFD26E600354C6BAC,0xE2EDEFE26D89B7FC,0x2DFDB0E510},{0x19E4D6D7ED5EEB24,0x3CBD4CAEA7B5E029,0x3EE82AC7B},{0x93200C97E0835D9E,0xC0399E67D491BF9B,0x1CB1836879},{0xDE0B2CC165D7AB3A,0xAF7164911FAFA645,0x1C58EAFBD8},{0x5020928F97C1C742,0x6AF50DFCB967473E,0x327373A6D3},{0xF600413D180C624E,0x5CBBFD7B62AE098,0x31397BA409},{0x86C5871507BE4A40,0xE41FAD4C31EEBD4C,0x219CA905A},{0xF8061BB191168000,0xCE162EA4E476FB4C,0x1529883FFF},{0x671B9384C1000000,0x90A6F7C3CBC157C3,0x3B8F2AEEB5},{0x18BDDA4A00000000,0xEB3EA04F638F90F2,0x2A461EC3AE},{0x2CC2640000000000,0x26329F5445B5AB0A,0x28B9FAF83E},{0x8AE8000000000000,0x367B4CB59565C14D,0xE7861AF50},{0x1000000000000000,0x49319AA57230372B,0x12AD0E7BD7},{0,0x4CDE59D2281F9AA0,0x32200A563C},{0,0xEA8B3F4ED4424000,0xE0A2D111C},{0,0x204B2816C6800000,0x6BB8A006D},{0,0xAB14E1A100000000,0x19686CDAEE},{0,0x4FE30A0000000000,0x3791BD0D8E},{0,0x29E4000000000000,0x212275ACEB},{0,0xE800000000000000,0x36C0D84E35},{0,0,0xC8D101910},{0,0,0x3B9ACA000},{0x1FB69CD94ABDAF10,0x95F83D0A},{0x86B4226DB0BDD523,0x22EAE3BBED902706},{0x20E29FC7323BFADE,0xA67F6B29B9C3B296,0x8213F56},{0xD87B38899A5E6D22,0x9F78C67672CE7919,0x142CC3E5B9},{0xF3F733C3388530D2,0xFC501CB4B9FF04F8,0x2B37FD3C39},{0x304EBCF8FD1E4133,0x223C445197E92C24,0xD8035FFE6},{0x313AB4F405E054AB,0x7500814EE1BBC309,0x35950A1303},{0x6AEEC91981E8DEBA,0x5D824F0499C565DD,0xCE0E3A6D},{0x44F6F1ECA1C22BF5,0x6A8EA08F1138125E,0x1976AD9462},{0xEC85C69324BAB157,0x19B92B8D0518C8B9,0x16EA10A0E2},{0xECAB3A293E66A4CE,0xCF5F0D3127BDD1DE,0x34A4A38EB9},{0x9A15BCF7B65B9380,0x442370EA683FBC27,0x2B432444D9},{0xEB2643F9B5A82F4F,0xEA225CF69ACCF335,0x329612981B},{0xA2B8136A601F1D2C,0xDF60F17D7389D23B,0x67FD6CAD7},{0x7176EE49453056CC,0xADA54186F6435D9A,0x3243020E3B},{0x130B93AD916C24BF,0xEBA6296A0EEA87FE,0xDE51AA287},{0xF9745C458B597AE4,0x77EAB6326C899B06,0x1FA57E4D71},{0x59C2531B45E18D55,0x6D1CCB2672036219,0x1A6B3EC3CE},{0x9D168A65C52FA7A1,0xC9B3B39B8657C8E0,0x300FF6283C},{0x7EDEE7E4AB5A529D,0xAF3DC41BDFD3ED68,0xE273DB7A6},{0x160754952ECDA5F6,0x22187BD11F6E25A5,0x26CF2C2DA1},{0xC4543E3EF118C2F,0xFFBE4DBC9B173449,0x2584494C2A},{0x6C8B6813AFCBD34,0x648A77629906FBFF,0xA02F0A231},{0xF257B4303BB9E5C1,0xCCC87706E0D19227,0xB80095E24},{0xB6F5D4E878775842,0x5DDEF8267E358482,0x891726D9C},{0xA19B68307A5E7053,0x160CA152115BDC51,0x24682E3D64},{0x7993A1414EFE2789,0xECA95EBBD5327204,0x174D99262C},{0x8BBBA054EAA8410A,0xEBE116D96CADB0E7,0xA75B4D975},{0x11ACF15D544A56AC,0x76DEF802D6150114,0x1B74A9D1CB},{0x2B057B3497B2F33D,0xC8BDDCCED8FF539C,0x2F5F6B7115},{0x8FD0FF68C8C3A832,0x50AC9916C1D55EA3,0x5126FB480},{0xB4D68BE144CEA112,0x8728BC1CFD36BE11,0x1DE02D8EC4},{0x5ABEC3B7389405E3,0xFC3AD0899D4E33FE,0x2DC1FAC481},{0x7CB0B90BC37452F4,0x92963D269AF34177,0x1E43B9DA77},{0x7922AB5223995D04,0x3B2FBCAFDD460558,0x1BD7152823},{0x58CC92C914929DFD,0xB4AD03F3DB5BABEC,0x833F167E7},{0x1086D4D81DDA347F,0x195E80DB3A4D0EF6,0x35F2BD648E},{0x3CD5C6EB33E23103,0x9BFDD0CE83A32D34,0x2115C42A90},{0x8D67EE4DC50135AC,0x7B54BF72FD1D1572,0x21AB6370E5},{0x4939278BF725B017,0x8A92B329406C6805,0x356E2DCC6B},{0x255CCD451212FFD9,0xA084A0555226446,0x1909F606E2},{0xA0AFC0A8173441A0,0x4C3C58F99FEE369D,0x34A0FC4DF6},{0x507BA2DEA2021D6B,0xAC3B141525F38BEB,0x39587E1CF6},{0xD7C79DE3363288CA,0x9250A5B39382966A,0x396ED7DD11},{0xDAC188B0F1A09BAB,0xB3C5879E26B11DBB,0x417587827},{0xB7FCFD26E600354C,0xE510E2EDEFE26D89,0x93E6FFEEE},{0xE02919E4D6D7ED5E,0xAC7B3CBD4CAEA7B5,0x379F3D3134},{0xBF9B93200C97E083,0x6879C0399E67D491,0xC4399B93B},{0xA645DE0B2CC165D7,0xFBD8AF7164911FAF,0xDD4FFC8FA},{0x473E5020928F97C1,0xA6D36AF50DFCB967,0x3A6FCC7B81},{0xE098F600413D180C,0xA40905CBBFD7B62A,0x1E2FD76277},{0xBD4C86C5871507BE,0x905AE41FAD4C31EE,0x1BDB252932},{0xFB4CF8061BB19116,0x3FFFCE162EA4E476,0xBC5D7AF28},{0x57C3671B9384C100,0xEEB590A6F7C3CBC1,0x95F1636E0},{0x90F218BDDA4A0000,0xC3AEEB3EA04F638F,0x345F04EDEA},{0xAB0A2CC264000000,0xF83E26329F5445B5,0x36A90C45D8},{0xC14D8AE800000000,0xAF50367B4CB59565,0x328466DC11},{0x372B100000000000,0x7BD749319AA57230,0x41E18E724},{0x9AA0000000000000,0x563C4CDE59D2281F,0x87E99E718},{0x4000000000000000,0x111CEA8B3F4ED442,0x5AA96FA09},{0,0x6D204B2816C680,0x21C6D1CF4},{0,0xDAEEAB14E1A10000,0x38CFA1F06C},{0,0xD8E4FE30A000000,0x19584699C1},{0,0xACEB29E400000000,0x2CF2DA48B7},{0,0x4E35E80000000000,0x2AC3E92690},{0,0x1910000000000000,0x219947569C},{0,0xA000000000000000,0x245828EF66},{0,0,0x17E4ED3A40},{0,0,0xEE6B28000},{0x3D0A1FB69CD94ABD,38392},{0x270686B4226DB0BD,0x22EAE3BBED90},{0xB29620E29FC7323B,0x3F56A67F6B29B9C3,2081},{0x7919D87B38899A5E,0xE5B99F78C67672CE,0x7BDB34E79},{0x4F8F3F733C33885,0x3C39FC501CB4B9FF,0x1C61A628AF},{0x2C24304EBCF8FD1E,0xFFE6223C445197E9,0x28CCD5DD8D},{0xC309313AB4F405E0,0x13037500814EE1BB,0x210FD60640},{0x65DD6AEEC91981E8,0x3A6D5D824F0499C5,0xEEB1FCB0C},{0x125E44F6F1ECA1C2,0x94626A8EA08F1138,0x2D8DC0071},{0xC8B9EC85C69324BA,0xA0E219B92B8D0518,0x1A71DF90D8},{0xD1DEECAB3A293E66,0x8EB9CF5F0D3127BD,0x32700FD2E3},{0xBC279A15BCF7B65B,0x44D9442370EA683F,0x34FB7C3D30},{0xF335EB2643F9B5A8,0x981BEA225CF69ACC,0xB3D0D93BA},{0xD23BA2B8136A601F,0xCAD7DF60F17D7389,0x2B71E12BC6},{0x5D9A7176EE494530,0xE3BADA54186F643,0x2E48F2A266},{0x87FE130B93AD916C,0xA287EBA6296A0EEA,0x17C2FCD826},{0x9B06F9745C458B59,0x4D7177EAB6326C89,0x8FED19552},{0x621959C2531B45E1,0xC3CE6D1CCB267203,0x13299CAE00},{0xC8E09D168A65C52F,0x283CC9B3B39B8657,0x2D96F7D4},{0xED687EDEE7E4AB5A,0xB7A6AF3DC41BDFD3,0x31658D9ECD},{0x25A5160754952ECD,0x2DA122187BD11F6E,0x2FE5B63792},{0x34490C4543E3EF11,0x4C2AFFBE4DBC9B17,0x2208E6EDCB},{0xFBFF06C8B6813AFC,0xA231648A77629906,0x2F557A24E8},{0x9227F257B4303BB9,0x5E24CCC87706E0D1,0x362A0A83DD},{0x8482B6F5D4E87877,0x6D9C5DDEF8267E35,0x338A8BC99E},{0xDC51A19B68307A5E,0x3D64160CA152115B,0x24E30DFC30},{0x72047993A1414EFE,0x262CECA95EBBD532,0xB3B510FBB},{0xB0E78BBBA054EAA8,0xD975EBE116D96CAD,0x2B92F4FDB0},{0x11411ACF15D544A,0xD1CB76DEF802D615,0x292D0C89E3},{0x539C2B057B3497B2,0x7115C8BDDCCED8FF,0x350B19DC55},{0x5EA38FD0FF68C8C3,0xB48050AC9916C1D5,0x13E4B97799},{0xBE11B4D68BE144CE,0x8EC48728BC1CFD36,0x23C9897035},{0x33FE5ABEC3B73894,0xC481FC3AD0899D4E,0xC78497006},{0x41777CB0B90BC374,0xDA7792963D269AF3,0x193618261},{0x5587922AB522399,0x28233B2FBCAFDD46,0x16C8843119},{0xABEC58CC92C91492,0x67E7B4AD03F3DB5B,0x5DB761D81},{0xEF61086D4D81DDA,0x648E195E80DB3A4D,0x1E21310403},{0x2D343CD5C6EB33E2,0x2A909BFDD0CE83A3,0xCA39EAAC},{0x15728D67EE4DC501,0x70E57B54BF72FD1D,0x2815E8C887},{0x68054939278BF725,0xCC6B8A92B329406C,0x1F88E9AC8D},{0x6446255CCD451212,0x6E20A084A055522,0x2103D9A4EE},{0x369DA0AFC0A81734,0x4DF64C3C58F99FEE,0x376B820DB8},{0x8BEB507BA2DEA202,0x1CF6AC3B141525F3,0x2AE9681740},{0x966AD7C79DE33632,0xDD119250A5B39382,0xEED70DCEF},{0x1DBBDAC188B0F1A0,0x7827B3C5879E26B1,0x37D8FB4DBA},{0x6D89B7FCFD26E600,0xFEEEE510E2EDEFE2,0x2B6A70911F},{0xA7B5E02919E4D6D7,0x3134AC7B3CBD4CAE,0x77319A9A9},{0xD491BF9B93200C97,0xB93B6879C0399E67,0x2764A43E43},{0x1FAFA645DE0B2CC1,0xC8FAFBD8AF716491,0xFC4A38EF9},{0xB967473E5020928F,0x7B81A6D36AF50DFC,0x3A2859D79C},{0xB62AE098F600413D,0x6277A40905CBBFD7,0x246F14A6E5},{0x31EEBD4C86C58715,0x2932905AE41FAD4C,0x356863CE79},{0xE476FB4CF8061BB1,0xAF283FFFCE162EA4,0x1C35C10A31},{0xCBC157C3671B9384,0x36E0EEB590A6F7C3,0xB9168D92C},{0x638F90F218BDDA4A,0xEDEAC3AEEB3EA04F,0xA4B61BDA0},{0x45B5AB0A2CC26400,0x45D8F83E26329F54,0x257823360E},{0x9565C14D8AE80000,0xDC11AF50367B4CB5,0x352BA48D8},{0x7230372B10000000,0xE7247BD749319AA5,0x327DD793B0},{0x281F9AA000000000,0xE718563C4CDE59D2,0x29303C0ADF},{0xD442400000000000,0xFA09111CEA8B3F4E,0x3421A44CDC},{0xC680000000000000,0x1CF4006D204B2816,0x33733CDDB1},{0,0xF06CDAEEAB14E1A1,0x293CC367B9},{0,0x99C10D8E4FE30A00,0x2B4AD66FA6},{0,0x48B7ACEB29E40000,0x26CA2B7194},{0,0x26904E35E8000000,0x22866B14B9},{0,0x569C191000000000,0x2B1BD68D43},{0,0xEF66A00000000000,0xFADAD3604},{0,0x3A40000000000000,0x126288F83},{0,0x8000000000000000,0x1E8DC55676},{0,0,0x1B97268100},{0xED90270686B4226D,0x22EAE3BB},{0xB9C3B29620E29FC7,0x8213F56A67F6B29},{0x72CE7919D87B3889,0x4E79E5B99F78C676,0x1E49403},{0xB9FF04F8F3F733C3,0x28AF3C39FC501CB4,0xC515E932},{0x97E92C24304EBCF8,0xDD8DFFE6223C4451,0xBADB47065},{0xE1BBC309313AB4F4,0x64013037500814E,0x17B7A76238},{0x99C565DD6AEEC919,0xCB0C3A6D5D824F04,0xD0B50BBDB},{0x1138125E44F6F1EC,0x7194626A8EA08F,0x332CB1650A},{0x518C8B9EC85C693,0x90D8A0E219B92B8D,0x2542655DF},{0x27BDD1DEECAB3A29,0xD2E38EB9CF5F0D31,0x340D8F77AF},{0x683FBC279A15BCF7,0x3D3044D9442370EA,0x28EFEA0B30},{0x9ACCF335EB2643F9,0x93BA981BEA225CF6,0xB3B44FF2F},{0x7389D23BA2B8136A,0x2BC6CAD7DF60F17D,0xB13D069DF},{0xF6435D9A7176EE49,0xA2660E3BADA54186,0x33F6073EE0},{0xEEA87FE130B93AD,0xD826A287EBA6296A,0x344D4076D0},{0x6C899B06F9745C45,0x95524D7177EAB632,0x30A017B941},{0x7203621959C2531B,0xAE00C3CE6D1CCB26,0xF45118B2E},{0x8657C8E09D168A65,0xF7D4283CC9B3B39B,0xADE53AEE2},{0xDFD3ED687EDEE7E4,0x9ECDB7A6AF3DC41B,0x34D85A1273},{0x1F6E25A516075495,0x37922DA122187BD1,0x1AEB822C62},{0x9B1734490C4543E3,0xEDCB4C2AFFBE4DBC,0x16DE319E4C},{0x9906FBFF06C8B681,0x24E8A231648A7762,0x11E9519A7C},{0xE0D19227F257B430,0x83DD5E24CCC87706,0x1CE791C672},{0x7E358482B6F5D4E8,0xC99E6D9C5DDEF826,0x1AA9A1B3E9},{0x115BDC51A19B6830,0xFC303D64160CA152,0x366ED345A7},{0xD53272047993A141,0xFBB262CECA95EBB,0x271CB16029},{0x6CADB0E78BBBA054,0xFDB0D975EBE116D9,0x98F73FECA},{0xD615011411ACF15D,0x89E3D1CB76DEF802,0x2F43348AAE},{0xD8FF539C2B057B34,0xDC557115C8BDDCCE,0x28A3502D33},{0xC1D55EA38FD0FF68,0x7799B48050AC9916,0xC13232851},{0xFD36BE11B4D68BE1,0x70358EC48728BC1C,0x12F7D2A76F},{0x9D4E33FE5ABEC3B7,0x7006C481FC3AD089,0x19F23DC6A9},{0x9AF341777CB0B90B,0x8261DA7792963D26,0x277344A5C1},{0xDD4605587922AB52,0x311928233B2FBCAF,0x2D0E0DAD18},{0xDB5BABEC58CC92C9,0x1D8167E7B4AD03F3,0x5A1F16C20},{0x3A4D0EF61086D4D8,0x403648E195E80DB,0x77A37EA13},{0x83A32D343CD5C6EB,0xEAAC2A909BFDD0CE,0x46D6C3361},{0xFD1D15728D67EE4D,0xC88770E57B54BF72,0x16CC4A1C8C},{0x406C68054939278B,0xAC8DCC6B8A92B329,0x20C756EEB9},{0x55226446255CCD45,0xA4EE06E20A084A05,0x2B3B08FD91},{0x9FEE369DA0AFC0A8,0xDB84DF64C3C58F9,0x21E912FEEA},{0x25F38BEB507BA2DE,0x17401CF6AC3B1415,0x367EAE69AA},{0x9382966AD7C79DE3,0xDCEFDD119250A5B3,0x279A33F996},{0x26B11DBBDAC188B0,0x4DBA7827B3C5879E,0x2320233A93},{0xEFE26D89B7FCFD26,0x911FFEEEE510E2ED,0x224BFAF732},{0x4CAEA7B5E02919E4,0xA9A93134AC7B3CBD,0xBC6059383},{0x9E67D491BF9B9320,0x3E43B93B6879C039,0x1EA7B5F1FE},{0x64911FAFA645DE0B,0x8EF9C8FAFBD8AF71,0x3B3213AD8F},{0xDFCB967473E5020,0xD79C7B81A6D36AF5,0x216CC0DA65},{0xBFD7B62AE098F600,0xA6E56277A40905CB,0x17B64520BA},{0xAD4C31EEBD4C86C5,0xCE792932905AE41F,0x2B75528B5F},{0x2EA4E476FB4CF806,0xA31AF283FFFCE16,0x164E83BA4D},{0xF7C3CBC157C3671B,0xD92C36E0EEB590A6,0x11EFEE5F4C},{0xA04F638F90F218BD,0xBDA0EDEAC3AEEB3E,0x11E484789B},{0x9F5445B5AB0A2CC2,0x360E45D8F83E2632,0x2442DF0D45},{0x4CB59565C14D8AE8,0x48D8DC11AF50367B,0x101D4E6B56},{0x9AA57230372B1000,0x93B0E7247BD74931,0x1416F5E2A7},{0x59D2281F9AA00000,0xADFE718563C4CDE,0x27045CD83A},{0x3F4ED44240000000,0x4CDCFA09111CEA8B,0xD8399F188},{0x2816C68000000000,0xDDB11CF4006D204B,0x1FBC20B734},{0xE1A1000000000000,0x67B9F06CDAEEAB14,0xC4F0EE525},{0xA00000000000000,0x6FA699C10D8E4FE3,0x8B585C41C},{0,0x719448B7ACEB29E4,0x69EECFFC1},{0,0x14B926904E35E800,0x2D0A242395},{0,0x8D43569C19100000,0x22B5EAC59E},{0,0x3604EF66A0000000,0x24EA6C9AEF},{0,0x8F833A4000000000,0x37B21662C4},{0,0x5676800000000000,0x2DC3ECAC9B},{0,0x8100000000000000,0x242AD9E502},{0,0,0x953E93CA},{0,0,0x2F08236400},{0xE3BBED90270686B4,8938},{0x6B29B9C3B29620E2,0x8213F56A67F},{0xC67672CE7919D87B,0x94034E79E5B99F78,484},{0x1CB4B9FF04F8F3F7,0xE93228AF3C39FC50,0x35385229DD},{0x445197E92C24304E,0x7065DD8DFFE6223C,0x33AAEBF18E},{0x814EE1BBC309313A,0x6238064013037500,0x212A077C07},{0x4F0499C565DD6AEE,0xBBDBCB0C3A6D5D82,0x1B819D2A4},{0xA08F1138125E44F6,0x650A007194626A8E,0x265AE6A63F},{0x2B8D0518C8B9EC85,0x55DF90D8A0E219B9,0xEC29E1BD8},{0xD3127BDD1DEECAB,0x77AFD2E38EB9CF5F,0x325E98E2A1},{0x70EA683FBC279A15,0xB303D3044D94423,0x259836EDD0},{0x5CF69ACCF335EB26,0xFF2F93BA981BEA22,0x30705F01F2},{0xF17D7389D23BA2B8,0x69DF2BC6CAD7DF60,0x3893BD3706},{0x4186F6435D9A7176,0x3EE0A2660E3BADA5,0x17E472EE1},{0x296A0EEA87FE130B,0x76D0D826A287EBA6,0x3471AF542C},{0xB6326C899B06F974,0xB94195524D7177EA,0xA5A44B133},{0xCB267203621959C2,0x8B2EAE00C3CE6D1C,0xC0AF85F0B},{0xB39B8657C8E09D16,0xAEE2F7D4283CC9B3,0x2B00E9801},{0xC41BDFD3ED687EDE,0x12739ECDB7A6AF3D,0x6452D7A6},{0x7BD11F6E25A51607,0x2C6237922DA12218,0x26AAAAC9B6},{0x4DBC9B1734490C45,0x9E4CEDCB4C2AFFBE,0x2A6A6114E9},{0x77629906FBFF06C8,0x9A7C24E8A231648A,0x3664BD4BFD},{0x7706E0D19227F257,0xC67283DD5E24CCC8,0x3B0BF1A715},{0xF8267E358482B6F5,0xB3E9C99E6D9C5DDE,0x511E6F3DD},{0xA152115BDC51A19B,0x45A7FC303D64160C,0x339E840C11},{0x5EBBD53272047993,0x60290FBB262CECA9,0x4057F3F23},{0x16D96CADB0E78BBB,0xFECAFDB0D975EBE1,0x83C8D3933},{0xF802D615011411AC,0x8AAE89E3D1CB76DE,0xC1B2915A0},{0xDCCED8FF539C2B05,0x2D33DC557115C8BD,0x2561085434},{0x9916C1D55EA38FD0,0x28517799B48050AC,0xC25F750A5},{0xBC1CFD36BE11B4D6,0xA76F70358EC48728,0x2674275962},{0xD0899D4E33FE5ABE,0xC6A97006C481FC3A,0x16F83D4003},{0x3D269AF341777CB0,0xA5C18261DA779296,0xE1118980},{0xBCAFDD4605587922,0xAD18311928233B2F,0x1DF3FCD23F},{0x3F3DB5BABEC58CC,0x6C201D8167E7B4AD,0xED364F273},{0x80DB3A4D0EF61086,0xEA130403648E195E,0x1ADFB5856F},{0xD0CE83A32D343CD5,0x3361EAAC2A909BFD,0x1A0E9D8010},{0xBF72FD1D15728D67,0x1C8CC88770E57B54,0x3C5A34288},{0xB329406C68054939,0xEEB9AC8DCC6B8A92,0x1FB0E1056E},{0x4A0555226446255C,0xFD91A4EE06E20A08,0x19D417EED4},{0x58F99FEE369DA0AF,0xFEEA0DB84DF64C3C,0x3197392AB4},{0x141525F38BEB507B,0x69AA17401CF6AC3B,0x2A24301B1A},{0xA5B39382966AD7C7,0xF996DCEFDD119250,0x626529B0D},{0x879E26B11DBBDAC1,0x3A934DBA7827B3C5,0x340F8F09D},{0xE2EDEFE26D89B7FC,0xF732911FFEEEE510,0x249B913FBE},{0x3CBD4CAEA7B5E029,0x9383A9A93134AC7B,0x2C76700AEB},{0xC0399E67D491BF9B,0xF1FE3E43B93B6879,0x36D96FF7B3},{0xAF7164911FAFA645,0xAD8F8EF9C8FAFBD8,0x29E593283D},{0x6AF50DFCB967473E,0xDA65D79C7B81A6D3,0xE5C4B2942},{0x5CBBFD7B62AE098,0x20BAA6E56277A409,0xF90C19A49},{0xE41FAD4C31EEBD4C,0x8B5FCE792932905A,0x1106C26892},{0xCE162EA4E476FB4C,0xBA4D0A31AF283FFF,0x221EBA8E31},{0x90A6F7C3CBC157C3,0x5F4CD92C36E0EEB5,0xB940110B2},{0xEB3EA04F638F90F2,0x789BBDA0EDEAC3AE,0x2987D0C97A},{0x26329F5445B5AB0A,0xD45360E45D8F83E,0x1C83D9158F},{0x367B4CB59565C14D,0x6B5648D8DC11AF50,0x214E8DCF90},{0x49319AA57230372B,0xE2A793B0E7247BD7,0x21A00F6963},{0x4CDE59D2281F9AA0,0xD83A0ADFE718563C,0x1741A1C8B0},{0xEA8B3F4ED4424000,0xF1884CDCFA09111C,0x292CC2FE09},{0x204B2816C6800000,0xB734DDB11CF4006D,0x250AD8E4A},{0xAB14E1A100000000,0xE52567B9F06CDAEE,0x1165665974},{0x4FE30A0000000000,0xC41C6FA699C10D8E,0x1B377DB437},{0x29E4000000000000,0xFFC1719448B7ACEB,0xCFBEA8794},{0xE800000000000000,0x239514B926904E35,0x22B109015A},{0,0xC59E8D43569C1910,0x14FCB3E388},{0,0x9AEF3604EF66A000,0x1FD83E57DE},{0,0x62C48F833A400000,0x33D44DFB9A},{0,0xAC9B567680000000,0x23F21C8940},{0,0xE502810000000000,0xF0EE2AA91},{0,0x93CA000000000000,0x21F7FE75F0},{0,0x6400000000000000,0x3803864A21},{0,0,0x7C63C80E8},{0,0,0x3604471000},{0xA67F6B29B9C3B296,0x8213F56},{0x9F78C67672CE7919,0x1E494034E79E5B9},{0xFC501CB4B9FF04F8,0x29DDE93228AF3C39,0x70D31C},{0x223C445197E92C24,0xF18E7065DD8DFFE6,0x68EAD8D45},{0x7500814EE1BBC309,0x7C07623806401303,0x1048F65431},{0x5D824F0499C565DD,0xD2A4BBDBCB0C3A6D,0xB85815BF1},{0x6A8EA08F1138125E,0xA63F650A00719462,0x384DC37E9A},{0x19B92B8D0518C8B9,0x1BD855DF90D8A0E2,0x2401D2A59A},{0xCF5F0D3127BDD1DE,0xE2A177AFD2E38EB9,0x23E19935E6},{0x442370EA683FBC27,0xEDD00B303D3044D9,0x35C1D5BA8A},{0xEA225CF69ACCF335,0x1F2FF2F93BA981B,0x2058CFA161},{0xDF60F17D7389D23B,0x370669DF2BC6CAD7,0x16961AB887},{0xADA54186F6435D9A,0x2EE13EE0A2660E3B,0x1F7B7045AD},{0xEBA6296A0EEA87FE,0x542C76D0D826A287,0x285284C3FB},{0x77EAB6326C899B06,0xB133B94195524D71,0x3A845D328C},{0x6D1CCB2672036219,0x5F0B8B2EAE00C3CE,0x20C1E888A2},{0xC9B3B39B8657C8E0,0x9801AEE2F7D4283C,0x25CE14F504},{0xAF3DC41BDFD3ED68,0xD7A612739ECDB7A6,0x111CF7442},{0x22187BD11F6E25A5,0xC9B62C6237922DA1,0xF901DBE50},{0xFFBE4DBC9B173449,0x14E99E4CEDCB4C2A,0x12CF5612FB},{0x648A77629906FBFF,0x4BFD9A7C24E8A231,0x3A75A28A85},{0xCCC87706E0D19227,0xA715C67283DD5E24,0x1F091C571F},{0x5DDEF8267E358482,0xF3DDB3E9C99E6D9C,0x75EA581AC},{0x160CA152115BDC51,0xC1145A7FC303D64,0x2844C74442},{0xECA95EBBD5327204,0x3F2360290FBB262C,0xF60B75AF7},{0xEBE116D96CADB0E7,0x3933FECAFDB0D975,0x39910C3A43},{0x76DEF802D6150114,0x15A08AAE89E3D1CB,0xFA6D47023},{0xC8BDDCCED8FF539C,0x54342D33DC557115,0x82B32B19A},{0x50AC9916C1D55EA3,0x50A528517799B480,0x23EEB8743F},{0x8728BC1CFD36BE11,0x5962A76F70358EC4,0xEBDDE8947},{0xFC3AD0899D4E33FE,0x4003C6A97006C481,0x109CBDCE77},{0x92963D269AF34177,0x8980A5C18261DA77,0x1BC3DB7991},{0x3B2FBCAFDD460558,0xD23FAD1831192823,0x21E2B03416},{0xB4AD03F3DB5BABEC,0xF2736C201D8167E7,0x550412918},{0x195E80DB3A4D0EF6,0x856FEA130403648E,0x5CEF622A9},{0x9BFDD0CE83A32D34,0x80103361EAAC2A90,0x277840D38F},{0x7B54BF72FD1D1572,0x42881C8CC88770E5,0x21694800A3},{0x8A92B329406C6805,0x56EEEB9AC8DCC6B,0x26030C36F5},{0xA084A0555226446,0xEED4FD91A4EE06E2,0x390C672C09},{0x4C3C58F99FEE369D,0x2AB4FEEA0DB84DF6,0x2500C9905},{0xAC3B141525F38BEB,0x1B1A69AA17401CF6,0x133F77B54},{0x9250A5B39382966A,0x9B0DF996DCEFDD11,0x139519C1A0},{0xB3C5879E26B11DBB,0xF09D3A934DBA7827,0x2564D83946},{0xE510E2EDEFE26D89,0x3FBEF732911FFEEE,0x108458F4F1},{0xAC7B3CBD4CAEA7B5,0xAEB9383A9A93134,0x382B8FB826},{0x6879C0399E67D491,0xF7B3F1FE3E43B93B,0x8DB84E153},{0xFBD8AF7164911FAF,0x283DAD8F8EF9C8FA,0x138CDBBC79},{0xA6D36AF50DFCB967,0x2942DA65D79C7B81,0x1C358805DB},{0xA40905CBBFD7B62A,0x9A4920BAA6E56277,0x330706291B},{0x905AE41FAD4C31EE,0x68928B5FCE792932,0x66D3F7246},{0x3FFFCE162EA4E476,0x8E31BA4D0A31AF28,0x1064AC3CCA},{0xEEB590A6F7C3CBC1,0x10B25F4CD92C36E0,0x2F293ED40D},{0xC3AEEB3EA04F638F,0xC97A789BBDA0EDEA,0x30ABF7670},{0xF83E26329F5445B5,0x158F0D45360E45D8,0x1A42A16C73},{0xAF50367B4CB59565,0xCF906B5648D8DC11,0x1ACB8DBF1F},{0x7BD749319AA57230,0x6963E2A793B0E724,0x768123F65},{0x563C4CDE59D2281F,0xC8B0D83A0ADFE718,0x179C9B707B},{0x111CEA8B3F4ED442,0xFE09F1884CDCFA09,0x1CD2192892},{0x6D204B2816C680,0x8E4AB734DDB11CF4,0x22396D1919},{0xDAEEAB14E1A10000,0x5974E52567B9F06C,0x5F33EFB72},{0xD8E4FE30A000000,0xB437C41C6FA699C1,0x1A9FC1FBB7},{0xACEB29E400000000,0x8794FFC1719448B7,0x2AC59C37F2},{0x4E35E80000000000,0x15A239514B92690,0x3877E4458F},{0x1910000000000000,0xE388C59E8D43569C,0x214BC76D7D},{0xA000000000000000,0x57DE9AEF3604EF66,0x1D4F8EBB5C},{0,0xFB9A62C48F833A40,0x15801606F3},{0,0x8940AC9B56768000,0x38CE82742A},{0,0xAA91E50281000000,0x9E75A08FC},{0,0x75F093CA00000000,0x3AD4159A22},{0,0x4A21640000000000,0x8060495D8},{0,0x80E8000000000000,0x325BDCF4A0},{0,0x1000000000000000,0x255EC1A947},{0,0,0x108BA7B2A0},{0,0,0x2540BE4000},{0x3F56A67F6B29B9C3,2081},{0xE5B99F78C67672CE,0x1E494034E79},{0x3C39FC501CB4B9FF,0xD31C29DDE93228AF,112},{0xFFE6223C445197E9,0x8D45F18E7065DD8D,0x1A44DF832B},{0x13037500814EE1BB,0x54317C0762380640,0xA23E47838},{0x3A6D5D824F0499C5,0x5BF1D2A4BBDBCB0C,0xD1D767FC9},{0x94626A8EA08F1138,0x7E9AA63F650A0071,0x2EE1F0ED91},{0xA0E219B92B8D0518,0xA59A1BD855DF90D8,0x21E0269B3E},{0x8EB9CF5F0D3127BD,0x35E6E2A177AFD2E3,0xE960B91CB},{0x44D9442370EA683F,0xBA8AEDD00B303D30,0x2F504AFBA7},{0x981BEA225CF69ACC,0xA16101F2FF2F93BA,0x270D689593},{0xCAD7DF60F17D7389,0xB887370669DF2BC6,0x225F74ED24},{0xE3BADA54186F643,0x45AD2EE13EE0A266,0x88CBB24A0},{0xA287EBA6296A0EEA,0xC3FB542C76D0D826,0x2550F74AF6},{0x4D7177EAB6326C89,0x328CB133B9419552,0x39745F883B},{0xC3CE6D1CCB267203,0x88A25F0B8B2EAE00,0xDC8718B5C},{0x283CC9B3B39B8657,0xF5049801AEE2F7D4,0x158B70A164},{0xB7A6AF3DC41BDFD3,0x7442D7A612739ECD,0x1781831D21},{0x2DA122187BD11F6E,0xBE50C9B62C623792,0x7CA05BDA5},{0x4C2AFFBE4DBC9B17,0x12FB14E99E4CEDCB,0x269713E342},{0xA231648A77629906,0x8A854BFD9A7C24E8,0xF62536BD6},{0x5E24CCC87706E0D1,0x571FA715C67283DD,0x31F3A55600},{0x6D9C5DDEF8267E35,0x81ACF3DDB3E9C99E,0x1448F94B},{0x3D64160CA152115B,0x44420C1145A7FC30,0x11948A7291},{0x262CECA95EBBD532,0x5AF73F2360290FBB,0x21D290E85F},{0xD975EBE116D96CAD,0x3A433933FECAFDB0,0x16339EF210},{0xD1CB76DEF802D615,0x702315A08AAE89E3,0x3C73D5898},{0x7115C8BDDCCED8FF,0xB19A54342D33DC55,0x237E03D392},{0xB48050AC9916C1D5,0x743F50A528517799,0x2227A12862},{0x8EC48728BC1CFD36,0x89475962A76F7035,0x16EC523566},{0xC481FC3AD0899D4E,0xCE774003C6A97006,0x17DFA2EED7},{0xDA7792963D269AF3,0x79918980A5C18261,0x323F11F867},{0x28233B2FBCAFDD46,0x3416D23FAD183119,0x181795522A},{0x67E7B4AD03F3DB5B,0x2918F2736C201D81,0x9D385E549},{0x648E195E80DB3A4D,0x22A9856FEA130403,0x1108B53350},{0x2A909BFDD0CE83A3,0xD38F80103361EAAC,0x12A8712714},{0x70E57B54BF72FD1D,0xA342881C8CC887,0x4D959C5C6},{0xCC6B8A92B329406C,0x36F5056EEEB9AC8D,0x2E19DE3F0C},{0x6E20A084A055522,0x2C09EED4FD91A4EE,0x2D80D2B03},{0x4DF64C3C58F99FEE,0x99052AB4FEEA0DB8,0xBD1148C4},{0x1CF6AC3B141525F3,0x7B541B1A69AA1740,0x2DC6235EB1},{0xDD119250A5B39382,0xC1A09B0DF996DCEF,0x2952BC9E27},{0x7827B3C5879E26B1,0x3946F09D3A934DBA,0x941A9DD22},{0xFEEEE510E2EDEFE2,0xF4F13FBEF732911F,0x7F7E4CF52},{0x3134AC7B3CBD4CAE,0xB8260AEB9383A9A9,0x13509C6817},{0xB93B6879C0399E67,0xE153F7B3F1FE3E43,0x585C842B4},{0xC8FAFBD8AF716491,0xBC79283DAD8F8EF9,0x2A1D4CA065},{0x7B81A6D36AF50DFC,0x5DB2942DA65D79C,0x17AFF393E0},{0x6277A40905CBBFD7,0x291B9A4920BAA6E5,0x3428CDCCF8},{0x2932905AE41FAD4C,0x724668928B5FCE79,0x39C785E799},{0xAF283FFFCE162EA4,0x3CCA8E31BA4D0A31,0x23BA1E0CA0},{0x36E0EEB590A6F7C3,0xD40D10B25F4CD92C,0x254EE5B096},{0xEDEAC3AEEB3EA04F,0x7670C97A789BBDA0,0x231E119607},{0x45D8F83E26329F54,0x6C73158F0D45360E,0x1BCCF21BD},{0xDC11AF50367B4CB5,0xBF1FCF906B5648D8,0x2C1A873AC5},{0xE7247BD749319AA5,0x3F656963E2A793B0,0x2E0A9D56C8},{0xE718563C4CDE59D2,0x707BC8B0D83A0ADF,0x2E9FB08451},{0xFA09111CEA8B3F4E,0x2892FE09F1884CDC,0x12F62A7479},{0x1CF4006D204B2816,0x19198E4AB734DDB1,0x1C359BE2FD},{0xF06CDAEEAB14E1A1,0xFB725974E52567B9,0x3AEDD1B2F8},{0x99C10D8E4FE30A00,0xFBB7B437C41C6FA6,0x39F87F13CF},{0x48B7ACEB29E40000,0x37F28794FFC17194,0x306CC4DFAA},{0x26904E35E8000000,0x458F015A239514B9,0x27A1D0DD4A},{0x569C191000000000,0x6D7DE388C59E8D43,0x114AF06839},{0xEF66A00000000000,0xBB5C57DE9AEF3604,0xD5EF53190},{0x3A40000000000000,0x6F3FB9A62C48F83,0x21B2B131A4},{0x8000000000000000,0x742A8940AC9B5676,0x2630C7D73E},{0,0x8FCAA91E5028100,0xE8A88F6E2},{0,0x9A2275F093CA0000,0x34A0BDFE65},{0,0x95D84A2164000000,0x17A7F4D588},{0,0xF4A080E800000000,0x1FCD1EC36E},{0,0xA947100000000000,0x19D577B349},{0,0xB2A0000000000000,0x11268D5501},{0,0x4000000000000000,0x6531AB32},{0,0,0xBB3222680},{0,0,0x1DCD650000},{0x4E79E5B99F78C676,0x1E49403},{0x28AF3C39FC501CB4,0x70D31C29DDE932},{0xDD8DFFE6223C4451,0x832B8D45F18E7065,0x1A44DF},{0x64013037500814E,0x783854317C076238,0x340A604F42},{0xCB0C3A6D5D824F04,0x7FC95BF1D2A4BBDB,0xF79E5C026},{0x7194626A8EA08F,0xED917E9AA63F650A,0x8F6BAA826},{0x90D8A0E219B92B8D,0x9B3EA59A1BD855DF,0x9104A2928},{0xD2E38EB9CF5F0D31,0x91CB35E6E2A177AF,0x97454DE59},{0x3D3044D9442370EA,0xFBA7BA8AEDD00B30,0x14DAC236B4},{0x93BA981BEA225CF6,0x9593A16101F2FF2F,0x2A236DD976},{0x2BC6CAD7DF60F17D,0xED24B887370669DF,0x1B9C2C9306},{0xA2660E3BADA54186,0x24A045AD2EE13EE0,0x19CD795BD},{0xD826A287EBA6296A,0x4AF6C3FB542C76D0,0x2C09CE375F},{0x95524D7177EAB632,0x883B328CB133B941,0x162FE528C3},{0xAE00C3CE6D1CCB26,0x8B5C88A25F0B8B2E,0x2D869FE1C1},{0xF7D4283CC9B3B39B,0xA164F5049801AEE2,0x2D1024E11E},{0x9ECDB7A6AF3DC41B,0x1D217442D7A61273,0x721B7868D},{0x37922DA122187BD1,0xBDA5BE50C9B62C62,0x20DB0994E7},{0xEDCB4C2AFFBE4DBC,0xE34212FB14E99E4C,0x35F4D42435},{0x24E8A231648A7762,0x6BD68A854BFD9A7C,0xC8BF57571},{0x83DD5E24CCC87706,0x5600571FA715C672,0x1A686ED013},{0xC99E6D9C5DDEF826,0xF94B81ACF3DDB3E9,0x480831224},{0xFC303D64160CA152,0x729144420C1145A7,0x89BCF8B04},{0xFBB262CECA95EBB,0xE85F5AF73F236029,0x10917E884},{0xFDB0D975EBE116D9,0xF2103A433933FECA,0x1EF1EAA2AE},{0x89E3D1CB76DEF802,0x5898702315A08AAE,0x28BB916631},{0xDC557115C8BDDCCE,0xD392B19A54342D33,0xB7D415D73},{0x7799B48050AC9916,0x2862743F50A52851,0x1AF7CB7A1F},{0x70358EC48728BC1C,0x356689475962A76F,0x7412591E2},{0x7006C481FC3AD089,0xEED7CE774003C6A9,0x34AB153F74},{0x8261DA7792963D26,0xF86779918980A5C1,0x1B39BFAEDD},{0x311928233B2FBCAF,0x522A3416D23FAD18,0x33AE766D45},{0x1D8167E7B4AD03F3,0xE5492918F2736C20,0x1023D9DA39},{0x403648E195E80DB,0x335022A9856FEA13,0xD7AD97967},{0xEAAC2A909BFDD0CE,0x2714D38F80103361,0x180739C4AF},{0xC88770E57B54BF72,0xC5C600A342881C8C,0x28C7E9841F},{0xAC8DCC6B8A92B329,0x3F0C36F5056EEEB9,0x765CAAD50},{0xA4EE06E20A084A05,0x2B032C09EED4FD91,0x12AF0D0FC3},{0xDB84DF64C3C58F9,0x48C499052AB4FEEA,0x2D70EB9AFF},{0x17401CF6AC3B1415,0x5EB17B541B1A69AA,0x3B702084F3},{0xDCEFDD119250A5B3,0x9E27C1A09B0DF996,0x38A9F9E6E8},{0x4DBA7827B3C5879E,0xDD223946F09D3A93,0x362919DA55},{0x911FFEEEE510E2ED,0xCF52F4F13FBEF732,0x13FDE1AA46},{0xA9A93134AC7B3CBD,0x6817B8260AEB9383,0x107C98B5F2},{0x3E43B93B6879C039,0x42B4E153F7B3F1FE,0x38708F5BD8},{0x8EF9C8FAFBD8AF71,0xA065BC79283DAD8F,0x325A227560},{0xD79C7B81A6D36AF5,0x93E005DB2942DA65,0x167F642E33},{0xA6E56277A40905CB,0xCCF8291B9A4920BA,0xC024448CB},{0xCE792932905AE41F,0xE799724668928B5F,0x2F73774E7D},{0xA31AF283FFFCE16,0xCA03CCA8E31BA4D,0x1D50810864},{0xD92C36E0EEB590A6,0xB096D40D10B25F4C,0x174B67785D},{0xBDA0EDEAC3AEEB3E,0x96077670C97A789B,0x15D058EAF1},{0x360E45D8F83E2632,0x21BD6C73158F0D45,0x383FA6992B},{0x48D8DC11AF50367B,0x3AC5BF1FCF906B56,0xA0ADAFC91},{0x93B0E7247BD74931,0x56C83F656963E2A7,0x21D05B8661},{0xADFE718563C4CDE,0x8451707BC8B0D83A,0x16A9DB298C},{0x4CDCFA09111CEA8B,0x74792892FE09F188,0x20B7753E52},{0xDDB11CF4006D204B,0xE2FD19198E4AB734,0x1332B30D23},{0x67B9F06CDAEEAB14,0xB2F8FB725974E525,0x85B033225},{0x6FA699C10D8E4FE3,0x13CFFBB7B437C41C,0x8C70ACAF3},{0x719448B7ACEB29E4,0xDFAA37F28794FFC1,0x38988AA7C2},{0x14B926904E35E800,0xDD4A458F015A2395,0x2D5F608BC6},{0x8D43569C19100000,0x68396D7DE388C59E,0x2E4D3E2752},{0x3604EF66A0000000,0x3190BB5C57DE9AEF,0x132FD8F505},{0x8F833A4000000000,0x31A406F3FB9A62C4,0x13590455B},{0x5676800000000000,0xD73E742A8940AC9B,0x153B949F71},{0x8100000000000000,0xF6E208FCAA91E502,0x1A8170B42E},{0,0xFE659A2275F093CA,0xAEF4BAAD9},{0,0xD58895D84A216400,0x32C1707660},{0,0xC36EF4A080E80000,0x168BC35730},{0,0xB349A94710000000,0xB5A869D55},{0,0x5501B2A000000000,0x13F42373CB},{0,0xAB32400000000000,0x2F5788F843},{0,0x2680000000000000,0xFC15EF610},{0,0,0x3C2A36761},{0,0,0x1695A68A00},{0x94034E79E5B99F78,484},{0xE93228AF3C39FC50,0x70D31C29DD},{0x7065DD8DFFE6223C,0x44DF832B8D45F18E,26},{0x6238064013037500,0x4F42783854317C07,0x61DC1AC08},{0xBBDBCB0C3A6D5D82,0xC0267FC95BF1D2A4,0x1EF4A8E3B},{0x650A007194626A8E,0xA826ED917E9AA63F,0xDE9699C3A},{0x55DF90D8A0E219B9,0x29289B3EA59A1BD8,0xDA83868DA},{0x77AFD2E38EB9CF5F,0xDE5991CB35E6E2A1,0x32CB6542AE},{0xB303D3044D94423,0x36B4FBA7BA8AEDD0,0x28B6FA61EE},{0xFF2F93BA981BEA22,0xD9769593A16101F2,0x3776A49609},{0x69DF2BC6CAD7DF60,0x9306ED24B8873706,0x24B12EB66},{0x3EE0A2660E3BADA5,0x95BD24A045AD2EE1,0x17E1E7FAD5},{0x76D0D826A287EBA6,0x375F4AF6C3FB542C,0x31BAA73360},{0xB94195524D7177EA,0x28C3883B328CB133,0x1666F0314B},{0x8B2EAE00C3CE6D1C,0xE1C18B5C88A25F0B,0x117FD6E42F},{0xAEE2F7D4283CC9B3,0xE11EA164F5049801,0xB25FB31AE},{0x12739ECDB7A6AF3D,0x868D1D217442D7A6,0x28B79F7941},{0x2C6237922DA12218,0x94E7BDA5BE50C9B6,0xF41A12AC5},{0x9E4CEDCB4C2AFFBE,0x2435E34212FB14E9,0x2E00C8E39C},{0x9A7C24E8A231648A,0x75716BD68A854BFD,0x245AC1685D},{0xC67283DD5E24CCC8,0xD0135600571FA715,0x15C29388C0},{0xB3E9C99E6D9C5DDE,0x1224F94B81ACF3DD,0x2CE489C4A3},{0x45A7FC303D64160C,0x8B04729144420C11,0x25F7C81C03},{0x60290FBB262CECA9,0xE884E85F5AF73F23,0xD32E72C5},{0xFECAFDB0D975EBE1,0xA2AEF2103A433933,0x2E1440AAFA},{0x8AAE89E3D1CB76DE,0x66315898702315A0,0x3A5B09F365},{0x2D33DC557115C8BD,0x5D73D392B19A5434,0x179BDCDBBD},{0x28517799B48050AC,0x7A1F2862743F50A5,0x2C1709552D},{0xA76F70358EC48728,0x91E2356689475962,0xA96A48769},{0xC6A97006C481FC3A,0x3F74EED7CE774003,0x189474317F},{0xA5C18261DA779296,0xAEDDF86779918980,0x1DA0908775},{0xAD18311928233B2F,0x6D45522A3416D23F,0x1B667535C2},{0x6C201D8167E7B4AD,0xDA39E5492918F273,0x2D44BE1FDB},{0xEA130403648E195E,0x7967335022A9856F,0x33303A18DD},{0x3361EAAC2A909BFD,0xC4AF2714D38F8010,0x3390E492B3},{0x1C8CC88770E57B54,0x841FC5C600A34288,0x29DB068891},{0xEEB9AC8DCC6B8A92,0xAD503F0C36F5056E,0x21E16F9FF2},{0xFD91A4EE06E20A08,0xFC32B032C09EED4,0x3880AD3D8F},{0xFEEA0DB84DF64C3C,0x9AFF48C499052AB4,0x214F2258C1},{0x69AA17401CF6AC3B,0x84F35EB17B541B1A,0x2D13C8D7A4},{0xF996DCEFDD119250,0xE6E89E27C1A09B0D,0x264E1DE221},{0x3A934DBA7827B3C5,0xDA55DD223946F09D,0x7E4B74495},{0xF732911FFEEEE510,0xAA46CF52F4F13FBE,0x22E3ED5FE5},{0x9383A9A93134AC7B,0xB5F26817B8260AEB,0x35791BF8BC},{0xF1FE3E43B93B6879,0x5BD842B4E153F7B3,0x2BF0093961},{0xAD8F8EF9C8FAFBD8,0x7560A065BC79283D,0x16AB08E9F0},{0xDA65D79C7B81A6D3,0x2E3393E005DB2942,0x37FC719DB6},{0x20BAA6E56277A409,0x48CBCCF8291B9A49,0x2A6ACD6E90},{0x8B5FCE792932905A,0x4E7DE79972466892,0x2198049C47},{0xBA4D0A31AF283FFF,0x8640CA03CCA8E31,0x109A34800D},{0x5F4CD92C36E0EEB5,0x785DB096D40D10B2,0x308D063B7},{0x789BBDA0EDEAC3AE,0xEAF196077670C97A,0x2AB7ACC508},{0xD45360E45D8F83E,0x992B21BD6C73158F,0x2138A0C4A},{0x6B5648D8DC11AF50,0xFC913AC5BF1FCF90,0x115E67F194},{0xE2A793B0E7247BD7,0x866156C83F656963,0x22B04AF733},{0xD83A0ADFE718563C,0x298C8451707BC8B0,0xBFF1FED97},{0xF1884CDCFA09111C,0x3E5274792892FE09,0x2331F9A7CF},{0xB734DDB11CF4006D,0xD23E2FD19198E4A,0x3040AC059F},{0xE52567B9F06CDAEE,0x3225B2F8FB725974,0x250832AD45},{0xC41C6FA699C10D8E,0xCAF313CFFBB7B437,0x101C65747E},{0xFFC1719448B7ACEB,0xA7C2DFAA37F28794,0x1D857027EE},{0x239514B926904E35,0x8BC6DD4A458F015A,0x3790F72526},{0xC59E8D43569C1910,0x275268396D7DE388,0x8F98554EC},{0x9AEF3604EF66A000,0xF5053190BB5C57DE,0x36FBD9FC9E},{0x62C48F833A400000,0x455B31A406F3FB9A,0x25029504E2},{0xAC9B567680000000,0x9F71D73E742A8940,0x34AECC4806},{0xE502810000000000,0xB42EF6E208FCAA91,0x18AC060E6},{0x93CA000000000000,0xAAD9FE659A2275F0,0x35B7054153},{0x6400000000000000,0x7660D58895D84A21,0x137AF70994},{0,0x5730C36EF4A080E8,0x22910CACDF},{0,0x9D55B349A9471000,0x340022EB2C},{0,0x73CB5501B2A00000,0xA633C9A05},{0,0xF843AB3240000000,0x144FBD246},{0,0xF610268000000000,0x108620F10E},{0,0x6761000000000000,0x37BC18CBF},{0,0x8A00000000000000,0x2C908E92EC},{0,0,0x3712D3A8E4},{0,0,0x3515DBE800},{0x29DDE93228AF3C39,0x70D31C},{0xF18E7065DD8DFFE6,0x1A44DF832B8D45},{0x7C07623806401303,0xAC084F4278385431,400833},{0xD2A4BBDBCB0C3A6D,0x8E3BC0267FC95BF1,0x2D17C03902},{0xA63F650A00719462,0x9C3AA826ED917E9A,0x98535975},{0x1BD855DF90D8A0E2,0x68DA29289B3EA59A,0x1B621E4D50},{0xE2A177AFD2E38EB9,0x42AEDE5991CB35E6,0x12B8C8CD75},{0xEDD00B303D3044D9,0x61EE36B4FBA7BA8A,0x1B4D44F10E},{0x1F2FF2F93BA981B,0x9609D9769593A161,0x35944292E},{0x370669DF2BC6CAD7,0xEB669306ED24B887,0xAD8BF496E},{0x2EE13EE0A2660E3B,0xFAD595BD24A045AD,0x19D351C555},{0x542C76D0D826A287,0x3360375F4AF6C3FB,0x1404CBF5EB},{0xB133B94195524D71,0x314B28C3883B328C,0x36C30DAB2E},{0x5F0B8B2EAE00C3CE,0xE42FE1C18B5C88A2,0xAC14A6C80},{0x9801AEE2F7D4283C,0x31AEE11EA164F504,0x1E028601E3},{0xD7A612739ECDB7A6,0x7941868D1D217442,0x34E5D27649},{0xC9B62C6237922DA1,0x2AC594E7BDA5BE50,0x111B5F051B},{0x14E99E4CEDCB4C2A,0xE39C2435E34212FB,0x65348B3EC},{0x4BFD9A7C24E8A231,0x685D75716BD68A85,0x3727B0D3DF},{0xA715C67283DD5E24,0x88C0D0135600571F,0x3404229AA3},{0xF3DDB3E9C99E6D9C,0xC4A31224F94B81AC,0x261365BDD9},{0xC1145A7FC303D64,0x1C038B0472914442,0x32B3FDB470},{0x3F2360290FBB262C,0x72C5E884E85F5AF7,0x1A1A3E2146},{0x3933FECAFDB0D975,0xAAFAA2AEF2103A43,0x10670C3E34},{0x15A08AAE89E3D1CB,0xF365663158987023,0xC43402D2D},{0x54342D33DC557115,0xDBBD5D73D392B19A,0xAB2E10B9A},{0x50A528517799B480,0x552D7A1F2862743F,0x240E4705D7},{0x5962A76F70358EC4,0x876991E235668947,0x3222D4A1B6},{0x4003C6A97006C481,0x317F3F74EED7CE77,0x2A7F92D0FA},{0x8980A5C18261DA77,0x8775AEDDF8677991,0x3A40AF853A},{0xD23FAD1831192823,0x35C26D45522A3416,0xDA09BCAFB},{0xF2736C201D8167E7,0x1FDBDA39E5492918,0x3A7D485E90},{0x856FEA130403648E,0x18DD7967335022A9,0x218E7C8EB0},{0x80103361EAAC2A90,0x92B3C4AF2714D38F,0x290034F3D4},{0x42881C8CC88770E5,0x8891841FC5C600A3,0x317E576A3A},{0x56EEEB9AC8DCC6B,0x9FF2AD503F0C36F5,0xDA0DDE0BF},{0xEED4FD91A4EE06E2,0x3D8F0FC32B032C09,0x2C9DBA5A23},{0x2AB4FEEA0DB84DF6,0x58C19AFF48C49905,0x8347ECF44},{0x1B1A69AA17401CF6,0xD7A484F35EB17B54,0xFE9C7F138},{0x9B0DF996DCEFDD11,0xE221E6E89E27C1A0,0xD3C117DC3},{0xF09D3A934DBA7827,0x4495DA55DD223946,0x2D9B8E690B},{0x3FBEF732911FFEEE,0x5FE5AA46CF52F4F1,0x29F9EAF95},{0xAEB9383A9A93134,0xF8BCB5F26817B826,0x22C76B7C11},{0xF7B3F1FE3E43B93B,0x39615BD842B4E153,0x42F314DB9},{0x283DAD8F8EF9C8FA,0xE9F07560A065BC79,0x2B20381C02},{0x2942DA65D79C7B81,0x9DB62E3393E005DB,0xADAD724B},{0x9A4920BAA6E56277,0x6E9048CBCCF8291B,0x119B1186AF},{0x68928B5FCE792932,0x9C474E7DE7997246,0x28D88E30D0},{0x8E31BA4D0A31AF28,0x800D08640CA03CCA,0x3092270D4C},{0x10B25F4CD92C36E0,0x63B7785DB096D40D,0x11CFC465D0},{0xC97A789BBDA0EDEA,0xC508EAF196077670,0x3084FBB3CA},{0x158F0D45360E45D8,0xC4A992B21BD6C73,0x2F360394FC},{0xCF906B5648D8DC11,0xF194FC913AC5BF1F,0x3AAF3B77DF},{0x6963E2A793B0E724,0xF733866156C83F65,0x3424155E74},{0xC8B0D83A0ADFE718,0xED97298C8451707B,0x1B3BB1E005},{0xFE09F1884CDCFA09,0xA7CF3E5274792892,0x1615770FB},{0x8E4AB734DDB11CF4,0x59F0D23E2FD1919,0x3A97D64872},{0x5974E52567B9F06C,0xAD453225B2F8FB72,0x1A8C3D0224},{0xB437C41C6FA699C1,0x747ECAF313CFFBB7,0x88A1C1EE7},{0x8794FFC1719448B7,0x27EEA7C2DFAA37F2,0x35E3CBEEF8},{0x15A239514B92690,0x25268BC6DD4A458F,0x39C73FD5BD},{0xE388C59E8D43569C,0x54EC275268396D7D,0x2C09ED7AB7},{0x57DE9AEF3604EF66,0xFC9EF5053190BB5C,0x2AAF6C2C21},{0xFB9A62C48F833A40,0x4E2455B31A406F3,0x7E9C56B6D},{0x8940AC9B56768000,0x48069F71D73E742A,0x19620B1BF4},{0xAA91E50281000000,0x60E6B42EF6E208FC,0x38E04D9B90},{0x75F093CA00000000,0x4153AAD9FE659A22,0x219DA162C5},{0x4A21640000000000,0x9947660D58895D8,0x2DED533A41},{0x80E8000000000000,0xACDF5730C36EF4A0,0xF24884C26},{0x1000000000000000,0xEB2C9D55B349A947,0x90139FBDA},{0,0x9A0573CB5501B2A0,0x32F8917EAA},{0,0xD246F843AB324000,0x27B8A6867F},{0,0xF10EF61026800000,0x1DC2BFB5D4},{0,0x8CBF676100000000,0x31944F7BEB},{0,0x92EC8A0000000000,0x36D7DCA506},{0,0xA8E4000000000000,0x187D61607},{0,0xE800000000000000,0x1C88E306B},{0,0,0x191FB6B510},{0,0,0x3B9ACA000},{0xD31C29DDE93228AF,112},{0x8D45F18E7065DD8D,0x1A44DF832B},{0x54317C0762380640,0x1DC1AC084F427838,6},{0x5BF1D2A4BBDBCB0C,0x39028E3BC0267FC9,0x16C8E5CA2},{0x7E9AA63F650A0071,0x59759C3AA826ED91,0x25C539E34D},{0xA59A1BD855DF90D8,0x4D5068DA29289B3E,0x120262F458},{0x35E6E2A177AFD2E3,0xCD7542AEDE5991CB,0x148F35B78A},{0xBA8AEDD00B303D30,0xF10E61EE36B4FBA7,0x2051472506},{0xA16101F2FF2F93BA,0x292E9609D9769593,0x19DC0CD6E},{0xB887370669DF2BC6,0x496EEB669306ED24,0x19A6196F19},{0x45AD2EE13EE0A266,0xC555FAD595BD24A0,0x5E336B0EB},{0xC3FB542C76D0D826,0xF5EB3360375F4AF6,0x36E509903D},{0x328CB133B9419552,0xAB2E314B28C3883B,0xE6D24085F},{0x88A25F0B8B2EAE00,0x6C80E42FE1C18B5C,0x16464C1C38},{0xF5049801AEE2F7D4,0x1E331AEE11EA164,0xD231F7FBE},{0x7442D7A612739ECD,0x76497941868D1D21,0x2C3D526C9C},{0xBE50C9B62C623792,0x51B2AC594E7BDA5,0x246DDD8C7B},{0x12FB14E99E4CEDCB,0xB3ECE39C2435E342,0x1CA48F673A},{0x8A854BFD9A7C24E8,0xD3DF685D75716BD6,0xDAAF626EE},{0x571FA715C67283DD,0x9AA388C0D0135600,0x379B3C64A0},{0x81ACF3DDB3E9C99E,0xBDD9C4A31224F94B,0x2564BF70E9},{0x44420C1145A7FC30,0xB4701C038B047291,0x366C15D51F},{0x5AF73F2360290FBB,0x214672C5E884E85F,0x761C16646},{0x3A433933FECAFDB0,0x3E34AAFAA2AEF210,0x1054129716},{0x702315A08AAE89E3,0x2D2DF36566315898,0x52DC91C2C},{0xB19A54342D33DC55,0xB9ADBBD5D73D392,0xA491FA063},{0x743F50A528517799,0x5D7552D7A1F2862,0x170F8FD2F5},{0x89475962A76F7035,0xA1B6876991E23566,0x390C7F7AC6},{0xCE774003C6A97006,0xD0FA317F3F74EED7,0x2E3F5F149C},{0x79918980A5C18261,0x853A8775AEDDF867,0x2482FB1CCF},{0x3416D23FAD183119,0xCAFB35C26D45522A,0x30512E618D},{0x2918F2736C201D81,0x5E901FDBDA39E549,0x210383E2AC},{0x22A9856FEA130403,0x8EB018DD79673350,0x2822041CA8},{0xD38F80103361EAAC,0xF3D492B3C4AF2714,0x273ECD6C40},{0xA342881C8CC887,0x6A3A8891841FC5C6,0xF1F77EC15},{0x36F5056EEEB9AC8D,0xE0BF9FF2AD503F0C,0x4FC6E4A81},{0x2C09EED4FD91A4EE,0x5A233D8F0FC32B03,0x1E3D53D87A},{0x99052AB4FEEA0DB8,0xCF4458C19AFF48C4,0x1C7CC0E382},{0x7B541B1A69AA1740,0xF138D7A484F35EB1,0x1E74DCA71D},{0xC1A09B0DF996DCEF,0x7DC3E221E6E89E27,0x6F8B2D63B},{0x3946F09D3A934DBA,0x690B4495DA55DD22,0xDD9F4BE30},{0xF4F13FBEF732911F,0xAF955FE5AA46CF52,0xB457AFC78},{0xB8260AEB9383A9A9,0x7C11F8BCB5F26817,0x1C19704781},{0xE153F7B3F1FE3E43,0x4DB939615BD842B4,0x1E25E2F309},{0xBC79283DAD8F8EF9,0x1C02E9F07560A065,0x22A89C8FA},{0x5DB2942DA65D79C,0x724B9DB62E3393E0,0x3A3BAEDFC5},{0x291B9A4920BAA6E5,0x86AF6E9048CBCCF8,0x2DF8B9FB05},{0x724668928B5FCE79,0x30D09C474E7DE799,0x14961D04A},{0x3CCA8E31BA4D0A31,0xD4C800D08640CA0,0x11461BFC07},{0xD40D10B25F4CD92C,0x65D063B7785DB096,0x1A4543206},{0x7670C97A789BBDA0,0xB3CAC508EAF19607,0x17D5552AD},{0x6C73158F0D45360E,0x94FC0C4A992B21BD,0x287176F341},{0xBF1FCF906B5648D8,0x77DFF194FC913AC5,0xF44FD7603},{0x3F656963E2A793B0,0x5E74F733866156C8,0xCEB975FB},{0x707BC8B0D83A0ADF,0xE005ED97298C8451,0x3A86C21FDD},{0x2892FE09F1884CDC,0x70FBA7CF3E527479,0x33A8C93417},{0x19198E4AB734DDB1,0x4872059F0D23E2FD,0x575367636},{0xFB725974E52567B9,0x224AD453225B2F8,0xCA384B10D},{0xFBB7B437C41C6FA6,0x1EE7747ECAF313CF,0x3075C01B0},{0x37F28794FFC17194,0xEEF827EEA7C2DFAA,0x29019CE777},{0x458F015A239514B9,0xD5BD25268BC6DD4A,0x1BEC97950B},{0x6D7DE388C59E8D43,0x7AB754EC27526839,0x2C16A81FF},{0xBB5C57DE9AEF3604,0x2C21FC9EF5053190,0x3B7BC1A9B0},{0x6F3FB9A62C48F83,0x6B6D04E2455B31A4,0x2904B1647D},{0x742A8940AC9B5676,0x1BF448069F71D73E,0x1D3397B679},{0x8FCAA91E5028100,0x9B9060E6B42EF6E2,0x1C32ABAD9B},{0x9A2275F093CA0000,0x62C54153AAD9FE65,0x243AF0A3EF},{0x95D84A2164000000,0x3A4109947660D588,0x37BC81C4A7},{0xF4A080E800000000,0x4C26ACDF5730C36E,0x26EF89FC4C},{0xA947100000000000,0xFBDAEB2C9D55B349,0x11C3AEED31},{0xB2A0000000000000,0x7EAA9A0573CB5501,0xBA344669F},{0x4000000000000000,0x867FD246F843AB32,0x2522A15E12},{0,0xB5D4F10EF6102680,0x45032FC7B},{0,0x7BEB8CBF67610000,0x1CCDB51321},{0,0xA50692EC8A000000,0x7CBCE40EA},{0,0x1607A8E400000000,0x36A1E8F008},{0,0x306BE80000000000,0x1E1F765EA},{0,0xB510000000000000,0x3686C2C996},{0,0xA000000000000000,0x2316DA867E},{0,0,0x1D7B702A40},{0,0,0xEE6B28000},{0x832B8D45F18E7065,0x1A44DF},{0x783854317C076238,0x61DC1AC084F42},{0x7FC95BF1D2A4BBDB,0x5CA239028E3BC026,93326},{0xED917E9AA63F650A,0xE34D59759C3AA826,0x21256D71D1},{0x9B3EA59A1BD855DF,0xF4584D5068DA2928,0x30DE4B2D80},{0x91CB35E6E2A177AF,0xB78ACD7542AEDE59,0x1E064917BD},{0xFBA7BA8AEDD00B30,0x2506F10E61EE36B4,0x2C2C0319AD},{0x9593A16101F2FF2F,0xCD6E292E9609D976,0x2850397EF2},{0xED24B887370669DF,0x6F19496EEB669306,0x3888278DDB},{0x24A045AD2EE13EE0,0xB0EBC555FAD595BD,0x331748CECC},{0x4AF6C3FB542C76D0,0x903DF5EB3360375F,0x2FA88A47E9},{0x883B328CB133B941,0x85FAB2E314B28C3,0x36617758C4},{0x8B5C88A25F0B8B2E,0x1C386C80E42FE1C1,0x2DA475C49C},{0xA164F5049801AEE2,0x7FBE01E331AEE11E,0x2458E52937},{0x1D217442D7A61273,0x6C9C76497941868D,0xCEBFF6D88},{0xBDA5BE50C9B62C62,0x8C7B051B2AC594E7,0x1FC3850B15},{0xE34212FB14E99E4C,0x673AB3ECE39C2435,0x50467DD07},{0x6BD68A854BFD9A7C,0x26EED3DF685D7571,0x1B944783C},{0x5600571FA715C672,0x64A09AA388C0D013,0xE0157ED38},{0xF94B81ACF3DDB3E9,0x70E9BDD9C4A31224,0xD214A0BA7},{0x729144420C1145A7,0xD51FB4701C038B04,0x26FC43EA75},{0xE85F5AF73F236029,0x6646214672C5E884,0x1B6F5D7DD3},{0xF2103A433933FECA,0x97163E34AAFAA2AE,0x3138647E8E},{0x5898702315A08AAE,0x1C2C2D2DF3656631,0x21330986EF},{0xD392B19A54342D33,0xA0630B9ADBBD5D73,0x37AC11CD37},{0x2862743F50A52851,0xD2F505D7552D7A1F,0xCF39933CF},{0x356689475962A76F,0x7AC6A1B6876991E2,0x3063475C33},{0xEED7CE774003C6A9,0x149CD0FA317F3F74,0xBFC6C41A3},{0xF86779918980A5C1,0x1CCF853A8775AEDD,0x25F85B38C3},{0x522A3416D23FAD18,0x618DCAFB35C26D45,0x2D6D9D1D46},{0xE5492918F2736C20,0xE2AC5E901FDBDA39,0x106309E60D},{0x335022A9856FEA13,0x1CA88EB018DD7967,0x33BA30A58},{0x2714D38F80103361,0x6C40F3D492B3C4AF,0x1483E19CE5},{0xC5C600A342881C8C,0xEC156A3A8891841F,0x356AAB1EAF},{0x3F0C36F5056EEEB9,0x4A81E0BF9FF2AD50,0x28F5C7C4A6},{0x2B032C09EED4FD91,0xD87A5A233D8F0FC3,0x26B7B7F7B7},{0x48C499052AB4FEEA,0xE382CF4458C19AFF,0x2ACE0D7D30},{0x5EB17B541B1A69AA,0xA71DF138D7A484F3,0xB61FE95FA},{0x9E27C1A09B0DF996,0xD63B7DC3E221E6E8,0x3A5C123678},{0xDD223946F09D3A93,0xBE30690B4495DA55,0x1C226FEED0},{0xCF52F4F13FBEF732,0xFC78AF955FE5AA46,0x309A0C4766},{0x6817B8260AEB9383,0x47817C11F8BCB5F2,0x17FA74F448},{0x42B4E153F7B3F1FE,0xF3094DB939615BD8,0x10D42EE3E8},{0xA065BC79283DAD8F,0xC8FA1C02E9F07560,0x363CDD2847},{0x93E005DB2942DA65,0xDFC5724B9DB62E33,0x10B6B92F7E},{0xCCF8291B9A4920BA,0xFB0586AF6E9048CB,0x1D8A493AAF},{0xE799724668928B5F,0xD04A30D09C474E7D,0x28F942236F},{0xCA03CCA8E31BA4D,0xFC070D4C800D0864,0x1A089CA03B},{0xB096D40D10B25F4C,0x320665D063B7785D,0xDF75A912C},{0x96077670C97A789B,0x52ADB3CAC508EAF1,0xA4A4070C9},{0x21BD6C73158F0D45,0xF34194FC0C4A992B,0x2EDFC8A02A},{0x3AC5BF1FCF906B56,0x760377DFF194FC91,0xA000856BB},{0x56C83F656963E2A7,0x75FB5E74F7338661,0x2BA58BB5D5},{0x8451707BC8B0D83A,0x1FDDE005ED97298C,0x31B3425714},{0x74792892FE09F188,0x341770FBA7CF3E52,0x4AF832F3F},{0xE2FD19198E4AB734,0x76364872059F0D23,0xEB7389C3E},{0xB2F8FB725974E525,0xB10D0224AD453225,0xE8B02E8A0},{0x13CFFBB7B437C41C,0x1B01EE7747ECAF3,0x2569F74D06},{0xDFAA37F28794FFC1,0xE777EEF827EEA7C2,0x166055866},{0xDD4A458F015A2395,0x950BD5BD25268BC6,0x17F59114DD},{0x68396D7DE388C59E,0x81FF7AB754EC2752,0x3397543AFC},{0x3190BB5C57DE9AEF,0xA9B02C21FC9EF505,0x3ACAA3538B},{0x31A406F3FB9A62C4,0x647D6B6D04E2455B,0x20848DE20B},{0xD73E742A8940AC9B,0xB6791BF448069F71,0x2A70C587F},{0xF6E208FCAA91E502,0xAD9B9B9060E6B42E,0x1DBC467447},{0xFE659A2275F093CA,0xA3EF62C54153AAD9,0x10B059DB72},{0xD58895D84A216400,0xC4A73A4109947660,0x1AB1193F1F},{0xC36EF4A080E80000,0xFC4C4C26ACDF5730,0x76587E831},{0xB349A94710000000,0xED31FBDAEB2C9D55,0xBA35ECC86},{0x5501B2A000000000,0x669F7EAA9A0573CB,0x1F6A3FAC46},{0xAB32400000000000,0x5E12867FD246F843,0x1064380B1D},{0x2680000000000000,0xFC7BB5D4F10EF610,0x6D670085E},{0,0x13217BEB8CBF6761,0x161D9F588D},{0,0x40EAA50692EC8A00,0x20D8B58ACC},{0,0xF0081607A8E40000,0x2F8E764C68},{0,0x65EA306BE8000000,0x186EC50F57},{0,0xC996B51000000000,0x1459553E74},{0,0x867EA00000000000,0x1B31132774},{0,0x2A40000000000000,0x1B2174092C},{0,0x8000000000000000,0xA487103D6},{0,0,0x31F1324100},{0x44DF832B8D45F18E,26},{0x4F42783854317C07,0x61DC1AC08},{0xC0267FC95BF1D2A4,0x6C8E5CA239028E3B,1},{0xA826ED917E9AA63F,0x71D1E34D59759C3A,0x54E13CA5},{0x29289B3EA59A1BD8,0x2D80F4584D5068DA,0x2685446375},{0xDE5991CB35E6E2A1,0x17BDB78ACD7542AE,0x1B48568DCB},{0x36B4FBA7BA8AEDD0,0x19AD2506F10E61EE,0x2F49454229},{0xD9769593A16101F2,0x7EF2CD6E292E9609,0x991C4C7F3},{0x9306ED24B8873706,0x8DDB6F19496EEB66,0x38B17C7593},{0x95BD24A045AD2EE1,0xCECCB0EBC555FAD5,0x225AE9568A},{0x375F4AF6C3FB542C,0x47E9903DF5EB3360,0x2051971B16},{0x28C3883B328CB133,0x58C4085FAB2E314B,0x5300BAB7D},{0xE1C18B5C88A25F0B,0xC49C1C386C80E42F,0x1D2F3F7BE5},{0xE11EA164F5049801,0x29377FBE01E331AE,0x357F3D8D8D},{0x868D1D217442D7A6,0x6D886C9C76497941,0x20DDD9F859},{0x94E7BDA5BE50C9B6,0xB158C7B051B2AC5,0x14D250E587},{0x2435E34212FB14E9,0xDD07673AB3ECE39C,0x1F71353115},{0x75716BD68A854BFD,0x783C26EED3DF685D,0x51728EBA6},{0xD0135600571FA715,0xED3864A09AA388C0,0x26C25D8C07},{0x1224F94B81ACF3DD,0xBA770E9BDD9C4A3,0x1D876F44C},{0x8B04729144420C11,0xEA75D51FB4701C03,0x11B4AA9AF1},{0xE884E85F5AF73F23,0x7DD36646214672C5,0x38534F1601},{0xA2AEF2103A433933,0x7E8E97163E34AAFA,0x58E69706},{0x66315898702315A0,0x86EF1C2C2D2DF365,0x183181E75},{0x5D73D392B19A5434,0xCD37A0630B9ADBBD,0x1B5D2903CD},{0x7A1F2862743F50A5,0x33CFD2F505D7552D,0x2FEABBA95B},{0x91E2356689475962,0x5C337AC6A1B68769,0x153C160785},{0x3F74EED7CE774003,0x41A3149CD0FA317F,0x1F0CE28F04},{0xAEDDF86779918980,0x38C31CCF853A8775,0xFDB36DA5},{0x6D45522A3416D23F,0x1D46618DCAFB35C2,0x2677FB7BCD},{0xDA39E5492918F273,0xE60DE2AC5E901FDB,0x2FC1C4ADEB},{0x7967335022A9856F,0xA581CA88EB018DD,0x36ECA7BB1F},{0xC4AF2714D38F8010,0x9CE56C40F3D492B3,0x73A2705C5},{0x841FC5C600A34288,0x1EAFEC156A3A8891,0x2E02A52FC3},{0xAD503F0C36F5056E,0xC4A64A81E0BF9FF2,0x2D6E0CF773},{0xFC32B032C09EED4,0xF7B7D87A5A233D8F,0x1AF451F85F},{0x9AFF48C499052AB4,0x7D30E382CF4458C1,0x16581E1CF3},{0x84F35EB17B541B1A,0x95FAA71DF138D7A4,0x38B113B4A0},{0xE6E89E27C1A09B0D,0x3678D63B7DC3E221,0x2563A9B3A4},{0xDA55DD223946F09D,0xEED0BE30690B4495,0x263BD8310B},{0xAA46CF52F4F13FBE,0x4766FC78AF955FE5,0x2C7412FD8},{0xB5F26817B8260AEB,0xF44847817C11F8BC,0x325B3A587A},{0x5BD842B4E153F7B3,0xE3E8F3094DB93961,0x1CA0A4A0B6},{0x7560A065BC79283D,0x2847C8FA1C02E9F0,0x2A951C19FB},{0x2E3393E005DB2942,0x2F7EDFC5724B9DB6,0x3A7A24F449},{0x48CBCCF8291B9A49,0x3AAFFB0586AF6E90,0x110A328F5F},{0x4E7DE79972466892,0x236FD04A30D09C47,0x162C1B0106},{0x8640CA03CCA8E31,0xA03BFC070D4C800D,0x16DE0EE3A},{0x785DB096D40D10B2,0x912C320665D063B7,0xDA660799A},{0xEAF196077670C97A,0x70C952ADB3CAC508,0x23FCEA7AAA},{0x992B21BD6C73158F,0xA02AF34194FC0C4A,0x27AF0CBC28},{0xFC913AC5BF1FCF90,0x56BB760377DFF194,0x9757A4E48},{0x866156C83F656963,0xB5D575FB5E74F733,0x10D7BA7567},{0x298C8451707BC8B0,0x57141FDDE005ED97,0x18259D6A14},{0x3E5274792892FE09,0x2F3F341770FBA7CF,0x4BC5E1229},{0xD23E2FD19198E4A,0x9C3E76364872059F,0x996CA7C4E},{0x3225B2F8FB725974,0xE8A0B10D0224AD45,0x124D8A6A1A},{0xCAF313CFFBB7B437,0x4D0601B01EE7747E,0x643E23507},{0xA7C2DFAA37F28794,0x5866E777EEF827EE,0x1B32A7AC7},{0x8BC6DD4A458F015A,0x14DD950BD5BD2526,0x2E69E83101},{0x275268396D7DE388,0x3AFC81FF7AB754EC,0x4076791C},{0xF5053190BB5C57DE,0x538BA9B02C21FC9E,0x692A9F467},{0x455B31A406F3FB9A,0xE20B647D6B6D04E2,0x180EBAFA0B},{0x9F71D73E742A8940,0x587FB6791BF44806,0x2C447FB60},{0xB42EF6E208FCAA91,0x7447AD9B9B9060E6,0x166EA6B1B6},{0xAAD9FE659A2275F0,0xDB72A3EF62C54153,0x2A7B1E6FE1},{0x7660D58895D84A21,0x3F1FC4A73A410994,0x349623A5E7},{0x5730C36EF4A080E8,0xE831FC4C4C26ACDF,0x35D75EC33D},{0x9D55B349A9471000,0xCC86ED31FBDAEB2C,0xE69F20C6E},{0x73CB5501B2A00000,0xAC46669F7EAA9A05,0x19CC218F37},{0xF843AB3240000000,0xB1D5E12867FD246,0xCF65DC9F0},{0xF610268000000000,0x85EFC7BB5D4F10E,0x37E3B3DD1E},{0x6761000000000000,0x588D13217BEB8CBF,0x6FE169FEF},{0x8A00000000000000,0x8ACC40EAA50692EC,0x37BA20A425},{0,0x4C68F0081607A8E4,0x8BDB0315A},{0,0xF5765EA306BE800,0x15063566BD},{0,0x3E74C996B5100000,0x2C04D98D2B},{0,0x2774867EA0000000,0xA118A9BFF},{0,0x92C2A4000000000,0x3B685EEC3A},{0,0x3D6800000000000,0xD83347D8B},{0,0x4100000000000000,0x205DF06F90},{0,0,0x219633ED4A},{0,0,0x113ABE6400},{0xAC084F4278385431,400833},{0x8E3BC0267FC95BF1,0x16C8E5CA23902},{0x9C3AA826ED917E9A,0x3CA571D1E34D5975,21729},{0x68DA29289B3EA59A,0x63752D80F4584D50,0x34712A569C},{0x42AEDE5991CB35E6,0x8DCB17BDB78ACD75,0x24697B3C74},{0x61EE36B4FBA7BA8A,0x422919AD2506F10E,0x1B23271287},{0x9609D9769593A161,0xC7F37EF2CD6E292E,0x1F7E07FFD8},{0xEB669306ED24B887,0x75938DDB6F19496E,0x3279287482},{0xFAD595BD24A045AD,0x568ACECCB0EBC555,0x1E5FFAAD3B},{0x3360375F4AF6C3FB,0x1B1647E9903DF5EB,0xDD0D2DF73},{0x314B28C3883B328C,0xAB7D58C4085FAB2E,0x1ACCD74159},{0xE42FE1C18B5C88A2,0x7BE5C49C1C386C80,0x14E0BDCE2D},{0x31AEE11EA164F504,0x8D8D29377FBE01E3,0xA970E604B},{0x7941868D1D217442,0xF8596D886C9C7649,0x11974E4D1B},{0x2AC594E7BDA5BE50,0xE5870B158C7B051B,0x683261400},{0xE39C2435E34212FB,0x3115DD07673AB3EC,0x3570E7E7},{0x685D75716BD68A85,0xEBA6783C26EED3DF,0x35D419FDD2},{0x88C0D0135600571F,0x8C07ED3864A09AA3,0x311BD78DCB},{0xC4A31224F94B81AC,0xF44C0BA770E9BDD9,0x2F6458ACEE},{0x1C038B0472914442,0x9AF1EA75D51FB470,0x37A2C90932},{0x72C5E884E85F5AF7,0x16017DD366462146,0xBC84EE4D3},{0xAAFAA2AEF2103A43,0x97067E8E97163E34,0x3125B42442},{0xF365663158987023,0x1E7586EF1C2C2D2D,0xF8111E43E},{0xDBBD5D73D392B19A,0x3CDCD37A0630B9A,0xE76946CD5},{0x552D7A1F2862743F,0xA95B33CFD2F505D7,0x3198ACCD19},{0x876991E235668947,0x7855C337AC6A1B6,0x5F98C2570},{0x317F3F74EED7CE77,0x8F0441A3149CD0FA,0x1A1578A868},{0x8775AEDDF8677991,0x6DA538C31CCF853A,0x18582E8489},{0x35C26D45522A3416,0x7BCD1D46618DCAFB,0x1FFF5D79FD},{0x1FDBDA39E5492918,0xADEBE60DE2AC5E90,0x3B04CCC2D2},{0x18DD7967335022A9,0xBB1F0A581CA88EB0,0x310D783B29},{0x92B3C4AF2714D38F,0x5C59CE56C40F3D4,0x9B75BA5B5},{0x8891841FC5C600A3,0x2FC31EAFEC156A3A,0x2A25C8DA97},{0x9FF2AD503F0C36F5,0xF773C4A64A81E0BF,0x23336BFF22},{0x3D8F0FC32B032C09,0xF85FF7B7D87A5A23,0x8242C2137},{0x58C19AFF48C49905,0x1CF37D30E382CF44,0xD0815B1CE},{0xD7A484F35EB17B54,0xB4A095FAA71DF138,0x2FFD4C2B2B},{0xE221E6E89E27C1A0,0xB3A43678D63B7DC3,0xA2D0E27B1},{0x4495DA55DD223946,0x310BEED0BE30690B,0x295FD92116},{0x5FE5AA46CF52F4F1,0x2FD84766FC78AF95,0x52AB8C3EB},{0xF8BCB5F26817B826,0x587AF44847817C11,0x36C23B3450},{0x39615BD842B4E153,0xA0B6E3E8F3094DB9,0x12B4F8F614},{0xE9F07560A065BC79,0x19FB2847C8FA1C02,0x4CD831B5C},{0x9DB62E3393E005DB,0xF4492F7EDFC5724B,0x1571AD2FDE},{0x6E9048CBCCF8291B,0x8F5F3AAFFB0586AF,0x33E91BBEBA},{0x9C474E7DE7997246,0x106236FD04A30D0,0x2B6FD866F1},{0x800D08640CA03CCA,0xEE3AA03BFC070D4C,0x381CF532AA},{0x63B7785DB096D40D,0x799A912C320665D0,0x27CC41B22C},{0xC508EAF196077670,0x7AAA70C952ADB3CA,0xA5AEADE64},{0xC4A992B21BD6C73,0xBC28A02AF34194FC,0x1765065B50},{0xF194FC913AC5BF1F,0x4E4856BB760377DF,0x12CC2E41D2},{0xF733866156C83F65,0x7567B5D575FB5E74,0x30F733B546},{0xED97298C8451707B,0x6A1457141FDDE005,0x1067A91FEF},{0xA7CF3E5274792892,0x12292F3F341770FB,0x37BE356A02},{0x59F0D23E2FD1919,0x7C4E9C3E76364872,0x7B700CFE},{0xAD453225B2F8FB72,0x6A1AE8A0B10D0224,0x3B4085B362},{0x747ECAF313CFFBB7,0x35074D0601B01EE7,0x16E9F5AF86},{0x27EEA7C2DFAA37F2,0x7AC75866E777EEF8,0x1F3F5E7AFC},{0x25268BC6DD4A458F,0x310114DD950BD5BD,0x3AC8F5062C},{0x54EC275268396D7D,0x791C3AFC81FF7AB7,0xA4A039920},{0xFC9EF5053190BB5C,0xF467538BA9B02C21,0x78F8BFC23},{0x4E2455B31A406F3,0xFA0BE20B647D6B6D,0x85F113542},{0x48069F71D73E742A,0xFB60587FB6791BF4,0xF9820018B},{0x60E6B42EF6E208FC,0xB1B67447AD9B9B90,0x209792E0B4},{0x4153AAD9FE659A22,0x6FE1DB72A3EF62C5,0x2A123688C8},{0x9947660D58895D8,0xA5E73F1FC4A73A41,0x2EAAFA83B9},{0xACDF5730C36EF4A0,0xC33DE831FC4C4C26,0x2B397C9590},{0xEB2C9D55B349A947,0xC6ECC86ED31FBDA,0x21B486F1D0},{0x9A0573CB5501B2A0,0x8F37AC46669F7EAA,0x3070A92D99},{0xD246F843AB324000,0xC9F00B1D5E12867F,0x23C0DB2733},{0xF10EF61026800000,0xDD1E085EFC7BB5D4,0xC0EDAAA4D},{0x8CBF676100000000,0x9FEF588D13217BEB,0x12210A6078},{0x92EC8A0000000000,0xA4258ACC40EAA506,0x1C15CB8D96},{0xA8E4000000000000,0x315A4C68F0081607,0x2312EA4318},{0xE800000000000000,0x66BD0F5765EA306B,0x5A20096DF},{0,0x8D2B3E74C996B510,0x3403C1A755},{0,0x9BFF2774867EA000,0x13EB4364CC},{0,0xEC3A092C2A400000,0x2FA3AB18AC},{0,0x7D8B03D680000000,0x2842FFED6C},{0,0x6F90410000000000,0x1942882A92},{0,0xED4A000000000000,0x221840E7C9},{0,0x6400000000000000,0x2F03C821C0},{0,0,0x2CCB5FF6E8},{0,0,0x3604471000},{0x1DC1AC084F427838,6},{0x39028E3BC0267FC9,0x16C8E5CA2},{0x59759C3AA826ED91,0x54E13CA571D1E34D},{0x4D5068DA29289B3E,0x569C63752D80F458,0x13C33B72},{0xCD7542AEDE5991CB,0x3C748DCB17BDB78A,0x1A9F185D57},{0xF10E61EE36B4FBA7,0x1287422919AD2506,0x144FAE107F},{0x292E9609D9769593,0xFFD8C7F37EF2CD6E,0x1D961A963B},{0x496EEB669306ED24,0x748275938DDB6F19,0xDF83E365E},{0xC555FAD595BD24A0,0xAD3B568ACECCB0EB,0x15FDF6AF82},{0xF5EB3360375F4AF6,0xDF731B1647E9903D,0x1E6CEFFF54},{0xAB2E314B28C3883B,0x4159AB7D58C4085F,0x13C2D0EACD},{0x6C80E42FE1C18B5C,0xCE2D7BE5C49C1C38,0x2FCA2AF007},{0x1E331AEE11EA164,0x604B8D8D29377FBE,0x1D13CAB9A},{0x76497941868D1D21,0x4D1BF8596D886C9C,0x23F189270E},{0x51B2AC594E7BDA5,0x1400E5870B158C7B,0x3546B1DE8},{0xB3ECE39C2435E342,0xE7E73115DD07673A,0x3608EF5D38},{0xD3DF685D75716BD6,0xFDD2EBA6783C26EE,0xD3FDAB05F},{0x9AA388C0D0135600,0x8DCB8C07ED3864A0,0x16598A0B79},{0xBDD9C4A31224F94B,0xACEEF44C0BA770E9,0x1C4D2D1F9A},{0xB4701C038B047291,0x9329AF1EA75D51F,0x2403612681},{0x214672C5E884E85F,0xE4D316017DD36646,0x1E0B240368},{0x3E34AAFAA2AEF210,0x244297067E8E9716,0x186C29119C},{0x2D2DF36566315898,0xE43E1E7586EF1C2C,0x245AC45D79},{0xB9ADBBD5D73D392,0x6CD503CDCD37A063,0x1C614DCC7C},{0x5D7552D7A1F2862,0xCD19A95B33CFD2F5,0x1CF850BDE4},{0xA1B6876991E23566,0x257007855C337AC6,0x35459CD54E},{0xD0FA317F3F74EED7,0xA8688F0441A3149C,0x1231E100AA},{0x853A8775AEDDF867,0x84896DA538C31CCF,0x27BC0010BE},{0xCAFB35C26D45522A,0x79FD7BCD1D46618D,0x2C5BBDBB85},{0x5E901FDBDA39E549,0xC2D2ADEBE60DE2AC,0x1F13D22046},{0x8EB018DD79673350,0x3B29BB1F0A581CA8,0x1079AF968C},{0xF3D492B3C4AF2714,0xA5B505C59CE56C40,0x20A66CDBE9},{0x6A3A8891841FC5C6,0xDA972FC31EAFEC15,0x366676C3FA},{0xE0BF9FF2AD503F0C,0xFF22F773C4A64A81,0x3A680E476F},{0x5A233D8F0FC32B03,0x2137F85FF7B7D87A,0x1A1384E962},{0xCF4458C19AFF48C4,0xB1CE1CF37D30E382,0x16D8FD501F},{0xF138D7A484F35EB1,0x2B2BB4A095FAA71D,0x7612478F6},{0x7DC3E221E6E89E27,0x27B1B3A43678D63B,0x3950CB48FC},{0x690B4495DA55DD22,0x2116310BEED0BE30,0x3AB59CCC9F},{0xAF955FE5AA46CF52,0xC3EB2FD84766FC78,0x250CD794C2},{0x7C11F8BCB5F26817,0x3450587AF4484781,0x2D58EABE19},{0x4DB939615BD842B4,0xF614A0B6E3E8F309,0x5DE4BE000},{0x1C02E9F07560A065,0x1B5C19FB2847C8FA,0x394B8B9F},{0x724B9DB62E3393E0,0x2FDEF4492F7EDFC5,0x250B823AFB},{0x86AF6E9048CBCCF8,0xBEBA8F5F3AAFFB05,0x3A7BE96231},{0x30D09C474E7DE799,0x66F10106236FD04A,0xB9508FBC4},{0xD4C800D08640CA0,0x32AAEE3AA03BFC07,0x2DBA7A7171},{0x65D063B7785DB096,0xB22C799A912C3206,0x1A5B1F31B5},{0xB3CAC508EAF19607,0xDE647AAA70C952AD,0x2A4DECCD5E},{0x94FC0C4A992B21BD,0x5B50BC28A02AF341,0x16169DCC32},{0x77DFF194FC913AC5,0x41D24E4856BB7603,0xBB97E45FC},{0x5E74F733866156C8,0xB5467567B5D575FB,0x3ABBB21C7D},{0xE005ED97298C8451,0x1FEF6A1457141FDD,0x1D44C97A7B},{0x70FBA7CF3E527479,0x6A0212292F3F3417,0x1CAACE8AAB},{0x4872059F0D23E2FD,0xCFE7C4E9C3E7636,0x27E9138114},{0x224AD453225B2F8,0xB3626A1AE8A0B10D,0x4AB1E49FD},{0x1EE7747ECAF313CF,0xAF8635074D0601B0,0x3B11BDC733},{0xEEF827EEA7C2DFAA,0x7AFC7AC75866E777,0xC08B44D74},{0xD5BD25268BC6DD4A,0x62C310114DD950B,0x1B1EC61539},{0x7AB754EC27526839,0x9920791C3AFC81FF,0xD46E6E4BF},{0x2C21FC9EF5053190,0xFC23F467538BA9B0,0x2C9C23C845},{0x6B6D04E2455B31A4,0x3542FA0BE20B647D,0x104B6D2FE9},{0x1BF448069F71D73E,0x18BFB60587FB679,0x364C487DF2},{0x9B9060E6B42EF6E2,0xE0B4B1B67447AD9B,0x3858AF265C},{0x62C54153AAD9FE65,0x88C86FE1DB72A3EF,0x159FF21AF6},{0x3A4109947660D588,0x83B9A5E73F1FC4A7,0x396697024A},{0x4C26ACDF5730C36E,0x9590C33DE831FC4C,0x115969D2DA},{0xFBDAEB2C9D55B349,0xF1D00C6ECC86ED31,0x32E4A2D018},{0x7EAA9A0573CB5501,0x2D998F37AC46669F,0x5CED018D3},{0x867FD246F843AB32,0x2733C9F00B1D5E12,0x312B32745D},{0xB5D4F10EF6102680,0xAA4DDD1E085EFC7B,0x15B05C05A0},{0x7BEB8CBF67610000,0x60789FEF588D1321,0x2568652B2E},{0xA50692EC8A000000,0x8D96A4258ACC40EA,0xACC466D8B},{0x1607A8E400000000,0x4318315A4C68F008,0x207E03022C},{0x306BE80000000000,0x96DF66BD0F5765EA,0xA4E39DCDE},{0xB510000000000000,0xA7558D2B3E74C996,0x33D35BE21D},{0xA000000000000000,0x64CC9BFF2774867E,0x6E77EC709},{0,0x18ACEC3A092C2A40,0x22FE93493},{0,0xED6C7D8B03D68000,0x223FA0C3EF},{0,0x2A926F9041000000,0x37DCCA258A},{0,0xE7C9ED4A00000000,0x202B5A6164},{0,0x21C0640000000000,0x177E6E980E},{0,0xF6E8000000000000,0x34A52CB69},{0,0x1000000000000000,0x18ABF99C63},{0,0,0x171095CAA0},{0,0,0x2540BE4000},{0x5CA239028E3BC026,93326},{0xE34D59759C3AA826,0x54E13CA571D1},{0xF4584D5068DA2928,0x3B72569C63752D80,5059},{0xB78ACD7542AEDE59,0x5D573C748DCB17BD,0x2D74BF29A6},{0x2506F10E61EE36B4,0x107F1287422919AD,0x26BC1A8710},{0xCD6E292E9609D976,0x963BFFD8C7F37EF2,0x3BD83E2BA},{0x6F19496EEB669306,0x365E748275938DDB,0x2B71716E9A},{0xB0EBC555FAD595BD,0xAF82AD3B568ACECC,0x23E7C62892},{0x903DF5EB3360375F,0xFF54DF731B1647E9,0x2227247105},{0x85FAB2E314B28C3,0xEACD4159AB7D58C4,0x16578E406},{0x1C386C80E42FE1C1,0xF007CE2D7BE5C49C,0x19C4C02CE},{0x7FBE01E331AEE11E,0xAB9A604B8D8D2937,0x302E717A9C},{0x6C9C76497941868D,0x270E4D1BF8596D88,0x247A476E77},{0x8C7B051B2AC594E7,0x1DE81400E5870B15,0x1BBE0BCF31},{0x673AB3ECE39C2435,0x5D38E7E73115DD07,0xB6F973BD1},{0x26EED3DF685D7571,0xB05FFDD2EBA6783C,0x30BF13653C},{0x64A09AA388C0D013,0xB798DCB8C07ED38,0xE21581C6A},{0x70E9BDD9C4A31224,0x1F9AACEEF44C0BA7,0x18B0C397DB},{0xD51FB4701C038B04,0x268109329AF1EA75,0x3304C68FD7},{0x6646214672C5E884,0x368E4D316017DD3,0x3217F6AB20},{0x97163E34AAFAA2AE,0x119C244297067E8E,0x774247C87},{0x1C2C2D2DF3656631,0x5D79E43E1E7586EF,0x1F72BA282E},{0xA0630B9ADBBD5D73,0xCC7C6CD503CDCD37,0xACB93E8AF},{0xD2F505D7552D7A1F,0xBDE4CD19A95B33CF,0x28EE6C6748},{0x7AC6A1B6876991E2,0xD54E257007855C33,0x10EFBF5CBE},{0x149CD0FA317F3F74,0xAAA8688F0441A3,0x2C6E8BE7F3},{0x1CCF853A8775AEDD,0x10BE84896DA538C3,0x3894157A00},{0x618DCAFB35C26D45,0xBB8579FD7BCD1D46,0x3E6085D},{0xE2AC5E901FDBDA39,0x2046C2D2ADEBE60D,0x15D2E48760},{0x1CA88EB018DD7967,0x968C3B29BB1F0A58,0x16618F92EF},{0x6C40F3D492B3C4AF,0xDBE9A5B505C59CE5,0x37C88FEEC8},{0xEC156A3A8891841F,0xC3FADA972FC31EAF,0x2EC421A144},{0x4A81E0BF9FF2AD50,0x476FFF22F773C4A6,0x1002BEF7EC},{0xD87A5A233D8F0FC3,0xE9622137F85FF7B7,0x370354398A},{0xE382CF4458C19AFF,0x501FB1CE1CF37D30,0x2057C79ED7},{0xA71DF138D7A484F3,0x78F62B2BB4A095FA,0x3221A76644},{0xD63B7DC3E221E6E8,0x48FC27B1B3A43678,0xFF147877B},{0xBE30690B4495DA55,0xCC9F2116310BEED0,0x1CB45D4C6C},{0xFC78AF955FE5AA46,0x94C2C3EB2FD84766,0x1954F19DCF},{0x47817C11F8BCB5F2,0xBE193450587AF448,0x3054CC2BB2},{0xF3094DB939615BD8,0xE000F614A0B6E3E8,0x299DE33437},{0xC8FA1C02E9F07560,0x8B9F1B5C19FB2847,0xD0269100B},{0xDFC5724B9DB62E33,0x3AFB2FDEF4492F7E,0x2B028C530},{0xFB0586AF6E9048CB,0x6231BEBA8F5F3AAF,0xB3AC16DAD},{0xD04A30D09C474E7D,0xFBC466F10106236F,0x285E77585C},{0xFC070D4C800D0864,0x717132AAEE3AA03B,0x15A63F1688},{0x320665D063B7785D,0x31B5B22C799A912C,0x1FC4A4FE49},{0x52ADB3CAC508EAF1,0xCD5EDE647AAA70C9,0x110AB68896},{0xF34194FC0C4A992B,0xCC325B50BC28A02A,0x231C83665F},{0x760377DFF194FC91,0x45FC41D24E4856BB,0x164DFC0876},{0x75FB5E74F7338661,0x1C7DB5467567B5D5,0x1B89A49024},{0x1FDDE005ED97298C,0x7A7B1FEF6A145714,0x868669AE1},{0x341770FBA7CF3E52,0x8AAB6A0212292F3F,0x347F8FF912},{0x76364872059F0D23,0x81140CFE7C4E9C3E,0x4512B8DF7},{0xB10D0224AD453225,0x49FDB3626A1AE8A0,0x39A06690E8},{0x1B01EE7747ECAF3,0xC733AF8635074D06,0x3615814557},{0xE777EEF827EEA7C2,0x4D747AFC7AC75866,0x146FFC01BA},{0x950BD5BD25268BC6,0x1539062C310114DD,0x2B607F7188},{0x81FF7AB754EC2752,0xE4BF9920791C3AFC,0x1FAF2C4978},{0xA9B02C21FC9EF505,0xC845FC23F467538B,0x1C25D1280B},{0x647D6B6D04E2455B,0x2FE93542FA0BE20B,0x2BE47E73D},{0xB6791BF448069F71,0x7DF2018BFB60587F,0xE3F09D95E},{0xAD9B9B9060E6B42E,0x265CE0B4B1B67447,0x1600291951},{0xA3EF62C54153AAD9,0x1AF688C86FE1DB72,0x12E4E883EE},{0xC4A73A4109947660,0x24A83B9A5E73F1F,0x37702EEB1B},{0xFC4C4C26ACDF5730,0xD2DA9590C33DE831,0x649DBDCFD},{0xED31FBDAEB2C9D55,0xD018F1D00C6ECC86,0x3B19118056},{0x669F7EAA9A0573CB,0x18D32D998F37AC46,0x1436736EF0},{0x5E12867FD246F843,0x745D2733C9F00B1D,0x37E6E50E22},{0xFC7BB5D4F10EF610,0x5A0AA4DDD1E085E,0x805A6A7E4},{0x13217BEB8CBF6761,0x2B2E60789FEF588D,0x35172B5657},{0x40EAA50692EC8A00,0x6D8B8D96A4258ACC,0x144BA87234},{0xF0081607A8E40000,0x22C4318315A4C68,0xC34F26E05},{0x65EA306BE8000000,0xDCDE96DF66BD0F57,0x12A8775CD},{0xC996B51000000000,0xE21DA7558D2B3E74,0x2FEE609AF3},{0x867EA00000000000,0xC70964CC9BFF2774,0x38C8934BD2},{0x2A40000000000000,0x349318ACEC3A092C,0x31135136EF},{0x8000000000000000,0xC3EFED6C7D8B03D6,0x37B1C046A8},{0,0x258A2A926F904100,0x274B3354A8},{0,0x6164E7C9ED4A0000,0x2726521A8C},{0,0x980E21C064000000,0x20AF539CF8},{0,0xCB69F6E800000000,0x39E15AE242},{0,0x9C63100000000000,0xF8D447E27},{0,0xCAA0000000000000,0x938FE29AD},{0,0x4000000000000000,0x2876C7E622},{0,0,0x7F9758680},{0,0,0x1DCD650000},{0x71D1E34D59759C3A,0x54E13CA5},{0x2D80F4584D5068DA,0x13C33B72569C6375},{0x17BDB78ACD7542AE,0x29A65D573C748DCB,0x499F1BD},{0x19AD2506F10E61EE,0x8710107F12874229,0x2C0AF9A874},{0x7EF2CD6E292E9609,0xE2BA963BFFD8C7F3,0x1B2195E609},{0x8DDB6F19496EEB66,0x6E9A365E74827593,0x24D3B31C5},{0xCECCB0EBC555FAD5,0x2892AF82AD3B568A,0x2DF7DDDC92},{0x47E9903DF5EB3360,0x7105FF54DF731B16,0x2207B98AB4},{0x58C4085FAB2E314B,0xE406EACD4159AB7D,0x2A0326C0A2},{0xC49C1C386C80E42F,0x2CEF007CE2D7BE5,0x25ED0B4C34},{0x29377FBE01E331AE,0x7A9CAB9A604B8D8D,0xC1C186C05},{0x6D886C9C76497941,0x6E77270E4D1BF859,0x14692308B},{0xB158C7B051B2AC5,0xCF311DE81400E587,0x2076C3EED7},{0xDD07673AB3ECE39C,0x3BD15D38E7E73115,0x323F3D3EED},{0x783C26EED3DF685D,0x653CB05FFDD2EBA6,0x373C3A6DA1},{0xED3864A09AA388C0,0x1C6A0B798DCB8C07,0x2593EB3D0A},{0xBA770E9BDD9C4A3,0x97DB1F9AACEEF44C,0x25AA982DB},{0xEA75D51FB4701C03,0x8FD7268109329AF1,0x3320C61FEC},{0x7DD36646214672C5,0xAB200368E4D31601,0x37142FC6CC},{0x7E8E97163E34AAFA,0x7C87119C24429706,0x2FA730D112},{0x86EF1C2C2D2DF365,0x282E5D79E43E1E75,0x44DE0A092},{0xCD37A0630B9ADBBD,0xE8AFCC7C6CD503CD,0x2207A22F23},{0x33CFD2F505D7552D,0x6748BDE4CD19A95B,0x85C56D37C},{0x5C337AC6A1B68769,0x5CBED54E25700785,0x1CF7060F05},{0x41A3149CD0FA317F,0xE7F300AAA8688F04,0x13F9E0123},{0x38C31CCF853A8775,0x7A0010BE84896DA5,0x85C2ADE5B},{0x1D46618DCAFB35C2,0x85DBB8579FD7BCD,0x154C6D962A},{0xE60DE2AC5E901FDB,0x87602046C2D2ADEB,0x9C957CD34},{0xA581CA88EB018DD,0x92EF968C3B29BB1F,0xC3AF60A15},{0x9CE56C40F3D492B3,0xEEC8DBE9A5B505C5,0x505E8A1C3},{0x1EAFEC156A3A8891,0xA144C3FADA972FC3,0x2D9E8089ED},{0xC4A64A81E0BF9FF2,0xF7EC476FFF22F773,0x3753D95DC8},{0xF7B7D87A5A233D8F,0x398AE9622137F85F,0x2ECAA72C3A},{0x7D30E382CF4458C1,0x9ED7501FB1CE1CF3,0xD8E7792C1},{0x95FAA71DF138D7A4,0x664478F62B2BB4A0,0x2D14ADF453},{0x3678D63B7DC3E221,0x877B48FC27B1B3A4,0x136AFF1BC3},{0xEED0BE30690B4495,0x4C6CCC9F2116310B,0x2D867332E3},{0x4766FC78AF955FE5,0x9DCF94C2C3EB2FD8,0x34EC0C66E9},{0xF44847817C11F8BC,0x2BB2BE193450587A,0x3664A01CAE},{0xE3E8F3094DB93961,0x3437E000F614A0B6,0x288D61E9D1},{0x2847C8FA1C02E9F0,0x100B8B9F1B5C19FB,0x30B5875D71},{0x2F7EDFC5724B9DB6,0xC5303AFB2FDEF449,0x1A530F86C8},{0x3AAFFB0586AF6E90,0x6DAD6231BEBA8F5F,0x2EBED72833},{0x236FD04A30D09C47,0x585CFBC466F10106,0xBF95F8479},{0xA03BFC070D4C800D,0x1688717132AAEE3A,0x1C40BC55AF},{0x912C320665D063B7,0xFE4931B5B22C799A,0x28C40F2800},{0x70C952ADB3CAC508,0x8896CD5EDE647AAA,0x3B349F22},{0xA02AF34194FC0C4A,0x665FCC325B50BC28,0x80A5C2BD3},{0x56BB760377DFF194,0x87645FC41D24E48,0x31386A7878},{0xB5D575FB5E74F733,0x90241C7DB5467567,0x1BF2870FF4},{0x57141FDDE005ED97,0x9AE17A7B1FEF6A14,0x38F1180206},{0x2F3F341770FBA7CF,0xF9128AAB6A021229,0x189B05913},{0x9C3E76364872059F,0x8DF781140CFE7C4E,0x4A67ADDA5},{0xE8A0B10D0224AD45,0x90E849FDB3626A1A,0x268BD213A8},{0x4D0601B01EE7747E,0x4557C733AF863507,0x273F51B721},{0x5866E777EEF827EE,0x1BA4D747AFC7AC7,0x7BF19326E},{0x14DD950BD5BD2526,0x71881539062C3101,0x199CE9C749},{0x3AFC81FF7AB754EC,0x4978E4BF9920791C,0x1119929C56},{0x538BA9B02C21FC9E,0x280BC845FC23F467,0x14171B256B},{0xE20B647D6B6D04E2,0xE73D2FE93542FA0B,0x18F3055BD7},{0x587FB6791BF44806,0xD95E7DF2018BFB60,0x3244D6914F},{0x7447AD9B9B9060E6,0x1951265CE0B4B1B6,0x1297608B63},{0xDB72A3EF62C54153,0x83EE1AF688C86FE1,0x1712C120A2},{0x3F1FC4A73A410994,0xEB1B024A83B9A5E7,0x25D6AB798C},{0xE831FC4C4C26ACDF,0xDCFDD2DA9590C33D,0x20CF63D949},{0xCC86ED31FBDAEB2C,0x8056D018F1D00C6E,0x113297B8A9},{0xAC46669F7EAA9A05,0x6EF018D32D998F37,0x277710F573},{0xB1D5E12867FD246,0xE22745D2733C9F0,0x1AE05D27B1},{0x85EFC7BB5D4F10E,0xA7E405A0AA4DDD1E,0x29395026B2},{0x588D13217BEB8CBF,0x56572B2E60789FEF,0x2998B784F1},{0x8ACC40EAA50692EC,0x72346D8B8D96A425,0x3830D27584},{0x4C68F0081607A8E4,0x6E05022C4318315A,0x1ED6674AE6},{0xF5765EA306BE800,0x75CDDCDE96DF66BD,0x35A6AF2953},{0x3E74C996B5100000,0x9AF3E21DA7558D2B,0x136E9D2AB2},{0x2774867EA0000000,0x4BD2C70964CC9BFF,0x2995B45A17},{0x92C2A4000000000,0x36EF349318ACEC3A,0x56C8F927F},{0x3D6800000000000,0x46A8C3EFED6C7D8B,0x1D9E948E5C},{0x4100000000000000,0x54A8258A2A926F90,0x157C14366F},{0,0x1A8C6164E7C9ED4A,0x19EBD3869A},{0,0x9CF8980E21C06400,0x23E14BEBD7},{0,0xE242CB69F6E80000,0x32338BDA72},{0,0x7E279C6310000000,0x1ABF9C2798},{0,0x29ADCAA000000000,0x238147586A},{0,0xE622400000000000,0x18B7CBE521},{0,0x8680000000000000,0x7E48914F1},{0,0,0x383C08FD21},{0,0,0x7AEF40A00}}};
};
}
# 3 "fast_io/fast_io_freestanding_impl/ryu/ryu.h" 2
# 1 "fast_io/fast_io_freestanding_impl/ryu/dbl_table.h" 1
       

namespace fast_io::details::ryu
{

template<std::floating_point F,bool controller>
requires (controller)
struct pow5
{
};

template<bool controller>
requires (controller)
struct pow5<float,controller>
{
inline static constexpr std::array<std::uint64_t,31> inv_split={0x800000000000001,0x666666666666667,0x51EB851EB851EB9,0x4189374BC6A7EFA,0x68DB8BAC710CB2A,0x53E2D6238DA3C22,0x431BDE82D7B634E,0x6B5FCA6AF2BD216,0x55E63B88C230E78,0x44B82FA09B5A52D,0x6DF37F675EF6EAE,0x57F5FF85E592558,0x465E6604B7A8447,0x709709A125DA071,0x5A126E1A84AE6C1,0x480EBE7B9D58567,0x734ACA5F6226F0B,0x5C3BD5191B525A3,0x49C97747490EAE9,0x760F253EDB4AB0E,0x5E72843249088D8,0x4B8ED0283A6D3E0,0x78E480405D7B966,0x60B6CD004AC9452,0x4D5F0A66A23A9DB,0x7BCB43D769F762B,0x63090312BB2C4EF,0x4F3A68DBC8F03F3,0x7EC3DAF94180651,0x65697BFA9ACD1DA,0x51212FFBAF0A7E2};
inline static constexpr std::array<std::uint64_t,47> split={0x1000000000000000,0x1400000000000000,0x1900000000000000,0x1F40000000000000,0x1388000000000000,0x186A000000000000,0x1E84800000000000,0x1312D00000000000,0x17D7840000000000,0x1DCD650000000000,0x12A05F2000000000,0x174876E800000000,0x1D1A94A200000000,0x12309CE540000000,0x16BCC41E90000000,0x1C6BF52634000000,0x11C37937E0800000,0x16345785D8A00000,0x1BC16D674EC80000,0x1158E460913D0000,0x15AF1D78B58C4000,0x1B1AE4D6E2EF5000,0x10F0CF064DD59200,0x152D02C7E14AF680,0x1A784379D99DB420,0x108B2A2C28029094,0x14ADF4B7320334B9,0x19D971E4FE8401E7,0x1027E72F1F128130,0x1431E0FAE6D7217C,0x193E5939A08CE9DB,0x1F8DEF8808B02452,0x13B8B5B5056E16B3,0x18A6E32246C99C60,0x1ED09BEAD87C0378,0x13426172C74D822B,0x1812F9CF7920E2B6,0x1E17B84357691B64,0x12CED32A16A1B11E,0x178287F49C4A1D66,0x1D6329F1C35CA4BF,0x125DFA371A19E6F7,0x16F578C4E0A060B5,0x1CB2D6F618C878E3,0x11EFC659CF7D4B8D,0x166BB7F0435C9E71,0x1C06A5EC5433C60D};
};

template<bool controller>
requires (controller)
struct pow5<double,controller>
{
inline static constexpr std::array<std::array<std::uint64_t,2>,342> inv_split={{{1,0x2000000000000000},{0x999999999999999A,0x1999999999999999},{0x47AE147AE147AE15,0x147AE147AE147AE1},{0x6C8B4395810624DE,0x10624DD2F1A9FBE7},{0x7A786C226809D496,0x1A36E2EB1C432CA5},{0x61F9F01B866E43AB,0x14F8B588E368F084},{0xB4C7F34938583622,0x10C6F7A0B5ED8D36},{0x87A6520EC08D236A,0x1AD7F29ABCAF4857},{0x9FB841A566D74F88,0x15798EE2308C39DF},{0xE62D01511F12A607,0x112E0BE826D694B2},{0xD6AE6881CB5109A4,0x1B7CDFD9D7BDBAB7},{0xDEF1ED34A2A73AEA,0x15FD7FE17964955F},{0x7F27F0F6E885C8BB,0x119799812DEA1119},{0x650CB4BE40D60DF8,0x1C25C268497681C2},{0xEA70909833DE7193,0x16849B86A12B9B01},{0x21F3A6E0297EC143,0x1203AF9EE756159B},{0x6985D7CD0F313537,0x1CD2B297D889BC2B},{0x2137DFD73F5A90F9,0x170EF54646D49689},{0xE75FE645CC4873FA,0x12725DD1D243ABA0},{0xA5663D3C7A0D865D,0x1D83C94FB6D2AC34},{0x511E976394D79EB1,0x179CA10C9242235D},{0xDA7EDF82DD794BC1,0x12E3B40A0E9B4F7D},{0x2A6498D1625BAC68,0x1E392010175EE596},{0xEEB6E0A781E2F053,0x182DB34012B25144},{0x58924D52CE4F26A9,0x1357C299A88EA76A},{0x27507BB7B07EA441,0x1EF2D0F5DA7DD8AA},{0x52A6C95FC0655034,0x18C240C4AECB13BB},{0xEEBD44C99EAA690,0x13CE9A36F23C0FC9},{0xB17953ADC3110A80,0x1FB0F6BE50601941},{0xC12DDC8B02740867,0x195A5EFEA6B34767},{0x3424B06F3529A052,0x14484BFEEBC29F86},{0x901D59F290EE19DB,0x1039D66589687F9E},{0x4CFBC31DB4B0295F,0x19F623D5A8A73297},{0x3D9635B15D59BAB2,0x14C4E977BA1F5BAC},{0x97AB5E277DE16228,0x109D8792FB4C4956},{0xF2ABC9D8C9689D0D,0x1A95A5B7F87A0EF0},{0x5BBCA17A3ABA173E,0x154484932D2E725A},{0xAFCA1AC82EFB45CB,0x11039D428A8B8EAE},{0xB2DCF7A6B1920945,0x1B38FB9DAA78E44A},{0xF57D92EBC141A104,0x15C72FB1552D836E},{0xC46475896767B403,0x116C262777579C58},{0x6D6D88DBD8A5ECD2,0x1BE03D0BF225C6F4},{0x8ABE071646EB23DB,0x164CFDA3281E38C3},{0x6EFE6C11D255B649,0x11D7314F534B609C},{0xB197134FB6EF8A0E,0x1C8B821885456760},{0x27AC0F72F8BFA1A5,0x16D601AD376AB91A},{0xB95672C260994E1E,0x1244CE242C5560E1},{0xF5571E03CDC21695,0x1D3AE36D13BBCE35},{0x2AAC18030B01ABAB,0x17624F8A762FD82B},{0xBBBCE0026F348956,0x12B50C6EC4F31355},{0x92C7CCD0B1EDA889,0x1DEE7A4AD4B81EEF},{0xDBD30A408E57BA07,0x17F1FB6F10934BF2},{0x7CA8D50071DFC806,0x1327FC58DA0F6FF5},{0xFAA7BB33E9660CD6,0x1EA6608E29B24CBB},{0x9552FC298784D711,0x18851A0B548EA3C9},{0xAAA8C9BAD2D0AC0E,0x139DAE6F76D88307},{0xDDDADC5E1E1AACE3,0x1F62B0B257C0D1A5},{0x7E48B04B4B488A4F,0x191BC08EAC9A4151},{0xCB6D59D5D5D3A1D9,0x141633A556E1CDDA},{0x3C577B1177DC817B,0x1011C2EAABE7D7E2},{0xC6F25E825960CF2A,0x19B604AAACA62636},{0x6BF518684780A5BB,0x14919D5556EB51C5},{0x232A79ED06008496,0x10747DDDDF22A7D1},{0xD1DD8FE1A3340756,0x1A53FC9631D10C81},{0xA7E4731AE8F66C45,0x150FFD44F4A73D34},{0x531D28E253F8569E,0x10D9976A5D52975D},{0xEB61DB03B98D5762,0x1AF5BF109550F22E},{0xBC4E48CFC7A445E8,0x159165A6DDDA5B58},{0x6371D3D96C836B20,0x11411E1F17E1E2AD},{0x9F1C8628AD9F11CD,0x1B9B6364F3030448},{0xE5B06B53BE18DB0B,0x1615E91D8F359D06},{0xEAF3890FCB4715A2,0x11AB20E472914A6B},{0x44B8DB4C7871BC37,0x1C45016D841BAA46},{0x3C715D6C6C1635F,0x169D9ABE03495505},{0x3638DE456BCDE919,0x1217AEFE69077737},{0x56C163A2461641C1,0x1CF2B1970E725858},{0xDF011C81D1AB67CE,0x17288E1271F51379},{0x7F3416CE4155ECA5,0x1286D80EC190DC61},{0x6520247D3556476E,0x1DA48CE468E7C702},{0xEA801D30F7783925,0x17B6D71D20B96C01},{0xBB99B0F3F92CFA84,0x12F8AC174D612334},{0x5F5C4E532847F739,0x1E5AACF215683854},{0x7F7D0B75B9D32C2E,0x18488A5B44536043},{0x9930D5F7C7DC2358,0x136D3B7C36A919CF},{0x8EB4898C72F9D226,0x1F152BF9F10E8FB2},{0x722A07A38F2E41B8,0x18DDBCC7F40BA628},{0xC1BB394FA5BE9AFA,0x13E497065CD61E86},{0x9C5EC2190930F7F6,0x1FD424D6FAF030D7},{0x49E56814075A5FF8,0x197683DF2F268D79},{0x6E51201005E1E660,0x145ECFE5BF520AC7},{0xF1DA800CD181851A,0x104BD984990E6F05},{0x4FC400148268D4F5,0x1A12F5A0F4E3E4D6},{0xD96999AA01ED772B,0x14DBF7B3F71CB711},{0xADEE1488018AC5BC,0x10AFF95CC5B09274},{0x497CEDA668DE092C,0x1AB328946F80EA54},{0x3ACA57B853E4D424,0x155C2076BF9A5510},{0x623B7960431D7683,0x1116805EFFAEAA73},{0x9D2BF566D1C8BD9E,0x1B5733CB32B110B8},{0x7DBCC452416D647F,0x15DF5CA28EF40D60},{0xCAFD69DB678AB6CC,0x117F7D4ED8C33DE6},{0xAB2F0FC572778ADF,0x1BFF2EE48E052FD7},{0x88F273045B92D580,0x1665BF1D3E6A8CAC},{0xD3F528D049424466,0x11EAFF4A98553D56},{0xB988414D4203A0A3,0x1CAB3210F3BB9557},{0x6139CDD76802E6E9,0x16EF5B40C2FC7779},{0xE761717920025254,0x125915CD68C9F92D},{0xA568B58E999D5086,0x1D5B561574765B7C},{0x5120913EE14AA6D2,0x177C44DDF6C515FD},{0xA74D40FF1AA21F0E,0x12C9D0B1923744CA},{0xBAECE64F769CB4A,0x1E0FB44F50586E11},{0x3C8BD850C5EE3C3B,0x180C903F7379F1A7},{0xCA0979DA37F1C9C9,0x133D4032C2C7F485},{0xA9A8C2F6BFE942DB,0x1EC866B79E0CBA6F},{0x2153CF2BCCBA9BE3,0x18A0522C7E709526},{0x1AA9728970954982,0x13B374F06526DDB8},{0xF775840F1A88759D,0x1F8587E7083E2F8C},{0x5F9136727BA05E17,0x19379FEC0698260A},{0x1940F85B9619E4DF,0x142C7FF0054684D5},{0xE100C6AFAB47EA4C,0x1023998CD1053710},{0xCE67A44C453FDD47,0x19D28F47B4D524E7},{0xD852E9D69DCCB106,0x14A8729FC3DDB71F},{0x79DBEE454B0A2738,0x1086C219697E2C19},{0x295FE3A211A9D859,0x1A71368F0F30468F},{0xBAB31C81A7BB137A,0x15275ED8D8F36BA5},{0x6228E39AEC95A92F,0x10EC4BE0AD8F8951},{0x9D0E38F7E0EF7517,0x1B13AC9AAF4C0EE8},{0xB0D82D931A592A79,0x15A956E225D67253},{0x8D79BE0F4847552E,0x11544581B7DEC1DC},{0x158F967EDA0BBB7C,0x1BBA08CF8C979C94},{0x77A611FF14D62F97,0x162E6D72D6DFB076},{0xF951A7FF43DE8C79,0x11BEBDF578B2F391},{0xC21C3FFED2FDAD8E,0x1C6463225AB7EC1C},{0x1B0333242648AD8,0x16B6B5B5155FF017},{0x159C28E9B83A246,0x122BC490DDE659AC},{0xCEF604175F3903A3,0x1D12D41AFCA3C2AC},{0x725E69AC4C2D9C83,0x17424348CA1C9BBD},{0xF5185489D68AE39C,0x129B69070816E2FD},{0xEE8D540FBDAB05C6,0x1DC574D80CF16B2F},{0xBED77672FE226B05,0x17D12A4670C1228C},{0xFF12C528CB4EBC04,0x130DBB6B8D674ED6},{0xCB513B74787DF9A0,0x1E7C5F127BD87E24},{0x90DC929F9FE614D,0x18637F41FCAD31B7},{0xA0D7D42194CB810A,0x1382CC34CA2427C5},{0x67BFB9CF5478CE77,0x1F37AD21436D0C6F},{0x1FCC94A5DD2D71F9,0x18F9574DCF8A7059},{0x7FD6DD517DBDF4C7,0x13FAAC3E3FA1F37A},{0xFFBE2EE8C92FEE0B,0x1FF779FD329CB8C3},{0x6631BF20A0F324D6,0x1992C7FDC216FA36},{0xB827CC1A1A5C1D78,0x14756CCB01ABFB5E},{0x935309AE7B7CE460,0x105DF0A267BCC918},{0x1EEB42B0C594A099,0x1A2FE76A3F9474F4},{0xE58902270476E6E1,0x14F31F8832DD2A5C},{0xB7A0CE859D2BEBE7,0x10C27FA028B0EEB0},{0x59014A6F61DFDFD8,0x1AD0CC33744E4AB4},{0xE0CDD525E7E64CAD,0x1573D68F903EA229},{0x4D7177518651D6F1,0x11297872D9CBB4EE},{0x7BE8BEE8D6E957E8,0x1B758D848FAC54B0},{0xFCBA3253DF211320,0x15F7A46A0C89DD59},{0x63C8284318E74280,0x1192E9EE706E4AAE},{0x60D0D3827D86A66,0x1C1E43171A4A1117},{0x6B3DA42CECAD21EB,0x167E9C127B6E7412},{0x88FE1CF0BD574E56,0x11FEE341FC585CDB},{0x419694B462254A23,0x1CCB0536608D615F},{0x67ABAA29E81DD4E9,0x1708D0F84D3DE77F},{0xB95621BB2017DD87,0x126D73F9D764B932},{0xC223692B668C95A5,0x1D7BECC2F23AC1EA},{0xCE82BA891ED6DE1D,0x179657025B6234BB},{0xA53562074BDF1818,0x12DEAC01E2B4F6FC},{0x3B889CD87964F359,0x1E3113363787F194},{0xFC6D4A46C783F5E1,0x18274291C6065ADC},{0x30576E9F06032B1A,0x13529BA7D19EAF17},{0x1A257DCB3CD1DE90,0x1EEA92A61C311825},{0x481DFE3C30A7E540,0x18BBA884E35A79B7},{0xD34B31C9C0865100,0x13C9539D82AEC7C5},{0x5211E942CDA3B4CD,0x1FA885C8D117A609},{0x74DB21023E1C90A4,0x19539E3A40DFB807},{0xF715B401CB4A0D50,0x1442E4FB67196005},{0xF8DE299B09080AA7,0x103583FC527AB337},{0x8E304291A80CDDD7,0x19EF3993B72AB859},{0x3E8D020E200A4B13,0x14BF6142F8EEF9E1},{0x653D9B3E80083C0F,0x10991A9BFA58C7E7},{0x6EC8F864000D2CE4,0x1A8E90F9908E0CA5},{0x8BD3F9E999A423EA,0x153EDA614071A3B7},{0x3CA994BAE1501CBB,0x10FF151A99F482F9},{0xC775BAC49BB3612B,0x1B31BB5DC320D18E},{0xD2C4956A16291A89,0x15C162B168E70E0B},{0xDBD0778811BA7BA1,0x11678227871F3E6F},{0x2C80BF401C5D929B,0x1BD8D03F3E9863E6},{0xBD33CC3349E47549,0x16470CFF6546B651},{0xCA8FD68F6E505DD4,0x11D270CC51055EA7},{0x4419574BE3B3C953,0x1C83E7AD4E6EFDD9},{0x347790982F63AA9,0x16CFEC8AA52597E1},{0xCF6C60D468C4FBBA,0x123FF06EEA847980},{0xE57A34870E07F92A,0x1D331A4B10D3F59A},{0x512E906C0B399422,0x175C1508DA432AE2},{0xDA8BA6BCD5C7A9B5,0x12B010D3E1CF5581},{0x90DF712E22D90F87,0x1DE6815302E5559C},{0xDA4C5A8B4F140C6C,0x17EB9AA8CF1DDE16},{0xAEA37BA2A5A9A38A,0x1322E220A5B17E78},{0x7DD25F6AA2A905A9,0x1E9E369AA2B59727},{0x97DB7F888220D154,0x187E92154EF7AC1F},{0x797C6606CE80A777,0x139874DDD8C6234C},{0x8F2D700AE4010BF1,0x1F5A549627A36BAD},{0xC2459A25000D65A,0x191510781FB5EFBE},{0x701D1481D99A4515,0x1410D9F9B2F7F2FE},{0xC017439B147B6A77,0x100D7B2E28C65BFE},{0xCCF205C4ED9243F2,0x19AF2B7D0E0A2CCA},{0xA5B37D0BE0E9CC2,0x148C22CA71A1BD6F},{0x848F973CB3EE3CE,0x10701BD527B4978C},{0xDA0E5BEC78649FB0,0x1A4CF9550C5425AC},{0x7B3EAFF060507FC0,0x150A6110D6A9B7BD},{0x95CBBFF380406633,0x10D51A73DEEE2C97},{0xEFAC665266CD7052,0x1AEE90B964B04758},{0x2623850EB8A459DB,0x158BA6FAB6F36C47},{0x1E82D0D893B6AE49,0x113C85955F29236C},{0xFD9E1AF41F8AB075,0x1B9408EEFEA838AC},{0x97B1AF29B2D559F7,0x16100725988693BD},{0xAC8E25BAF5777B2C,0x11A66C1E139EDC97},{0x7A7D092B2258C513,0x1C3D79C9B8FE2DBF},{0x61FDA0EF4EAD6A76,0x169794A160CB57CC},{0xE7FE1A590BBDEEC5,0x1212DD4DE7091309},{0xA6635D5B45FCB13A,0x1CEAFBAFD80E84DC},{0x851C4AAF6B308DC8,0x172262F3133ED0B0},{0xD0E36EF2BC26D7D4,0x1281E8C275CBDA26},{0xB49F17EAC6A48C86,0x1D9CA79D894629D7},{0x2A18DFEF0550706B,0x17B08617A104EE46},{0x54E0B3259DD9F389,0x12F39E794D9D8B6B},{0x87CDEB6F62F65274,0x1E5297287C2F4578},{0xD30B22BF825EA85D,0x18421286C9BF6AC6},{0xF3C1BCC684BB9E4,0x13680ED23AFF889F},{0x18602C7A4079296D,0x1F0CE4839198DA98},{0x46B356C833942124,0x18D71D360E13E213},{0x388F78A029434DB6,0x13DF4A91A4DCB4DC},{0x5A7F2766A86BAF8A,0x1FCBAA82A1612160},{0x153285EBB9EFBFA2,0x196FBB9BB44DB44D},{0xAA8ED189618C994E,0x145962E2F6A4903D},{0xEED8A7A11AD6E10C,0x1047824F2BB6D9CA},{0x7E27729B5E249B45,0x1A0C03B1DF8AF611},{0xFE85F549181D4904,0x14D6695B193BF80D},{0xCB9E5DD4134AA0D0,0x10AB877C142FF9A4},{0xDF63C9535211014D,0x1AAC0BF9B9E65C3A},{0x191CA10F74DA6771,0x15566FFAFB1EB02F},{0xADB080D92A4852C1,0x1111F32F2F4BC025},{0x15E7348EAA0D5134,0x1B4FEB7EB212CD09},{0xAB1F5D3EEE710DC4,0x15D98932280F0A6D},{0xBC1917658B8DA49D,0x117AD428200C0857},{0x2CF4F23C127C3A94,0x1BF7B9D9CCE00D59},{0xF0C3F4FCDB969543,0x165FC7E170B33DE0},{0x5A365D9716121103,0x11E6398126F5CB1A},{0x9056FC24F01CE804,0x1CA38F350B22DE90},{0xD9DF301D8CE3ECD0,0x16E93F5DA2824BA6},{0xE17F59B13D8323DA,0x125432B14ECEA2EB},{0x68CBC2B52F38395C,0x1D53844EE47DD179},{0x53D6355DBF602DE3,0x177603725064A794},{0xA9782AB165E68B1C,0x12C4CF8EA6B6EC76},{0xF26AAB56FD744FA,0x1E07B27DD78B13F1},{0x3F52222ABFDF6A62,0x18062864AC6F4327},{0x65DB4E88997F884E,0x1338205089F29C1F},{0x6FC54A7428CC0D4A,0x1EC033B40FEA9365},{0x596AA1F68709A43B,0x1899C2F673220F84},{0xADEEE7F86C07B696,0x13AE3591F5B4D936},{0x497E3FF3E00C5756,0x1F7D228322BAF524},{0xD464FFF64CD6AC45,0x1930E868E89590E9},{0x4383FFF83D7889D1,0x14272053ED4473EE},{0xCF9CCCC69793A174,0x101F4D0FF1038FF1},{0x7F6147A425B90252,0x19CBAE7FE805B31C},{0xCC4DD2E9B7C7350F,0x14A2F1FFECD15C16},{0x3D0B0F215FD290D9,0x10825B3323DAB012},{0x61AB4B689950E7C1,0x1A6A2B85062AB350},{0x4E22A2BA1440B967,0x1521BC6A6B555C40},{0xB4EE894DD009453,0x10E7C9EEBC4449CD},{0x1217DA87C800ED51,0x1B0C764AC6D3A948},{0xDB46486CA000BDDA,0x15A391D56BDC876C},{0x490506BD4CCD64AF,0x114FA7DDEFE39F8A},{0xA8080AC87AE23AB1,0x1BB2A62FE638FF43},{0x5339A239FBE82EF4,0x162884F31E93FF69},{0x75C7B4FB2FECF25D,0x11BA03F5B20FFF87},{0x22D92191E647EA2E,0x1C5CD322B67FFF3F},{0xB57A8141850654F2,0x16B0A8E891FFFF65},{0xC4620101373843F5,0x1226ED86DB3332B7},{0x3A366801F1F39FEE,0x1D0B15A491EB8459},{0xFB5EB99B27F6198B,0x173C115074BC69E0},{0x2F7EFAE2865E7AD6,0x129674405D6387E7},{0xE597F7D0D6FD9156,0x1DBD86CD6238D971},{0x8479930D78CADAAB,0x17CAD23DE82D7AC1},{0xD06142712D6F1556,0x1308A831868AC89A},{0x4D686A4EAF182222,0x1E74404F3DAADA91},{0xA453883EF279B4E8,0x185D003F6488AEDA},{0xE9DC6CFF28615D87,0x137D99CC506D58AE},{0xA960AE650D6895A4,0x1F2F5C7A1A488DE4},{0xBAB3BEB73DED4483,0x18F2B061AEA07183},{0x2EF6322C318A9D36,0x13F559E7BEE6C136},{0xE4BD1D13827761F0,0x1FEEF63F97D79B89},{0x83CA7DA9352C4E5A,0x198BF832DFDFAFA1},{0x9CA1FE20F756A515,0x146FF9C24CB2F2E7},{0x4A1B31B3F9121DAA,0x1059949B708F28B9},{0x435EB5ECC1B695DD,0x1A28EDC580E50DF5},{0x35E55E57015EDE4A,0x14ED8B04671DA4C4},{0xC4B77EAC0118B1D5,0x10BE08D0527E1D69},{0xA12597799B5AB622,0x1AC9A7B3B7302F0F},{0x4DB7AC6149155E81,0x156E1FC2F8F358D9},{0xD7C6238107444B9B,0x1124E63593F5E0AD},{0x593D059B3ED3AC2B,0x1B6E3D2286563449},{0xE0FD9E15CBDC89BC,0x15F1CA820511C36D},{0xB3FE18116FE3A163,0x118E3B9B37416924},{0x866359B57FD29BD1,0x1C16C5C525357507},{0xD1E91491330EE30E,0x16789E3750F790D2},{0x74BA76DA8F3F1C0B,0x11FA182C40C60D75},{0xEDF72490E531C678,0x1CC359E067A348BB},{0x8B2C1D40B75B052D,0x1702AE4D1FB5D3C9},{0x6F567DCD5F7C0424,0x12688B70E62B0FD4},{0x7EF0C94898C66D06,0x1D74124E3D11B2ED},{0x98C0A106E09EBD9F,0x17900EA4FDA7C257},{0x470080D24D4BCAE6,0x12D9A550CAEC9B79},{0xD800CE1D487944A2,0x1E29088144ADC58E},{0x1333D8176D2DD082,0x1820D39A9D57D13F},{0xA8F646792424A6CE,0x134D76154AACA765},{0x74BD3D8EA03AA47D,0x1EE25688777AA56F},{0x5D64313EE6955064,0x18B51206C5FBB78C},{0x4AB68DCBEBAAA6B7,0x13C40E6BD1962C70},{0x1124161312AAA457,0x1FA01712E8F0471A},{0xDA8344DC0EEEE9DF,0x194CDF4253F36C14},{0xE2029D7CD8BF2180,0x143D7F6843292343},{0x4E687DFD7A328133,0x103132B9CF541C36},{0x4A40C9959050CEB8,0x19E851294BB9C6BD},{0x833D477A6A70BC6,0x14B9DA876FC7D231},{0xA02976C61EEC096B,0x1094AED2BFD30E8D},{0x4257A364ACDBDF,0x1A877E1DFFB81749},{0xCD01DFB5EA23E319,0x153931B1996012A0},{0x70CE4C91881CB5AE,0x10FA8E27ADE6754D},{0x1AE3ADB5A69455E2,0x1B2A7D0C4970BBAF},{0x7BE957C4854377E8,0x15BB973D078D62F2},{0xC987796A0435F987,0x1162DF64060AB58E},{0x75A58F1006BCC271,0x1BD1656CD67788E4},{0xF7B7A5A66BCA3527,0x16411DF0AB92D3E9},{0x5FC61E1EBCA1C41F,0x11CDB18D560F0FEE},{0xFFA363646102D365,0x1C7C4F4889B1B316},{0x32E91C504D9BDC51,0x16C9D906D48E28DF},{0x8F20E37371497D0E,0x123B140576D820B2},{0x7E9B0585820F2E7C,0x1D2B533BF159CDEA},{0xCBAF379E01A5BECA,0x1755DC2FF447D7EE},{0x958F94B348498A1,0x12AB168CC36CACBF}}};
inline static constexpr std::array<std::array<std::uint64_t,2>,326> split={{{0,0x1000000000000000},{0,0x1400000000000000},{0,0x1900000000000000},{0,0x1F40000000000000},{0,0x1388000000000000},{0,0x186A000000000000},{0,0x1E84800000000000},{0,0x1312D00000000000},{0,0x17D7840000000000},{0,0x1DCD650000000000},{0,0x12A05F2000000000},{0,0x174876E800000000},{0,0x1D1A94A200000000},{0,0x12309CE540000000},{0,0x16BCC41E90000000},{0,0x1C6BF52634000000},{0,0x11C37937E0800000},{0,0x16345785D8A00000},{0,0x1BC16D674EC80000},{0,0x1158E460913D0000},{0,0x15AF1D78B58C4000},{0,0x1B1AE4D6E2EF5000},{0,0x10F0CF064DD59200},{0,0x152D02C7E14AF680},{0,0x1A784379D99DB420},{0,0x108B2A2C28029094},{0,0x14ADF4B7320334B9},{0x4000000000000000,0x19D971E4FE8401E7},{0x8800000000000000,0x1027E72F1F128130},{0xAA00000000000000,0x1431E0FAE6D7217C},{0xD480000000000000,0x193E5939A08CE9DB},{0xC9A0000000000000,0x1F8DEF8808B02452},{0xBE04000000000000,0x13B8B5B5056E16B3},{0xAD85000000000000,0x18A6E32246C99C60},{0xD8E6400000000000,0x1ED09BEAD87C0378},{0x878FE80000000000,0x13426172C74D822B},{0x6973E20000000000,0x1812F9CF7920E2B6},{0x3D0DA8000000000,0x1E17B84357691B64},{0x8262889000000000,0x12CED32A16A1B11E},{0x22FB2AB400000000,0x178287F49C4A1D66},{0xABB9F56100000000,0x1D6329F1C35CA4BF},{0xCB54395CA0000000,0x125DFA371A19E6F7},{0xBE2947B3C8000000,0x16F578C4E0A060B5},{0x2DB399A0BA000000,0x1CB2D6F618C878E3},{0xFC90400474400000,0x11EFC659CF7D4B8D},{0x7BB4500591500000,0x166BB7F0435C9E71},{0xDAA16406F5A40000,0x1C06A5EC5433C60D},{0xA8A4DE8459868000,0x118427B3B4A05BC8},{0xD2CE16256FE82000,0x15E531A0A1C872BA},{0x87819BAECBE22800,0x1B5E7E08CA3A8F69},{0xF4B1014D3F6D5900,0x111B0EC57E6499A1},{0x71DD41A08F48AF40,0x1561D276DDFDC00A},{0xE549208B31ADB10,0x1ABA4714957D300D},{0x28F4DB456FF0C8EA,0x10B46C6CDD6E3E08},{0x33321216CBECFB24,0x14E1878814C9CD8A},{0xBFFE969C7EE839ED,0x1A19E96A19FC40EC},{0xF7FF1E21CF512434,0x105031E2503DA893},{0xF5FEE5AA43256D41,0x14643E5AE44D12B8},{0x337E9F14D3EEC892,0x197D4DF19D605767},{0x5E46DA08EA7AB6,0x1FDCA16E04B86D41},{0xA03AEC4845928CB2,0x13E9E4E4C2F34448},{0xC849A75A56F72FDE,0x18E45E1DF3B0155A},{0x7A5C1130ECB4FBD6,0x1F1D75A5709C1AB1},{0xEC798ABE93F11D65,0x13726987666190AE},{0xA797ED6E38ED64BF,0x184F03E93FF9F4DA},{0x517DE8C9C728BDEF,0x1E62C4E38FF87211},{0xD2EEB17E1C7976B5,0x12FDBB0E39FB474A},{0x87AA5DDDA397D462,0x17BD29D1C87A191D},{0xE994F5550C7DC97B,0x1DAC74463A989F64},{0x11FD195527CE9DED,0x128BC8ABE49F639F},{0xD67C5FAA71C24568,0x172EBAD6DDC73C86},{0x8C1B77950E32D6C2,0x1CFA698C95390BA8},{0x57912ABD28DFC639,0x121C81F7DD43A749},{0xAD75756C7317B7C8,0x16A3A275D494911B},{0x98D2D2C78FDDA5BA,0x1C4C8B1349B9B562},{0x9F83C3BCB9EA8794,0x11AFD6EC0E14115D},{0x764B4ABE8652979,0x161BCCA7119915B5},{0x493DE1D6E27E73D7,0x1BA2BFD0D5FF5B22},{0x6DC6AD264D8F0866,0x1145B7E285BF98F5},{0xC938586FE0F2CA80,0x159725DB272F7F32},{0x7B866E8BD92F7D20,0x1AFCEF51F0FB5EFF},{0xAD34051767BDAE34,0x10DE1593369D1B5F},{0x9881065D41AD19C1,0x15159AF804446237},{0x7EA147F492186032,0x1A5B01B605557AC5},{0x6F24CCF8DB4F3C1F,0x1078E111C3556CBB},{0x4AEE003712230B27,0x14971956342AC7EA},{0xDDA98044D6ABCDF0,0x19BCDFABC13579E4},{0xA89F02B062B60B6,0x10160BCB58C16C2F},{0xCD2C6C35C7B638E4,0x141B8EBE2EF1C73A},{0x8077874339A3C71D,0x1922726DBAAE3909},{0xE0956914080CB8E4,0x1F6B0F092959C74B},{0x6C5D61AC8507F38E,0x13A2E965B9D81C8F},{0x4774BA17A649F072,0x188BA3BF284E23B3},{0x1951E89D8FDC6C8F,0x1EAE8CAEF261ACA0},{0xFD3316279E9C3D9,0x132D17ED577D0BE4},{0x13C7FDBB186434CF,0x17F85DE8AD5C4EDD},{0x58B9FD29DE7D4203,0x1DF67562D8B36294},{0xB7743E3A2B0E4942,0x12BA095DC7701D9C},{0xE5514DC8B5D1DB92,0x17688BB5394C2503},{0xDEA5A13AE3465277,0x1D42AEA2879F2E44},{0xB2784C4CE0BF38A,0x1249AD2594C37CEB},{0xCDF165F6018EF06D,0x16DC186EF9F45C25},{0x416DBF7381F2AC88,0x1C931E8AB871732F},{0x88E497A83137ABD5,0x11DBF316B346E7FD},{0xEB1DBD923D8596CA,0x1652EFDC6018A1FC},{0x25E52CF6CCE6FC7D,0x1BE7ABD3781ECA7C},{0x97AF3C1A40105DCE,0x1170CB642B133E8D},{0xFD9B0B20D0147542,0x15CCFE3D35D80E30},{0x3D01CDE904199292,0x1B403DCC834E11BD},{0x462120B1A28FFB9B,0x1108269FD210CB16},{0xD7A968DE0B33FA82,0x154A3047C694FDDB},{0xCD93C3158E00F923,0x1A9CBC59B83A3D52},{0xC07C59ED78C09BB6,0x10A1F5B813246653},{0xB09B7068D6F0C2A3,0x14CA732617ED7FE8},{0xDCC24C830CACF34C,0x19FD0FEF9DE8DFE2},{0xC9F96FD1E7EC180F,0x103E29F5C2B18BED},{0x3C77CBC661E71E13,0x144DB473335DEEE9},{0x8B95BEB7FA60E598,0x1961219000356AA3},{0x6E7B2E65F8F91EFE,0x1FB969F40042C54C},{0xC50CFCFFBB9BB35F,0x13D3E2388029BB4F},{0xB6503C3FAA82A037,0x18C8DAC6A0342A23},{0xA3E44B4F95234844,0x1EFB1178484134AC},{0xE66EAF11BD360D2B,0x135CEAEB2D28C0EB},{0xE00A5AD62C839075,0x183425A5F872F126},{0x980CF18BB7A47493,0x1E412F0F768FAD70},{0x5F0816F752C6C8DC,0x12E8BD69AA19CC66},{0xF6CA1CB527787B13,0x17A2ECC414A03F7F},{0xF47CA3E2715699D7,0x1D8BA7F519C84F5F},{0xF8CDE66D86D62026,0x127748F9301D319B},{0xF7016008E88BA830,0x17151B377C247E02},{0xB4C1B80B22AE923C,0x1CDA62055B2D9D83},{0x50F91306F5AD1B65,0x12087D4358FC8272},{0xE53757C8B318623F,0x168A9C942F3BA30E},{0x9E852DBADFDE7ACF,0x1C2D43B93B0A8BD2},{0xA3133C94CBEB0CC1,0x119C4A53C4E69763},{0x8BD80BB9FEE5CFF1,0x16035CE8B6203D3C},{0xAECE0EA87E9F43EE,0x1B843422E3A84C8B},{0x4D40C9294F238A75,0x1132A095CE492FD7},{0x2090FB73A2EC6D12,0x157F48BB41DB7BCD},{0x68B53A508BA78856,0x1ADF1AEA12525AC0},{0x417144725748B536,0x10CB70D24B7378B8},{0x51CD958EED1AE283,0x14FE4D06DE5056E6},{0xE640FAF2A8619B24,0x1A3DE04895E46C9F},{0xEFE89CD7A93D00F7,0x1066AC2D5DAEC3E3},{0xEBE2C40D938C4134,0x14805738B51A74DC},{0x26DB7510F86F5181,0x19A06D06E2611214},{0x9849292A9B4592F1,0x100444244D7CAB4C},{0xBE5B73754216F7AD,0x1405552D60DBD61F},{0xADF25052929CB598,0x1906AA78B912CBA7},{0x996EE4673743E2FF,0x1F485516E7577E91},{0xFFE54EC0828A6DDF,0x138D352E5096AF1A},{0xBFDEA270A32D0957,0x18708279E4BC5AE1},{0x2FD64B0CCBF84BAD,0x1E8CA3185DEB719A},{0x5DE5EEE7FF7B2F4C,0x1317E5EF3AB32700},{0x755F6AA1FF59FB1F,0x17DDDF6B095FF0C0},{0x92B7454A7F3079E7,0x1DD55745CBB7ECF0},{0x5BB28B4E8F7E4C30,0x12A5568B9F52F416},{0xF29F2E22335DDF3C,0x174EAC2E8727B11B},{0xEF46F9AAC035570B,0x1D22573A28F19D62},{0xD58C5C0AB8215667,0x123576845997025D},{0x4AEF730D6629AC01,0x16C2D4256FFCC2F5},{0x9DAB4FD0BFB41701,0x1C73892ECBFBF3B2},{0xA28B11E277D08E60,0x11C835BD3F7D784F},{0x8B2DD65B15C4B1F9,0x163A432C8F5CD663},{0x6DF94BF1DB35DE77,0x1BC8D3F7B3340BFC},{0xC4BBCF772901AB0A,0x115D847AD000877D},{0x35EAC354F34215CD,0x15B4E5998400A95D},{0x8365742A30129B40,0x1B221EFFE500D3B4},{0xD21F689A5E0BA108,0x10F5535FEF208450},{0x6A742C0F58E894A,0x1532A837EAE8A565},{0x4851137132F22B9D,0x1A7F5245E5A2CEBE},{0xED32AC26BFD75B42,0x108F936BAF85C136},{0xA87F57306FCD3212,0x14B378469B673184},{0xD29F2CFC8BC07E97,0x19E056584240FDE5},{0xA3A37C1DD7584F1E,0x102C35F729689EAF},{0x8C8C5B254D2E62E6,0x14374374F3C2C65B},{0x6FAF71EEA079FB9F,0x1945145230B377F2},{0xB9B4E6A48987A87,0x1F965966BCE055EF},{0x674111026D5F4C94,0x13BDF7E0360C35B5},{0xC111554308B71FBA,0x18AD75D8438F4322},{0x7155AA93CAE4E7A8,0x1ED8D34E547313EB},{0x26D58A9C5ECF10C9,0x13478410F4C7EC73},{0xF08AED437682D4FB,0x1819651531F9E78F},{0xECADA89454238A3A,0x1E1FBE5A7E786173},{0x73EC895CB4963664,0x12D3D6F88F0B3CE8},{0x90E7ABB3E1BBC3FD,0x1788CCB6B2CE0C22},{0x352196A0DA2AB4FD,0x1D6AFFE45F818F2B},{0x134FE24885AB11E,0x1262DFEEBBB0F97B},{0xC1823DADAA715D65,0x16FB97EA6A9D37D9},{0x31E2CD19150DB4BF,0x1CBA7DE5054485D0},{0x1F2DC02FAD2890F7,0x11F48EAF234AD3A2},{0xA6F9303B9872B535,0x1671B25AEC1D888A},{0x50B77C4A7E8F6282,0x1C0E1EF1A724EAAD},{0x5272ADAE8F199D91,0x1188D357087712AC},{0x670F591A32E004F6,0x15EB082CCA94D757},{0x40D32F60BF980633,0x1B65CA37FD3A0D2D},{0x4883FD9C77BF03E0,0x111F9E62FE44483C},{0x5AA4FD0395AEC4D8,0x156785FBBDD55A4B},{0x314E3C447B1A760E,0x1AC1677AAD4AB0DE},{0xDED0E5AACCF089C9,0x10B8E0ACAC4EAE8A},{0x96851F15802CAC3B,0x14E718D7D7625A2D},{0xFC2666DAE037D74A,0x1A20DF0DCD3AF0B8},{0x9D980048CC22E68E,0x10548B68A044D673},{0x84FE005AFF2BA032,0x1469AE42C8560C10},{0xA63D8071BEF6883E,0x198419D37A6B8F14},{0xCFCCE08E2EB42A4E,0x1FE52048590672D9},{0x21E00C58DD309A70,0x13EF342D37A407C8},{0x2A580F6F147CC10D,0x18EB0138858D09BA},{0xB4EE134AD99BF150,0x1F25C186A6F04C28},{0x7114CC0EC80176D2,0x137798F428562F99},{0xCD59FF127A01D486,0x18557F31326BBB7F},{0xC0B07ED7188249A8,0x1E6ADEFD7F06AA5F},{0xD86E4F466F516E09,0x1302CB5E6F642A7B},{0xCE89E3180B25C98B,0x17C37E360B3D351A},{0x822C5BDE0DEF3BEE,0x1DB45DC38E0C8261},{0xF15BB96AC8B58575,0x1290BA9A38C7D17C},{0x2DB2A7C57AE2E6D2,0x1734E940C6F9C5DC},{0x391F51B6D99BA086,0x1D022390F8B83753},{0x3B3931248014454,0x1221563A9B732294},{0x4A077D6DA019569,0x16A9ABC9424FEB39},{0x45C895CC9081FAC3,0x1C5416BB92E3E607},{0x8B9D5D9FDA513CBA,0x11B48E353BCE6FC4},{0xAE84B507D0E58BE8,0x1621B1C28AC20BB5},{0x1A25E249C51EEEE3,0x1BAA1E332D728EA3},{0xF057AD6E1B33554D,0x114A52DFFC679925},{0x6C6D98C9A2002AA1,0x159CE797FB817F6F},{0x4788FEFC0A803549,0x1B04217DFA61DF4B},{0xCB59F5D8690214E,0x10E294EEBC7D2B8F},{0xCFE30734E83429A1,0x151B3A2A6B9C7672},{0x83DBC9022241340A,0x1A6208B50683940F},{0xB2695DA15568C086,0x107D457124123C89},{0x1F03B509AAC2F0A7,0x149C96CD6D16CBAC},{0x26C4A24C1573ACD1,0x19C3BC80C85C7E97},{0x783AE56F8D684C03,0x101A55D07D39CF1E},{0x16499ECB70C25F03,0x1420EB449C8842E6},{0x9BDC067E4CF2F6C4,0x19292615C3AA539F},{0x82D3081DE02FB476,0x1F736F9B3494E887},{0xB1C3E512AC1DD0C9,0x13A825C100DD1154},{0xDE34DE57572544FC,0x18922F31411455A9},{0x55C215ED2CEE963B,0x1EB6BAFD91596B14},{0xB5994DB43C151DE5,0x133234DE7AD7E2EC},{0xE2FFA1214B1A655E,0x17FEC216198DDBA7},{0xDBBF89699DE0FEB6,0x1DFE729B9FF15291},{0x2957B5E202AC9F31,0x12BF07A143F6D39B},{0xF3ADA35A8357C6FE,0x176EC98994F48881},{0x70990C31242DB8BD,0x1D4A7BEBFA31AAA2},{0x865FA79EB69C9376,0x124E8D737C5F0AA5},{0xE7F791866443B854,0x16E230D05B76CD4E},{0xA1F575E7FD54A669,0x1C9ABD04725480A2},{0xA53969B0FE54E801,0x11E0B622C774D065},{0xE87C41D3DEA2202,0x1658E3AB7952047F},{0xD229B5248D64AA82,0x1BEF1C9657A6859E},{0x435A1136D85EEA91,0x117571DDF6C81383},{0x143095848E76A536,0x15D2CE55747A1864},{0x193CBAE5B2144E83,0x1B4781EAD1989E7D},{0x2FC5F4CF8F4CB112,0x110CB132C2FF630E},{0xBBB77203731FDD56,0x154FDD7F73BF3BD1},{0x2AA54E844FE7D4AC,0x1AA3D4DF50AF0AC6},{0xDAA75112B1F0E4EB,0x10A6650B926D66BB},{0xD15125575E6D1E26,0x14CFFE4E7708C06A},{0x85A56EAD360865B0,0x1A03FDE214CAF085},{0x7387652C41C53F8E,0x10427EAD4CFED653},{0x50693E7752368F71,0x14531E58A03E8BE8},{0x64838E1526C4334E,0x1967E5EEC84E2EE2},{0xFDA4719A70754022,0x1FC1DF6A7A61BA9A},{0xDE86C70086494815,0x13D92BA28C7D14A0},{0x162878C0A7DB9A1A,0x18CF768B2F9C59C9},{0x5BB296F0D1D280A1,0x1F03542DFB83703B},{0x194F9E5683239064,0x1362149CBD322625},{0x5FA385EC23EC747E,0x183A99C3EC7EAFAE},{0xF78C67672CE7919D,0x1E494034E79E5B99},{0x3AB7C0A07C10BB02,0x12EDC82110C2F940},{0x4965B0C89B14E9C3,0x17A93A2954F3B790},{0x5BBF1CFAC1DA2433,0x1D9388B3AA30A574},{0xB957721CB92856A0,0x127C35704A5E6768},{0xE7AD4EA3E7726C48,0x171B42CC5CF60142},{0xA198A24CE14F075A,0x1CE2137F74338193},{0x44FF65700CD16498,0x120D4C2FA8A030FC},{0x563F3ECC1005BDBE,0x16909F3B92C83D3B},{0x2BCF0E7F14072D2E,0x1C34C70A777A4C8A},{0x5B61690F6C847C3D,0x11A0FC668AAC6FD6},{0xF239C35347A59B4C,0x16093B802D578BCB},{0xEEC83428198F021F,0x1B8B8A6038AD6EBE},{0x553D20990FF96153,0x1137367C236C6537},{0x2A8C68BF53F7B9A8,0x1585041B2C477E85},{0x752F82EF28F5A812,0x1AE64521F7595E26},{0x93DB1D57999890B,0x10CFEB353A97DAD8},{0xB8D1E4AD7FFEB4E,0x1503E602893DD18E},{0x8E7065DD8DFFE622,0x1A44DF832B8D45F1},{0xF9063FAA78BFEFD5,0x106B0BB1FB384BB6},{0xB747CF9516EFEBCA,0x1485CE9E7A065EA4},{0xE519C37A5CABE6BD,0x19A742461887F64D},{0xAF301A2C79EB7036,0x1008896BCF54F9F0},{0xDAFC20B798664C43,0x140AABC6C32A386C},{0x11BB28E57E7FDF54,0x190D56B873F4C688},{0x1629F31EDE1FD72A,0x1F50AC6690F1F82A},{0x4DDA37F34AD3E67A,0x13926BC01A973B1A},{0xE150C5F01D88E019,0x187706B0213D09E0},{0x19A4F76C24EB181F,0x1E94C85C298C4C59},{0xB0071AA39712EF13,0x131CFD3999F7AFB7},{0x9C08E14C7CD7AAD8,0x17E43C8800759BA5},{0x30B199F9C0D958E,0x1DDD4BAA0093028F},{0x61E6F003C1887D79,0x12AA4F4A405BE199},{0xBA60AC04B1EA9CD7,0x1754E31CD072D9FF},{0xA8F8D705DE65440D,0x1D2A1BE4048F907F},{0xC99B8663AAFF4A88,0x123A516E82D9BA4F},{0xBC0267FC95BF1D2A,0x16C8E5CA239028E3},{0xAB0301FBBB2EE474,0x1C7B1F3CAC74331C},{0xEAE1E13D54FD4EC9,0x11CCF385EBC89FF1},{0x659A598CAA3CA27B,0x1640306766BAC7EE},{0xFF00EFEFD4CBCB1A,0x1BD03C81406979E9},{0x3F6095F5E4FF5EF0,0x116225D0C841EC32},{0xCF38BB735E3F36AC,0x15BAAF44FA52673E},{0x8306EA5035CF0457,0x1B295B1638E7010E},{0x11E4527221A162B6,0x10F9D8EDE39060A9},{0x565D670EAA09BB64,0x15384F295C7478D3},{0x2BF4C0D2548C2A3D,0x1A8662F3B3919708},{0x1B78F88374D79A66,0x1093FDD8503AFE65},{0x625736A4520D8100,0x14B8FD4E6449BDFE},{0xFAED044D6690E140,0x19E73CA1FD5C2D7D},{0xBCD422B0601A8CC8,0x103085E53E599C6E},{0x6C092B5C78212FFA,0x143CA75E8DF0038A},{0x70B763396297BF8,0x194BD136316C046D},{0x48CE53C07BB3DAF6,0x1F9EC583BDC70588},{0x2D80F4584D5068DA,0x13C33B72569C6375},{0x78E1316E60A48310,0x18B40A4EEC437C52}}};
};

template<bool controller>
requires (controller)
struct pow5<long double,controller>
{
inline static constexpr std::array<std::uint64_t,156> errors={0,0,0,0x9555596400000000,0x65A6569525565555,0x4415551445449655,0x5105015504144541,0x65A69969A6965964,0x5054955969959656,0x5105154515554145,0x4055511051591555,0x5500514455550115,0x41140014145515,0x1005440545511051,0x14405450411004,0x414440010500000,0x44000440010040,0x5551155000004001,0x4554555454544114,0x5150045544005441,0x1111400054501,0x6550955555554554,0x1504159645559559,0x4105055141454545,0x1411541410405454,0x415555044545555,0x14154115405550,0x1540055040411445,0x500000000,0x5644000000000000,0x1155555591596555,0x410440054569565,0x5145100010010005,0x555041405500150,0x4141450455140450,0x144000140,0x5114004001105410,0x4444100404005504,0x414014410001015,0x5145055155555015,0x141041444445540,0x100451541414,0x4105041104155550,0x500501150451145,0x1001050000004114,0x5551504400141045,0x5110545410151454,0x100001400004040,0x5040010111040000,0x140000150541100,0x4400140400104110,0x5011014405545004,0x44155440,0x10000000,0x1100401444440001,0x40401010055111,0x5155155551405454,0x444440015514411,0x54505054014101,0x451015441115511,0x1541411401140551,0x4155104514445110,0x4141145450145515,0x5451445055155050,0x4400515554110054,0x5111145104501151,0x565A655455500501,0x5565555555525955,0x550511500405695,0x4415504051054544,0x6555595965555554,0x100915915555655,0x5540001510001001,0x5450051414000544,0x1405010555555551,0x5555515555644155,0x5555055595496555,0x5451045004415000,0x5450510144040144,0x5554155555556455,0x5051555495415555,0x5555554555555545,0x10005455,0x4000005000040000,0x5565555555555954,0x5554559555555505,0x9645545495552555,0x4000400055955564,0x40000000000001,0x4004100100000000,0x5540040440000411,0x4565555955545644,0x1140659549651556,0x100000410010000,0x5555515400004001,0x5955545555155255,0x5151055545505556,0x5051454510554515,0x501500050415554,0x5044154005441005,0x1455445450550455,0x10144055144545,0x401100000004,0x1050145050000010,0x415004554011540,0x1000510100151150,0x100040400001144,0,0x550004400000100,0x151145041451151,0x400400005450,0x100044010004,0x100054100050040,0x504400005410010,0x4011410445500105,0x404000144411,0x101504404500000,0x5044400400,0x14000100,0x404440414000000,0x5554100410000140,0x4555455544505555,0x5454105055455455,0x115454155454015,0x4404110000045100,0x4400001100101501,0x6596955956966A94,0x40655955665965,0x5554144400100155,0xA549495401011041,0x5596555565955555,0x5569965959549555,0x969565A655555456,0x1000000000,0x40000140,0x40100000000,0x1415454400000000,0x5410415411454114,0x400040104000154,0x504045000000411,0x1000000010,0x5554000000001040,0x5549155551556595,0x1455541055515555,0x510555454554541,0x9555555555540455,0x6455456555556465,0x4524565555654514,0x5554655255559545,0x9555455441155556,0x51515555,0x10005040000550,0x5044044040000000,0x1045040440010500,0x400000040000,0};
inline static constexpr std::array<std::array<std::uint64_t,4>,89> split={{{0,0,0,0x100000000000000},{0,0x4840000000000000,0x3F7FF1E21CF51243,0x105031E2503DA89},{0x2EA2EEBEE3D257E5,0x60E94FDE0330F221,0x3C07C59ED78C09BB,0x10A1F5B81324665},{0xA5640967B2D0DEAB,0x85F6231F93842F43,0xD21F689A5E0BA10,0x10F5535FEF20845},{0x1BAF2497FF066293,0xDF78218B8B9B52F9,0x5F057AD6E1B33554,0x114A52DFFC67992},{0xD4CFA0E5A78FF42,0xD0FD8C6E61EA0168,0x65B61690F6C847C3,0x11A0FC668AAC6FD},{0x1CA8DE546BB86CFC,0x632920C7B148DE18,0xCC42749E154BD14F,0x11F9584AEAB1DC9},{0x7CA0C234C4381DC7,0xBE405B12A22D552D,0x723860DEBA3616BF,0x12536F0E3BCFE45},{0x5FF4CE7144FB9EF,0x6E7823B0861AB890,0xA74FD53910719D28,0x12AF495C3D7EFE7},{0x6B7E6D81E817BD3,0xD050974C01DD3EC6,0xE97E3A9395999ABC,0x130CF00C24FD9C9},{0xCD4DD26F069DA25C,0xE4E7E4DD705ED700,0x8CCAA9298B92BAEF,0x136C6C21772487C},{0xD619A96ECC15B8D2,0xAB1F0D0D11F1D6F3,0xC205C010727FAC16,0x13CDC6CCE67F0AA},{0x8A7DF7300FB0DA78,0xBB0982143A45EB5B,0xC8ABC09B749677A9,0x1431096D35BC492},{0xABE0CA112803BE67,0x7E3F8046E188A34E,0x5A896444E83D63D7,0x14963D901E8F909},{0x194C5A1B506DF9CF,0xDEEB2667019D6A09,0x3239E94B877813F4,0x14FD6CF33D15D93},{0xAAF4801BF041E12D,0xB90058810A0D1A5B,0x987894AEA2A36529,0x1566A184FFD7215},{0xBDE916A26EBBE0DD,0x6A825FD3CE55FA6A,0xD30E151B0E473B1E,0x15D1E5659C7ABB7},{0x4B103106A4326024,0x59CA7FA7F96B69BE,0xD1BB253E1387DFEB,0x163F42E809461CB},{0x9E4E19B3E2691D66,0xFC6FDB05FD38EBF9,0x3C32636B0752863A,0x16AEC492FB7E2F5},{0x3912336034B67B3D,0xCD4ECD37BF8DED3,0xC5C61B607C1F1BA5,0x17207521EAC3A4B},{0xEBE08C2A4D684035,0x8AFFC81BDFC2FCAB,0x213D6B9632C8EA11,0x17945F8619833E1},{0x3FACF7E6A8452F17,0x4A1B763882DD7CCC,0xD6497A98000855A2,0x180A8EE7A2937E4},{0x1FBA126325DEAA11,0xC6DD58610B287998,0x52FD461B7AFD48F3,0x18830EA68C19B99},{0x85FC9FE41B6DA4BB,0x9CBABAB52A33C694,0xA2EC9E99F22D69BD,0x18FDEA5BDFD0F6E},{0x9DB15BF65C009298,0x6EE486A50D75E1D0,0x37D6FF7B8397D16,0x197B2DDAC8CD9E1},{0x13C0F83C8709EB29,0xC618D721710E9AA3,0xE5B9C8E58C33547E,0x19FAE531B6D972C},{0x1CBBB2058D1F4891,0x9FD51A2D7B2A89C9,0xA1C8FBDF829480DC,0x1A7D1CAB8783E87},{0x6A2447AF26AF7DB9,0xD3D5CD85086EA558,0x36E2AF8C144940A,0x1B01E0D0B503655},{0xF19FEE5AC978F3C8,0x97998A5846DBD9AE,0xC1F61731ED7789E1,0x1B893E688B049C6},{0x846E63EED720BBFF,0x2ABC57BBAFA2553C,0xC58D8D82EC9C08FC,0x1C13427A6185B74},{0x8FD6B1B1DE55B4F8,0x75783476E4D6F132,0xB10FD1B9F813B786,0x1C9FFA4EDDDB9CC},{0xCC4934B80DB8BABB,0x9F51E128817D2F7F,0x676346C8551B479E,0x1D2F73713A003B5},{0x177E69FEF2C60519,0xF7840AF1F470A291,0x185A80E1E6764356,0x1DC1BBB09249571},{0x4E005A0A2262E6C3,0x9DAD233C08225343,0xB9457E18C75029C0,0x1E56E12139A7FA6},{0xF23F50FE5159E3B9,0x8FCF41511303A341,0x9C11E2732B9F384E,0x1EEEF21E149148B},{0x2236DFF15F7CB136,0xF590A3767F35D624,0x14F46F327D642889,0x1F89FD49FAB2168},{0x1DDE4749978073E1,0x9B767F093152E5E3,0xE36F635B539BD750,0x101408C88FC7A93},{0xF059889E56C056C4,0x97E463E96F32D6E4,0x22198D0CD8BAD365,0x10649F15411AFA8},{0xF304592EC5347498,0x471535F9B79281CD,0x1CFFC568611B97E3,0x10B6C94CB20EECC},{0x8BECD9F9E85A912D,0xC83E230A5441DA67,0xB23AE7DE7D558792,0x110A8F5763B1CB7},{0xE0C61275A1955B60,0x8E637C29040299B5,0x923C6852363DEACD,0x115FF9457A3F10A},{0xD156A1ED2090E71D,0x3424D865FE91057,0xE73D2707AE7A90D1,0x11B70F4F83CADB0},{0x71CAFCCB2865614E,0x348F41C2BBF8F30D,0x67398BDCA32C5802,0x120FD9D742D1293},{0xA714DFF2A0B33F15,0x87A39776FA00B4ED,0x5282680F9FDD592E,0x126A61687CBC582},{0xDA9CD6DD08EAA19,0x6EAD4620C44F70EE,0x5AFDF4FA53889C23,0x12C6AEB9CC76C66},{0x85B06B9216130844,0xDF6D3E034C83B454,0x86B50910B2C8BA38,0x1324CAAD791BDFC},{0x5F3615CE78409D9A,0x3E0F29FABCB4A358,0x6CA3DBD512F668C0,0x1384BE5250DD3BB},{0xCA6260909F614C3B,0x3E656E20A44744E6,0x496A0011B24A53D2,0x13E692E48830DF9},{0xFB19A06CAA7E7143,0xB2BD32FD3E8BAF12,0xF9E13CF017990471,0x144A51CE9D5E203},{0xF9C3F16876116BA1,0xCB41D5E7EC5B82EE,0x8E74B0510D2E0342,0x14B004AA407F096},{0xAA78FEC5C62A9F4E,0x9CAF0DE724FD62B7,0x89164634E1D6A889,0x1517B541400C9F4},{0x703D78494339AE14,0x49087FBBA218E00D,0x99F437BC3E8E6AAD,0x15816D8E7A0CBF1},{0xD08D6D55C699FA4D,0xAA01B6FB233626D8,0x80EE61C00843B49A,0x15ED37BED1F8D4E},{0xD0389DB9707F8989,0x28C381DBAAD77967,0x4AFF2B396E04653A,0x165B1E322B75119},{0x488519081A48E705,0xCF398762AD36264B,0x26818740E2441EAA,0x16CB2B7C69F0429},{0xED7D705CE68F0FD8,0xA77DFE24501AB42C,0x3623891A057064D7,0x173D6A667544E5D},{0x38604693C25E8B8E,0x3769297992DAA7C9,0xDAACCECA8C37A5EC,0x17B1E5EF43748FA},{0x4CAE09D7EBE2D28D,0xA4862711D8D158F4,0x9D7112031C9EDD34,0x1828A94CE797363},{0x80B4608622CD5F36,0x3E265A063F83A3FD,0xF9F0A667529090CB,0x18A1BFEDA61875D},{0xAEEAE7A967FFC974,0x7BF110931480440C,0x823435D5CF9F153A,0x191D35790E5D657},{0xC96BD5DEE882A23D,0x13939F33006B522C,0x825C53E13B20C2C,0x199B15D119EE15B},{0x1EE75DA9E3211E9A,0x6B18A7CF7DD948AF,0x63BEEC028AF94416,0x1A1B6D13513E5F3},{0x4CB5B7AAAD2DC39B,0x209293A1284970EC,0xEB97B9A05E4798ED,0x1A9E4799F6322DB},{0x547EA0199E9D406B,0xF53701559036A0EC,0x9888513BA436B13A,0x1B23B1FD347A033},{0x9A26994CF4CF3709,0x2F1213C849422547,0xEF2B54231D83A106,0x1BABB91457E4FE7},{0x6DD13C79EE67B3FE,0xF6028688CC142EB8,0x8E589A595AE7614,0x1C3669F708C643A},{0xAED181458D805B5D,0xDA16222C14DDB6BE,0x53C41511E2269F20,0x1CC3D1FE8E8C39B},{0xEA8FF4A920CE82AC,0x3B542759743CAA23,0xC38F923AB8683DA7,0x1D53FEC718A8AA9},{0x686CA8C1DB224E38,0xD957C6692D5FEC53,0x21ECB3DBC42B348B,0x1DE6FE310DE96CD},{0x71C997E9598FF746,0x5E6A1D22BEE0AB63,0xDEF1B28D7572A970,0x1E7CDE626261DE1},{0x3DCD25599BF4B7B0,0xD3E9A9A64046F305,0x2B93628E9B1F1384,0x1F15ADC7F40617A},{0xDBD940031D4771A3,0x29D0F1DB6CE0E584,0x3CD63A4E8A681CF6,0x1FB17B16EE1968D},{0x879CBFD9293570F9,0x4402A3B9AF4A6911,0xABE45CA05F9BA979,0x10282AA719C9277},{0x82BC2E63F7FF1806,0x19CEA5EA785F1F4D,0x5AF82E6BF8770279,0x107925DBE84B652},{0x476AA4205D507E8F,0x1FBE1FA4005FED67,0x3C06CEA0151D342F,0x10CBB6F5399A507},{0x98ECA0F75FC01D90,0x74E364ADD9B2A886,0x639358A08EBC4A52,0x111FE5E575BCE8A},{0x98BC40EB7451346C,0x39586EDE5168BCB5,0x8210F365CBEDDD16,0x1175BAC6D989166},{0x7B570FB0BCC623D0,0x6F6FEF0DA29AB02E,0xCA5E678CA57A25F5,0x11CD3DDC3E47E57},{0x4FFDB36D1AEE4AB,0xAE6BB8483033BCE3,0xCB5AD4C61151D16A,0x12267791E54261F},{0xAAE515CE5133A97A,0x41CA827B28282854,0x553B7548CBDFC283,0x1281707E474AB08},{0x61EEE8028A48DF7,0x6E30DDE587359682,0xA311193565F8B668,0x12DE3162E8555AE},{0x2FB1761F7443078D,0x7F7ECDACD9869E03,0xE374010C8CE3A20A,0x133CC32D2F372F1},{0xBB36E3DA59D6F21C,0xD4DF55865AB3983E,0x7AC3AB3A80555C9F,0x139D2EF7419C741},{0x394154DABCC73239,0x232905F41588ACD,0x93007839B0C8066F,0x13FF7E08E44EA08},{0xA92B53293C09717F,0x2120154785E05593,0x6145142A2E4B4ABC,0x1463B9D85FDE296},{0x80759F292DB5BC19,0x277B1D9F247A477D,0x9AB708A55E4605FC,0x14C9EC0B69C66A5},{0xA0C40884BA56B1D0,0x27BDC2C55142490A,0x890570995790517F,0x15321E78122218A},{0xC212344CB1C0C73E,0x1ACDF443099DC170,0xB31A53BAA245C84F,0x159C5B25B607216},{0x510159B4226648EB,0x8DBDA2F384DB3570,0xCEB1F1FBC058074D,0x1608AC4DF6A146B}}};
inline static constexpr std::array<std::uint64_t,154> inv_errors={0x1144155514145504,0x541555401141,0,0x154454000000000,0x4114105515544440,0x1001111500415,0x4041411410011000,0x5550114515155014,0x1404100041554551,0x515000450404410,0x5054544401140004,0x5155501005555105,0x1144141000105515,0x541500000500000,0x1104105540444140,0x4000015055514110,0x54010450004005,0x4155515404100005,0x5155145045155555,0x1511555515440558,0x5558544555515555,16,0x5004000000000050,0x1415510100000010,0x4545555444514500,0x5155151555555551,0x1441540144044554,0x5150104045544400,0x5450545401444040,0x5554455045501400,0x4655155555555145,0x1000010055455055,0x1000004000055004,0x4455405104000005,0x4500114504150545,0x14000000,0x5450000000000000,0x5514551511445555,0x4111501040555451,0x4515445500054444,0x5101500104100441,0x1545115155545055,0,0x1554000000100000,0x5555545595551555,0x5555051851455955,0x5555555555555559,0x400011001555,0x4400040000,0x5455511555554554,0x5614555544115445,0x6455156145555155,0x5455855455415455,0x5515555144555545,0x114400000145155,0x51000450511,0x4455154554445100,0x4554150141544455,0x65955555559A5965,0x5555555854559559,0x9569654559616595,0x1040044040005565,0x1010010500011044,0x1554015545154540,0x4440555401545441,0x1014441450550105,0x4545400410504145,0x5015111541040151,0x5145051154000410,0x1040001044545044,0x4001400000151410,0x540000044040000,0x510555454411544,0x400054054141550,0x1001041145001100,0x140000000,0x14100000,0x1544005454000140,0x4050055505445145,0x11511104504155,0x5505544415045055,0x1155154445515554,17749,0,0x5101010510400004,0x1514045044440400,0x5515519555515555,0x4554545441555545,0x1551055955551515,0x150000011505515,0x44005040400000,0x4001004010050,0x51004450414,0x114001101001144,0x401000001000001,0x4500010001000401,0x4100000005000,0x105000441101100,0x455455550454540,0x5404050144105505,0x4101510540555455,0x1055541411451555,0x5451445110115505,0x1154110010101545,0x1145140450054055,0x5555565415551554,0x1550559555555555,0x5555541545045141,0x4555455450500100,0x5510454545554555,0x1510140115045455,0x1001050040111510,0x5555454555555504,0x9954155545515554,0x6596656555555555,0x140410051555559,0x11104010001544,0x965669659A680501,0x5655A55955556955,0x4015111014404514,0x1414155554505145,0x540040011051404,0x1010000000015005,0x10054050004410,0x5041104014000100,0x4440010500100001,0x1155510504545554,0x450151545115541,0x4000100400110440,0x1004440010514440,0x115050450000,0x545404455541500,0x1051051555505101,0x5505144554544144,0x4550545555515550,0x15400450045445,0x4514155400554415,0x4555055051050151,0x1511441450001014,0x4544554510404414,0x4115115545545450,0x5500541555551555,0x5550010544155015,0x144414045545500,0x4154050001050150,0x5550511111000145,0x1114504055000151,0x5104041101451040,0x10501401051441,0x10501450504401,0x4554585440044444,0x5155555951450455,0x40000400105555,1};
inline static constexpr std::array<std::array<std::uint64_t,4>,89> inv_split={{{0,0,0,0x200000000000000},{0x15D778EB40769AC1,0x25585C9E2C59F5A8,0x5DDDADC5E1E1AACE,0x1F62B0B257C0D1A},{0xB3DC337F4D28FF1C,0xAB5412A03AB2A94A,0xFA9A8C2F6BFE942D,0x1EC866B79E0CBA6},{0x69B1030355A33AE8,0x83F01E6C2E8E6194,0x43B889CD87964F35,0x1E3113363787F19},{0x6D37B7F8424C1BA3,0x508C1358B8F13394,0x7B49F17EAC6A48C8,0x1D9CA79D894629D},{0x28D480C11FC21BCF,0xD1F221F3EC90465E,0x93A366801F1F39FE,0x1D0B15A491EB845},{0xC4E899D3337FDA42,0x4A6C763E58AD1B87,0x6FFA363646102D36,0x1C7C4F4889B1B31},{0x63AFD78C374EF53C,0x1B17EEFA978B366B,0xA79650B9D65FDA08,0x1BF046CB892F6A8},{0x4EB914BB8CBAE8B4,0xF84E4D89150A713F,0x89098CC79DCD70DC,0x1B66EEB336C0E84},{0x3DA7408F33C88E75,0x3F422C81345FBE3D,0x8F8CA9A0E4E3CD87,0x1AE039C77A70F7E},{0x29B5E5BD807D8186,0x1CE5B67782B618E0,0xC1C0175B1BF81B19,0x1A5C1B1138427FA},{0xB88FBEF1573D2512,0xF780566055125703,0x7D50ABC24E227910,0x19DA85D910BB3B7},{0x4B2582F5965A11AB,0xB584DFF71D02A64E,0xF85FFFE251350098,0x195B6DA62790E6D},{0xCAC04791F42FAF62,0xD00D39F1EA3A5CBC,0x2D60AC1848DF21D3,0x18DEC63CF05AAE1},{0xDD98EEB9196DBC3B,0x22DAC1A05D58C613,0xE11CB45CA22D75E3,0x1864839E012951C},{0x80A346947CCE8909,0x2E3F6C0D3F164DF0,0xE124AC4981AFB266,0x17EC9A04EAE8FBC},{0xE84EDC7E1ECFE0AA,0x1A01BCE7B3AB7CD2,0x5ADA954B6A176BB8,0x1776FDE717704FE},{0xED89CB45F0C98807,0x12DC679B9B486CE4,0x1C49A4AD8A814A06,0x1703A3F2AD20D1B},{0xEDEE442E8364439E,0x2C6E73E2B60D5878,0x8769C97CB6C8ABDF,0x1692810D77FD401},{0xF3FA6939E01743C1,0x5ADA505FC36E2250,0xD18DE0EB89703F8E,0x16238A53D81B0E4},{0x86FB6367F1C201D6,0xCA50C563EC3AC9BB,0xA2C26C6D0D2C3483,0x15B6B517B554A60},{0x1DE2C7BE5F52DD3,0x4F504BE65791ED61,0x170A1618B2ED6420,0x154BF6DF7822A02},{0x4C8C7695697A8F1E,0x62DECB076B66DAA8,0x4D0019F570189C5D,0x14E3456507829F7},{0x55E1A019D93B5EE8,0x4ED7E7DD4DECC346,0xD5F5A57C2CF2ECBE,0x147C9694CBD2F6E},{0xDCC7BBF6D1F2E361,0x905045C71F5EE964,0x42DC3EFE2C85D755,0x1417E08CB68ABD2},{0x139C428806A8BFAD,0xAFE6DA35AEF3721C,0x6B4B8B1ABF2348ED,0x13B5199B4EB6683},{0x14A1EFEF82623355,0x9DC82BB164AD284A,0xA11F10AFD0EBCEEE,0x1354383EC22181B},{0x79F75E0769152CB4,0x3736C2455456E542,0x8070F1314DC45F04,0x12F53323FB1675F},{0x63F809BEF0691148,0xD0C9A3E2BB45828D,0x22879EE3AB89FAF0,0x12980125BA9DF2A},{0x3791B0D3DAAC35E3,0xFD16CC91D283BCEF,0xD8ACE010CD70BAAF,0x123C994BB727B7F},{0xFEF61CC6EB9518EF,0xBE0FC3C2012FA8,0xE482DAFF3563CCEB,0x11E2F2C9BF872C3},{0x8D25DCFF9C8E88F3,0x1BC0402E2EB7E081,0x8DB05DE50C04E7BD,0x118B04FEE22E6B6},{0xED6C4B265238ED12,0xE98131CDDA17F7AD,0x1CD9075A24C1FE41,0x1134C7749892F6A},{0xEF00163C2693FDE4,0xA88D39FA5CD94654,0x4AD22708B361F4E5,0x10E031DDF6A78C6},{0x4370BA720A8CB166,0x17CFBE0D78C27FB4,0x36D444921D1D3D93,0x108D3C16DE5717B},{0xBB897CAD90669226,0x8C311B703591CEE,0x91F4E1734594C160,0x103BDE2336ED06F},{0xA32B13E8C6F4A197,0x23D5048560061C94,0xF2D8CAD8763E593B,0x1FD8205C50AF783},{0xC990E018220E3481,0x4E47973D3BF2663F,0x122CD82BE8ACF0D8,0x1F3B9512B4644C8},{0x265F9791BF2943AA,0x98F2DA150241002A,0x2CBF070B675105FE,0x1EA20B586D03E4E},{0xABB72F311BAD6EED,0xBDD6420DE86BEFC3,0xA199F63985DE3E89,0x1E0B7466603038E},{0xB1D18BEB4C7FA1F7,0x34199824527E3AF4,0x8A262ACB7C67BB52,0x1D77C1BE1904035},{0xF3A899D332778CC2,0x2CEEF9365BF7DBC0,0xF85412D37F10CF27,0x1CE6E52862F2E0D},{0xCB17204616681393,0x393AEDDDE582A87C,0x60863216A47F0E57,0x1C58D0B3EB85084},{0x1E53EEC1DE22BE50,0x27C1DC8F808393BC,0xB518233E6D004248,0x1BCD76B3EACCE59},{0x5541E0ECCA5ED35A,0x913A338683EBE85E,0x60E85571E70C8AC5,0x1B44C9BED27587C},{0xF423DB79ACBBA30,0x8D971DB5D03452B1,0xA7A49CD1B8204E4,0x1ABEBCAD0349725},{0x21744863B10BE56F,0xF1930F3F8850D3EC,0xD46E6CE6153C8FFD,0x1A3B4297891204B},{0xA9A7CFF76E480749,0x171944460AB0335E,0x9FADD476E66053DE,0x19BA4ED6DCB0450},{0x3084065F3F2E37F8,0xFF3F6AEC08D566A0,0x988E967963FC3AD4,0x193BD501AC50746},{0x795ABA2310798260,0x370C14EA91297341,0xFE8CD0CEFABE8D85,0x18BFC8EBA99A6B9},{0x6AB6F2EEA4AA2D7F,0x48EB226124841936,0x859F828F5BC90874,0x18461EA45DC14FF},{0xA4A08E11CE31696C,0x2FF69B28810455E8,0xCBDF0999339698BA,0x17CECA760355C27},{0x4F10FBDBCA0FE56C,0xAC6B351F41A02973,0x4F898CBA2B8C298,0x1759C0E465BE390},{0x9C3A85F4D16257B6,0xD5588D4F67E56966,0x95211FA9510E516,0x16E6F6ABC639BBC},{0xE9D87C9CBF8D606C,0x1A8F9362D5FD1FBE,0x3F25C3783F7667E3,0x167660BFC651CAE},{0x8635B5B5DDBEFAD3,0x92E2086D2492954E,0x2A794B4EA81B3AAD,0x1607F44A57A0B50},{0x6AD73AA7183259F6,0xA238B5E77A9A58C1,0xA3D88382F27AD3A1,0x159BA6AAB0D22B3},{0xA9C65EBC101C6D69,0x2E75BE61FE5D62C7,0x8F69673BB3BB71A6,0x15316D7447C4601},{0xB518C87DC60F7FFD,0xEDE6D34238DECD80,0x349AB665EE27AFE8,0x14C93E6DD0B07D0},{0xAC81DB00AD5EED58,0x4E104A38C03C68C8,0xCCE8038DE123F0EE,0x14630F904241B59},{0x420CF13A070D2E28,0x1EF48CD4EB7CE7B6,0x44C1B7B1548876AC,0x13FED705DE82BA4},{0x6492357491BF81C6,0x7BA7BCAC1DC68045,0x37BB5B700AEF720D,0x139C8B294089C1E},{0xB2641C33F11E22C3,0x70E5D27FC199CF9F,0xA04308E0DD48D498,0x133C22846ECBD83},{0x434A7EB2A1DD843B,0x4277B0EA8EC77B79,0x3758E7E044DDFEBD,0x12DD93CFF200907},{0x673056C9D2A7589C,0xC8BDF60BE419E91,0xCA969BC69C1D787C,0x1280D5F1F07FAC4},{0x993F40E43CCCF235,0x7C2F120C3AE2FA8A,0x8B8230FF418315B7,0x1225DFFD4E02B65},{0x997AB2AD1DFB737F,0xA2525F1E5931AFE8,0x3480A9EA6C0493D7,0x11CCA930CFB4FA2},{0x616C16AE2C95A502,0x45BCB7A8AE584B50,0x7C590FE316728F15,0x117528F6447CAF0},{0xF617B818CF4440D0,0x6C894CD4DADFACA6,0x547E3F27E3287953,0x111F56E1B16892A},{0x98D41AC94E242E5,0x2A442ECD232F582A,0x7884A17C5DD750FA,0x10CB2AB0822D95E},{0x25F327E31BC01B91,0x362AC2FB4043713F,0x836F05B63F8D5749,0x10789C48BDA0A3B},{0xDDFED55CCD34B41B,0x4249FDB2A10F7200,0xAC036046F1480B68,0x1027A3B83E18EA9},{0xBB3D7252D98AE93B,0x6690649C4EA6EDBF,0x16A0A5D2513E1E46,0x1FB07267DB4EE58},{0xBDA3E8C5062D62B8,0x895C2C324821A626,0xF884D14A9EE17A51,0x1F14AA2E0C22512},{0x85477550980936A5,0x957D88CDDC36B0C6,0x941D0BF8FE9DB7A7,0x1E7BDFC4A8F1C0E},{0x32612087A2556B61,0x70F39279FE23E126,0x27EB4F001E47DECF,0x1DE60477014E65B},{0x7372712F4D9EBA7C,0x8430E8DF98D4321B,0x26CDD0924A7CBB41,0x1D5309D8AFBCD3E},{0x9B4AE07EB9CF4C33,0xAC6C24875096AAAE,0xAE04B51C3CBB7683,0x1CC2E1C43652208},{0x78C39A8CAB7EC9A4,0xB633FB11FC50B67,0x2022A24A0D03AB2E,0x1C357E59A2240CC},{0x46FC88FB66031FF7,0xEA9F430C181150B2,0x8962F9B0DCFF9D9C,0x1BAAD1FD356AB26},{0xD7B5BB2C8BE6C196,0x97E5202C66A1D967,0x3151DBFFB99FC9B6,0x1B22CF561832CAF},{0x6AFCC8A037D2B5AE,0x108A3D0ABB159DF0,0xD13CC03CE0F45869,0x1A9D694D0F804A7},{0x68A832A141FB8569,0x87DD42E7B43E1D6F,0x479F5BED6554F89E,0x1A1A930B3AC1A81},{0xAAA9163D01529E68,0x11C831D242F9D06E,0x43003C708C6307F9,0x199A3FF8D774C7C},{0xB7C96EB5C4F7D8A1,0xDC4B60832ECBFBF9,0x32122AAC9B1560AF,0x191C63BC0ADF138},{0x9DFE4858AD3783EA,0xD2B8CF74B0D01899,0xB678ABE7F28FFDE1,0x18A0F237B1BAE5D},{0xF60667AA219E4FCB,0x109C798707D542F6,0xC9C0BFC840F947AA,0x1827DF8A35BCFBE},{0xEF45A478AF9FD773,0x7B3E2CB8073D5ADA,0x9B1044FFBF82756A,0x17B1200C68D5346},{0x63B436787BA7112B,0xC6E74E701575094D,0xC57BB65BFBC7F14D,0x173CA850660E6E6}}};
};
}
# 4 "fast_io/fast_io_freestanding_impl/ryu/ryu.h" 2
# 1 "fast_io/fast_io_freestanding_impl/ryu/fixed.h" 1
       

namespace fast_io::details::ryu
{

template<std::floating_point T>
struct floating_traits
{
};


template<>
struct floating_traits<float>
{
 using mantissa_type = std::uint32_t;
 using exponent_type = std::uint32_t;
 static inline constexpr exponent_type exponent_bits = 8;
 static inline constexpr mantissa_type mantissa_bits = sizeof(float)*8-1-exponent_bits;
 static inline constexpr exponent_type exponent_max = (static_cast<exponent_type>(1)<<exponent_bits)-1;
 static inline constexpr exponent_type bias = (static_cast<exponent_type>(1)<<(exponent_bits - 1)) - 1;

 static inline constexpr exponent_type pow5_bitcount= 61;
 static inline constexpr exponent_type floor_log5 = 9;
 static inline constexpr exponent_type bound = 31;
 static inline constexpr exponent_type digits10=8;
 static inline constexpr mantissa_type carry10=0x989680;
};

template<>
struct floating_traits<double>
{
 using mantissa_type = std::uint64_t;
 using exponent_type = std::uint32_t;
 static inline constexpr exponent_type exponent_bits = 11;
 static inline constexpr mantissa_type mantissa_bits = sizeof(double)*8-1-exponent_bits;
 static inline constexpr exponent_type exponent_max = (static_cast<exponent_type>(1)<<exponent_bits)-1;
 static inline constexpr exponent_type bias = (static_cast<exponent_type>(1)<<(exponent_bits - 1)) - 1;

 static inline constexpr exponent_type pow5_bitcount= 125;
 static inline constexpr exponent_type floor_log5 = 21;
 static inline constexpr exponent_type bound = 63;
 static inline constexpr exponent_type digits10=17;
 static inline constexpr mantissa_type carry10=0x2386F26FC10000;
};

template<>
struct floating_traits<long double>
{
 using mantissa_type = uint128_t;
 using exponent_type = std::uint32_t;
 static inline constexpr exponent_type exponent_bits = 17;
 static inline constexpr std::uint32_t mantissa_bits = sizeof(long double)*8-1-exponent_bits;
 static inline constexpr exponent_type exponent_max = (static_cast<exponent_type>(1)<<exponent_bits)-1;
 static inline constexpr exponent_type bias = (static_cast<exponent_type>(1)<<(exponent_bits - 1)) - 1;

 static inline constexpr std::size_t pow5_bitcount= 249;
 static inline constexpr exponent_type floor_log5 = 55;
 static inline constexpr exponent_type bound = 127;
 static inline constexpr exponent_type digits10=21;

};

template<std::integral mantissaType,std::integral exponentType>
struct unrep
{
 using mantissa_type = mantissaType;
 using exponent_type = exponentType;
 mantissa_type m=0;
 exponent_type e=0;
};
template<std::unsigned_integral T>
inline constexpr T index_for_exponent(T e){return (e+15)>>4;}

template<std::unsigned_integral T>
inline constexpr T pow10_bits_for_index(T idx){return (idx<<4)+120;}

template<std::unsigned_integral T>
inline constexpr bool multiple_of_power_of_2(T value,std::size_t p) {

return !(static_cast<uint128_t>(value) & ((static_cast<uint128_t>(1)<<p) - 1));
}

template<typename T>
inline constexpr std::uint32_t pow5_factor(T value)
{
 for (std::uint32_t count(0);value;++count)
 {
  if (value%5)
   return count;
  value/=5;
 }
 return 0;
}
template<std::integral U>
inline constexpr std::int32_t log2pow5(U e)
{
 return static_cast<int32_t>(((static_cast<std::uint32_t>(e) * 1217359) >> 19));
}

template<std::integral U>
inline constexpr std::int32_t pow5bits(U e)
{
 return log2pow5(e)+1;
}



template<typename T>
inline constexpr bool multiple_of_power_of_5(T value,std::uint32_t p)
{

 return p<=pow5_factor(value);
}

inline constexpr uint32_t log10_pow2(std::uint64_t e)
{
 return static_cast<std::uint32_t> (((static_cast<std::uint64_t>(e)) * 169464822037455ull) >> 49);
}
template<std::unsigned_integral T>
inline constexpr std::size_t length_for_index(T idx){return (log10_pow2(idx<<4)+25)/9;}

template<std::integral T>
inline constexpr uint32_t log10_pow5(T e)
{

 return static_cast<uint32_t> (((static_cast<uint64_t>(e)) * 196742565691928ull) >> 48);
}
# 154 "fast_io/fast_io_freestanding_impl/ryu/fixed.h"
template<std::unsigned_integral T,std::size_t muldiff=sizeof(T)*8>
requires std::same_as<T,std::uint64_t>||std::same_as<T,fast_io::uint128_t>
inline constexpr T mul_shift(T m, std::array<T,2> const& mul, std::size_t j)
{
 return low((mul_extend(m,mul.back())+high(mul_extend(m,mul.front())))>>(j-muldiff));
}

template<typename T>
requires (std::same_as<std::uint64_t,T>||std::same_as<fast_io::uint128_t,T>)
inline constexpr std::array<T,3> mul_shift_all(T m, std::array<T,2> const& mul,std::size_t j,std::uint32_t mmshift)
{
 auto const m4(m<<2);
 return {mul_shift(m4,mul,j),mul_shift(m4+2,mul,j),mul_shift(m4-1-mmshift,mul,j)};
}

template<typename T>
inline constexpr std::uint32_t mul_shift_mod_1e9(std::uint64_t m, std::array<T,3> const& mul, std::size_t j)
{
 uint128_t b1(mul_extend(m,mul[1]));
 b1+=high(mul_extend(m,mul[0]));
 uint128_t s1(mul_extend(m,mul[2]));
 s1+=high(b1);
 s1>>=j-128;
 uint128_t constexpr mulb(construct_unsigned_extension(static_cast<std::uint64_t>(0x31680A88F8953031),static_cast<std::uint64_t>(0x89705F4136B4A597)));
 return static_cast<std::uint32_t>(s1)-1000000000*static_cast<std::uint32_t>(low(mul_high(s1,mulb))>>29);
}

template<std::random_access_iterator Iter,std::unsigned_integral mantissaType>
inline constexpr auto easy_case(Iter result,bool sign, mantissaType const& mantissa)
{
 if (mantissa)
  return std::copy_n(u8"nan",3,result);
 if (sign)
  return std::copy_n(u8"-inf",4,result);
 return std::copy_n(u8"inf",3,result);
}

template<std::floating_point floating,std::unsigned_integral mantissaType,std::signed_integral exponentType>
inline constexpr unrep<mantissaType,exponentType> init_rep(mantissaType const& mantissa,exponentType const& exponent)
{
 if(!exponent)
  return {mantissa,1-static_cast<exponentType>(floating_traits<floating>::bias+floating_traits<floating>::exponent_bits)};
 return {static_cast<mantissaType>((static_cast<mantissaType>(1)<<floating_traits<floating>::mantissa_bits)|mantissa),
  static_cast<exponentType>(exponent-static_cast<exponentType>(floating_traits<floating>::bias+floating_traits<floating>::mantissa_bits))};
}

template<bool uppercase_e=false,std::signed_integral T,std::random_access_iterator Iter>
requires std::same_as<T,std::int32_t>
inline constexpr Iter output_exp(T exp,Iter result)
{
 if constexpr(uppercase_e)
  *result=0X65;
 else
  *result=0x65;
 ++result;
 if(exp<0)
 {
  *result=0x2d;
  ++result;
  exp=-exp;
 }
 else
 {
  *result=0x2b;
  ++result;
 }
 using char_type = std::remove_reference_t<decltype(*result)>;
 std::make_unsigned_t<T> unsigned_exp(exp);
 if(99<unsigned_exp)
 {
  auto const quo(unsigned_exp/100);
  unsigned_exp%=100;
  *result=static_cast<char_type>(quo+0x30);
  ++result;
 }
 auto exp_tb(shared_static_base_table<10,false>::table[unsigned_exp]);
 constexpr auto sz(exp_tb.size()-2);
 return std::copy_n(exp_tb.data()+sz,2,result);
}

template<std::size_t precision,bool scientific = false,bool uppercase_e=false,std::random_access_iterator Iter,std::floating_point F>
inline constexpr auto output_fixed(Iter result, F d)
{
 using floating_trait = floating_traits<F>;
 using mantissa_type = typename floating_trait::mantissa_type;
 using exponent_type = typename floating_trait::exponent_type;
 using signed_exponent_type = std::make_signed_t<exponent_type>;
 using char_type = std::remove_reference_t<decltype(*result)>;
 auto const bits(bit_cast<mantissa_type>(d));

 bool const sign((bits >> (floating_trait::mantissa_bits + floating_trait::exponent_bits)) & 1u);
 mantissa_type const mantissa(bits & ((static_cast<mantissa_type>(1u) << floating_trait::mantissa_bits) - 1u));
 exponent_type const exponent(static_cast<exponent_type>(((bits >> floating_trait::mantissa_bits) & floating_trait::exponent_max)));

 if(exponent == floating_trait::exponent_max)
  return easy_case(result,sign,mantissa);
 auto start(result);
 if(!exponent&&!mantissa)
 {
  if(sign)
  {
   *result=0x2d;
   ++result;
  }
  *result=0x30;
  ++result;
  if constexpr(precision!=0)
  {
   *result=0x2E;
   ++result;
   result=std::fill_n(result,precision,0x30);
   if constexpr(scientific)
   {
    if constexpr(uppercase_e)
     return std::copy_n(u8"E+00",4,result);
    else
     return std::copy_n(u8"e+00",4,result);
   }
  }
  return result;
 }
 auto const r2(init_rep<F>(mantissa,static_cast<signed_exponent_type>(exponent)));
 if (sign)
 {
  *result=0x2d;
  ++result;
 }
 bool const negative_r2_e(r2.e<0);
 if constexpr(scientific)
 {
  constexpr std::size_t scientific_precision(precision+1);
  exponent_type digits(0),printed_digits(0),available_digits(0);
  signed_exponent_type exp(0);
  if(-52<=r2.e)
  {
   exponent_type const idx(negative_r2_e?0:index_for_exponent(static_cast<exponent_type>(r2.e)));
   signed_exponent_type const p10bitsmr2e(pow10_bits_for_index(idx)-r2.e+8);
   auto const idx_offset(fixed_pow10<>::offset[idx]);
   for(std::size_t i(length_for_index(idx));i--;)
   {
    digits=mul_shift_mod_1e9(r2.m<<8,fixed_pow10<>::split[idx_offset+i],p10bitsmr2e);
    if(printed_digits)
    {
     if constexpr(precision<9)
     {
      available_digits=9;
      break;
     }
     else if(scientific_precision < printed_digits + 9)
     {
      available_digits=9;
      break;
     }
     std::fill(result,output_base_number_impl<10,false>(result+9,digits),0x30);
     result+=9;
     printed_digits+=9;
    }
    else if(digits)
    {
     available_digits = chars_len<10,true>(digits);
     exp = static_cast<signed_exponent_type>(i*9 + available_digits - 1);
     if(scientific_precision < available_digits)
      break;
     if constexpr (precision!=0)
      output_base_number_impl<10,false,true>(result+=available_digits+1,digits);
     else
     {
      *result=static_cast<char_type>(0x30+digits);
      ++result;
     }
     printed_digits = available_digits;
     available_digits = 0;
    }
   }
  }
  if(negative_r2_e&&!available_digits)
  {
   auto abs_e2(-r2.e);
   exponent_type const idx(static_cast<exponent_type>(abs_e2)>>4);
   signed_exponent_type j(128+(abs_e2-(idx<<4)));
   exponent_type const of2i(fixed_pow10<>::offset_2[idx]);
   exponent_type const idxp1(fixed_pow10<>::offset_2[idx+1]);
   exponent_type const mb2_idx(fixed_pow10<>::min_block_2[idx]);
   for (exponent_type i(mb2_idx); i < 200; ++i)
   {
    exponent_type const p(of2i+i-mb2_idx);
    digits=(idxp1<=p)?0:mul_shift_mod_1e9(r2.m<<8,fixed_pow10<>::split_2[p],j);
    if(printed_digits)
    {
     if constexpr(precision<9)
     {
      available_digits=9;
      break;
     }
     else if(scientific_precision < printed_digits + 9)
     {
      available_digits=9;
      break;
     }
     std::fill(result,output_base_number_impl<10,false>(result+9,digits),0x30);
     result+=9;
     printed_digits+=9;
    }
    else if(digits)
    {
     available_digits=chars_len<10,true>(digits);
     exp = static_cast<signed_exponent_type> (available_digits -(i + 1) * 9 - 1);
     if (scientific_precision<available_digits)
      break;
     if constexpr (precision!=0)
      output_base_number_impl<10,false,true>(result+=available_digits+1,digits);
     else
     {
      *result=static_cast<char_type>(0x30+digits);
      ++result;
     }
     printed_digits = available_digits;
     available_digits = 0;
    }
   }
  }
  exponent_type const maximum(scientific_precision - printed_digits);
  exponent_type lastdigit(0);
  for(exponent_type k(maximum);k<available_digits;++k)
  {
   lastdigit = digits%10;
   digits /= 10;
  }
  std::size_t round_up(0);
  if(lastdigit!=5)
   round_up = 5 < lastdigit;
  else
  {
   signed_exponent_type const rexp (static_cast<signed_exponent_type> (scientific_precision - exp));
   signed_exponent_type const required_twos(-r2.e - rexp);
   bool trailing_zeros(required_twos <= 0 || (required_twos < 60 && multiple_of_power_of_2(r2.m, static_cast<exponent_type>(required_twos))));
   if (rexp < 0)
   {
    signed_exponent_type required_fives = -rexp;
    trailing_zeros = trailing_zeros && multiple_of_power_of_5(r2.m, static_cast<exponent_type>(required_fives));
   }
   round_up = trailing_zeros ? 2 : 1;
  }
  if(printed_digits)
  {
   if(digits)
   {
    std::fill(result,output_base_number_impl<10,false>(result+maximum,digits),0x30);
    result+=maximum;
   }
   else
    result=std::fill_n(result,maximum,0x30);
  }
  else
  {
   if constexpr(precision!=0)
   {
    std::fill(result,output_base_number_impl<10,false,true>(result+maximum+1,digits),0x30);
    result+=maximum+1;
   }
   else
   {
    *result = 0x30 + digits;
    ++result;
   }
  }
  if(round_up)
  {
   std::size_t round_index(result-start);
   while(round_index--)
   {
    auto c(start[round_index]);
    if (c == 0x2d)
    {
     start[round_index+1] = 0x31;
     ++exp;
     break;
    }
    if constexpr(precision==0)
    {
     if (c == 0x39)
     {
      start[round_index] = 0x30;
      round_up = 1;
      continue;
     }
     else
     {
      if (round_up==2&&!(c&1))
       break;
      start[round_index]=c+1;
      break;
     }
    }
    else
    {
     if (c == 0x2E)
      continue;
     else if (c == 0x39)
     {
      start[round_index] = 0x30;
      round_up = 1;
      continue;
     }
     else
     {
      if (round_up==2&&!(c&1))
       break;
      start[round_index]=c+1;
      break;
     }
    }
   }
   if(round_index==static_cast<std::size_t>(-1))
   {
    start[round_index+1] = 0x31;
    ++exp;
   }
  }
  return output_exp<uppercase_e>(exp,result);
 }
 else
 {
  bool nonzero(false);
  if(-52<=r2.e)
  {
   exponent_type const idx(negative_r2_e?0:index_for_exponent(static_cast<exponent_type>(r2.e)));
   signed_exponent_type const p10bitsmr2e(pow10_bits_for_index(idx)-r2.e+8);
   for(std::size_t i(length_for_index(idx));i--;)
   {
    exponent_type digits(mul_shift_mod_1e9(r2.m<<8,fixed_pow10<>::split[fixed_pow10<>::offset[idx]+i],p10bitsmr2e));
    if(nonzero)
    {
     std::fill(result,output_base_number_impl<10,false>(result+9,digits),0x30);
     result+=9;
    }
    else if(digits)
    {
     output_base_number_impl<10,false>(result+=chars_len<10,true>(digits),digits);
     nonzero = true;
    }
   }
  }
  if(!nonzero)
  {
   *result=0x30;
   ++result;
  }
  if constexpr(precision!=0)
  {
   *result=0x2E;
   ++result;
  }
  if(negative_r2_e)
  {
   auto abs_e2(-r2.e);
   exponent_type const idx(static_cast<exponent_type>(abs_e2)>>4);
   constexpr std::size_t blocks(precision/9+1);
   std::size_t round_up(0);
   std::size_t i(0);
   auto const mb2_idx(fixed_pow10<>::min_block_2[idx]);
   if (blocks<=mb2_idx)
   {
    i=blocks;
    result=std::fill_n(result,precision,0x30);
   }
   else if(i<mb2_idx)
    result=std::fill_n(result,9*(i=mb2_idx),0x30);
   signed_exponent_type j(128+(abs_e2-(idx<<4)));
   auto const of2i(fixed_pow10<>::offset_2[idx]);
   for(;i<blocks;++i)
   {
    exponent_type p(of2i+i-mb2_idx);
    exponent_type digits(mul_shift_mod_1e9(r2.m<<8,fixed_pow10<>::split_2[p],j));
    if (fixed_pow10<>::offset_2[idx+1]<=p)
    {
     result=std::fill_n(result,precision-9*i,0x30);
     break;
    }
    if(i+1<blocks)
    {
     std::fill(result,output_base_number_impl<10,false>(result+9,digits),0x30);
     result+=9;
    }
    else
    {
     exponent_type const maximum(precision-9*i);
     exponent_type lastdigit(0);
     for(exponent_type k(maximum);k<9;++k)
     {
      lastdigit = digits%10;
      digits /= 10;
     }
     if(lastdigit!=5)
      round_up=lastdigit>5;
     else
     {
      auto const required_twos(static_cast<signed_exponent_type>(abs_e2-precision-1));
      if(required_twos<=0||(required_twos<60&&multiple_of_power_of_2(r2.m,static_cast<exponent_type>(required_twos))))
       round_up = 2;
      else
       round_up = 1;
     }
     if(maximum)
     {
      std::fill(result,output_base_number_impl<10,false>(result+maximum,digits),0x30);
      result+=maximum;
     }
     break;
    }
   }
   if(round_up)
   {
    std::size_t round_index(result-start);
    if constexpr(precision!=0)
    {
     std::size_t dot_index(0);
     while(round_index--)
     {
      auto c(start[round_index]);
      if (c == 0x2d)
      {
       start[round_index+1] = 0x31;
       if(dot_index)
       {
        start[dot_index] = 0x30;
        start[dot_index+1] = 0x2E;
       }
       *result=0x30;
       return ++result;
      }
      if (c == 0x2E)
      {
       dot_index = round_index;
       continue;
      }
      else if (c == 0x39)
      {
       start[round_index] = 0x30;
       round_up = 1;
       continue;
      }
      if (round_up!=2||c&1)
       start[round_index]=c+1;
      return result;
     }
     *start=0x31;
     if(dot_index)
     {
      start[dot_index] = 0x30;
      start[dot_index+1] = 0x2E;
     }
    }
    else
    {
     while(round_index--)
     {
      auto c(start[round_index]);
      if (c == 0x2d)
      {
       start[round_index+1] = 0x31;
       *result=0x30;
       return ++result;
      }
      if (c == 0x39)
      {
       start[round_index] = 0x30;
       round_up = 1;
       continue;
      }
      if (round_up!=2||c&1)
       start[round_index]=c+1;
      return result;
     }
     *start=0x31;
    }
    *result=0x30;
    ++result;
   }
   return result;
  }
  return std::fill_n(result,precision,0x30);
 }
}
template<std::floating_point floating,std::unsigned_integral mantissaType,std::signed_integral exponentType>
inline constexpr unrep<mantissaType,exponentType> init_repm2(mantissaType const& mantissa,exponentType const& exponent)
{
 if(!exponent)
  return {mantissa,1-static_cast<exponentType>(floating_traits<floating>::bias+floating_traits<floating>::exponent_bits+2)};
 return {static_cast<mantissaType>((static_cast<mantissaType>(1)<<floating_traits<floating>::mantissa_bits)|mantissa),
  static_cast<exponentType>(exponent-static_cast<exponentType>(floating_traits<floating>::bias+floating_traits<floating>::mantissa_bits+2))};
}

template<bool uppercase_e=false,std::size_t mode=0,std::random_access_iterator Iter,std::floating_point F>
inline constexpr Iter output_shortest(Iter result, F d)
{
 using char_type = std::remove_reference_t<decltype(*result)>;
 using floating_trait = floating_traits<F>;
 using mantissa_type = typename floating_trait::mantissa_type;
 using exponent_type = typename floating_trait::exponent_type;
 using signed_exponent_type = std::make_signed_t<exponent_type>;
 auto const bits(bit_cast<mantissa_type>(d));

 bool const sign((bits >> (floating_trait::mantissa_bits + floating_trait::exponent_bits)) & 1u);
 mantissa_type const mantissa(bits & ((static_cast<mantissa_type>(1u) << floating_trait::mantissa_bits) - 1u));
 exponent_type const exponent(static_cast<exponent_type>(((bits >> floating_trait::mantissa_bits) & floating_trait::exponent_max)));

 if(exponent == floating_trait::exponent_max)
  return easy_case(result,sign,mantissa);
 if(!exponent&&!mantissa)
 {
  if(sign)
  {
   *result=0x2d;
   ++result;
  }
  *result=0x30;
  ++result;
  if constexpr(mode==2)
  {
   if constexpr(uppercase_e)
    return std::copy_n(u8"E+00",4,result);
   else
    return std::copy_n(u8"e+00",4,result);
  }
  return result;
 }
 auto const r2(init_repm2<F>(mantissa,static_cast<signed_exponent_type>(exponent)));
 bool const accept_bounds(!(r2.m&1));
 auto const mv(r2.m<<2);
 exponent_type const mm_shift(mantissa||static_cast<signed_exponent_type>(exponent)<2);
 std::array<mantissa_type,3> v{};

 signed_exponent_type e10{};
 bool vm_is_trailing_zeros(false),vr_is_trailing_zeros(false);
 if(0<=r2.e)
 {
  exponent_type const q(log10_pow2(r2.e)-(3<r2.e));
  e10=static_cast<signed_exponent_type>(q);
  signed_exponent_type const k(floating_trait::pow5_bitcount + pow5bits(q) - 1);
  signed_exponent_type const i(-r2.e+static_cast<signed_exponent_type>(q)+k);
  if constexpr(std::same_as<std::remove_cvref_t<F>,long double>)
   v=mul_shift_all(r2.m,compute_pow5_inv(q),i,mm_shift);
  else
   v=mul_shift_all(r2.m,pow5<F,true>::inv_split[q],i,mm_shift);
  if(q<=floating_trait::floor_log5)
  {
   if(!(mv%5))
    vm_is_trailing_zeros=multiple_of_power_of_5(mv,q);
   else if(accept_bounds)
    vm_is_trailing_zeros=multiple_of_power_of_5(mv-1-mm_shift,q);
   else
    v[1]-=multiple_of_power_of_5(mv+2,q);
  }
 }
 else
 {
  exponent_type abs_e2(static_cast<exponent_type>(-r2.e));
  exponent_type const q(log10_pow5(abs_e2)-(1<abs_e2));
  signed_exponent_type const signed_q(static_cast<signed_exponent_type>(q));
  e10=signed_q+r2.e;
  signed_exponent_type const i(-r2.e-signed_q);
  signed_exponent_type const k(pow5bits(i)-floating_trait::pow5_bitcount);
  signed_exponent_type const j(signed_q-k);
  if constexpr(std::same_as<std::remove_cvref_t<F>,long double>)
   v=mul_shift_all(r2.m,compute_pow5(i),j,mm_shift);
  else
   v=mul_shift_all(r2.m,pow5<F,true>::split[i],j,mm_shift);
  if(q<2)
  {
   vr_is_trailing_zeros=true;
   if(accept_bounds)
    vm_is_trailing_zeros=mm_shift==1;
   else
    --v[1];
  }
  else if(q<floating_trait::bound)
   vr_is_trailing_zeros=multiple_of_power_of_2(mv,q);
 }
 signed_exponent_type removed(0);
 std::uint8_t last_removed_digit(0);
 if(vm_is_trailing_zeros||vr_is_trailing_zeros)
 {
  for(;;)
  {
   mantissa_type const vpdiv10(v[1]/10);
   mantissa_type const vmdiv10(v[2]/10);
   auto const vmmod10(static_cast<std::uint8_t>(v[2]%10));
   if(vpdiv10 <= vmdiv10)
    break;
   mantissa_type const vrdiv10(v.front()/10);
   auto const vrmod10(static_cast<std::uint8_t>(v.front()%10));
   vm_is_trailing_zeros&=!vmmod10;
   vr_is_trailing_zeros&=!last_removed_digit;
   last_removed_digit=static_cast<std::uint8_t>(vrmod10);
   v.front()=vrdiv10;
   v[1]=vpdiv10;
   v[2]=vmdiv10;
   ++removed;
  }
  if(vm_is_trailing_zeros)
   for(;;)
   {
    mantissa_type const vmdiv10(v[2]/10);
    auto const vmmod10(static_cast<std::uint8_t>(v[2]%10));
    if(vmmod10)
     break;
    mantissa_type const vpdiv10(v[1]/10);
    mantissa_type const vrdiv10(v.front()/10);
    auto const vrmod10(v.front()%10);
    vr_is_trailing_zeros&=!last_removed_digit;
    last_removed_digit=static_cast<std::uint8_t>(vrmod10);
    v.front()=vrdiv10;
    v[1]=vpdiv10;
    v[2]=vmdiv10;
    ++removed;
   }
  if(vr_is_trailing_zeros&&last_removed_digit==5&&!(v.front()&1))
   last_removed_digit=4;
  v.front() += ((v.front()==std::get<2>(v)&&(!accept_bounds || !vm_is_trailing_zeros))|| 4 < last_removed_digit);
 }
 else
 {
  bool round_up(false);
  mantissa_type const vpdiv100(v[1]/100);
  mantissa_type const vmdiv100(v[2]/100);
  if(vmdiv100<vpdiv100)
  {
   mantissa_type const vrdiv100(v.front()/100);
   auto const vrmod100(v.front()%100);
   round_up=50<=vrmod100;
   v.front()=vrdiv100;
   v[1]=vpdiv100;
   v[2]=vmdiv100;
   removed+=2;
  }
  for (;;)
  {
   mantissa_type const vpdiv10(v[1]/10);
   mantissa_type const vmdiv10(v[2]/10);
   if(vpdiv10<=vmdiv10)
    break;
   mantissa_type const vrdiv10(v.front()/10);
   auto const vrmod10(v.front()%10);
   round_up=5<=vrmod10;
   v.front()=vrdiv10;
   v[1]=vpdiv10;
   v[2]=vmdiv10;
   ++removed;
  }
  v.front()+=(v.front()==v[2]||round_up);
 }
 if(sign)
 {
  *result=0x2d;
  ++result;
 }
 std::int32_t olength(static_cast<std::int32_t>(chars_len<10,true>(v.front())));
 std::int32_t const real_exp(static_cast<std::int32_t>(e10 + removed + olength - 1));
 if constexpr(mode==0)
 {
  std::uint32_t fixed_length(0),this_case(0);
  if(olength<=real_exp)
  {
   fixed_length=real_exp+1;
   this_case=1;
  }
  else if(0<=real_exp&&real_exp<olength)
  {
   fixed_length=olength+2;
   if(olength==real_exp+1)
    --fixed_length;
   this_case=2;
  }
  else
   fixed_length=static_cast<exponent_type>(-real_exp)+olength+1;
  std::uint32_t scientific_length(olength==1?olength+3:olength+5);
  if(scientific_length<fixed_length)
  {
   if(olength==1)
    output_base_number_impl<10,false,false>(result+=olength,v.front());
   else
    output_base_number_impl<10,false,true>(result+=olength+1,v.front());
   return output_exp<uppercase_e>(static_cast<std::int32_t>(real_exp),result);
  }
  switch(this_case)
  {
  case 1:
   output_base_number_impl<10,false>(result+=olength,v.front());
   return std::fill_n(result,real_exp+1-olength,0x30);
  case 2:
  {
   constexpr auto &table(details::shared_static_base_table<10,uppercase_e>::table);
   constexpr std::uint32_t pw(table.size());
   constexpr std::uint32_t chars(table.front().size());
   auto a(v.front());
   auto eposition(result+real_exp+1);
   auto iter(result+=olength);
   if(eposition!=iter)
   {
    ++result;
    ++iter;
    for(;eposition+2<iter&&pw<=a;)
    {
     auto const rem(a%pw);
     a/=pw;
     std::copy_n(table[rem].data(),chars,iter-=chars);
    }
    if(iter==eposition+2)
    {
     auto const rem(a%10);
     a/=10;
     *--iter=static_cast<char_type>(0x30+rem);
    }
    *--iter=0x2E;
   }
   output_base_number_impl<10,false>(iter,a);
   return result;
  }
  default:
   result=std::copy_n(u8"0.",2,result);
   result=std::fill_n(result,static_cast<exponent_type>(-real_exp-1),0x30);
   output_base_number_impl<10,false>(result+=olength,v.front());
   return result;
  }
 }
 else if constexpr(mode==1)
 {
  if(olength<=real_exp)
  {
   output_base_number_impl<10,false>(result+=olength,v.front());
   return std::fill_n(result,real_exp+1-olength,0x30);
  }
  else if(0<=real_exp&&real_exp<olength)
  {
   constexpr auto &table(details::shared_static_base_table<10,uppercase_e>::table);
   constexpr std::uint32_t pw(table.size());
   constexpr std::uint32_t chars(table.front().size());
   auto a(v.front());
   auto eposition(result+real_exp+1);
   auto iter(result+=olength);
   if(eposition!=iter)
   {
    ++result;
    ++iter;
    for(;eposition+2<iter&&pw<=a;)
    {
     auto const rem(a%pw);
     a/=pw;
     std::copy_n(table[rem].data(),chars,iter-=chars);
    }
    if(iter==eposition+2)
    {
     auto const rem(a%10);
     a/=10;
     *--iter=static_cast<char_type>(0x30+rem);
    }
    *--iter=0x2E;
   }
   output_base_number_impl<10,false>(iter,a);
   return result;
  }
  else
  {
   result=std::copy_n(u8"0.",2,result);
   result=std::fill_n(result,static_cast<exponent_type>(-real_exp-1),0x30);
   output_base_number_impl<10,false>(result+=olength,v.front());
   return result;
  }
 }
 else
 {
  if(olength==1)
   output_base_number_impl<10,false,false>(result+=olength,v.front());
  else
   output_base_number_impl<10,false,true>(result+=olength+1,v.front());
  return output_exp<uppercase_e>(static_cast<std::int32_t>(real_exp),result);
 }
}

}
# 5 "fast_io/fast_io_freestanding_impl/ryu/ryu.h" 2
# 1 "fast_io/fast_io_freestanding_impl/ryu/id.h" 1
       

namespace fast_io::details::ryu
{


template<std::floating_point F,character_input_stream input>
inline constexpr F input_floating(input& in)
{
 using floating_trait = floating_traits<F>;
 using mantissa_type = typename floating_trait::mantissa_type;
 using exponent_type = typename floating_trait::exponent_type;
 using unsigned_char_type = std::make_unsigned_t<std::remove_reference_t<decltype(get(in))>>;
 using signed_exponent_type = std::make_signed_t<exponent_type>;
 mantissa_type ipart{};
 bool negative{};
 std::uint8_t phase2{};





 exponent_type m10digits{};
 signed_exponent_type m10e(0);
 bool zero_front{};
 for(;;)
 {
  unsigned_char_type ch(static_cast<unsigned_char_type>(get(in))-48);
  if(ch<10)
  {
   if(!ch)
   {
    zero_front=true;
    break;
   }
   ipart=ch;
   ++m10digits;
   break;
  }
  else
  {

   if(ch==static_cast<unsigned_char_type>(-3))
   {
    if((ch=static_cast<unsigned_char_type>(get(in))-48)<10)
    {
     negative=true;
     if(!ch)
     {
      zero_front=true;
      break;
     }
     ipart=ch;
     ++m10digits;
     break;
    }
    else if(ch==static_cast<unsigned_char_type>(-2))
    {
     negative=true;
     phase2=1;
     ipart={};
     break;
    }
   }
   else if(ch==static_cast<unsigned_char_type>(-2))
   {
    if((ch=static_cast<unsigned_char_type>(get(in))-48)<10)
    {
     --m10e;
     if(!ch)
     {
      zero_front=false;
      for(;;--m10e)
      {
       unsigned_char_type ch(static_cast<unsigned_char_type>(get(in))-48);
       if(ch==0)
        continue;
       else if(ch<10)
       {
        ipart=ch;
        --m10e;
        phase2 = 1;
        ++m10digits;
        break;
       }
       else if(ch==21||ch==53)
       {
        phase2 = 0;
        break;
       }
       else
       {
        phase2 = 2;
        break;
       }
      }
      break;
     }
     phase2=1;
     ipart=ch;
     break;
    }
   }
  }
 }
 if(zero_front)
 {
  for(;;)
  {
   unsigned_char_type ch(static_cast<unsigned_char_type>(get(in))-48);
   if(ch==0)
    continue;
   else if(ch<10)
   {
    ipart=ch;
    ++m10digits;
    break;
   }
   else if(ch==static_cast<unsigned_char_type>(-2))
   {
    for(;;--m10e)
    {
     unsigned_char_type ch(static_cast<unsigned_char_type>(get(in))-48);
     if(ch==0)
      continue;
     else if(ch<10)
     {
      ipart=ch;
      --m10e;
      phase2 = 1;
      ++m10digits;
      break;
     }
     else if(ch==21||ch==53)
     {
      phase2 = 0;
      break;
     }
     else
     {
      phase2 = 2;
      break;
     }
    }
    break;
   }
   else if(ch==21||ch==53)
   {
    phase2 = 0;
    break;
   }
   else
   {
    phase2 = 2;
    break;
   }
  }
 }
 if(!phase2)
 {
  for(;m10digits<floating_trait::digits10;++m10digits)
  {
   unsigned_char_type const ch(static_cast<unsigned_char_type>(get<true>(in).first)-48);
   if(ch<10)
    ipart=ipart*10+ch;
   else if(ch==static_cast<unsigned_char_type>(-2))
   {
    phase2 = 1;
    break;
   }
   else if(ch==21||ch==53)
   {
    phase2 = 0;
    break;
   }
   else
   {
    if(negative)
     return -static_cast<F>(ipart);
    return static_cast<F>(ipart);
   }
  }
  if(m10digits==floating_trait::digits10)
  {
   unsigned_char_type const ch(static_cast<unsigned_char_type>(get<true>(in).first)-48);

   if(ch==5)
   {
    if(ipart&1)
    {
     if(++ipart==floating_trait::carry10)
     {
      ipart=floating_trait::carry10/10;
      ++m10e;
     }
     for(;;++m10e)
     {
      unsigned_char_type const ch(static_cast<unsigned_char_type>(get<true>(in).first)-48);
      if(ch==static_cast<unsigned_char_type>(-2))
      {
       phase2 = 1;
       break;
      }
      else if(ch==21||ch==53)
      {
       phase2 = 0;
       break;
      }
      else if(9<ch)
      {
       phase2 = 2;
       break;
      }
     }
    }
    else
    {
     for(;;++m10e)
     {
      unsigned_char_type const ch(static_cast<unsigned_char_type>(get<true>(in).first)-48);
      if(ch==static_cast<unsigned_char_type>(-2))
      {
       phase2 = 1;
       break;
      }
      else if(ch==21||ch==53)
      {
       phase2 = 0;
       break;
      }
      else if(ch)
      {
       if(9<ch)
       {
        phase2 = 2;
        break;
       }
       ++m10e;
       if(++ipart==floating_trait::carry10)
       {
        ipart=floating_trait::carry10/10;
        ++m10e;
       }
       for(;;++m10e)
       {
        unsigned_char_type const ch(static_cast<unsigned_char_type>(get<true>(in).first)-48);
        if(ch==static_cast<unsigned_char_type>(-2))
        {
         phase2 = 1;
         break;
        }
        else if(ch==21||ch==53)
        {
         phase2 = 0;
         break;
        }
        else if(9<ch)
         break;
       }
       break;
      }
     }
    }
   }
   if(ch<10)
   {
    ++m10e;
    if(5<ch)
    {
     if(++ipart==floating_trait::carry10)
     {
      ipart=floating_trait::carry10/10;
      ++m10e;
     }
    }
    for(;;++m10e)
    {
     unsigned_char_type const ch(static_cast<unsigned_char_type>(get<true>(in).first)-48);
     if(ch==static_cast<unsigned_char_type>(-2))
     {
      phase2 = 1;
      break;
     }
     else if(ch==21||ch==53)
     {
      phase2 = 0;
      break;
     }
     else if(9<ch)
     {
      phase2 = 2;
      break;
     }
    }
   }
   else if(ch==static_cast<unsigned_char_type>(-2))
    phase2 = 1;
   else if(ch==21||ch==53)
    phase2 = 0;
   else
    phase2 = 2;
  }
 }
 if(phase2==1)
 {
  for(;m10digits<floating_trait::digits10;++m10digits,--m10e)
  {
   unsigned_char_type const ch(static_cast<unsigned_char_type>(get<true>(in).first)-48);
   if(ch<10)
    ipart=ipart*10+ch;
   else if(ch==21||ch==53)
   {
    phase2 = 0;
    break;
   }
   else
   {
    phase2 = 2;
    break;
   }
  }


  if(m10digits==floating_trait::digits10)
  {
   unsigned_char_type const ch(static_cast<unsigned_char_type>(get<true>(in).first)-48);

   if(ch==5)
   {
    if(ipart&1)
    {
     if(++ipart==floating_trait::carry10)
     {
      ipart=floating_trait::carry10/10;
      ++m10e;
     }
     for(;;)
     {
      unsigned_char_type const ch(static_cast<unsigned_char_type>(get<true>(in).first)-48);
      if(ch==21||ch==53)
      {
       phase2 = 0;
       break;
      }
      else if(9<ch)
      {
       phase2 = 2;
       break;
      }
     }
    }
    else
    {
     for(;;)
     {
      unsigned_char_type const ch(static_cast<unsigned_char_type>(get<true>(in).first)-48);
      if(ch==21||ch==53)
      {
       phase2 = 0;
       break;
      }
      else if(ch)
      {
       if(9<ch)
       {
        phase2 = 2;
        break;
       }
       if(++ipart==floating_trait::carry10)
       {
        ipart=floating_trait::carry10/10;
        ++m10e;
       }
       for(;;)
       {
        unsigned_char_type const ch(static_cast<unsigned_char_type>(get<true>(in).first)-48);
        if(ch==static_cast<unsigned_char_type>(-2))
        {
         phase2 = 1;
         break;
        }
        else if(ch==21||ch==53)
        {
         phase2 = 0;
         break;
        }
        else if(9<ch)
         break;
       }
       break;
      }
     }
    }
   }
   else if(ch<10)
   {
    if(5<ch)
    {
     if(++ipart==floating_trait::carry10)
     {
      ipart=floating_trait::carry10/10;
      ++m10e;
     }
    }
    for(;;)
    {
     unsigned_char_type const ch(static_cast<unsigned_char_type>(get<true>(in).first)-48);
     if(ch==21||ch==53)
     {
      phase2 = 0;
      break;
     }
     else if(9<ch)
     {
      phase2 = 2;
      break;
     }
    }
   }
   else if(ch==21||ch==53)
    phase2 = 0;
   else
    phase2 = 2;
  }
 }
 if(!phase2)
 {
  signed_exponent_type user_exp{};
  scan(in,user_exp);
  m10e+=user_exp;
  if(m10e<-308||308<m10e)
   throw std::overflow_error("exponent too large");
 }
 bool trailing_zeros{};
 using std::log2p1;
 signed_exponent_type e2(static_cast<signed_exponent_type>(log2p1(ipart))+m10e-(2+floating_trait::mantissa_bits));
 mantissa_type m2{};
 if(m10e<0)
 {
  auto const p5bm10e(pow5bits(-m10e));
  e2-=p5bm10e;
  m2=mul_shift(ipart,pow5<F,true>::inv_split[-m10e],e2-m10e+p5bm10e-1+floating_trait::pow5_bitcount);
  trailing_zeros=multiple_of_power_of_5(ipart,-m10e);
 }
 else
 {
  e2+=log2pow5(m10e);
  m2=mul_shift(ipart,pow5<F,true>::split[m10e],e2-m10e-pow5bits(m10e)+floating_trait::pow5_bitcount);
  trailing_zeros = e2 < m10e || multiple_of_power_of_2(ipart, e2 - m10e);
 }
 exponent_type ieee_e2(e2 + (floating_trait::bias-1) + log2p1(m2));
 if(ieee_e2<0)
  ieee_e2=0;
 signed_exponent_type shift((!ieee_e2?1:ieee_e2)-e2-(floating_trait::bias+floating_trait::mantissa_bits));
 trailing_zeros &= !(m2 & ((1L << (shift - 1)) - 1));
 bool last_removed_bit((m2>>(shift-1))&1);
 bool round_up((last_removed_bit) && (!trailing_zeros || ((m2 >> shift) & 1)));
 return bit_cast<F>(((((static_cast<mantissa_type>(negative)) << floating_trait::exponent_bits) | static_cast<mantissa_type>(ieee_e2)) <<
 floating_trait::mantissa_bits)|(((m2 >> shift) + round_up) & ((static_cast<mantissa_type>(1) << floating_trait::mantissa_bits) - 1)));
}

}
# 6 "fast_io/fast_io_freestanding_impl/ryu/ryu.h" 2
# 3 "fast_io/fast_io_freestanding_impl/floating.h" 2

namespace fast_io
{
# 227 "fast_io/fast_io_freestanding_impl/floating.h"
template<output_stream output,std::size_t precision,std::floating_point T>
inline void print_define(output& out,manip::fixed<precision,T const> a)
{

 std::size_t constexpr reserved_size(precision+325);
 if constexpr(buffer_output_stream<output>)
 {

  auto reserved(oreserve(out,reserved_size));
  if constexpr(std::is_pointer_v<decltype(reserved)>)
  {
   if(reserved)
   {
    auto start(reserved-reserved_size);
    orelease(out,reserved-details::ryu::output_fixed<precision>(start,static_cast<double>(a.reference)));
    return;
   }
  }
  else
  {
   auto start(reserved-reserved_size);
   orelease(out,reserved-details::ryu::output_fixed<precision>(start,static_cast<double>(a.reference)));
   return;
  }
 }
 if constexpr (precision<325)
 {
  std::array<typename output::char_type,reserved_size> array;
  send(out,array.data(),details::ryu::output_fixed<precision>(array.data(),static_cast<double>(a.reference)));
 }
 else
 {
  std::basic_string<typename output::char_type> str(reserved_size);
  send(out,str.data(),details::ryu::output_fixed<precision>(str.data(),static_cast<double>(a.reference)));
 }
}

template<output_stream output,std::size_t precision,bool uppercase_e,std::floating_point T>
inline void print_define(output& out,manip::scientific<precision,uppercase_e,T const> a)
{

 std::size_t constexpr reserved_size(precision+10);
 if constexpr(buffer_output_stream<output>)
 {

  auto reserved(oreserve(out,reserved_size));
  if constexpr(std::is_pointer_v<decltype(reserved)>)
  {
   if(reserved)
   {
    auto start(reserved-reserved_size);
    orelease(out,reserved-details::ryu::output_fixed<precision,true,uppercase_e>(start,static_cast<double>(a.reference)));
    return;
   }
  }
  else
  {
   auto start(reserved-reserved_size);
   orelease(out,reserved-details::ryu::output_fixed<precision,true,uppercase_e>(static_cast<double>(a.reference)));
   return;
  }
 }
 if constexpr (precision<325)
 {
  std::array<typename output::char_type,reserved_size> array;
  send(out,array.data(),details::ryu::output_fixed<precision,true,uppercase_e>(array.data(),static_cast<double>(a.reference)));
 }
 else
 {
  std::basic_string<typename output::char_type> str(reserved_size);
  send(out,str.data(),details::ryu::output_fixed<precision,true,uppercase_e>(str.data(),static_cast<double>(a.reference)));
 }
}

template<output_stream output,std::floating_point T>
inline void print_define(output& out,manip::fixed_shortest<T const> a)
{

 std::size_t constexpr reserved_size(325);
 if constexpr(buffer_output_stream<output>)
 {

  auto reserved(oreserve(out,reserved_size));
  if constexpr(std::is_pointer_v<decltype(reserved)>)
  {
   if(reserved)
   {
    auto start(reserved-reserved_size);
    orelease(out,reserved-details::ryu::output_shortest<false,1>(start,static_cast<double>(a.reference)));
    return;
   }
  }
  else
  {
   auto start(reserved-reserved_size);
   orelease(out,reserved-details::ryu::output_shortest<false,1>(start,static_cast<double>(a.reference)));
   return;
  }
 }
 std::array<typename output::char_type,reserved_size> array;
 send(out,array.data(),details::ryu::output_shortest<false,1>(array.data(),static_cast<double>(a.reference)));
}

template<output_stream output,bool uppercase_e,std::floating_point T>
inline void print_define(output& out,manip::scientific_shortest<uppercase_e,T const> a)
{

 std::size_t constexpr reserved_size(30);
 if constexpr(buffer_output_stream<output>)
 {

  auto reserved(oreserve(out,reserved_size));
  if constexpr(std::is_pointer_v<decltype(reserved)>)
  {
   if(reserved)
   {
    auto start(reserved-reserved_size);
    orelease(out,reserved-details::ryu::output_shortest<uppercase_e,2>(start,static_cast<double>(a.reference)));
    return;
   }
  }
  else
  {
   auto start(reserved-reserved_size);
   orelease(out,reserved-details::ryu::output_shortest<uppercase_e,2>(start,static_cast<double>(a.reference)));
   return;
  }
 }
 std::array<typename output::char_type,reserved_size> array;
 send(out,array.data(),details::ryu::output_shortest<uppercase_e,2>(array.data(),static_cast<double>(a.reference)));
}

template<output_stream output,bool uppercase_e,std::floating_point T>
inline void print_define(output& out,manip::shortest_shortest<uppercase_e,T const> a)
{

 std::size_t constexpr reserved_size(30);
 if constexpr(buffer_output_stream<output>)
 {

  auto reserved(oreserve(out,reserved_size));
  if constexpr(std::is_pointer_v<decltype(reserved)>)
  {
   if(reserved)
   {
    auto start(reserved-reserved_size);
    orelease(out,reserved-details::ryu::output_shortest<uppercase_e>(start,static_cast<double>(a.reference)));
    return;
   }
  }
  else
  {
   auto start(reserved-reserved_size);
   orelease(out,reserved-details::ryu::output_shortest<uppercase_e>(start,static_cast<double>(a.reference)));
   return;
  }
 }
 std::array<typename output::char_type,reserved_size> array;
 send(out,array.data(),details::ryu::output_shortest<uppercase_e>(array.data(),static_cast<double>(a.reference)));
}

template<output_stream output,std::floating_point T>
inline void print_define(output& out,T a)
{
 std::size_t constexpr reserved_size(30);
 if constexpr(buffer_output_stream<output>)
 {

  auto reserved(oreserve(out,reserved_size));
  if constexpr(std::is_pointer_v<decltype(reserved)>)
  {
   if(reserved)
   {
    auto start(reserved-reserved_size);
    orelease(out,reserved-details::ryu::output_shortest<false>(start,static_cast<double>(a)));
    return;
   }
  }
  else
  {
   auto start(reserved-reserved_size);
   orelease(out,reserved-details::ryu::output_shortest<false>(start,static_cast<double>(a)));
   return;
  }
 }
 std::array<typename output::char_type,reserved_size> array;
 send(out,array.data(),details::ryu::output_shortest<false>(array.data(),static_cast<double>(a)));
}

template<character_input_stream input,std::floating_point T>
inline constexpr void scan_define(input& in,T &t)
{
 t=static_cast<std::remove_cvref_t<T>>(details::ryu::input_floating<double>(in));
}

}
# 17 "fast_io/fast_io_freestanding.h" 2
# 1 "fast_io/fast_io_freestanding_impl/iobuf.h" 1
       

namespace fast_io
{
template<input_stream Ihandler,typename Buf>
class basic_ibuf;
template<output_stream Ohandler,typename Buf>
class basic_obuf;

template<typename T,std::size_t alignment=16384>
struct io_aligned_allocator
{
 using value_type = T;
 using size_type = std::size_t;
 using difference_type = std::ptrdiff_t;
 [[nodiscard]] inline T* allocate(std::size_t n)
 {
  return static_cast<T*>(operator new(n*sizeof(T),std::align_val_t{alignment}));
 }
 inline void deallocate(T* p, std::size_t n) noexcept
 {
  operator delete(p,n*sizeof(T),std::align_val_t{alignment});
 }
};

template<typename CharT,typename Allocator = io_aligned_allocator<CharT>,
  std::size_t buffer_size = ((65536<sizeof(CharT))?1:65536/sizeof(CharT))>
class basic_buf_handler
{
 Allocator alloc;
public:
 using char_type = CharT;
 using allocator_type = Allocator;
 char_type *beg{},*curr{},*end{};
 basic_buf_handler()=default;
 basic_buf_handler& operator=(basic_buf_handler const&)=delete;
 basic_buf_handler(basic_buf_handler const&)=delete;
 static constexpr std::size_t size = buffer_size;
 basic_buf_handler(basic_buf_handler&& m) noexcept:beg(m.beg),curr(m.curr),end(m.end)
 {
  m.end=m.curr=m.beg=nullptr;
 }
 basic_buf_handler& operator=(basic_buf_handler&& m) noexcept
 {
  if(std::addressof(m)!=this)
  {
   if(m.beg)
    alloc.deallocate(beg,buffer_size);
   beg=m.beg;
   curr=m.curr;
   end=m.end;
   m.end=m.curr=m.beg=nullptr;
  }
  return *this;
 }
 inline void init_space()
 {
  beg=alloc.allocate(buffer_size);
 }
 ~basic_buf_handler()
 {
  if(beg)
   alloc.deallocate(beg,buffer_size);
 }
 Allocator get_allocator() const{ return alloc;}
 void swap(basic_buf_handler& o) noexcept
 {
  using std::swap;
  swap(alloc,o.alloc);
  swap(beg,o.beg);
  swap(curr,o.curr);
  swap(end,o.end);
 }
};

template<typename CharT,typename Allocator,std::size_t buffer_size>
inline void swap(basic_buf_handler<CharT,Allocator,buffer_size>& a,basic_buf_handler<CharT,Allocator,buffer_size>& b) noexcept
{
 a.swap(b);
}

template<input_stream Ihandler,typename Buf=basic_buf_handler<typename Ihandler::char_type>>
class basic_ibuf
{
public:
 Ihandler ih;
 Buf ibuffer;

 using native_handle_type = Ihandler;
 using buffer_type = Buf;
 using char_type = typename Buf::char_type;
 template<typename... Args>

 basic_ibuf(Args&&... args):ih(std::forward<Args>(args)...){}
 inline constexpr auto& native_handle()
 {
  return ih;
 }
};

template<input_stream Ihandler,typename Buf>
[[nodiscard]] inline constexpr auto ireserve(basic_ibuf<Ihandler,Buf>& ib,std::size_t size)->decltype(ib.ibuffer.curr)
{
 if(ib.ibuffer.end<=ib.ibuffer.curr+size)
  return nullptr;
 return ib.ibuffer.curr+=size;
}

template<input_stream Ihandler,typename Buf>
inline constexpr void irelease(basic_ibuf<Ihandler,Buf>& ib,std::size_t size)
{
 ib.ibuffer.curr-=size;
}

template<output_stream output,input_stream Ihandler,typename Buf>
inline constexpr void idump(output& out,basic_ibuf<Ihandler,Buf>& ib)
{
 send(out,ib.ibuffer.curr,ib.ibuffer.end);
 ib.ibuffer.curr=ib.ibuffer.end;
}

template<typename T,typename Iter>
concept send_receive_punned_constraints = (std::contiguous_iterator<Iter>&&sizeof(typename T::char_type)==1) ||
 (std::random_access_iterator<Iter>&&std::same_as<typename T::char_type,typename std::iterator_traits<Iter>::value_type>);

namespace details
{
template<std::size_t buffer_size,bool punning=false,typename T,typename Iter>
inline constexpr Iter ibuf_receive(T& ib,Iter begin,Iter end)
{
 std::size_t const buffer_remain(ib.ibuffer.end-ib.ibuffer.curr);

 std::size_t n(end-begin);
 if(buffer_remain<n)
 {
  if(ib.ibuffer.end==nullptr)
  {
   if(buffer_size<=n)
   {
    return receive(ib.native_handle(),begin,end);
   }
   ib.ibuffer.init_space();
   ib.ibuffer.curr=ib.ibuffer.end=ib.ibuffer.beg;
  }
  if constexpr(punning)
  {
   std::memcpy(begin,ib.ibuffer.curr,buffer_remain);
   begin+=buffer_remain;
  }
  else
   begin=std::copy_n(ib.ibuffer.curr,buffer_remain,begin);
  if(begin+buffer_size<end)
  {

    begin=receive(ib.native_handle(),begin,end);




   if(begin!=end)
   {
    ib.ibuffer.end=ib.ibuffer.curr=ib.ibuffer.beg;
    return begin;
   }
  }
  ib.ibuffer.end=receive(ib.native_handle(),ib.ibuffer.beg,ib.ibuffer.beg+buffer_size);
  ib.ibuffer.curr=ib.ibuffer.beg;
  n=end-begin;
  std::size_t const sz(ib.ibuffer.end-ib.ibuffer.beg);
  if(sz<n)
   n=sz;
 }
 if constexpr(punning)
 {
  std::memcpy(begin,ib.ibuffer.curr,n);
  begin+=n;
 }
 else
  begin=std::copy_n(ib.ibuffer.curr,n,begin);
 ib.ibuffer.curr+=n;
 return begin;
}
}

template<input_stream Ihandler,typename Buf,std::random_access_iterator Iter>
requires (send_receive_punned_constraints<basic_ibuf<Ihandler,Buf>,Iter>)
inline constexpr Iter receive(basic_ibuf<Ihandler,Buf>& ib,Iter begin,Iter end)
{
 using char_type = typename basic_ibuf<Ihandler,Buf>::char_type;
 if constexpr(std::same_as<char_type,typename std::iterator_traits<Iter>::value_type>)
  return details::ibuf_receive<Buf::size>(ib,begin,end);
 else
 {
  auto b(reinterpret_cast<std::byte*>(std::to_address(begin)));
  return begin+(details::ibuf_receive<Buf::size,true>(ib,b,reinterpret_cast<std::byte*>(std::to_address(end)))-b)/sizeof(*begin);
 }
}

template<bool err=false,input_stream Ihandler,typename Buf>
inline constexpr auto get(basic_ibuf<Ihandler,Buf>& ib)
{
 using buffer_type = typename basic_ibuf<Ihandler,Buf>::buffer_type;
 if(ib.ibuffer.end==ib.ibuffer.curr)[[unlikely]]
 {
  if(ib.ibuffer.end==nullptr)
  {
   ib.ibuffer.init_space();
   ib.ibuffer.curr=ib.ibuffer.end=ib.ibuffer.beg;
  }
  if((ib.ibuffer.end=receive(ib.native_handle(),ib.ibuffer.beg,ib.ibuffer.beg+buffer_type::size))==ib.ibuffer.beg)
  {
   ib.ibuffer.curr=ib.ibuffer.beg;
   if constexpr(err)
    return std::pair<typename basic_ibuf<Ihandler,Buf>::char_type,bool>{0,true};
   else
    throw eof();
  }
  ib.ibuffer.curr=ib.ibuffer.beg;
 }
 if constexpr(err)
  return std::pair<typename basic_ibuf<Ihandler,Buf>::char_type,bool>{*ib.ibuffer.curr++,false};
 else
  return *ib.ibuffer.curr++;
}

template<input_stream Ihandler,typename Buf,typename... Args>
requires random_access_stream<Ihandler>
inline constexpr auto seek(basic_ibuf<Ihandler,Buf>& ib,Args&& ...args)
{
 ib.ibuffer.curr=ib.ibuffer.end;
 return seek(ib.native_handle(),std::forward<Args>(args)...);
}

template<zero_copy_input_stream Ihandler,typename Buf>
inline constexpr auto zero_copy_in_handle(basic_ibuf<Ihandler,Buf>& ib)
{
 return zero_copy_in_handle(ib.native_handle());
}

template<output_stream Ohandler,typename Buf=basic_buf_handler<typename Ohandler::char_type>>
class basic_obuf
{
 Ohandler oh;
public:
 Buf obuffer;
 inline constexpr void close_impl() noexcept
 try
 {
  if(obuffer.beg)
   send(oh,obuffer.beg,obuffer.curr);
 }
 catch(...){}
public:
 using native_handle_type = Ohandler;
 using buffer_type = Buf;
 using char_type = typename Buf::char_type;
 template<typename... Args>

 basic_obuf(Args&&... args):oh(std::forward<Args>(args)...){}
 ~basic_obuf()
 {
  close_impl();
 }
 basic_obuf& operator=(basic_obuf const&)=delete;
 basic_obuf(basic_obuf const&)=delete;
 basic_obuf(basic_obuf&& bmv) noexcept:oh(std::move(bmv.oh)),obuffer(std::move(bmv.obuffer)){}
 basic_obuf& operator=(basic_obuf&& b) noexcept
 {
  if(std::addressof(b)!=this)
  {
   close_impl();
   oh=std::move(b.oh);
   obuffer=std::move(b.obuffer);
  }
  return *this;
 }
 inline constexpr auto& native_handle()
 {
  return oh;
 }
};

namespace details
{

template<bool punning=false,typename T,typename Iter>
inline constexpr void obuf_send(T& ob,Iter cbegin,Iter cend)
{
 using char_type = typename T::char_type;
 std::size_t const n(ob.obuffer.end-ob.obuffer.curr);
 std::size_t const diff(std::distance(cbegin,cend));
 if(n<diff)[[unlikely]]
 {
  if(ob.obuffer.end==nullptr)
  {
   if(T::buffer_type::size<=diff)
   {
    send(ob.native_handle(),cbegin,cend);
    return;
   }
   ob.obuffer.init_space();
   ob.obuffer.end=(ob.obuffer.curr=ob.obuffer.beg)+T::buffer_type::size;
   if constexpr(punning)
    std::memcpy(ob.obuffer.curr,cbegin,diff);
   else
    std::copy_n(cbegin,diff,ob.obuffer.curr);
   ob.obuffer.curr+=diff;
   return;
  }
  if constexpr(punning)
   std::memcpy(ob.obuffer.curr,cbegin,n);
  else
   std::copy_n(cbegin,n,ob.obuffer.curr);
  cbegin+=n;
  send(ob.native_handle(),ob.obuffer.beg,ob.obuffer.end);
  if(cbegin+(T::buffer_type::size)<cend)
  {
   send(ob.native_handle(),cbegin,cend);
   ob.obuffer.curr=ob.obuffer.beg;
  }
  else
  {
   std::size_t const df(cend-cbegin);
   if constexpr(punning)
    std::memcpy(ob.obuffer.beg,cbegin,df);
   else
    std::copy_n(cbegin,df,ob.obuffer.beg);
   ob.obuffer.curr=ob.obuffer.beg+df;
  }
  return;
 }
 if constexpr(punning)
  std::memcpy(ob.obuffer.curr,cbegin,diff);
 else
  std::copy_n(cbegin,diff,ob.obuffer.curr);
 ob.obuffer.curr+=diff;
}

}

template<output_stream Ohandler,typename Buf,std::input_iterator Iter>
requires (send_receive_punned_constraints<basic_obuf<Ohandler,Buf>,Iter>)
inline constexpr void send(basic_obuf<Ohandler,Buf>& ob,Iter cbegini,Iter cendi)
{
 using char_type = typename basic_obuf<Ohandler,Buf>::char_type;
 if constexpr(std::same_as<char_type,typename std::iterator_traits<Iter>::value_type>)
  details::obuf_send(ob,cbegini,cendi);
 else
  details::obuf_send<true>(ob,reinterpret_cast<std::byte const*>(std::to_address(cbegini)),
     reinterpret_cast<std::byte const*>(std::to_address(cendi)));
}

template<output_stream Ohandler,typename Buf>
inline constexpr void fill_nc(basic_obuf<Ohandler,Buf>& ob,std::size_t count,typename basic_obuf<Ohandler,Buf>::char_type const& ch)
{
 std::size_t const remain_space(static_cast<std::size_t>(ob.obuffer.end-ob.obuffer.curr));
 if(remain_space<=count)
 {
  obuf_deal_with_cold_buffer(ob);
  std::fill(ob.obuffer.curr,ob.obuffer.end,ch);
  send(ob.native_handle(),ob.obuffer.beg,ob.obuffer.end);
  count-=remain_space;
  constexpr auto buffer_size(Buf::size);
  std::size_t const times(count/buffer_size),remain(count%buffer_size);
  if(times)
  {
   std::fill(ob.obuffer.beg,ob.obuffer.curr,ch);
   for(std::size_t i(0);i!=times;++i)
    send(ob.native_handle(),ob.obuffer.beg,ob.obuffer.end);
  }
  else
  {
   std::size_t cb(static_cast<std::size_t>(ob.obuffer.curr-ob.obuffer.beg));
   if(remain<cb)
    cb=remain;
   std::fill_n(ob.obuffer.beg,cb,ch);
  }
  ob.obuffer.curr=ob.obuffer.beg+remain;
  return;
 }
 ob.obuffer.curr=std::fill_n(ob.obuffer.curr,count,ch);
}

template<output_stream Ohandler,typename Buf>
inline constexpr void put(basic_obuf<Ohandler,Buf>& ob,typename basic_obuf<Ohandler,Buf>::char_type ch)
{
 if(ob.obuffer.curr==ob.obuffer.end)[[unlikely]]
 {
  if(ob.obuffer.beg)
   send(ob.native_handle(),ob.obuffer.beg,ob.obuffer.end);
  else
  {
   ob.obuffer.init_space();
   ob.obuffer.end=ob.obuffer.beg+Buf::size;
  }
  ob.obuffer.curr=ob.obuffer.beg+1;
  *ob.obuffer.beg=ch;
  return;
 }
 *ob.obuffer.curr++=ch;
}
template<output_stream Ohandler,typename Buf>
inline constexpr void flush(basic_obuf<Ohandler,Buf>& ob)
{
 if(ob.obuffer.beg==ob.obuffer.curr)
  return;
 send(ob.native_handle(),ob.obuffer.beg,ob.obuffer.curr);
 ob.obuffer.curr=ob.obuffer.beg;

}


template<output_stream Ohandler,typename Buf,typename... Args>
requires random_access_stream<Ohandler>
inline constexpr auto seek(basic_obuf<Ohandler,Buf>& ob,Args&& ...args)
{
 if(ob.obuffer.beg!=ob.obuffer.curr)
 {
  send(ob.native_handle(),ob.obuffer.beg,ob.obuffer.curr);
  ob.obuffer.curr=ob.obuffer.beg;
 }
 return seek(ob.native_handle(),std::forward<Args>(args)...);
}

template<output_stream Ohandler,typename Buf>
[[nodiscard]] inline constexpr auto oreserve(basic_obuf<Ohandler,Buf>& ob,std::size_t size) -> decltype(ob.obuffer.curr)
{
 if(ob.obuffer.end<=ob.obuffer.curr+size)
  return nullptr;
 return ob.obuffer.curr+=size;
}

template<output_stream Ohandler,typename Buf>
inline constexpr void orelease(basic_obuf<Ohandler,Buf>& ob,std::size_t size)
{
 ob.obuffer.curr-=size;
}

template<zero_copy_output_stream Ohandler,typename Buf>
inline constexpr void zero_copy_out_handle(basic_obuf<Ohandler,Buf>& ob)
{
 return zero_copy_out_handle(ob.native_handle());
}

namespace details
{
template<io_stream io_handler,typename Buf>
struct fake_basic_ihandler:basic_obuf<io_handler,Buf>
{
template<typename... Args>

fake_basic_ihandler(Args&& ...args):basic_obuf<io_handler,Buf>(std::forward<Args>(args)...){}
};

template<io_stream io_handler,typename Buf,std::contiguous_iterator Iter>
inline constexpr Iter receive(fake_basic_ihandler<io_handler,Buf>& iob,Iter begin,Iter end)
{
 return receive(iob.native_handle(),begin,end);
}

}

template<io_stream io_handler,typename Buf=basic_buf_handler<typename io_handler::char_type>>
class basic_iobuf
{
public:
 using native_handle_type = io_handler;
 using buffer_type = Buf;
 using char_type = typename Buf::char_type;
 basic_ibuf<details::fake_basic_ihandler<native_handle_type,Buf>> ibf;
 template<typename... Args>

 basic_iobuf(Args&& ...args):ibf(std::forward<Args>(args)...){}
 inline constexpr auto& native_handle()
 {
  return ibf.native_handle().native_handle();
 }
 inline constexpr auto& ibuffer()
 {
  return ibf.ibuffer;
 }
 inline constexpr auto& obuffer()
 {
  return ibf.native_handle().obuffer;
 }
 friend inline constexpr void flush(basic_iobuf& iob)
 {
  flush(iob.ibf.native_handle());
 }
 friend inline constexpr void put(basic_iobuf& iob,char_type ch)
 {
  put(iob.ibf.native_handle(),ch);
 }
 template<std::contiguous_iterator Iter>
 friend inline constexpr void send(basic_iobuf& iob,Iter begin,Iter end)
 {
  send(iob.ibf.native_handle(),begin,end);
 }
 template<std::contiguous_iterator Iter>
 friend inline constexpr Iter receive(basic_iobuf& iob,Iter begin,Iter end)
 {
  return receive(iob.ibf,begin,end);
 }
 template<bool err=false>
 friend inline constexpr auto get(basic_iobuf& iob)
 {
  return get<err>(iob.ibf);
 }
 friend inline constexpr auto& ibuffer(basic_iobuf& iob)
 {
  return ibuffer(iob.ibf);
 }
 friend inline constexpr void irelease(basic_iobuf& iob,std::size_t size)
 {
  irelease(iob.ibf,size);
 }
 friend inline constexpr auto ireserve(basic_iobuf& iob,std::size_t size)
 {
  return ireserve(iob.ibf,size);
 }
 template<output_stream output>
 friend inline constexpr auto& idump(output& out,basic_iobuf& iob)
 {
  return idump(out,iob.ibf);
 }
 friend inline constexpr auto& obuffer(basic_iobuf& iob)
 {
  return obuffer(iob.ibf.native_handle());
 }
 friend inline constexpr void fill_nc(basic_iobuf& ob,std::size_t count,char_type const& ch)
 {
  fill_nc(ob.ibf.native_handle(),count,ch);
 }
 friend inline constexpr void orelease(basic_iobuf& ob,std::size_t size)
 {
  orelease(ob.ibf.native_handle(),size);
 }
 friend inline constexpr auto oreserve(basic_iobuf& iob,std::size_t size)
 {
  return oreserve(iob.ibf.native_handle(),size);
 }

};

template<zero_copy_input_stream Ihandler,typename Buf>
inline constexpr auto zero_copy_in_handle(basic_iobuf<Ihandler,Buf>& ib)
{
 return zero_copy_in_handle(ib.native_handle());
}

template<zero_copy_output_stream Ohandler,typename Buf>
inline constexpr auto zero_copy_out_handle(basic_iobuf<Ohandler,Buf>& ob)
{
 return zero_copy_out_handle(ob.native_handle());
}

template<io_stream io_handler,typename Buf,typename... Args>
requires random_access_stream<io_handler>
inline constexpr auto seek(basic_iobuf<io_handler,Buf>& iob,Args&& ...args)
{
 flush(iob.ibf.native_handle());
 return seek(iob.ibf,std::forward<Args>(args)...);
}

}
# 18 "fast_io/fast_io_freestanding.h" 2
# 1 "fast_io/fast_io_freestanding_impl/dynamic.h" 1
       

namespace fast_io
{

template<std::integral T>
class basic_dynamic_base
{
public:
 using char_type = T;
private:
 struct base
 {
  virtual char_type* receive_impl(char_type*,char_type*) = 0;
  virtual void send_impl(char_type const*,char_type const*) = 0;
  virtual void flush_impl() = 0;
  virtual char_type* oreserve_impl(std::size_t) = 0;
  virtual void orelease_impl(std::size_t) = 0;
  virtual base* clone() = 0;
  virtual ~base() = default;
 };
 template<stream stm>
 struct derv:base
 {
  stm io;
  template<typename ...Args>
  derv(std::in_place_type_t<stm>,Args&& ...args):io(std::forward<Args>(args)...){}
  char_type* receive_impl(char_type* b,char_type* e) override
  {
   if constexpr(input_stream<stm>)
    return receive(io,b,e);
   else
    throw std::system_error(
# 33 "fast_io/fast_io_freestanding_impl/dynamic.h" 3 4
                           1
# 33 "fast_io/fast_io_freestanding_impl/dynamic.h"
                                ,std::generic_category());
  }
  void send_impl(char_type const* b,char_type const* e) override
  {
   if constexpr(output_stream<stm>)
    send(io,b,e);
   else
    throw std::system_error(
# 40 "fast_io/fast_io_freestanding_impl/dynamic.h" 3 4
                           1
# 40 "fast_io/fast_io_freestanding_impl/dynamic.h"
                                ,std::generic_category());
  }
  void flush_impl() override
  {
   if constexpr(output_stream<stm>)
    flush(io);
   else
    throw std::system_error(
# 47 "fast_io/fast_io_freestanding_impl/dynamic.h" 3 4
                           1
# 47 "fast_io/fast_io_freestanding_impl/dynamic.h"
                                ,std::generic_category());
  }
  char_type* oreserve_impl(std::size_t sz) override
  {
   if constexpr(buffer_output_stream<stm>)
   {
    if constexpr(std::contiguous_iterator<std::remove_cvref_t<decltype(oreserve(io,sz))>>)
     return std::to_address(oreserve(io,sz));
    else
     return nullptr;
   }
   else
    return nullptr;
  }
  void orelease_impl(std::size_t sz) override
  {
   if constexpr(buffer_output_stream<stm>)
    orelease(io,sz);
  }
  base* clone() override
  {
   if constexpr(std::copyable<stm>)
    return new derv<stm>(std::in_place_type<stm>,io);
   else
    throw std::system_error(
# 71 "fast_io/fast_io_freestanding_impl/dynamic.h" 3 4
                           1
# 71 "fast_io/fast_io_freestanding_impl/dynamic.h"
                                ,std::generic_category());
  }
 };
 base* ptr=nullptr;
public:
 using opaque_base = base;
 basic_dynamic_base()=default;
 basic_dynamic_base(void* p):ptr(bit_cast<base*>(p)){}
 auto release() noexcept
 {
  auto temp(ptr);
  ptr=nullptr;
  return temp;
 }
 auto opaque_base_pointer()
 {
  return ptr;
 }
 auto opaque_base_pointer() const
 {
  return ptr;
 }
 basic_dynamic_base(basic_dynamic_base const& b):basic_dynamic_base(b.ptr->clone()){}
 basic_dynamic_base& operator=(basic_dynamic_base const& b)
 {
  auto newp(b.ptr->clone());
  delete ptr;
  ptr=newp;
  return *this;
 }
 basic_dynamic_base(basic_dynamic_base&& b) noexcept:ptr(b.ptr)
 {
  b.ptr=nullptr;
 }
 basic_dynamic_base& operator=(basic_dynamic_base&& b) noexcept
 {
  if(b.ptr!=ptr)
  {
   delete ptr;
   ptr=b.ptr;
   b.ptr=nullptr;
  }
  return *this;
 }
 template<stream P>
 requires (!std::same_as<basic_dynamic_base,P>)
 basic_dynamic_base(P p):ptr(new derv<P>(std::in_place_type<P>,std::move(p))){}
 template<stream P,typename ...Args>
 basic_dynamic_base(std::in_place_type_t<P>,Args&& ...args):
  ptr(new derv<P>(std::in_place_type<P>,std::forward<Args>(args)...)){}
};

template<std::integral T>
struct basic_dynamic_stream:basic_dynamic_base<T>
{
public:
 using basic_dynamic_base<T>::char_type;
 template<typename ...Args>
 basic_dynamic_stream(Args&& ...args):basic_dynamic_base<T>(std::forward<Args>(args)...){}
 ~basic_dynamic_stream()
 {
  delete this->opaque_base_pointer();
 }
};
template<std::integral char_type,std::contiguous_iterator Iter>
inline Iter receive(basic_dynamic_base<char_type>& io,Iter b,Iter e)
{
 char_type *pb(static_cast<char_type*>(static_cast<void*>(std::to_address(b))));
 char_type *pe(static_cast<char_type*>(static_cast<void*>(std::to_address(e))));
 return b+(io.opaque_base_pointer()->receive_impl(pb,pe)-pb)*sizeof(*b)/sizeof(char_type);
}

template<std::integral char_type,std::contiguous_iterator Iter>
inline void send(basic_dynamic_base<char_type>& io,Iter b,Iter e)
{
 io.opaque_base_pointer()->send_impl(static_cast<char_type const*>(static_cast<void const*>(std::to_address(b))),
   static_cast<char_type const*>(static_cast<void const*>(std::to_address(e))));
}

template<std::integral char_type>
inline auto oreserve(basic_dynamic_base<char_type>& io,std::size_t sz)
{
 return io.opaque_base_pointer()->oreserve_impl(sz);
}

template<std::integral char_type>
inline void orelease(basic_dynamic_base<char_type>& io,std::size_t sz)
{
 return io.opaque_base_pointer()->orelease_impl(sz);
}

template<std::integral char_type>
inline void flush(basic_dynamic_base<char_type>& io) { return io.opaque_base_pointer()->flush_impl();}

using dynamic_base = basic_dynamic_base<char>;

using dynamic_stream = basic_dynamic_stream<char>;


}
# 19 "fast_io/fast_io_freestanding.h" 2
# 1 "fast_io/fast_io_freestanding_impl/read_write.h" 1
       

namespace fast_io
{


template<character_input_stream input>
inline constexpr std::size_t read_size(input& in)
{
 auto constexpr bytes(sizeof(get(in))*8);
 auto constexpr lshift(bytes-1);
 auto constexpr limit(static_cast<std::size_t>(1)<<lshift);
 auto constexpr limitm1(limit-1);
 for(std::size_t temp(0),lsf(0);lsf<sizeof(std::size_t)*8;lsf+=lshift)
 {
  std::make_unsigned_t<decltype(get(in))> ch(get(in));
  temp|=(ch&limitm1)<<lsf;
  if(ch<limit)
   return temp;
 }
 throw std::runtime_error("size is out of std::size_t range");
}

template<character_output_stream output>
inline constexpr void write_size(output& out,std::size_t size)
{
 using ch_type = typename output::char_type;
 auto constexpr bytes(sizeof(typename output::char_type)*8);
 auto constexpr lshift(bytes-1);
 auto constexpr limit(static_cast<std::size_t>(1)<<lshift);
 auto constexpr limitm1(limit-1);
 for(;limitm1<size;size>>=lshift)
  put(out,static_cast<ch_type>((size&limitm1)|limit));
 put(out,static_cast<ch_type>(size));
}

namespace details
{
template<typename T,std::size_t N>
inline constexpr bool detect_std_array(std::array<T,N> const&) {return true;}

template<typename T>
inline constexpr bool detect_std_array(T const&) {return false;}
}

template<output_stream output,typename T>
requires (std::is_trivially_copyable_v<T>||std::ranges::sized_range<T>)
inline constexpr void write_define(output& out,T const& v)
{
 if constexpr(std::is_trivially_copyable_v<T>)
 {
  if constexpr(std::is_bounded_array_v<T>)
   write_size(out,std::size(v));
  auto address(std::addressof(v));
  send(out,address,address+1);
 }
 else
 {
  if constexpr(!details::detect_std_array(v))
   write_size(out,std::size(v));
  for(auto const& e : v)
   write(out,e);
 }
}
template<input_stream input,typename T>
requires (std::is_trivially_copyable_v<T>||std::ranges::sized_range<T>)
inline constexpr void read_define(input& in,T& v)
{
 if constexpr(std::is_trivially_copyable_v<T>)
 {
  auto address(std::addressof(v));
  receive(in,address,address+1);
 }
 else
 {
  if constexpr(!details::detect_std_array(v)&&!std::is_bounded_array_v<T>)
   v.resize(read_size(in));
  for(auto& e : v)
   read(in,e);
 }
}


}
# 20 "fast_io/fast_io_freestanding.h" 2
# 1 "fast_io/fast_io_freestanding_impl/natural.h" 1
       

# 1 "/usr/local/include/c++/10.0.0/complex" 1 3
# 39 "/usr/local/include/c++/10.0.0/complex" 3
       
# 40 "/usr/local/include/c++/10.0.0/complex" 3




# 1 "/usr/local/include/c++/10.0.0/cmath" 1 3
# 39 "/usr/local/include/c++/10.0.0/cmath" 3
       
# 40 "/usr/local/include/c++/10.0.0/cmath" 3





# 1 "/usr/include/math.h" 1 3 4
# 27 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/math.h" 2 3 4







# 34 "/usr/include/math.h" 3 4
extern "C" {





# 1 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libm-simd-decl-stubs.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 2 3 4
# 41 "/usr/include/math.h" 2 3 4
# 138 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/flt-eval-method.h" 1 3 4
# 139 "/usr/include/math.h" 2 3 4
# 149 "/usr/include/math.h" 3 4
typedef float float_t;
typedef double double_t;
# 190 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-logb.h" 1 3 4
# 191 "/usr/include/math.h" 2 3 4
# 233 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-fast.h" 1 3 4
# 234 "/usr/include/math.h" 2 3 4



enum
  {
    FP_INT_UPWARD =

      0,
    FP_INT_DOWNWARD =

      1,
    FP_INT_TOWARDZERO =

      2,
    FP_INT_TONEARESTFROMZERO =

      3,
    FP_INT_TONEAREST =

      4,
  };
# 289 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassify (double __value) throw ()
     __attribute__ ((__const__));


extern int __signbit (double __value) throw ()
     __attribute__ ((__const__));



extern int __isinf (double __value) throw () __attribute__ ((__const__));


extern int __finite (double __value) throw () __attribute__ ((__const__));


extern int __isnan (double __value) throw () __attribute__ ((__const__));


extern int __iseqsig (double __x, double __y) throw ();


extern int __issignaling (double __value) throw ()
     __attribute__ ((__const__));
# 290 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double acos (double __x) throw (); extern double __acos (double __x) throw ();

extern double asin (double __x) throw (); extern double __asin (double __x) throw ();

extern double atan (double __x) throw (); extern double __atan (double __x) throw ();

extern double atan2 (double __y, double __x) throw (); extern double __atan2 (double __y, double __x) throw ();


 extern double cos (double __x) throw (); extern double __cos (double __x) throw ();

 extern double sin (double __x) throw (); extern double __sin (double __x) throw ();

extern double tan (double __x) throw (); extern double __tan (double __x) throw ();




extern double cosh (double __x) throw (); extern double __cosh (double __x) throw ();

extern double sinh (double __x) throw (); extern double __sinh (double __x) throw ();

extern double tanh (double __x) throw (); extern double __tanh (double __x) throw ();



 extern void sincos (double __x, double *__sinx, double *__cosx) throw (); extern void __sincos (double __x, double *__sinx, double *__cosx) throw ()
                                                        ;




extern double acosh (double __x) throw (); extern double __acosh (double __x) throw ();

extern double asinh (double __x) throw (); extern double __asinh (double __x) throw ();

extern double atanh (double __x) throw (); extern double __atanh (double __x) throw ();





 extern double exp (double __x) throw (); extern double __exp (double __x) throw ();


extern double frexp (double __x, int *__exponent) throw (); extern double __frexp (double __x, int *__exponent) throw ();


extern double ldexp (double __x, int __exponent) throw (); extern double __ldexp (double __x, int __exponent) throw ();


 extern double log (double __x) throw (); extern double __log (double __x) throw ();


extern double log10 (double __x) throw (); extern double __log10 (double __x) throw ();


extern double modf (double __x, double *__iptr) throw (); extern double __modf (double __x, double *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern double exp10 (double __x) throw (); extern double __exp10 (double __x) throw ();




extern double expm1 (double __x) throw (); extern double __expm1 (double __x) throw ();


extern double log1p (double __x) throw (); extern double __log1p (double __x) throw ();


extern double logb (double __x) throw (); extern double __logb (double __x) throw ();




extern double exp2 (double __x) throw (); extern double __exp2 (double __x) throw ();


extern double log2 (double __x) throw (); extern double __log2 (double __x) throw ();






 extern double pow (double __x, double __y) throw (); extern double __pow (double __x, double __y) throw ();


extern double sqrt (double __x) throw (); extern double __sqrt (double __x) throw ();



extern double hypot (double __x, double __y) throw (); extern double __hypot (double __x, double __y) throw ();




extern double cbrt (double __x) throw (); extern double __cbrt (double __x) throw ();






extern double ceil (double __x) throw () __attribute__ ((__const__)); extern double __ceil (double __x) throw () __attribute__ ((__const__));


extern double fabs (double __x) throw () __attribute__ ((__const__)); extern double __fabs (double __x) throw () __attribute__ ((__const__));


extern double floor (double __x) throw () __attribute__ ((__const__)); extern double __floor (double __x) throw () __attribute__ ((__const__));


extern double fmod (double __x, double __y) throw (); extern double __fmod (double __x, double __y) throw ();
# 182 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int finite (double __value) throw () __attribute__ ((__const__));


extern double drem (double __x, double __y) throw (); extern double __drem (double __x, double __y) throw ();



extern double significand (double __x) throw (); extern double __significand (double __x) throw ();






extern double copysign (double __x, double __y) throw () __attribute__ ((__const__)); extern double __copysign (double __x, double __y) throw () __attribute__ ((__const__));




extern double nan (const char *__tagb) throw () __attribute__ ((__const__)); extern double __nan (const char *__tagb) throw () __attribute__ ((__const__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double j0 (double) throw (); extern double __j0 (double) throw ();
extern double j1 (double) throw (); extern double __j1 (double) throw ();
extern double jn (int, double) throw (); extern double __jn (int, double) throw ();
extern double y0 (double) throw (); extern double __y0 (double) throw ();
extern double y1 (double) throw (); extern double __y1 (double) throw ();
extern double yn (int, double) throw (); extern double __yn (int, double) throw ();





extern double erf (double) throw (); extern double __erf (double) throw ();
extern double erfc (double) throw (); extern double __erfc (double) throw ();
extern double lgamma (double) throw (); extern double __lgamma (double) throw ();




extern double tgamma (double) throw (); extern double __tgamma (double) throw ();





extern double gamma (double) throw (); extern double __gamma (double) throw ();







extern double lgamma_r (double, int *__signgamp) throw (); extern double __lgamma_r (double, int *__signgamp) throw ();






extern double rint (double __x) throw (); extern double __rint (double __x) throw ();


extern double nextafter (double __x, double __y) throw (); extern double __nextafter (double __x, double __y) throw ();

extern double nexttoward (double __x, long double __y) throw (); extern double __nexttoward (double __x, long double __y) throw ();




extern double nextdown (double __x) throw (); extern double __nextdown (double __x) throw ();

extern double nextup (double __x) throw (); extern double __nextup (double __x) throw ();



extern double remainder (double __x, double __y) throw (); extern double __remainder (double __x, double __y) throw ();



extern double scalbn (double __x, int __n) throw (); extern double __scalbn (double __x, int __n) throw ();



extern int ilogb (double __x) throw (); extern int __ilogb (double __x) throw ();




extern long int llogb (double __x) throw (); extern long int __llogb (double __x) throw ();




extern double scalbln (double __x, long int __n) throw (); extern double __scalbln (double __x, long int __n) throw ();



extern double nearbyint (double __x) throw (); extern double __nearbyint (double __x) throw ();



extern double round (double __x) throw () __attribute__ ((__const__)); extern double __round (double __x) throw () __attribute__ ((__const__));



extern double trunc (double __x) throw () __attribute__ ((__const__)); extern double __trunc (double __x) throw () __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) throw (); extern double __remquo (double __x, double __y, int *__quo) throw ();






extern long int lrint (double __x) throw (); extern long int __lrint (double __x) throw ();
__extension__
extern long long int llrint (double __x) throw (); extern long long int __llrint (double __x) throw ();



extern long int lround (double __x) throw (); extern long int __lround (double __x) throw ();
__extension__
extern long long int llround (double __x) throw (); extern long long int __llround (double __x) throw ();



extern double fdim (double __x, double __y) throw (); extern double __fdim (double __x, double __y) throw ();


extern double fmax (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmax (double __x, double __y) throw () __attribute__ ((__const__));


extern double fmin (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmin (double __x, double __y) throw () __attribute__ ((__const__));


extern double fma (double __x, double __y, double __z) throw (); extern double __fma (double __x, double __y, double __z) throw ();




extern double roundeven (double __x) throw () __attribute__ ((__const__)); extern double __roundeven (double __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfp (double __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfp (double __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfp (double __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfp (double __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpx (double __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpx (double __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpx (double __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpx (double __x, int __round, unsigned int __width) throw ()
                               ;


extern double fmaxmag (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmaxmag (double __x, double __y) throw () __attribute__ ((__const__));


extern double fminmag (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fminmag (double __x, double __y) throw () __attribute__ ((__const__));


extern int totalorder (double __x, double __y) throw ()
     __attribute__ ((__const__));


extern int totalordermag (double __x, double __y) throw ()
     __attribute__ ((__const__));


extern int canonicalize (double *__cx, const double *__x) throw ();


extern double getpayload (const double *__x) throw (); extern double __getpayload (const double *__x) throw ();


extern int setpayload (double *__x, double __payload) throw ();


extern int setpayloadsig (double *__x, double __payload) throw ();







extern double scalb (double __x, double __n) throw (); extern double __scalb (double __x, double __n) throw ();
# 291 "/usr/include/math.h" 2 3 4
# 306 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf (float __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf (float __value) throw ()
     __attribute__ ((__const__));



extern int __isinff (float __value) throw () __attribute__ ((__const__));


extern int __finitef (float __value) throw () __attribute__ ((__const__));


extern int __isnanf (float __value) throw () __attribute__ ((__const__));


extern int __iseqsigf (float __x, float __y) throw ();


extern int __issignalingf (float __value) throw ()
     __attribute__ ((__const__));
# 307 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern float acosf (float __x) throw (); extern float __acosf (float __x) throw ();

extern float asinf (float __x) throw (); extern float __asinf (float __x) throw ();

extern float atanf (float __x) throw (); extern float __atanf (float __x) throw ();

extern float atan2f (float __y, float __x) throw (); extern float __atan2f (float __y, float __x) throw ();


 extern float cosf (float __x) throw (); extern float __cosf (float __x) throw ();

 extern float sinf (float __x) throw (); extern float __sinf (float __x) throw ();

extern float tanf (float __x) throw (); extern float __tanf (float __x) throw ();




extern float coshf (float __x) throw (); extern float __coshf (float __x) throw ();

extern float sinhf (float __x) throw (); extern float __sinhf (float __x) throw ();

extern float tanhf (float __x) throw (); extern float __tanhf (float __x) throw ();



 extern void sincosf (float __x, float *__sinx, float *__cosx) throw (); extern void __sincosf (float __x, float *__sinx, float *__cosx) throw ()
                                                        ;




extern float acoshf (float __x) throw (); extern float __acoshf (float __x) throw ();

extern float asinhf (float __x) throw (); extern float __asinhf (float __x) throw ();

extern float atanhf (float __x) throw (); extern float __atanhf (float __x) throw ();





 extern float expf (float __x) throw (); extern float __expf (float __x) throw ();


extern float frexpf (float __x, int *__exponent) throw (); extern float __frexpf (float __x, int *__exponent) throw ();


extern float ldexpf (float __x, int __exponent) throw (); extern float __ldexpf (float __x, int __exponent) throw ();


 extern float logf (float __x) throw (); extern float __logf (float __x) throw ();


extern float log10f (float __x) throw (); extern float __log10f (float __x) throw ();


extern float modff (float __x, float *__iptr) throw (); extern float __modff (float __x, float *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern float exp10f (float __x) throw (); extern float __exp10f (float __x) throw ();




extern float expm1f (float __x) throw (); extern float __expm1f (float __x) throw ();


extern float log1pf (float __x) throw (); extern float __log1pf (float __x) throw ();


extern float logbf (float __x) throw (); extern float __logbf (float __x) throw ();




extern float exp2f (float __x) throw (); extern float __exp2f (float __x) throw ();


extern float log2f (float __x) throw (); extern float __log2f (float __x) throw ();






 extern float powf (float __x, float __y) throw (); extern float __powf (float __x, float __y) throw ();


extern float sqrtf (float __x) throw (); extern float __sqrtf (float __x) throw ();



extern float hypotf (float __x, float __y) throw (); extern float __hypotf (float __x, float __y) throw ();




extern float cbrtf (float __x) throw (); extern float __cbrtf (float __x) throw ();






extern float ceilf (float __x) throw () __attribute__ ((__const__)); extern float __ceilf (float __x) throw () __attribute__ ((__const__));


extern float fabsf (float __x) throw () __attribute__ ((__const__)); extern float __fabsf (float __x) throw () __attribute__ ((__const__));


extern float floorf (float __x) throw () __attribute__ ((__const__)); extern float __floorf (float __x) throw () __attribute__ ((__const__));


extern float fmodf (float __x, float __y) throw (); extern float __fmodf (float __x, float __y) throw ();
# 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinff (float __value) throw () __attribute__ ((__const__));




extern int finitef (float __value) throw () __attribute__ ((__const__));


extern float dremf (float __x, float __y) throw (); extern float __dremf (float __x, float __y) throw ();



extern float significandf (float __x) throw (); extern float __significandf (float __x) throw ();






extern float copysignf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) throw () __attribute__ ((__const__));




extern float nanf (const char *__tagb) throw () __attribute__ ((__const__)); extern float __nanf (const char *__tagb) throw () __attribute__ ((__const__));
# 211 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanf (float __value) throw () __attribute__ ((__const__));





extern float j0f (float) throw (); extern float __j0f (float) throw ();
extern float j1f (float) throw (); extern float __j1f (float) throw ();
extern float jnf (int, float) throw (); extern float __jnf (int, float) throw ();
extern float y0f (float) throw (); extern float __y0f (float) throw ();
extern float y1f (float) throw (); extern float __y1f (float) throw ();
extern float ynf (int, float) throw (); extern float __ynf (int, float) throw ();





extern float erff (float) throw (); extern float __erff (float) throw ();
extern float erfcf (float) throw (); extern float __erfcf (float) throw ();
extern float lgammaf (float) throw (); extern float __lgammaf (float) throw ();




extern float tgammaf (float) throw (); extern float __tgammaf (float) throw ();





extern float gammaf (float) throw (); extern float __gammaf (float) throw ();







extern float lgammaf_r (float, int *__signgamp) throw (); extern float __lgammaf_r (float, int *__signgamp) throw ();






extern float rintf (float __x) throw (); extern float __rintf (float __x) throw ();


extern float nextafterf (float __x, float __y) throw (); extern float __nextafterf (float __x, float __y) throw ();

extern float nexttowardf (float __x, long double __y) throw (); extern float __nexttowardf (float __x, long double __y) throw ();




extern float nextdownf (float __x) throw (); extern float __nextdownf (float __x) throw ();

extern float nextupf (float __x) throw (); extern float __nextupf (float __x) throw ();



extern float remainderf (float __x, float __y) throw (); extern float __remainderf (float __x, float __y) throw ();



extern float scalbnf (float __x, int __n) throw (); extern float __scalbnf (float __x, int __n) throw ();



extern int ilogbf (float __x) throw (); extern int __ilogbf (float __x) throw ();




extern long int llogbf (float __x) throw (); extern long int __llogbf (float __x) throw ();




extern float scalblnf (float __x, long int __n) throw (); extern float __scalblnf (float __x, long int __n) throw ();



extern float nearbyintf (float __x) throw (); extern float __nearbyintf (float __x) throw ();



extern float roundf (float __x) throw () __attribute__ ((__const__)); extern float __roundf (float __x) throw () __attribute__ ((__const__));



extern float truncf (float __x) throw () __attribute__ ((__const__)); extern float __truncf (float __x) throw () __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) throw (); extern float __remquof (float __x, float __y, int *__quo) throw ();






extern long int lrintf (float __x) throw (); extern long int __lrintf (float __x) throw ();
__extension__
extern long long int llrintf (float __x) throw (); extern long long int __llrintf (float __x) throw ();



extern long int lroundf (float __x) throw (); extern long int __lroundf (float __x) throw ();
__extension__
extern long long int llroundf (float __x) throw (); extern long long int __llroundf (float __x) throw ();



extern float fdimf (float __x, float __y) throw (); extern float __fdimf (float __x, float __y) throw ();


extern float fmaxf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fminf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fminf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fmaf (float __x, float __y, float __z) throw (); extern float __fmaf (float __x, float __y, float __z) throw ();




extern float roundevenf (float __x) throw () __attribute__ ((__const__)); extern float __roundevenf (float __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf (float __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf (float __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf (float __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf (float __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf (float __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf (float __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf (float __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf (float __x, int __round, unsigned int __width) throw ()
                               ;


extern float fmaxmagf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fmaxmagf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fminmagf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fminmagf (float __x, float __y) throw () __attribute__ ((__const__));


extern int totalorderf (float __x, float __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf (float __x, float __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef (float *__cx, const float *__x) throw ();


extern float getpayloadf (const float *__x) throw (); extern float __getpayloadf (const float *__x) throw ();


extern int setpayloadf (float *__x, float __payload) throw ();


extern int setpayloadsigf (float *__x, float __payload) throw ();







extern float scalbf (float __x, float __n) throw (); extern float __scalbf (float __x, float __n) throw ();
# 308 "/usr/include/math.h" 2 3 4
# 349 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyl (long double __value) throw ()
     __attribute__ ((__const__));


extern int __signbitl (long double __value) throw ()
     __attribute__ ((__const__));



extern int __isinfl (long double __value) throw () __attribute__ ((__const__));


extern int __finitel (long double __value) throw () __attribute__ ((__const__));


extern int __isnanl (long double __value) throw () __attribute__ ((__const__));


extern int __iseqsigl (long double __x, long double __y) throw ();


extern int __issignalingl (long double __value) throw ()
     __attribute__ ((__const__));
# 350 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern long double acosl (long double __x) throw (); extern long double __acosl (long double __x) throw ();

extern long double asinl (long double __x) throw (); extern long double __asinl (long double __x) throw ();

extern long double atanl (long double __x) throw (); extern long double __atanl (long double __x) throw ();

extern long double atan2l (long double __y, long double __x) throw (); extern long double __atan2l (long double __y, long double __x) throw ();


 extern long double cosl (long double __x) throw (); extern long double __cosl (long double __x) throw ();

 extern long double sinl (long double __x) throw (); extern long double __sinl (long double __x) throw ();

extern long double tanl (long double __x) throw (); extern long double __tanl (long double __x) throw ();




extern long double coshl (long double __x) throw (); extern long double __coshl (long double __x) throw ();

extern long double sinhl (long double __x) throw (); extern long double __sinhl (long double __x) throw ();

extern long double tanhl (long double __x) throw (); extern long double __tanhl (long double __x) throw ();



 extern void sincosl (long double __x, long double *__sinx, long double *__cosx) throw (); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) throw ()
                                                        ;




extern long double acoshl (long double __x) throw (); extern long double __acoshl (long double __x) throw ();

extern long double asinhl (long double __x) throw (); extern long double __asinhl (long double __x) throw ();

extern long double atanhl (long double __x) throw (); extern long double __atanhl (long double __x) throw ();





 extern long double expl (long double __x) throw (); extern long double __expl (long double __x) throw ();


extern long double frexpl (long double __x, int *__exponent) throw (); extern long double __frexpl (long double __x, int *__exponent) throw ();


extern long double ldexpl (long double __x, int __exponent) throw (); extern long double __ldexpl (long double __x, int __exponent) throw ();


 extern long double logl (long double __x) throw (); extern long double __logl (long double __x) throw ();


extern long double log10l (long double __x) throw (); extern long double __log10l (long double __x) throw ();


extern long double modfl (long double __x, long double *__iptr) throw (); extern long double __modfl (long double __x, long double *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern long double exp10l (long double __x) throw (); extern long double __exp10l (long double __x) throw ();




extern long double expm1l (long double __x) throw (); extern long double __expm1l (long double __x) throw ();


extern long double log1pl (long double __x) throw (); extern long double __log1pl (long double __x) throw ();


extern long double logbl (long double __x) throw (); extern long double __logbl (long double __x) throw ();




extern long double exp2l (long double __x) throw (); extern long double __exp2l (long double __x) throw ();


extern long double log2l (long double __x) throw (); extern long double __log2l (long double __x) throw ();






 extern long double powl (long double __x, long double __y) throw (); extern long double __powl (long double __x, long double __y) throw ();


extern long double sqrtl (long double __x) throw (); extern long double __sqrtl (long double __x) throw ();



extern long double hypotl (long double __x, long double __y) throw (); extern long double __hypotl (long double __x, long double __y) throw ();




extern long double cbrtl (long double __x) throw (); extern long double __cbrtl (long double __x) throw ();






extern long double ceill (long double __x) throw () __attribute__ ((__const__)); extern long double __ceill (long double __x) throw () __attribute__ ((__const__));


extern long double fabsl (long double __x) throw () __attribute__ ((__const__)); extern long double __fabsl (long double __x) throw () __attribute__ ((__const__));


extern long double floorl (long double __x) throw () __attribute__ ((__const__)); extern long double __floorl (long double __x) throw () __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) throw (); extern long double __fmodl (long double __x, long double __y) throw ();
# 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinfl (long double __value) throw () __attribute__ ((__const__));




extern int finitel (long double __value) throw () __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) throw (); extern long double __dreml (long double __x, long double __y) throw ();



extern long double significandl (long double __x) throw (); extern long double __significandl (long double __x) throw ();






extern long double copysignl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) throw () __attribute__ ((__const__));




extern long double nanl (const char *__tagb) throw () __attribute__ ((__const__)); extern long double __nanl (const char *__tagb) throw () __attribute__ ((__const__));
# 211 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanl (long double __value) throw () __attribute__ ((__const__));





extern long double j0l (long double) throw (); extern long double __j0l (long double) throw ();
extern long double j1l (long double) throw (); extern long double __j1l (long double) throw ();
extern long double jnl (int, long double) throw (); extern long double __jnl (int, long double) throw ();
extern long double y0l (long double) throw (); extern long double __y0l (long double) throw ();
extern long double y1l (long double) throw (); extern long double __y1l (long double) throw ();
extern long double ynl (int, long double) throw (); extern long double __ynl (int, long double) throw ();





extern long double erfl (long double) throw (); extern long double __erfl (long double) throw ();
extern long double erfcl (long double) throw (); extern long double __erfcl (long double) throw ();
extern long double lgammal (long double) throw (); extern long double __lgammal (long double) throw ();




extern long double tgammal (long double) throw (); extern long double __tgammal (long double) throw ();





extern long double gammal (long double) throw (); extern long double __gammal (long double) throw ();







extern long double lgammal_r (long double, int *__signgamp) throw (); extern long double __lgammal_r (long double, int *__signgamp) throw ();






extern long double rintl (long double __x) throw (); extern long double __rintl (long double __x) throw ();


extern long double nextafterl (long double __x, long double __y) throw (); extern long double __nextafterl (long double __x, long double __y) throw ();

extern long double nexttowardl (long double __x, long double __y) throw (); extern long double __nexttowardl (long double __x, long double __y) throw ();




extern long double nextdownl (long double __x) throw (); extern long double __nextdownl (long double __x) throw ();

extern long double nextupl (long double __x) throw (); extern long double __nextupl (long double __x) throw ();



extern long double remainderl (long double __x, long double __y) throw (); extern long double __remainderl (long double __x, long double __y) throw ();



extern long double scalbnl (long double __x, int __n) throw (); extern long double __scalbnl (long double __x, int __n) throw ();



extern int ilogbl (long double __x) throw (); extern int __ilogbl (long double __x) throw ();




extern long int llogbl (long double __x) throw (); extern long int __llogbl (long double __x) throw ();




extern long double scalblnl (long double __x, long int __n) throw (); extern long double __scalblnl (long double __x, long int __n) throw ();



extern long double nearbyintl (long double __x) throw (); extern long double __nearbyintl (long double __x) throw ();



extern long double roundl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundl (long double __x) throw () __attribute__ ((__const__));



extern long double truncl (long double __x) throw () __attribute__ ((__const__)); extern long double __truncl (long double __x) throw () __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) throw (); extern long double __remquol (long double __x, long double __y, int *__quo) throw ();






extern long int lrintl (long double __x) throw (); extern long int __lrintl (long double __x) throw ();
__extension__
extern long long int llrintl (long double __x) throw (); extern long long int __llrintl (long double __x) throw ();



extern long int lroundl (long double __x) throw (); extern long int __lroundl (long double __x) throw ();
__extension__
extern long long int llroundl (long double __x) throw (); extern long long int __llroundl (long double __x) throw ();



extern long double fdiml (long double __x, long double __y) throw (); extern long double __fdiml (long double __x, long double __y) throw ();


extern long double fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fmal (long double __x, long double __y, long double __z) throw (); extern long double __fmal (long double __x, long double __y, long double __z) throw ();




extern long double roundevenl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundevenl (long double __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpl (long double __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpl (long double __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpl (long double __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpl (long double __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxl (long double __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxl (long double __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxl (long double __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxl (long double __x, int __round, unsigned int __width) throw ()
                               ;


extern long double fmaxmagl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fmaxmagl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fminmagl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fminmagl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern int totalorderl (long double __x, long double __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagl (long double __x, long double __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizel (long double *__cx, const long double *__x) throw ();


extern long double getpayloadl (const long double *__x) throw (); extern long double __getpayloadl (const long double *__x) throw ();


extern int setpayloadl (long double *__x, long double __payload) throw ();


extern int setpayloadsigl (long double *__x, long double __payload) throw ();







extern long double scalbl (long double __x, long double __n) throw (); extern long double __scalbl (long double __x, long double __n) throw ();
# 351 "/usr/include/math.h" 2 3 4
# 389 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 acosf32 (_Float32 __x) throw (); extern _Float32 __acosf32 (_Float32 __x) throw ();

extern _Float32 asinf32 (_Float32 __x) throw (); extern _Float32 __asinf32 (_Float32 __x) throw ();

extern _Float32 atanf32 (_Float32 __x) throw (); extern _Float32 __atanf32 (_Float32 __x) throw ();

extern _Float32 atan2f32 (_Float32 __y, _Float32 __x) throw (); extern _Float32 __atan2f32 (_Float32 __y, _Float32 __x) throw ();


 extern _Float32 cosf32 (_Float32 __x) throw (); extern _Float32 __cosf32 (_Float32 __x) throw ();

 extern _Float32 sinf32 (_Float32 __x) throw (); extern _Float32 __sinf32 (_Float32 __x) throw ();

extern _Float32 tanf32 (_Float32 __x) throw (); extern _Float32 __tanf32 (_Float32 __x) throw ();




extern _Float32 coshf32 (_Float32 __x) throw (); extern _Float32 __coshf32 (_Float32 __x) throw ();

extern _Float32 sinhf32 (_Float32 __x) throw (); extern _Float32 __sinhf32 (_Float32 __x) throw ();

extern _Float32 tanhf32 (_Float32 __x) throw (); extern _Float32 __tanhf32 (_Float32 __x) throw ();



 extern void sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) throw (); extern void __sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) throw ()
                                                        ;




extern _Float32 acoshf32 (_Float32 __x) throw (); extern _Float32 __acoshf32 (_Float32 __x) throw ();

extern _Float32 asinhf32 (_Float32 __x) throw (); extern _Float32 __asinhf32 (_Float32 __x) throw ();

extern _Float32 atanhf32 (_Float32 __x) throw (); extern _Float32 __atanhf32 (_Float32 __x) throw ();





 extern _Float32 expf32 (_Float32 __x) throw (); extern _Float32 __expf32 (_Float32 __x) throw ();


extern _Float32 frexpf32 (_Float32 __x, int *__exponent) throw (); extern _Float32 __frexpf32 (_Float32 __x, int *__exponent) throw ();


extern _Float32 ldexpf32 (_Float32 __x, int __exponent) throw (); extern _Float32 __ldexpf32 (_Float32 __x, int __exponent) throw ();


 extern _Float32 logf32 (_Float32 __x) throw (); extern _Float32 __logf32 (_Float32 __x) throw ();


extern _Float32 log10f32 (_Float32 __x) throw (); extern _Float32 __log10f32 (_Float32 __x) throw ();


extern _Float32 modff32 (_Float32 __x, _Float32 *__iptr) throw (); extern _Float32 __modff32 (_Float32 __x, _Float32 *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float32 exp10f32 (_Float32 __x) throw (); extern _Float32 __exp10f32 (_Float32 __x) throw ();




extern _Float32 expm1f32 (_Float32 __x) throw (); extern _Float32 __expm1f32 (_Float32 __x) throw ();


extern _Float32 log1pf32 (_Float32 __x) throw (); extern _Float32 __log1pf32 (_Float32 __x) throw ();


extern _Float32 logbf32 (_Float32 __x) throw (); extern _Float32 __logbf32 (_Float32 __x) throw ();




extern _Float32 exp2f32 (_Float32 __x) throw (); extern _Float32 __exp2f32 (_Float32 __x) throw ();


extern _Float32 log2f32 (_Float32 __x) throw (); extern _Float32 __log2f32 (_Float32 __x) throw ();






 extern _Float32 powf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __powf32 (_Float32 __x, _Float32 __y) throw ();


extern _Float32 sqrtf32 (_Float32 __x) throw (); extern _Float32 __sqrtf32 (_Float32 __x) throw ();



extern _Float32 hypotf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __hypotf32 (_Float32 __x, _Float32 __y) throw ();




extern _Float32 cbrtf32 (_Float32 __x) throw (); extern _Float32 __cbrtf32 (_Float32 __x) throw ();






extern _Float32 ceilf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __ceilf32 (_Float32 __x) throw () __attribute__ ((__const__));


extern _Float32 fabsf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __fabsf32 (_Float32 __x) throw () __attribute__ ((__const__));


extern _Float32 floorf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __floorf32 (_Float32 __x) throw () __attribute__ ((__const__));


extern _Float32 fmodf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __fmodf32 (_Float32 __x, _Float32 __y) throw ();
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 copysignf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __copysignf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));




extern _Float32 nanf32 (const char *__tagb) throw () __attribute__ ((__const__)); extern _Float32 __nanf32 (const char *__tagb) throw () __attribute__ ((__const__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 j0f32 (_Float32) throw (); extern _Float32 __j0f32 (_Float32) throw ();
extern _Float32 j1f32 (_Float32) throw (); extern _Float32 __j1f32 (_Float32) throw ();
extern _Float32 jnf32 (int, _Float32) throw (); extern _Float32 __jnf32 (int, _Float32) throw ();
extern _Float32 y0f32 (_Float32) throw (); extern _Float32 __y0f32 (_Float32) throw ();
extern _Float32 y1f32 (_Float32) throw (); extern _Float32 __y1f32 (_Float32) throw ();
extern _Float32 ynf32 (int, _Float32) throw (); extern _Float32 __ynf32 (int, _Float32) throw ();





extern _Float32 erff32 (_Float32) throw (); extern _Float32 __erff32 (_Float32) throw ();
extern _Float32 erfcf32 (_Float32) throw (); extern _Float32 __erfcf32 (_Float32) throw ();
extern _Float32 lgammaf32 (_Float32) throw (); extern _Float32 __lgammaf32 (_Float32) throw ();




extern _Float32 tgammaf32 (_Float32) throw (); extern _Float32 __tgammaf32 (_Float32) throw ();
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 lgammaf32_r (_Float32, int *__signgamp) throw (); extern _Float32 __lgammaf32_r (_Float32, int *__signgamp) throw ();






extern _Float32 rintf32 (_Float32 __x) throw (); extern _Float32 __rintf32 (_Float32 __x) throw ();


extern _Float32 nextafterf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __nextafterf32 (_Float32 __x, _Float32 __y) throw ();






extern _Float32 nextdownf32 (_Float32 __x) throw (); extern _Float32 __nextdownf32 (_Float32 __x) throw ();

extern _Float32 nextupf32 (_Float32 __x) throw (); extern _Float32 __nextupf32 (_Float32 __x) throw ();



extern _Float32 remainderf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __remainderf32 (_Float32 __x, _Float32 __y) throw ();



extern _Float32 scalbnf32 (_Float32 __x, int __n) throw (); extern _Float32 __scalbnf32 (_Float32 __x, int __n) throw ();



extern int ilogbf32 (_Float32 __x) throw (); extern int __ilogbf32 (_Float32 __x) throw ();




extern long int llogbf32 (_Float32 __x) throw (); extern long int __llogbf32 (_Float32 __x) throw ();




extern _Float32 scalblnf32 (_Float32 __x, long int __n) throw (); extern _Float32 __scalblnf32 (_Float32 __x, long int __n) throw ();



extern _Float32 nearbyintf32 (_Float32 __x) throw (); extern _Float32 __nearbyintf32 (_Float32 __x) throw ();



extern _Float32 roundf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __roundf32 (_Float32 __x) throw () __attribute__ ((__const__));



extern _Float32 truncf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __truncf32 (_Float32 __x) throw () __attribute__ ((__const__));




extern _Float32 remquof32 (_Float32 __x, _Float32 __y, int *__quo) throw (); extern _Float32 __remquof32 (_Float32 __x, _Float32 __y, int *__quo) throw ();






extern long int lrintf32 (_Float32 __x) throw (); extern long int __lrintf32 (_Float32 __x) throw ();
__extension__
extern long long int llrintf32 (_Float32 __x) throw (); extern long long int __llrintf32 (_Float32 __x) throw ();



extern long int lroundf32 (_Float32 __x) throw (); extern long int __lroundf32 (_Float32 __x) throw ();
__extension__
extern long long int llroundf32 (_Float32 __x) throw (); extern long long int __llroundf32 (_Float32 __x) throw ();



extern _Float32 fdimf32 (_Float32 __x, _Float32 __y) throw (); extern _Float32 __fdimf32 (_Float32 __x, _Float32 __y) throw ();


extern _Float32 fmaxf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __fmaxf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));


extern _Float32 fminf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __fminf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));


extern _Float32 fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) throw (); extern _Float32 __fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) throw ();




extern _Float32 roundevenf32 (_Float32 __x) throw () __attribute__ ((__const__)); extern _Float32 __roundevenf32 (_Float32 __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf32 (_Float32 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf32 (_Float32 __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf32 (_Float32 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf32 (_Float32 __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf32 (_Float32 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf32 (_Float32 __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) throw ()
                               ;


extern _Float32 fmaxmagf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __fmaxmagf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));


extern _Float32 fminmagf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__)); extern _Float32 __fminmagf32 (_Float32 __x, _Float32 __y) throw () __attribute__ ((__const__));


extern int totalorderf32 (_Float32 __x, _Float32 __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf32 (_Float32 __x, _Float32 __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef32 (_Float32 *__cx, const _Float32 *__x) throw ();


extern _Float32 getpayloadf32 (const _Float32 *__x) throw (); extern _Float32 __getpayloadf32 (const _Float32 *__x) throw ();


extern int setpayloadf32 (_Float32 *__x, _Float32 __payload) throw ();


extern int setpayloadsigf32 (_Float32 *__x, _Float32 __payload) throw ();
# 390 "/usr/include/math.h" 2 3 4
# 406 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 acosf64 (_Float64 __x) throw (); extern _Float64 __acosf64 (_Float64 __x) throw ();

extern _Float64 asinf64 (_Float64 __x) throw (); extern _Float64 __asinf64 (_Float64 __x) throw ();

extern _Float64 atanf64 (_Float64 __x) throw (); extern _Float64 __atanf64 (_Float64 __x) throw ();

extern _Float64 atan2f64 (_Float64 __y, _Float64 __x) throw (); extern _Float64 __atan2f64 (_Float64 __y, _Float64 __x) throw ();


 extern _Float64 cosf64 (_Float64 __x) throw (); extern _Float64 __cosf64 (_Float64 __x) throw ();

 extern _Float64 sinf64 (_Float64 __x) throw (); extern _Float64 __sinf64 (_Float64 __x) throw ();

extern _Float64 tanf64 (_Float64 __x) throw (); extern _Float64 __tanf64 (_Float64 __x) throw ();




extern _Float64 coshf64 (_Float64 __x) throw (); extern _Float64 __coshf64 (_Float64 __x) throw ();

extern _Float64 sinhf64 (_Float64 __x) throw (); extern _Float64 __sinhf64 (_Float64 __x) throw ();

extern _Float64 tanhf64 (_Float64 __x) throw (); extern _Float64 __tanhf64 (_Float64 __x) throw ();



 extern void sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) throw (); extern void __sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) throw ()
                                                        ;




extern _Float64 acoshf64 (_Float64 __x) throw (); extern _Float64 __acoshf64 (_Float64 __x) throw ();

extern _Float64 asinhf64 (_Float64 __x) throw (); extern _Float64 __asinhf64 (_Float64 __x) throw ();

extern _Float64 atanhf64 (_Float64 __x) throw (); extern _Float64 __atanhf64 (_Float64 __x) throw ();





 extern _Float64 expf64 (_Float64 __x) throw (); extern _Float64 __expf64 (_Float64 __x) throw ();


extern _Float64 frexpf64 (_Float64 __x, int *__exponent) throw (); extern _Float64 __frexpf64 (_Float64 __x, int *__exponent) throw ();


extern _Float64 ldexpf64 (_Float64 __x, int __exponent) throw (); extern _Float64 __ldexpf64 (_Float64 __x, int __exponent) throw ();


 extern _Float64 logf64 (_Float64 __x) throw (); extern _Float64 __logf64 (_Float64 __x) throw ();


extern _Float64 log10f64 (_Float64 __x) throw (); extern _Float64 __log10f64 (_Float64 __x) throw ();


extern _Float64 modff64 (_Float64 __x, _Float64 *__iptr) throw (); extern _Float64 __modff64 (_Float64 __x, _Float64 *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float64 exp10f64 (_Float64 __x) throw (); extern _Float64 __exp10f64 (_Float64 __x) throw ();




extern _Float64 expm1f64 (_Float64 __x) throw (); extern _Float64 __expm1f64 (_Float64 __x) throw ();


extern _Float64 log1pf64 (_Float64 __x) throw (); extern _Float64 __log1pf64 (_Float64 __x) throw ();


extern _Float64 logbf64 (_Float64 __x) throw (); extern _Float64 __logbf64 (_Float64 __x) throw ();




extern _Float64 exp2f64 (_Float64 __x) throw (); extern _Float64 __exp2f64 (_Float64 __x) throw ();


extern _Float64 log2f64 (_Float64 __x) throw (); extern _Float64 __log2f64 (_Float64 __x) throw ();






 extern _Float64 powf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __powf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float64 sqrtf64 (_Float64 __x) throw (); extern _Float64 __sqrtf64 (_Float64 __x) throw ();



extern _Float64 hypotf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __hypotf64 (_Float64 __x, _Float64 __y) throw ();




extern _Float64 cbrtf64 (_Float64 __x) throw (); extern _Float64 __cbrtf64 (_Float64 __x) throw ();






extern _Float64 ceilf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __ceilf64 (_Float64 __x) throw () __attribute__ ((__const__));


extern _Float64 fabsf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __fabsf64 (_Float64 __x) throw () __attribute__ ((__const__));


extern _Float64 floorf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __floorf64 (_Float64 __x) throw () __attribute__ ((__const__));


extern _Float64 fmodf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __fmodf64 (_Float64 __x, _Float64 __y) throw ();
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 copysignf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __copysignf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));




extern _Float64 nanf64 (const char *__tagb) throw () __attribute__ ((__const__)); extern _Float64 __nanf64 (const char *__tagb) throw () __attribute__ ((__const__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 j0f64 (_Float64) throw (); extern _Float64 __j0f64 (_Float64) throw ();
extern _Float64 j1f64 (_Float64) throw (); extern _Float64 __j1f64 (_Float64) throw ();
extern _Float64 jnf64 (int, _Float64) throw (); extern _Float64 __jnf64 (int, _Float64) throw ();
extern _Float64 y0f64 (_Float64) throw (); extern _Float64 __y0f64 (_Float64) throw ();
extern _Float64 y1f64 (_Float64) throw (); extern _Float64 __y1f64 (_Float64) throw ();
extern _Float64 ynf64 (int, _Float64) throw (); extern _Float64 __ynf64 (int, _Float64) throw ();





extern _Float64 erff64 (_Float64) throw (); extern _Float64 __erff64 (_Float64) throw ();
extern _Float64 erfcf64 (_Float64) throw (); extern _Float64 __erfcf64 (_Float64) throw ();
extern _Float64 lgammaf64 (_Float64) throw (); extern _Float64 __lgammaf64 (_Float64) throw ();




extern _Float64 tgammaf64 (_Float64) throw (); extern _Float64 __tgammaf64 (_Float64) throw ();
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 lgammaf64_r (_Float64, int *__signgamp) throw (); extern _Float64 __lgammaf64_r (_Float64, int *__signgamp) throw ();






extern _Float64 rintf64 (_Float64 __x) throw (); extern _Float64 __rintf64 (_Float64 __x) throw ();


extern _Float64 nextafterf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __nextafterf64 (_Float64 __x, _Float64 __y) throw ();






extern _Float64 nextdownf64 (_Float64 __x) throw (); extern _Float64 __nextdownf64 (_Float64 __x) throw ();

extern _Float64 nextupf64 (_Float64 __x) throw (); extern _Float64 __nextupf64 (_Float64 __x) throw ();



extern _Float64 remainderf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __remainderf64 (_Float64 __x, _Float64 __y) throw ();



extern _Float64 scalbnf64 (_Float64 __x, int __n) throw (); extern _Float64 __scalbnf64 (_Float64 __x, int __n) throw ();



extern int ilogbf64 (_Float64 __x) throw (); extern int __ilogbf64 (_Float64 __x) throw ();




extern long int llogbf64 (_Float64 __x) throw (); extern long int __llogbf64 (_Float64 __x) throw ();




extern _Float64 scalblnf64 (_Float64 __x, long int __n) throw (); extern _Float64 __scalblnf64 (_Float64 __x, long int __n) throw ();



extern _Float64 nearbyintf64 (_Float64 __x) throw (); extern _Float64 __nearbyintf64 (_Float64 __x) throw ();



extern _Float64 roundf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __roundf64 (_Float64 __x) throw () __attribute__ ((__const__));



extern _Float64 truncf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __truncf64 (_Float64 __x) throw () __attribute__ ((__const__));




extern _Float64 remquof64 (_Float64 __x, _Float64 __y, int *__quo) throw (); extern _Float64 __remquof64 (_Float64 __x, _Float64 __y, int *__quo) throw ();






extern long int lrintf64 (_Float64 __x) throw (); extern long int __lrintf64 (_Float64 __x) throw ();
__extension__
extern long long int llrintf64 (_Float64 __x) throw (); extern long long int __llrintf64 (_Float64 __x) throw ();



extern long int lroundf64 (_Float64 __x) throw (); extern long int __lroundf64 (_Float64 __x) throw ();
__extension__
extern long long int llroundf64 (_Float64 __x) throw (); extern long long int __llroundf64 (_Float64 __x) throw ();



extern _Float64 fdimf64 (_Float64 __x, _Float64 __y) throw (); extern _Float64 __fdimf64 (_Float64 __x, _Float64 __y) throw ();


extern _Float64 fmaxf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __fmaxf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));


extern _Float64 fminf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __fminf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));


extern _Float64 fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) throw (); extern _Float64 __fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) throw ();




extern _Float64 roundevenf64 (_Float64 __x) throw () __attribute__ ((__const__)); extern _Float64 __roundevenf64 (_Float64 __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf64 (_Float64 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf64 (_Float64 __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf64 (_Float64 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf64 (_Float64 __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf64 (_Float64 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf64 (_Float64 __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) throw ()
                               ;


extern _Float64 fmaxmagf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __fmaxmagf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));


extern _Float64 fminmagf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__)); extern _Float64 __fminmagf64 (_Float64 __x, _Float64 __y) throw () __attribute__ ((__const__));


extern int totalorderf64 (_Float64 __x, _Float64 __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf64 (_Float64 __x, _Float64 __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef64 (_Float64 *__cx, const _Float64 *__x) throw ();


extern _Float64 getpayloadf64 (const _Float64 *__x) throw (); extern _Float64 __getpayloadf64 (const _Float64 *__x) throw ();


extern int setpayloadf64 (_Float64 *__x, _Float64 __payload) throw ();


extern int setpayloadsigf64 (_Float64 *__x, _Float64 __payload) throw ();
# 407 "/usr/include/math.h" 2 3 4
# 420 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf128 (_Float128 __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf128 (_Float128 __value) throw ()
     __attribute__ ((__const__));



extern int __isinff128 (_Float128 __value) throw () __attribute__ ((__const__));


extern int __finitef128 (_Float128 __value) throw () __attribute__ ((__const__));


extern int __isnanf128 (_Float128 __value) throw () __attribute__ ((__const__));


extern int __iseqsigf128 (_Float128 __x, _Float128 __y) throw ();


extern int __issignalingf128 (_Float128 __value) throw ()
     __attribute__ ((__const__));
# 421 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 acosf128 (_Float128 __x) throw (); extern _Float128 __acosf128 (_Float128 __x) throw ();

extern _Float128 asinf128 (_Float128 __x) throw (); extern _Float128 __asinf128 (_Float128 __x) throw ();

extern _Float128 atanf128 (_Float128 __x) throw (); extern _Float128 __atanf128 (_Float128 __x) throw ();

extern _Float128 atan2f128 (_Float128 __y, _Float128 __x) throw (); extern _Float128 __atan2f128 (_Float128 __y, _Float128 __x) throw ();


 extern _Float128 cosf128 (_Float128 __x) throw (); extern _Float128 __cosf128 (_Float128 __x) throw ();

 extern _Float128 sinf128 (_Float128 __x) throw (); extern _Float128 __sinf128 (_Float128 __x) throw ();

extern _Float128 tanf128 (_Float128 __x) throw (); extern _Float128 __tanf128 (_Float128 __x) throw ();




extern _Float128 coshf128 (_Float128 __x) throw (); extern _Float128 __coshf128 (_Float128 __x) throw ();

extern _Float128 sinhf128 (_Float128 __x) throw (); extern _Float128 __sinhf128 (_Float128 __x) throw ();

extern _Float128 tanhf128 (_Float128 __x) throw (); extern _Float128 __tanhf128 (_Float128 __x) throw ();



 extern void sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) throw (); extern void __sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) throw ()
                                                        ;




extern _Float128 acoshf128 (_Float128 __x) throw (); extern _Float128 __acoshf128 (_Float128 __x) throw ();

extern _Float128 asinhf128 (_Float128 __x) throw (); extern _Float128 __asinhf128 (_Float128 __x) throw ();

extern _Float128 atanhf128 (_Float128 __x) throw (); extern _Float128 __atanhf128 (_Float128 __x) throw ();





 extern _Float128 expf128 (_Float128 __x) throw (); extern _Float128 __expf128 (_Float128 __x) throw ();


extern _Float128 frexpf128 (_Float128 __x, int *__exponent) throw (); extern _Float128 __frexpf128 (_Float128 __x, int *__exponent) throw ();


extern _Float128 ldexpf128 (_Float128 __x, int __exponent) throw (); extern _Float128 __ldexpf128 (_Float128 __x, int __exponent) throw ();


 extern _Float128 logf128 (_Float128 __x) throw (); extern _Float128 __logf128 (_Float128 __x) throw ();


extern _Float128 log10f128 (_Float128 __x) throw (); extern _Float128 __log10f128 (_Float128 __x) throw ();


extern _Float128 modff128 (_Float128 __x, _Float128 *__iptr) throw (); extern _Float128 __modff128 (_Float128 __x, _Float128 *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float128 exp10f128 (_Float128 __x) throw (); extern _Float128 __exp10f128 (_Float128 __x) throw ();




extern _Float128 expm1f128 (_Float128 __x) throw (); extern _Float128 __expm1f128 (_Float128 __x) throw ();


extern _Float128 log1pf128 (_Float128 __x) throw (); extern _Float128 __log1pf128 (_Float128 __x) throw ();


extern _Float128 logbf128 (_Float128 __x) throw (); extern _Float128 __logbf128 (_Float128 __x) throw ();




extern _Float128 exp2f128 (_Float128 __x) throw (); extern _Float128 __exp2f128 (_Float128 __x) throw ();


extern _Float128 log2f128 (_Float128 __x) throw (); extern _Float128 __log2f128 (_Float128 __x) throw ();






 extern _Float128 powf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __powf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float128 sqrtf128 (_Float128 __x) throw (); extern _Float128 __sqrtf128 (_Float128 __x) throw ();



extern _Float128 hypotf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __hypotf128 (_Float128 __x, _Float128 __y) throw ();




extern _Float128 cbrtf128 (_Float128 __x) throw (); extern _Float128 __cbrtf128 (_Float128 __x) throw ();






extern _Float128 ceilf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __ceilf128 (_Float128 __x) throw () __attribute__ ((__const__));


extern _Float128 fabsf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __fabsf128 (_Float128 __x) throw () __attribute__ ((__const__));


extern _Float128 floorf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __floorf128 (_Float128 __x) throw () __attribute__ ((__const__));


extern _Float128 fmodf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __fmodf128 (_Float128 __x, _Float128 __y) throw ();
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 copysignf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__)); extern _Float128 __copysignf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__));




extern _Float128 nanf128 (const char *__tagb) throw () __attribute__ ((__const__)); extern _Float128 __nanf128 (const char *__tagb) throw () __attribute__ ((__const__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 j0f128 (_Float128) throw (); extern _Float128 __j0f128 (_Float128) throw ();
extern _Float128 j1f128 (_Float128) throw (); extern _Float128 __j1f128 (_Float128) throw ();
extern _Float128 jnf128 (int, _Float128) throw (); extern _Float128 __jnf128 (int, _Float128) throw ();
extern _Float128 y0f128 (_Float128) throw (); extern _Float128 __y0f128 (_Float128) throw ();
extern _Float128 y1f128 (_Float128) throw (); extern _Float128 __y1f128 (_Float128) throw ();
extern _Float128 ynf128 (int, _Float128) throw (); extern _Float128 __ynf128 (int, _Float128) throw ();





extern _Float128 erff128 (_Float128) throw (); extern _Float128 __erff128 (_Float128) throw ();
extern _Float128 erfcf128 (_Float128) throw (); extern _Float128 __erfcf128 (_Float128) throw ();
extern _Float128 lgammaf128 (_Float128) throw (); extern _Float128 __lgammaf128 (_Float128) throw ();




extern _Float128 tgammaf128 (_Float128) throw (); extern _Float128 __tgammaf128 (_Float128) throw ();
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 lgammaf128_r (_Float128, int *__signgamp) throw (); extern _Float128 __lgammaf128_r (_Float128, int *__signgamp) throw ();






extern _Float128 rintf128 (_Float128 __x) throw (); extern _Float128 __rintf128 (_Float128 __x) throw ();


extern _Float128 nextafterf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __nextafterf128 (_Float128 __x, _Float128 __y) throw ();






extern _Float128 nextdownf128 (_Float128 __x) throw (); extern _Float128 __nextdownf128 (_Float128 __x) throw ();

extern _Float128 nextupf128 (_Float128 __x) throw (); extern _Float128 __nextupf128 (_Float128 __x) throw ();



extern _Float128 remainderf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __remainderf128 (_Float128 __x, _Float128 __y) throw ();



extern _Float128 scalbnf128 (_Float128 __x, int __n) throw (); extern _Float128 __scalbnf128 (_Float128 __x, int __n) throw ();



extern int ilogbf128 (_Float128 __x) throw (); extern int __ilogbf128 (_Float128 __x) throw ();




extern long int llogbf128 (_Float128 __x) throw (); extern long int __llogbf128 (_Float128 __x) throw ();




extern _Float128 scalblnf128 (_Float128 __x, long int __n) throw (); extern _Float128 __scalblnf128 (_Float128 __x, long int __n) throw ();



extern _Float128 nearbyintf128 (_Float128 __x) throw (); extern _Float128 __nearbyintf128 (_Float128 __x) throw ();



extern _Float128 roundf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __roundf128 (_Float128 __x) throw () __attribute__ ((__const__));



extern _Float128 truncf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __truncf128 (_Float128 __x) throw () __attribute__ ((__const__));




extern _Float128 remquof128 (_Float128 __x, _Float128 __y, int *__quo) throw (); extern _Float128 __remquof128 (_Float128 __x, _Float128 __y, int *__quo) throw ();






extern long int lrintf128 (_Float128 __x) throw (); extern long int __lrintf128 (_Float128 __x) throw ();
__extension__
extern long long int llrintf128 (_Float128 __x) throw (); extern long long int __llrintf128 (_Float128 __x) throw ();



extern long int lroundf128 (_Float128 __x) throw (); extern long int __lroundf128 (_Float128 __x) throw ();
__extension__
extern long long int llroundf128 (_Float128 __x) throw (); extern long long int __llroundf128 (_Float128 __x) throw ();



extern _Float128 fdimf128 (_Float128 __x, _Float128 __y) throw (); extern _Float128 __fdimf128 (_Float128 __x, _Float128 __y) throw ();


extern _Float128 fmaxf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__)); extern _Float128 __fmaxf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__));


extern _Float128 fminf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__)); extern _Float128 __fminf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__));


extern _Float128 fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) throw (); extern _Float128 __fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) throw ();




extern _Float128 roundevenf128 (_Float128 __x) throw () __attribute__ ((__const__)); extern _Float128 __roundevenf128 (_Float128 __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf128 (_Float128 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf128 (_Float128 __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf128 (_Float128 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf128 (_Float128 __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf128 (_Float128 __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf128 (_Float128 __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) throw ()
                               ;


extern _Float128 fmaxmagf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__)); extern _Float128 __fmaxmagf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__));


extern _Float128 fminmagf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__)); extern _Float128 __fminmagf128 (_Float128 __x, _Float128 __y) throw () __attribute__ ((__const__));


extern int totalorderf128 (_Float128 __x, _Float128 __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf128 (_Float128 __x, _Float128 __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef128 (_Float128 *__cx, const _Float128 *__x) throw ();


extern _Float128 getpayloadf128 (const _Float128 *__x) throw (); extern _Float128 __getpayloadf128 (const _Float128 *__x) throw ();


extern int setpayloadf128 (_Float128 *__x, _Float128 __payload) throw ();


extern int setpayloadsigf128 (_Float128 *__x, _Float128 __payload) throw ();
# 424 "/usr/include/math.h" 2 3 4
# 440 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x acosf32x (_Float32x __x) throw (); extern _Float32x __acosf32x (_Float32x __x) throw ();

extern _Float32x asinf32x (_Float32x __x) throw (); extern _Float32x __asinf32x (_Float32x __x) throw ();

extern _Float32x atanf32x (_Float32x __x) throw (); extern _Float32x __atanf32x (_Float32x __x) throw ();

extern _Float32x atan2f32x (_Float32x __y, _Float32x __x) throw (); extern _Float32x __atan2f32x (_Float32x __y, _Float32x __x) throw ();


 extern _Float32x cosf32x (_Float32x __x) throw (); extern _Float32x __cosf32x (_Float32x __x) throw ();

 extern _Float32x sinf32x (_Float32x __x) throw (); extern _Float32x __sinf32x (_Float32x __x) throw ();

extern _Float32x tanf32x (_Float32x __x) throw (); extern _Float32x __tanf32x (_Float32x __x) throw ();




extern _Float32x coshf32x (_Float32x __x) throw (); extern _Float32x __coshf32x (_Float32x __x) throw ();

extern _Float32x sinhf32x (_Float32x __x) throw (); extern _Float32x __sinhf32x (_Float32x __x) throw ();

extern _Float32x tanhf32x (_Float32x __x) throw (); extern _Float32x __tanhf32x (_Float32x __x) throw ();



 extern void sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) throw (); extern void __sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) throw ()
                                                        ;




extern _Float32x acoshf32x (_Float32x __x) throw (); extern _Float32x __acoshf32x (_Float32x __x) throw ();

extern _Float32x asinhf32x (_Float32x __x) throw (); extern _Float32x __asinhf32x (_Float32x __x) throw ();

extern _Float32x atanhf32x (_Float32x __x) throw (); extern _Float32x __atanhf32x (_Float32x __x) throw ();





 extern _Float32x expf32x (_Float32x __x) throw (); extern _Float32x __expf32x (_Float32x __x) throw ();


extern _Float32x frexpf32x (_Float32x __x, int *__exponent) throw (); extern _Float32x __frexpf32x (_Float32x __x, int *__exponent) throw ();


extern _Float32x ldexpf32x (_Float32x __x, int __exponent) throw (); extern _Float32x __ldexpf32x (_Float32x __x, int __exponent) throw ();


 extern _Float32x logf32x (_Float32x __x) throw (); extern _Float32x __logf32x (_Float32x __x) throw ();


extern _Float32x log10f32x (_Float32x __x) throw (); extern _Float32x __log10f32x (_Float32x __x) throw ();


extern _Float32x modff32x (_Float32x __x, _Float32x *__iptr) throw (); extern _Float32x __modff32x (_Float32x __x, _Float32x *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float32x exp10f32x (_Float32x __x) throw (); extern _Float32x __exp10f32x (_Float32x __x) throw ();




extern _Float32x expm1f32x (_Float32x __x) throw (); extern _Float32x __expm1f32x (_Float32x __x) throw ();


extern _Float32x log1pf32x (_Float32x __x) throw (); extern _Float32x __log1pf32x (_Float32x __x) throw ();


extern _Float32x logbf32x (_Float32x __x) throw (); extern _Float32x __logbf32x (_Float32x __x) throw ();




extern _Float32x exp2f32x (_Float32x __x) throw (); extern _Float32x __exp2f32x (_Float32x __x) throw ();


extern _Float32x log2f32x (_Float32x __x) throw (); extern _Float32x __log2f32x (_Float32x __x) throw ();






 extern _Float32x powf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __powf32x (_Float32x __x, _Float32x __y) throw ();


extern _Float32x sqrtf32x (_Float32x __x) throw (); extern _Float32x __sqrtf32x (_Float32x __x) throw ();



extern _Float32x hypotf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __hypotf32x (_Float32x __x, _Float32x __y) throw ();




extern _Float32x cbrtf32x (_Float32x __x) throw (); extern _Float32x __cbrtf32x (_Float32x __x) throw ();






extern _Float32x ceilf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __ceilf32x (_Float32x __x) throw () __attribute__ ((__const__));


extern _Float32x fabsf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __fabsf32x (_Float32x __x) throw () __attribute__ ((__const__));


extern _Float32x floorf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __floorf32x (_Float32x __x) throw () __attribute__ ((__const__));


extern _Float32x fmodf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __fmodf32x (_Float32x __x, _Float32x __y) throw ();
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x copysignf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __copysignf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));




extern _Float32x nanf32x (const char *__tagb) throw () __attribute__ ((__const__)); extern _Float32x __nanf32x (const char *__tagb) throw () __attribute__ ((__const__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x j0f32x (_Float32x) throw (); extern _Float32x __j0f32x (_Float32x) throw ();
extern _Float32x j1f32x (_Float32x) throw (); extern _Float32x __j1f32x (_Float32x) throw ();
extern _Float32x jnf32x (int, _Float32x) throw (); extern _Float32x __jnf32x (int, _Float32x) throw ();
extern _Float32x y0f32x (_Float32x) throw (); extern _Float32x __y0f32x (_Float32x) throw ();
extern _Float32x y1f32x (_Float32x) throw (); extern _Float32x __y1f32x (_Float32x) throw ();
extern _Float32x ynf32x (int, _Float32x) throw (); extern _Float32x __ynf32x (int, _Float32x) throw ();





extern _Float32x erff32x (_Float32x) throw (); extern _Float32x __erff32x (_Float32x) throw ();
extern _Float32x erfcf32x (_Float32x) throw (); extern _Float32x __erfcf32x (_Float32x) throw ();
extern _Float32x lgammaf32x (_Float32x) throw (); extern _Float32x __lgammaf32x (_Float32x) throw ();




extern _Float32x tgammaf32x (_Float32x) throw (); extern _Float32x __tgammaf32x (_Float32x) throw ();
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x lgammaf32x_r (_Float32x, int *__signgamp) throw (); extern _Float32x __lgammaf32x_r (_Float32x, int *__signgamp) throw ();






extern _Float32x rintf32x (_Float32x __x) throw (); extern _Float32x __rintf32x (_Float32x __x) throw ();


extern _Float32x nextafterf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __nextafterf32x (_Float32x __x, _Float32x __y) throw ();






extern _Float32x nextdownf32x (_Float32x __x) throw (); extern _Float32x __nextdownf32x (_Float32x __x) throw ();

extern _Float32x nextupf32x (_Float32x __x) throw (); extern _Float32x __nextupf32x (_Float32x __x) throw ();



extern _Float32x remainderf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __remainderf32x (_Float32x __x, _Float32x __y) throw ();



extern _Float32x scalbnf32x (_Float32x __x, int __n) throw (); extern _Float32x __scalbnf32x (_Float32x __x, int __n) throw ();



extern int ilogbf32x (_Float32x __x) throw (); extern int __ilogbf32x (_Float32x __x) throw ();




extern long int llogbf32x (_Float32x __x) throw (); extern long int __llogbf32x (_Float32x __x) throw ();




extern _Float32x scalblnf32x (_Float32x __x, long int __n) throw (); extern _Float32x __scalblnf32x (_Float32x __x, long int __n) throw ();



extern _Float32x nearbyintf32x (_Float32x __x) throw (); extern _Float32x __nearbyintf32x (_Float32x __x) throw ();



extern _Float32x roundf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __roundf32x (_Float32x __x) throw () __attribute__ ((__const__));



extern _Float32x truncf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __truncf32x (_Float32x __x) throw () __attribute__ ((__const__));




extern _Float32x remquof32x (_Float32x __x, _Float32x __y, int *__quo) throw (); extern _Float32x __remquof32x (_Float32x __x, _Float32x __y, int *__quo) throw ();






extern long int lrintf32x (_Float32x __x) throw (); extern long int __lrintf32x (_Float32x __x) throw ();
__extension__
extern long long int llrintf32x (_Float32x __x) throw (); extern long long int __llrintf32x (_Float32x __x) throw ();



extern long int lroundf32x (_Float32x __x) throw (); extern long int __lroundf32x (_Float32x __x) throw ();
__extension__
extern long long int llroundf32x (_Float32x __x) throw (); extern long long int __llroundf32x (_Float32x __x) throw ();



extern _Float32x fdimf32x (_Float32x __x, _Float32x __y) throw (); extern _Float32x __fdimf32x (_Float32x __x, _Float32x __y) throw ();


extern _Float32x fmaxf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __fmaxf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));


extern _Float32x fminf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __fminf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));


extern _Float32x fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) throw (); extern _Float32x __fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) throw ();




extern _Float32x roundevenf32x (_Float32x __x) throw () __attribute__ ((__const__)); extern _Float32x __roundevenf32x (_Float32x __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf32x (_Float32x __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf32x (_Float32x __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf32x (_Float32x __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf32x (_Float32x __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf32x (_Float32x __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf32x (_Float32x __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) throw ()
                               ;


extern _Float32x fmaxmagf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __fmaxmagf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));


extern _Float32x fminmagf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__)); extern _Float32x __fminmagf32x (_Float32x __x, _Float32x __y) throw () __attribute__ ((__const__));


extern int totalorderf32x (_Float32x __x, _Float32x __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf32x (_Float32x __x, _Float32x __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef32x (_Float32x *__cx, const _Float32x *__x) throw ();


extern _Float32x getpayloadf32x (const _Float32x *__x) throw (); extern _Float32x __getpayloadf32x (const _Float32x *__x) throw ();


extern int setpayloadf32x (_Float32x *__x, _Float32x __payload) throw ();


extern int setpayloadsigf32x (_Float32x *__x, _Float32x __payload) throw ();
# 441 "/usr/include/math.h" 2 3 4
# 457 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x acosf64x (_Float64x __x) throw (); extern _Float64x __acosf64x (_Float64x __x) throw ();

extern _Float64x asinf64x (_Float64x __x) throw (); extern _Float64x __asinf64x (_Float64x __x) throw ();

extern _Float64x atanf64x (_Float64x __x) throw (); extern _Float64x __atanf64x (_Float64x __x) throw ();

extern _Float64x atan2f64x (_Float64x __y, _Float64x __x) throw (); extern _Float64x __atan2f64x (_Float64x __y, _Float64x __x) throw ();


 extern _Float64x cosf64x (_Float64x __x) throw (); extern _Float64x __cosf64x (_Float64x __x) throw ();

 extern _Float64x sinf64x (_Float64x __x) throw (); extern _Float64x __sinf64x (_Float64x __x) throw ();

extern _Float64x tanf64x (_Float64x __x) throw (); extern _Float64x __tanf64x (_Float64x __x) throw ();




extern _Float64x coshf64x (_Float64x __x) throw (); extern _Float64x __coshf64x (_Float64x __x) throw ();

extern _Float64x sinhf64x (_Float64x __x) throw (); extern _Float64x __sinhf64x (_Float64x __x) throw ();

extern _Float64x tanhf64x (_Float64x __x) throw (); extern _Float64x __tanhf64x (_Float64x __x) throw ();



 extern void sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) throw (); extern void __sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) throw ()
                                                        ;




extern _Float64x acoshf64x (_Float64x __x) throw (); extern _Float64x __acoshf64x (_Float64x __x) throw ();

extern _Float64x asinhf64x (_Float64x __x) throw (); extern _Float64x __asinhf64x (_Float64x __x) throw ();

extern _Float64x atanhf64x (_Float64x __x) throw (); extern _Float64x __atanhf64x (_Float64x __x) throw ();





 extern _Float64x expf64x (_Float64x __x) throw (); extern _Float64x __expf64x (_Float64x __x) throw ();


extern _Float64x frexpf64x (_Float64x __x, int *__exponent) throw (); extern _Float64x __frexpf64x (_Float64x __x, int *__exponent) throw ();


extern _Float64x ldexpf64x (_Float64x __x, int __exponent) throw (); extern _Float64x __ldexpf64x (_Float64x __x, int __exponent) throw ();


 extern _Float64x logf64x (_Float64x __x) throw (); extern _Float64x __logf64x (_Float64x __x) throw ();


extern _Float64x log10f64x (_Float64x __x) throw (); extern _Float64x __log10f64x (_Float64x __x) throw ();


extern _Float64x modff64x (_Float64x __x, _Float64x *__iptr) throw (); extern _Float64x __modff64x (_Float64x __x, _Float64x *__iptr) throw () __attribute__ ((__nonnull__ (2)));



extern _Float64x exp10f64x (_Float64x __x) throw (); extern _Float64x __exp10f64x (_Float64x __x) throw ();




extern _Float64x expm1f64x (_Float64x __x) throw (); extern _Float64x __expm1f64x (_Float64x __x) throw ();


extern _Float64x log1pf64x (_Float64x __x) throw (); extern _Float64x __log1pf64x (_Float64x __x) throw ();


extern _Float64x logbf64x (_Float64x __x) throw (); extern _Float64x __logbf64x (_Float64x __x) throw ();




extern _Float64x exp2f64x (_Float64x __x) throw (); extern _Float64x __exp2f64x (_Float64x __x) throw ();


extern _Float64x log2f64x (_Float64x __x) throw (); extern _Float64x __log2f64x (_Float64x __x) throw ();






 extern _Float64x powf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __powf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float64x sqrtf64x (_Float64x __x) throw (); extern _Float64x __sqrtf64x (_Float64x __x) throw ();



extern _Float64x hypotf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __hypotf64x (_Float64x __x, _Float64x __y) throw ();




extern _Float64x cbrtf64x (_Float64x __x) throw (); extern _Float64x __cbrtf64x (_Float64x __x) throw ();






extern _Float64x ceilf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __ceilf64x (_Float64x __x) throw () __attribute__ ((__const__));


extern _Float64x fabsf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __fabsf64x (_Float64x __x) throw () __attribute__ ((__const__));


extern _Float64x floorf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __floorf64x (_Float64x __x) throw () __attribute__ ((__const__));


extern _Float64x fmodf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __fmodf64x (_Float64x __x, _Float64x __y) throw ();
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x copysignf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __copysignf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));




extern _Float64x nanf64x (const char *__tagb) throw () __attribute__ ((__const__)); extern _Float64x __nanf64x (const char *__tagb) throw () __attribute__ ((__const__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x j0f64x (_Float64x) throw (); extern _Float64x __j0f64x (_Float64x) throw ();
extern _Float64x j1f64x (_Float64x) throw (); extern _Float64x __j1f64x (_Float64x) throw ();
extern _Float64x jnf64x (int, _Float64x) throw (); extern _Float64x __jnf64x (int, _Float64x) throw ();
extern _Float64x y0f64x (_Float64x) throw (); extern _Float64x __y0f64x (_Float64x) throw ();
extern _Float64x y1f64x (_Float64x) throw (); extern _Float64x __y1f64x (_Float64x) throw ();
extern _Float64x ynf64x (int, _Float64x) throw (); extern _Float64x __ynf64x (int, _Float64x) throw ();





extern _Float64x erff64x (_Float64x) throw (); extern _Float64x __erff64x (_Float64x) throw ();
extern _Float64x erfcf64x (_Float64x) throw (); extern _Float64x __erfcf64x (_Float64x) throw ();
extern _Float64x lgammaf64x (_Float64x) throw (); extern _Float64x __lgammaf64x (_Float64x) throw ();




extern _Float64x tgammaf64x (_Float64x) throw (); extern _Float64x __tgammaf64x (_Float64x) throw ();
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x lgammaf64x_r (_Float64x, int *__signgamp) throw (); extern _Float64x __lgammaf64x_r (_Float64x, int *__signgamp) throw ();






extern _Float64x rintf64x (_Float64x __x) throw (); extern _Float64x __rintf64x (_Float64x __x) throw ();


extern _Float64x nextafterf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __nextafterf64x (_Float64x __x, _Float64x __y) throw ();






extern _Float64x nextdownf64x (_Float64x __x) throw (); extern _Float64x __nextdownf64x (_Float64x __x) throw ();

extern _Float64x nextupf64x (_Float64x __x) throw (); extern _Float64x __nextupf64x (_Float64x __x) throw ();



extern _Float64x remainderf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __remainderf64x (_Float64x __x, _Float64x __y) throw ();



extern _Float64x scalbnf64x (_Float64x __x, int __n) throw (); extern _Float64x __scalbnf64x (_Float64x __x, int __n) throw ();



extern int ilogbf64x (_Float64x __x) throw (); extern int __ilogbf64x (_Float64x __x) throw ();




extern long int llogbf64x (_Float64x __x) throw (); extern long int __llogbf64x (_Float64x __x) throw ();




extern _Float64x scalblnf64x (_Float64x __x, long int __n) throw (); extern _Float64x __scalblnf64x (_Float64x __x, long int __n) throw ();



extern _Float64x nearbyintf64x (_Float64x __x) throw (); extern _Float64x __nearbyintf64x (_Float64x __x) throw ();



extern _Float64x roundf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __roundf64x (_Float64x __x) throw () __attribute__ ((__const__));



extern _Float64x truncf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __truncf64x (_Float64x __x) throw () __attribute__ ((__const__));




extern _Float64x remquof64x (_Float64x __x, _Float64x __y, int *__quo) throw (); extern _Float64x __remquof64x (_Float64x __x, _Float64x __y, int *__quo) throw ();






extern long int lrintf64x (_Float64x __x) throw (); extern long int __lrintf64x (_Float64x __x) throw ();
__extension__
extern long long int llrintf64x (_Float64x __x) throw (); extern long long int __llrintf64x (_Float64x __x) throw ();



extern long int lroundf64x (_Float64x __x) throw (); extern long int __lroundf64x (_Float64x __x) throw ();
__extension__
extern long long int llroundf64x (_Float64x __x) throw (); extern long long int __llroundf64x (_Float64x __x) throw ();



extern _Float64x fdimf64x (_Float64x __x, _Float64x __y) throw (); extern _Float64x __fdimf64x (_Float64x __x, _Float64x __y) throw ();


extern _Float64x fmaxf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __fmaxf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));


extern _Float64x fminf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __fminf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));


extern _Float64x fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) throw (); extern _Float64x __fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) throw ();




extern _Float64x roundevenf64x (_Float64x __x) throw () __attribute__ ((__const__)); extern _Float64x __roundevenf64x (_Float64x __x) throw () __attribute__ ((__const__));



extern __intmax_t fromfpf64x (_Float64x __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpf64x (_Float64x __x, int __round, unsigned int __width) throw ()
                            ;



extern __uintmax_t ufromfpf64x (_Float64x __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpf64x (_Float64x __x, int __round, unsigned int __width) throw ()
                              ;




extern __intmax_t fromfpxf64x (_Float64x __x, int __round, unsigned int __width) throw (); extern __intmax_t __fromfpxf64x (_Float64x __x, int __round, unsigned int __width) throw ()
                             ;




extern __uintmax_t ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) throw (); extern __uintmax_t __ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) throw ()
                               ;


extern _Float64x fmaxmagf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __fmaxmagf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));


extern _Float64x fminmagf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__)); extern _Float64x __fminmagf64x (_Float64x __x, _Float64x __y) throw () __attribute__ ((__const__));


extern int totalorderf64x (_Float64x __x, _Float64x __y) throw ()
     __attribute__ ((__const__));


extern int totalordermagf64x (_Float64x __x, _Float64x __y) throw ()
     __attribute__ ((__const__));


extern int canonicalizef64x (_Float64x *__cx, const _Float64x *__x) throw ();


extern _Float64x getpayloadf64x (const _Float64x *__x) throw (); extern _Float64x __getpayloadf64x (const _Float64x *__x) throw ();


extern int setpayloadf64x (_Float64x *__x, _Float64x __payload) throw ();


extern int setpayloadsigf64x (_Float64x *__x, _Float64x __payload) throw ();
# 458 "/usr/include/math.h" 2 3 4
# 489 "/usr/include/math.h" 3 4
extern int signgam;
# 569 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 684 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 3 4
extern int __iscanonicall (long double __x)
     throw () __attribute__ ((__const__));
# 46 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 3 4
extern "C++" {
inline int iscanonical (float __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (double __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (long double __val) { return __iscanonicall (__val); }

inline int iscanonical (_Float128 __val) { return ((void) (__typeof (__val)) (__val), 1); }

}
# 685 "/usr/include/math.h" 2 3 4
# 696 "/usr/include/math.h" 3 4
extern "C++" {
inline int issignaling (float __val) { return __issignalingf (__val); }
inline int issignaling (double __val) { return __issignaling (__val); }
inline int
issignaling (long double __val)
{



  return __issignalingl (__val);

}

inline int issignaling (_Float128 __val) { return __issignalingf128 (__val); }

}
# 725 "/usr/include/math.h" 3 4
extern "C++" {
# 754 "/usr/include/math.h" 3 4
template <class __T> inline bool
iszero (__T __val)
{
  return __val == 0;
}

}
# 952 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathinline.h" 1 3 4
# 953 "/usr/include/math.h" 2 3 4
# 1205 "/usr/include/math.h" 3 4
extern "C++" {
template<typename> struct __iseqsig_type;

template<> struct __iseqsig_type<float>
{
  static int __call (float __x, float __y) throw ()
  {
    return __iseqsigf (__x, __y);
  }
};

template<> struct __iseqsig_type<double>
{
  static int __call (double __x, double __y) throw ()
  {
    return __iseqsig (__x, __y);
  }
};

template<> struct __iseqsig_type<long double>
{
  static int __call (double __x, double __y) throw ()
  {

    return __iseqsigl (__x, __y);



  }
};


template<> struct __iseqsig_type<_Float128>
{
  static int __call (_Float128 __x, _Float128 __y) throw ()
  {
    return __iseqsigf128 (__x, __y);
  }
};


template<typename _T1, typename _T2>
inline int
iseqsig (_T1 __x, _T2 __y) throw ()
{

  typedef decltype (((__x) + (__y) + 0.0f)) _T3;



  return __iseqsig_type<_T3>::__call (__x, __y);
}

}




}
# 46 "/usr/local/include/c++/10.0.0/cmath" 2 3
# 77 "/usr/local/include/c++/10.0.0/cmath" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::acos;


  inline constexpr float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline constexpr long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline constexpr float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline constexpr long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline constexpr float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline constexpr long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline constexpr float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline constexpr long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;


  inline constexpr float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline constexpr long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline constexpr float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline constexpr long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline constexpr float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline constexpr long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline constexpr float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline constexpr long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline constexpr float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline constexpr float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline constexpr long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline constexpr float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline constexpr long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline constexpr float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline constexpr long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline constexpr float
  log(float __x)
  { return __builtin_logf(__x); }

  inline constexpr long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline constexpr float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline constexpr long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline constexpr float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline constexpr long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
# 412 "/usr/local/include/c++/10.0.0/cmath" 3
  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;


  inline constexpr float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline constexpr long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline constexpr float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline constexpr long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline constexpr float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline constexpr long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline constexpr float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline constexpr long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline constexpr float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline constexpr long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }
# 536 "/usr/local/include/c++/10.0.0/cmath" 3
  constexpr int
  fpclassify(float __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(long double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              int>::__type
    fpclassify(_Tp __x)
    { return __x != 0 ? 4 : 2; }



  constexpr bool
  isfinite(float __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(double __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(long double __x)
  { return __builtin_isfinite(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isfinite(_Tp __x)
    { return true; }



  constexpr bool
  isinf(float __x)
  { return __builtin_isinf(__x); }





  constexpr bool
  isinf(double __x)
  { return __builtin_isinf(__x); }


  constexpr bool
  isinf(long double __x)
  { return __builtin_isinf(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isinf(_Tp __x)
    { return false; }



  constexpr bool
  isnan(float __x)
  { return __builtin_isnan(__x); }





  constexpr bool
  isnan(double __x)
  { return __builtin_isnan(__x); }


  constexpr bool
  isnan(long double __x)
  { return __builtin_isnan(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnan(_Tp __x)
    { return false; }



  constexpr bool
  isnormal(float __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(double __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(long double __x)
  { return __builtin_isnormal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnormal(_Tp __x)
    { return __x != 0 ? true : false; }




  constexpr bool
  signbit(float __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(double __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(long double __x)
  { return __builtin_signbit(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    signbit(_Tp __x)
    { return __x < 0 ? true : false; }



  constexpr bool
  isgreater(float __x, float __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(double __x, double __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(long double __x, long double __y)
  { return __builtin_isgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isgreaterequal(float __x, float __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(double __x, double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(long double __x, long double __y)
  { return __builtin_isgreaterequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreaterequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreaterequal(__type(__x), __type(__y));
    }



  constexpr bool
  isless(float __x, float __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(double __x, double __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(long double __x, long double __y)
  { return __builtin_isless(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isless(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isless(__type(__x), __type(__y));
    }



  constexpr bool
  islessequal(float __x, float __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(double __x, double __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(long double __x, long double __y)
  { return __builtin_islessequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessequal(__type(__x), __type(__y));
    }



  constexpr bool
  islessgreater(float __x, float __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(double __x, double __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(long double __x, long double __y)
  { return __builtin_islessgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isunordered(float __x, float __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(double __x, double __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(long double __x, long double __y)
  { return __builtin_isunordered(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isunordered(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isunordered(__type(__x), __type(__y));
    }
# 1065 "/usr/local/include/c++/10.0.0/cmath" 3
  using ::double_t;
  using ::float_t;


  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;


  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;


  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;



  constexpr float
  acosh(float __x)
  { return __builtin_acoshf(__x); }

  constexpr long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    acosh(_Tp __x)
    { return __builtin_acosh(__x); }



  constexpr float
  asinh(float __x)
  { return __builtin_asinhf(__x); }

  constexpr long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    asinh(_Tp __x)
    { return __builtin_asinh(__x); }



  constexpr float
  atanh(float __x)
  { return __builtin_atanhf(__x); }

  constexpr long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    atanh(_Tp __x)
    { return __builtin_atanh(__x); }



  constexpr float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }

  constexpr long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    cbrt(_Tp __x)
    { return __builtin_cbrt(__x); }



  constexpr float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }

  constexpr long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }



  constexpr float
  erf(float __x)
  { return __builtin_erff(__x); }

  constexpr long double
  erf(long double __x)
  { return __builtin_erfl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erf(_Tp __x)
    { return __builtin_erf(__x); }



  constexpr float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  constexpr long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erfc(_Tp __x)
    { return __builtin_erfc(__x); }



  constexpr float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  constexpr long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    exp2(_Tp __x)
    { return __builtin_exp2(__x); }



  constexpr float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  constexpr long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    expm1(_Tp __x)
    { return __builtin_expm1(__x); }



  constexpr float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  constexpr long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }



  constexpr float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  constexpr long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }



  template<typename _Tp, typename _Up, typename _Vp>
    constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }



  constexpr float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  constexpr long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }



  constexpr float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  constexpr long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }



  constexpr float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  constexpr long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }



  constexpr int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  constexpr int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }



  template<typename _Tp>
    constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    int>::__type
    ilogb(_Tp __x)
    { return __builtin_ilogb(__x); }



  constexpr float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  constexpr long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    lgamma(_Tp __x)
    { return __builtin_lgamma(__x); }



  constexpr long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  constexpr long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llrint(_Tp __x)
    { return __builtin_llrint(__x); }



  constexpr long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  constexpr long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llround(_Tp __x)
    { return __builtin_llround(__x); }



  constexpr float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  constexpr long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log1p(_Tp __x)
    { return __builtin_log1p(__x); }




  constexpr float
  log2(float __x)
  { return __builtin_log2f(__x); }

  constexpr long double
  log2(long double __x)
  { return __builtin_log2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log2(_Tp __x)
    { return __builtin_log2(__x); }



  constexpr float
  logb(float __x)
  { return __builtin_logbf(__x); }

  constexpr long double
  logb(long double __x)
  { return __builtin_logbl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    logb(_Tp __x)
    { return __builtin_logb(__x); }



  constexpr long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  constexpr long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lrint(_Tp __x)
    { return __builtin_lrint(__x); }



  constexpr long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  constexpr long
  lround(long double __x)
  { return __builtin_lroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lround(_Tp __x)
    { return __builtin_lround(__x); }



  constexpr float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  constexpr long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nearbyint(_Tp __x)
    { return __builtin_nearbyint(__x); }



  constexpr float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  constexpr long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }



  constexpr float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  constexpr long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nexttoward(_Tp __x, long double __y)
    { return __builtin_nexttoward(__x, __y); }



  constexpr float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  constexpr long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }



  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }



  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }



  constexpr float
  rint(float __x)
  { return __builtin_rintf(__x); }

  constexpr long double
  rint(long double __x)
  { return __builtin_rintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    rint(_Tp __x)
    { return __builtin_rint(__x); }



  constexpr float
  round(float __x)
  { return __builtin_roundf(__x); }

  constexpr long double
  round(long double __x)
  { return __builtin_roundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    round(_Tp __x)
    { return __builtin_round(__x); }



  constexpr float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  constexpr long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbln(_Tp __x, long __ex)
    { return __builtin_scalbln(__x, __ex); }



  constexpr float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  constexpr long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbn(_Tp __x, int __ex)
    { return __builtin_scalbn(__x, __ex); }



  constexpr float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  constexpr long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    tgamma(_Tp __x)
    { return __builtin_tgamma(__x); }



  constexpr float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  constexpr long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    trunc(_Tp __x)
    { return __builtin_trunc(__x); }
# 1852 "/usr/local/include/c++/10.0.0/cmath" 3
  template<typename _Tp>
    inline _Tp
    __hypot3(_Tp __x, _Tp __y, _Tp __z)
    {
      __x = std::abs(__x);
      __y = std::abs(__y);
      __z = std::abs(__z);
      if (_Tp __a = __x < __y ? __y < __z ? __z : __y : __x < __z ? __z : __x)
 return __a * std::sqrt((__x / __a) * (__x / __a)
          + (__y / __a) * (__y / __a)
          + (__z / __a) * (__z / __a));
      else
 return {};
    }

  inline float
  hypot(float __x, float __y, float __z)
  { return std::__hypot3<float>(__x, __y, __z); }

  inline double
  hypot(double __x, double __y, double __z)
  { return std::__hypot3<double>(__x, __y, __z); }

  inline long double
  hypot(long double __x, long double __y, long double __z)
  { return std::__hypot3<long double>(__x, __y, __z); }

  template<typename _Tp, typename _Up, typename _Vp>
    typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    hypot(_Tp __x, _Up __y, _Vp __z)
    {
      using __type = typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type;
      return std::__hypot3<__type>(__x, __y, __z);
    }






  template<typename _Fp>
    constexpr _Fp
    __lerp(_Fp __a, _Fp __b, _Fp __t) noexcept
    {
      if (__a <= 0 && __b >= 0 || __a >= 0 && __b <= 0)
 return __t * __b + (1 - __t) * __a;

      if (__t == 1)
 return __b;



      const _Fp __x = __a + __t * (__b - __a);
      return __t > 1 == __b > __a
 ? (__b < __x ? __x : __b)
 : (__b > __x ? __x : __b);
    }

  constexpr float
  lerp(float __a, float __b, float __t) noexcept
  { return std::__lerp(__a, __b, __t); }

  constexpr double
  lerp(double __a, double __b, double __t) noexcept
  { return std::__lerp(__a, __b, __t); }

  constexpr long double
  lerp(long double __a, long double __b, long double __t) noexcept
  { return std::__lerp(__a, __b, __t); }



}


# 1 "/usr/local/include/c++/10.0.0/bits/specfun.h" 1 3
# 33 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
#pragma GCC visibility push(default)
# 49 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
# 1 "/usr/local/include/c++/10.0.0/tr1/gamma.tcc" 1 3
# 49 "/usr/local/include/c++/10.0.0/tr1/gamma.tcc" 3
# 1 "/usr/local/include/c++/10.0.0/tr1/special_function_util.h" 1 3
# 39 "/usr/local/include/c++/10.0.0/tr1/special_function_util.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 50 "/usr/local/include/c++/10.0.0/tr1/special_function_util.h" 3
  namespace __detail
  {



    template<typename _Tp>
    struct __floating_point_constant
    {
      static const _Tp __value;
    };



    template<typename _Tp>
      struct __numeric_constants
      {

        static _Tp __pi() throw()
        { return static_cast<_Tp>(3.1415926535897932384626433832795029L); }

        static _Tp __pi_2() throw()
        { return static_cast<_Tp>(1.5707963267948966192313216916397514L); }

        static _Tp __pi_3() throw()
        { return static_cast<_Tp>(1.0471975511965977461542144610931676L); }

        static _Tp __pi_4() throw()
        { return static_cast<_Tp>(0.7853981633974483096156608458198757L); }

        static _Tp __1_pi() throw()
        { return static_cast<_Tp>(0.3183098861837906715377675267450287L); }

        static _Tp __2_sqrtpi() throw()
        { return static_cast<_Tp>(1.1283791670955125738961589031215452L); }

        static _Tp __sqrt2() throw()
        { return static_cast<_Tp>(1.4142135623730950488016887242096981L); }

        static _Tp __sqrt3() throw()
        { return static_cast<_Tp>(1.7320508075688772935274463415058723L); }

        static _Tp __sqrtpio2() throw()
        { return static_cast<_Tp>(1.2533141373155002512078826424055226L); }

        static _Tp __sqrt1_2() throw()
        { return static_cast<_Tp>(0.7071067811865475244008443621048490L); }

        static _Tp __lnpi() throw()
        { return static_cast<_Tp>(1.1447298858494001741434273513530587L); }

        static _Tp __gamma_e() throw()
        { return static_cast<_Tp>(0.5772156649015328606065120900824024L); }

        static _Tp __euler() throw()
        { return static_cast<_Tp>(2.7182818284590452353602874713526625L); }
      };
# 114 "/usr/local/include/c++/10.0.0/tr1/special_function_util.h" 3
    template<typename _Tp>
    inline bool __isnan(_Tp __x)
    { return std::isnan(__x); }
# 133 "/usr/local/include/c++/10.0.0/tr1/special_function_util.h" 3
  }





}
# 50 "/usr/local/include/c++/10.0.0/tr1/gamma.tcc" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 65 "/usr/local/include/c++/10.0.0/tr1/gamma.tcc" 3
  namespace __detail
  {
# 76 "/usr/local/include/c++/10.0.0/tr1/gamma.tcc" 3
    template <typename _Tp>
    _Tp
    __bernoulli_series(unsigned int __n)
    {

      static const _Tp __num[28] = {
        _Tp(1UL), -_Tp(1UL) / _Tp(2UL),
        _Tp(1UL) / _Tp(6UL), _Tp(0UL),
        -_Tp(1UL) / _Tp(30UL), _Tp(0UL),
        _Tp(1UL) / _Tp(42UL), _Tp(0UL),
        -_Tp(1UL) / _Tp(30UL), _Tp(0UL),
        _Tp(5UL) / _Tp(66UL), _Tp(0UL),
        -_Tp(691UL) / _Tp(2730UL), _Tp(0UL),
        _Tp(7UL) / _Tp(6UL), _Tp(0UL),
        -_Tp(3617UL) / _Tp(510UL), _Tp(0UL),
        _Tp(43867UL) / _Tp(798UL), _Tp(0UL),
        -_Tp(174611) / _Tp(330UL), _Tp(0UL),
        _Tp(854513UL) / _Tp(138UL), _Tp(0UL),
        -_Tp(236364091UL) / _Tp(2730UL), _Tp(0UL),
        _Tp(8553103UL) / _Tp(6UL), _Tp(0UL)
      };

      if (__n == 0)
        return _Tp(1);

      if (__n == 1)
        return -_Tp(1) / _Tp(2);


      if (__n % 2 == 1)
        return _Tp(0);


      if (__n < 28)
        return __num[__n];


      _Tp __fact = _Tp(1);
      if ((__n / 2) % 2 == 0)
        __fact *= _Tp(-1);
      for (unsigned int __k = 1; __k <= __n; ++__k)
        __fact *= __k / (_Tp(2) * __numeric_constants<_Tp>::__pi());
      __fact *= _Tp(2);

      _Tp __sum = _Tp(0);
      for (unsigned int __i = 1; __i < 1000; ++__i)
        {
          _Tp __term = std::pow(_Tp(__i), -_Tp(__n));
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term;
        }

      return __fact * __sum;
    }
# 139 "/usr/local/include/c++/10.0.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    inline _Tp
    __bernoulli(int __n)
    { return __bernoulli_series<_Tp>(__n); }
# 153 "/usr/local/include/c++/10.0.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_gamma_bernoulli(_Tp __x)
    {
      _Tp __lg = (__x - _Tp(0.5L)) * std::log(__x) - __x
               + _Tp(0.5L) * std::log(_Tp(2)
               * __numeric_constants<_Tp>::__pi());

      const _Tp __xx = __x * __x;
      _Tp __help = _Tp(1) / __x;
      for ( unsigned int __i = 1; __i < 20; ++__i )
        {
          const _Tp __2i = _Tp(2 * __i);
          __help /= __2i * (__2i - _Tp(1)) * __xx;
          __lg += __bernoulli<_Tp>(2 * __i) * __help;
        }

      return __lg;
    }
# 181 "/usr/local/include/c++/10.0.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_gamma_lanczos(_Tp __x)
    {
      const _Tp __xm1 = __x - _Tp(1);

      static const _Tp __lanczos_cheb_7[9] = {
       _Tp( 0.99999999999980993227684700473478L),
       _Tp( 676.520368121885098567009190444019L),
       _Tp(-1259.13921672240287047156078755283L),
       _Tp( 771.3234287776530788486528258894L),
       _Tp(-176.61502916214059906584551354L),
       _Tp( 12.507343278686904814458936853L),
       _Tp(-0.13857109526572011689554707L),
       _Tp( 9.984369578019570859563e-6L),
       _Tp( 1.50563273514931155834e-7L)
      };

      static const _Tp __LOGROOT2PI
          = _Tp(0.9189385332046727417803297364056176L);

      _Tp __sum = __lanczos_cheb_7[0];
      for(unsigned int __k = 1; __k < 9; ++__k)
        __sum += __lanczos_cheb_7[__k] / (__xm1 + __k);

      const _Tp __term1 = (__xm1 + _Tp(0.5L))
                        * std::log((__xm1 + _Tp(7.5L))
                       / __numeric_constants<_Tp>::__euler());
      const _Tp __term2 = __LOGROOT2PI + std::log(__sum);
      const _Tp __result = __term1 + (__term2 - _Tp(7));

      return __result;
    }
# 225 "/usr/local/include/c++/10.0.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_gamma(_Tp __x)
    {
      if (__x > _Tp(0.5L))
        return __log_gamma_lanczos(__x);
      else
        {
          const _Tp __sin_fact
                 = std::abs(std::sin(__numeric_constants<_Tp>::__pi() * __x));
          if (__sin_fact == _Tp(0))
            std::__throw_domain_error(("Argument is nonpositive integer " "in __log_gamma")
                                                           );
          return __numeric_constants<_Tp>::__lnpi()
                     - std::log(__sin_fact)
                     - __log_gamma_lanczos(_Tp(1) - __x);
        }
    }
# 252 "/usr/local/include/c++/10.0.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_gamma_sign(_Tp __x)
    {
      if (__x > _Tp(0))
        return _Tp(1);
      else
        {
          const _Tp __sin_fact
                  = std::sin(__numeric_constants<_Tp>::__pi() * __x);
          if (__sin_fact > _Tp(0))
            return (1);
          else if (__sin_fact < _Tp(0))
            return -_Tp(1);
          else
            return _Tp(0);
        }
    }
# 283 "/usr/local/include/c++/10.0.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_bincoef(unsigned int __n, unsigned int __k)
    {

      static const _Tp __max_bincoeff
                      = std::numeric_limits<_Tp>::max_exponent10
                      * std::log(_Tp(10)) - _Tp(1);

      _Tp __coeff = ::std::lgamma(_Tp(1 + __n))
                  - ::std::lgamma(_Tp(1 + __k))
                  - ::std::lgamma(_Tp(1 + __n - __k));





    }
# 314 "/usr/local/include/c++/10.0.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __bincoef(unsigned int __n, unsigned int __k)
    {

      static const _Tp __max_bincoeff
                      = std::numeric_limits<_Tp>::max_exponent10
                      * std::log(_Tp(10)) - _Tp(1);

      const _Tp __log_coeff = __log_bincoef<_Tp>(__n, __k);
      if (__log_coeff > __max_bincoeff)
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return std::exp(__log_coeff);
    }
# 337 "/usr/local/include/c++/10.0.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    inline _Tp
    __gamma(_Tp __x)
    { return std::exp(__log_gamma(__x)); }
# 356 "/usr/local/include/c++/10.0.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __psi_series(_Tp __x)
    {
      _Tp __sum = -__numeric_constants<_Tp>::__gamma_e() - _Tp(1) / __x;
      const unsigned int __max_iter = 100000;
      for (unsigned int __k = 1; __k < __max_iter; ++__k)
        {
          const _Tp __term = __x / (__k * (__k + __x));
          __sum += __term;
          if (std::abs(__term / __sum) < std::numeric_limits<_Tp>::epsilon())
            break;
        }
      return __sum;
    }
# 386 "/usr/local/include/c++/10.0.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __psi_asymp(_Tp __x)
    {
      _Tp __sum = std::log(__x) - _Tp(0.5L) / __x;
      const _Tp __xx = __x * __x;
      _Tp __xp = __xx;
      const unsigned int __max_iter = 100;
      for (unsigned int __k = 1; __k < __max_iter; ++__k)
        {
          const _Tp __term = __bernoulli<_Tp>(2 * __k) / (2 * __k * __xp);
          __sum -= __term;
          if (std::abs(__term / __sum) < std::numeric_limits<_Tp>::epsilon())
            break;
          __xp *= __xx;
        }
      return __sum;
    }
# 417 "/usr/local/include/c++/10.0.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __psi(_Tp __x)
    {
      const int __n = static_cast<int>(__x + 0.5L);
      const _Tp __eps = _Tp(4) * std::numeric_limits<_Tp>::epsilon();
      if (__n <= 0 && std::abs(__x - _Tp(__n)) < __eps)
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x < _Tp(0))
        {
          const _Tp __pi = __numeric_constants<_Tp>::__pi();
          return __psi(_Tp(1) - __x)
               - __pi * std::cos(__pi * __x) / std::sin(__pi * __x);
        }
      else if (__x > _Tp(100))
        return __psi_asymp(__x);
      else
        return __psi_series(__x);
    }
# 446 "/usr/local/include/c++/10.0.0/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __psi(unsigned int __n, _Tp __x)
    {
      if (__x <= _Tp(0))
        std::__throw_domain_error(("Argument out of range " "in __psi")
                                                 );
      else if (__n == 0)
        return __psi(__x);
      else
        {
          const _Tp __hzeta = __hurwitz_zeta(_Tp(__n + 1), __x);

          const _Tp __ln_nfact = ::std::lgamma(_Tp(__n + 1));



          _Tp __result = std::exp(__ln_nfact) * __hzeta;
          if (__n % 2 == 1)
            __result = -__result;
          return __result;
        }
    }
  }






}
# 50 "/usr/local/include/c++/10.0.0/bits/specfun.h" 2 3
# 1 "/usr/local/include/c++/10.0.0/tr1/bessel_function.tcc" 1 3
# 55 "/usr/local/include/c++/10.0.0/tr1/bessel_function.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 71 "/usr/local/include/c++/10.0.0/tr1/bessel_function.tcc" 3
  namespace __detail
  {
# 98 "/usr/local/include/c++/10.0.0/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    void
    __gamma_temme(_Tp __mu,
                  _Tp & __gam1, _Tp & __gam2, _Tp & __gampl, _Tp & __gammi)
    {

      __gampl = _Tp(1) / ::std::tgamma(_Tp(1) + __mu);
      __gammi = _Tp(1) / ::std::tgamma(_Tp(1) - __mu);





      if (std::abs(__mu) < std::numeric_limits<_Tp>::epsilon())
        __gam1 = -_Tp(__numeric_constants<_Tp>::__gamma_e());
      else
        __gam1 = (__gammi - __gampl) / (_Tp(2) * __mu);

      __gam2 = (__gammi + __gampl) / (_Tp(2));

      return;
    }
# 136 "/usr/local/include/c++/10.0.0/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    void
    __bessel_jn(_Tp __nu, _Tp __x,
                _Tp & __Jnu, _Tp & __Nnu, _Tp & __Jpnu, _Tp & __Npnu)
    {
      if (__x == _Tp(0))
        {
          if (__nu == _Tp(0))
            {
              __Jnu = _Tp(1);
              __Jpnu = _Tp(0);
            }
          else if (__nu == _Tp(1))
            {
              __Jnu = _Tp(0);
              __Jpnu = _Tp(0.5L);
            }
          else
            {
              __Jnu = _Tp(0);
              __Jpnu = _Tp(0);
            }
          __Nnu = -std::numeric_limits<_Tp>::infinity();
          __Npnu = std::numeric_limits<_Tp>::infinity();
          return;
        }

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();




      const _Tp __fp_min = std::sqrt(std::numeric_limits<_Tp>::min());
      const int __max_iter = 15000;
      const _Tp __x_min = _Tp(2);

      const int __nl = (__x < __x_min
                    ? static_cast<int>(__nu + _Tp(0.5L))
                    : std::max(0, static_cast<int>(__nu - __x + _Tp(1.5L))));

      const _Tp __mu = __nu - __nl;
      const _Tp __mu2 = __mu * __mu;
      const _Tp __xi = _Tp(1) / __x;
      const _Tp __xi2 = _Tp(2) * __xi;
      _Tp __w = __xi2 / __numeric_constants<_Tp>::__pi();
      int __isign = 1;
      _Tp __h = __nu * __xi;
      if (__h < __fp_min)
        __h = __fp_min;
      _Tp __b = __xi2 * __nu;
      _Tp __d = _Tp(0);
      _Tp __c = __h;
      int __i;
      for (__i = 1; __i <= __max_iter; ++__i)
        {
          __b += __xi2;
          __d = __b - __d;
          if (std::abs(__d) < __fp_min)
            __d = __fp_min;
          __c = __b - _Tp(1) / __c;
          if (std::abs(__c) < __fp_min)
            __c = __fp_min;
          __d = _Tp(1) / __d;
          const _Tp __del = __c * __d;
          __h *= __del;
          if (__d < _Tp(0))
            __isign = -__isign;
          if (std::abs(__del - _Tp(1)) < __eps)
            break;
        }
      if (__i > __max_iter)
        std::__throw_runtime_error(("Argument x too large in __bessel_jn; " "try asymptotic expansion.")
                                                                   );
      _Tp __Jnul = __isign * __fp_min;
      _Tp __Jpnul = __h * __Jnul;
      _Tp __Jnul1 = __Jnul;
      _Tp __Jpnu1 = __Jpnul;
      _Tp __fact = __nu * __xi;
      for ( int __l = __nl; __l >= 1; --__l )
        {
          const _Tp __Jnutemp = __fact * __Jnul + __Jpnul;
          __fact -= __xi;
          __Jpnul = __fact * __Jnutemp - __Jnul;
          __Jnul = __Jnutemp;
        }
      if (__Jnul == _Tp(0))
        __Jnul = __eps;
      _Tp __f= __Jpnul / __Jnul;
      _Tp __Nmu, __Nnu1, __Npmu, __Jmu;
      if (__x < __x_min)
        {
          const _Tp __x2 = __x / _Tp(2);
          const _Tp __pimu = __numeric_constants<_Tp>::__pi() * __mu;
          _Tp __fact = (std::abs(__pimu) < __eps
                      ? _Tp(1) : __pimu / std::sin(__pimu));
          _Tp __d = -std::log(__x2);
          _Tp __e = __mu * __d;
          _Tp __fact2 = (std::abs(__e) < __eps
                       ? _Tp(1) : std::sinh(__e) / __e);
          _Tp __gam1, __gam2, __gampl, __gammi;
          __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
          _Tp __ff = (_Tp(2) / __numeric_constants<_Tp>::__pi())
                   * __fact * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
          __e = std::exp(__e);
          _Tp __p = __e / (__numeric_constants<_Tp>::__pi() * __gampl);
          _Tp __q = _Tp(1) / (__e * __numeric_constants<_Tp>::__pi() * __gammi);
          const _Tp __pimu2 = __pimu / _Tp(2);
          _Tp __fact3 = (std::abs(__pimu2) < __eps
                       ? _Tp(1) : std::sin(__pimu2) / __pimu2 );
          _Tp __r = __numeric_constants<_Tp>::__pi() * __pimu2 * __fact3 * __fact3;
          _Tp __c = _Tp(1);
          __d = -__x2 * __x2;
          _Tp __sum = __ff + __r * __q;
          _Tp __sum1 = __p;
          for (__i = 1; __i <= __max_iter; ++__i)
            {
              __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
              __c *= __d / _Tp(__i);
              __p /= _Tp(__i) - __mu;
              __q /= _Tp(__i) + __mu;
              const _Tp __del = __c * (__ff + __r * __q);
              __sum += __del;
              const _Tp __del1 = __c * __p - __i * __del;
              __sum1 += __del1;
              if ( std::abs(__del) < __eps * (_Tp(1) + std::abs(__sum)) )
                break;
            }
          if ( __i > __max_iter )
            std::__throw_runtime_error(("Bessel y series failed to converge " "in __bessel_jn.")
                                                             );
          __Nmu = -__sum;
          __Nnu1 = -__sum1 * __xi2;
          __Npmu = __mu * __xi * __Nmu - __Nnu1;
          __Jmu = __w / (__Npmu - __f * __Nmu);
        }
      else
        {
          _Tp __a = _Tp(0.25L) - __mu2;
          _Tp __q = _Tp(1);
          _Tp __p = -__xi / _Tp(2);
          _Tp __br = _Tp(2) * __x;
          _Tp __bi = _Tp(2);
          _Tp __fact = __a * __xi / (__p * __p + __q * __q);
          _Tp __cr = __br + __q * __fact;
          _Tp __ci = __bi + __p * __fact;
          _Tp __den = __br * __br + __bi * __bi;
          _Tp __dr = __br / __den;
          _Tp __di = -__bi / __den;
          _Tp __dlr = __cr * __dr - __ci * __di;
          _Tp __dli = __cr * __di + __ci * __dr;
          _Tp __temp = __p * __dlr - __q * __dli;
          __q = __p * __dli + __q * __dlr;
          __p = __temp;
          int __i;
          for (__i = 2; __i <= __max_iter; ++__i)
            {
              __a += _Tp(2 * (__i - 1));
              __bi += _Tp(2);
              __dr = __a * __dr + __br;
              __di = __a * __di + __bi;
              if (std::abs(__dr) + std::abs(__di) < __fp_min)
                __dr = __fp_min;
              __fact = __a / (__cr * __cr + __ci * __ci);
              __cr = __br + __cr * __fact;
              __ci = __bi - __ci * __fact;
              if (std::abs(__cr) + std::abs(__ci) < __fp_min)
                __cr = __fp_min;
              __den = __dr * __dr + __di * __di;
              __dr /= __den;
              __di /= -__den;
              __dlr = __cr * __dr - __ci * __di;
              __dli = __cr * __di + __ci * __dr;
              __temp = __p * __dlr - __q * __dli;
              __q = __p * __dli + __q * __dlr;
              __p = __temp;
              if (std::abs(__dlr - _Tp(1)) + std::abs(__dli) < __eps)
                break;
          }
          if (__i > __max_iter)
            std::__throw_runtime_error(("Lentz's method failed " "in __bessel_jn.")
                                                             );
          const _Tp __gam = (__p - __f) / __q;
          __Jmu = std::sqrt(__w / ((__p - __f) * __gam + __q));

          __Jmu = ::std::copysign(__Jmu, __Jnul);




          __Nmu = __gam * __Jmu;
          __Npmu = (__p + __q / __gam) * __Nmu;
          __Nnu1 = __mu * __xi * __Nmu - __Npmu;
      }
      __fact = __Jmu / __Jnul;
      __Jnu = __fact * __Jnul1;
      __Jpnu = __fact * __Jpnu1;
      for (__i = 1; __i <= __nl; ++__i)
        {
          const _Tp __Nnutemp = (__mu + __i) * __xi2 * __Nnu1 - __Nmu;
          __Nmu = __Nnu1;
          __Nnu1 = __Nnutemp;
        }
      __Nnu = __Nmu;
      __Npnu = __nu * __xi * __Nmu - __Nnu1;

      return;
    }
# 361 "/usr/local/include/c++/10.0.0/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    void
    __cyl_bessel_jn_asymp(_Tp __nu, _Tp __x, _Tp & __Jnu, _Tp & __Nnu)
    {
      const _Tp __mu = _Tp(4) * __nu * __nu;
      const _Tp __8x = _Tp(8) * __x;

      _Tp __P = _Tp(0);
      _Tp __Q = _Tp(0);

      _Tp __k = _Tp(0);
      _Tp __term = _Tp(1);

      int __epsP = 0;
      int __epsQ = 0;

      _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      do
        {
          __term *= (__k == 0
                     ? _Tp(1)
                     : -(__mu - (2 * __k - 1) * (2 * __k - 1)) / (__k * __8x));

          __epsP = std::abs(__term) < __eps * std::abs(__P);
          __P += __term;

          __k++;

          __term *= (__mu - (2 * __k - 1) * (2 * __k - 1)) / (__k * __8x);
          __epsQ = std::abs(__term) < __eps * std::abs(__Q);
          __Q += __term;

          if (__epsP && __epsQ && __k > (__nu / 2.))
            break;

          __k++;
        }
      while (__k < 1000);

      const _Tp __chi = __x - (__nu + _Tp(0.5L))
                             * __numeric_constants<_Tp>::__pi_2();

      const _Tp __c = std::cos(__chi);
      const _Tp __s = std::sin(__chi);

      const _Tp __coef = std::sqrt(_Tp(2)
                             / (__numeric_constants<_Tp>::__pi() * __x));

      __Jnu = __coef * (__c * __P - __s * __Q);
      __Nnu = __coef * (__s * __P + __c * __Q);

      return;
    }
# 444 "/usr/local/include/c++/10.0.0/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    _Tp
    __cyl_bessel_ij_series(_Tp __nu, _Tp __x, _Tp __sgn,
                           unsigned int __max_iter)
    {
      if (__x == _Tp(0))
 return __nu == _Tp(0) ? _Tp(1) : _Tp(0);

      const _Tp __x2 = __x / _Tp(2);
      _Tp __fact = __nu * std::log(__x2);

      __fact -= ::std::lgamma(__nu + _Tp(1));



      __fact = std::exp(__fact);
      const _Tp __xx4 = __sgn * __x2 * __x2;
      _Tp __Jn = _Tp(1);
      _Tp __term = _Tp(1);

      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          __term *= __xx4 / (_Tp(__i) * (__nu + _Tp(__i)));
          __Jn += __term;
          if (std::abs(__term / __Jn) < std::numeric_limits<_Tp>::epsilon())
            break;
        }

      return __fact * __Jn;
    }
# 490 "/usr/local/include/c++/10.0.0/tr1/bessel_function.tcc" 3
    template<typename _Tp>
    _Tp
    __cyl_bessel_j(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_bessel_j.")
                                                           );
      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x * __x < _Tp(10) * (__nu + _Tp(1)))
        return __cyl_bessel_ij_series(__nu, __x, -_Tp(1), 200);
      else if (__x > _Tp(1000))
        {
          _Tp __J_nu, __N_nu;
          __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
          return __J_nu;
        }
      else
        {
          _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
          __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          return __J_nu;
        }
    }
# 532 "/usr/local/include/c++/10.0.0/tr1/bessel_function.tcc" 3
    template<typename _Tp>
    _Tp
    __cyl_neumann_n(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_neumann_n.")
                                                            );
      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x > _Tp(1000))
        {
          _Tp __J_nu, __N_nu;
          __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
          return __N_nu;
        }
      else
        {
          _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
          __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          return __N_nu;
        }
    }
# 569 "/usr/local/include/c++/10.0.0/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    void
    __sph_bessel_jn(unsigned int __n, _Tp __x,
                    _Tp & __j_n, _Tp & __n_n, _Tp & __jp_n, _Tp & __np_n)
    {
      const _Tp __nu = _Tp(__n) + _Tp(0.5L);

      _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
      __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);

      const _Tp __factor = __numeric_constants<_Tp>::__sqrtpio2()
                         / std::sqrt(__x);

      __j_n = __factor * __J_nu;
      __n_n = __factor * __N_nu;
      __jp_n = __factor * __Jp_nu - __j_n / (_Tp(2) * __x);
      __np_n = __factor * __Np_nu - __n_n / (_Tp(2) * __x);

      return;
    }
# 604 "/usr/local/include/c++/10.0.0/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    _Tp
    __sph_bessel(unsigned int __n, _Tp __x)
    {
      if (__x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __sph_bessel.")
                                                         );
      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x == _Tp(0))
        {
          if (__n == 0)
            return _Tp(1);
          else
            return _Tp(0);
        }
      else
        {
          _Tp __j_n, __n_n, __jp_n, __np_n;
          __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
          return __j_n;
        }
    }
# 642 "/usr/local/include/c++/10.0.0/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    _Tp
    __sph_neumann(unsigned int __n, _Tp __x)
    {
      if (__x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __sph_neumann.")
                                                          );
      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x == _Tp(0))
        return -std::numeric_limits<_Tp>::infinity();
      else
        {
          _Tp __j_n, __n_n, __jp_n, __np_n;
          __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
          return __n_n;
        }
    }
  }






}
# 51 "/usr/local/include/c++/10.0.0/bits/specfun.h" 2 3
# 1 "/usr/local/include/c++/10.0.0/tr1/beta_function.tcc" 1 3
# 49 "/usr/local/include/c++/10.0.0/tr1/beta_function.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 65 "/usr/local/include/c++/10.0.0/tr1/beta_function.tcc" 3
  namespace __detail
  {
# 79 "/usr/local/include/c++/10.0.0/tr1/beta_function.tcc" 3
    template<typename _Tp>
    _Tp
    __beta_gamma(_Tp __x, _Tp __y)
    {

      _Tp __bet;

      if (__x > __y)
        {
          __bet = ::std::tgamma(__x)
                / ::std::tgamma(__x + __y);
          __bet *= ::std::tgamma(__y);
        }
      else
        {
          __bet = ::std::tgamma(__y)
                / ::std::tgamma(__x + __y);
          __bet *= ::std::tgamma(__x);
        }
# 111 "/usr/local/include/c++/10.0.0/tr1/beta_function.tcc" 3
      return __bet;
    }
# 127 "/usr/local/include/c++/10.0.0/tr1/beta_function.tcc" 3
    template<typename _Tp>
    _Tp
    __beta_lgamma(_Tp __x, _Tp __y)
    {

      _Tp __bet = ::std::lgamma(__x)
                + ::std::lgamma(__y)
                - ::std::lgamma(__x + __y);





      __bet = std::exp(__bet);
      return __bet;
    }
# 158 "/usr/local/include/c++/10.0.0/tr1/beta_function.tcc" 3
    template<typename _Tp>
    _Tp
    __beta_product(_Tp __x, _Tp __y)
    {

      _Tp __bet = (__x + __y) / (__x * __y);

      unsigned int __max_iter = 1000000;
      for (unsigned int __k = 1; __k < __max_iter; ++__k)
        {
          _Tp __term = (_Tp(1) + (__x + __y) / __k)
                     / ((_Tp(1) + __x / __k) * (_Tp(1) + __y / __k));
          __bet *= __term;
        }

      return __bet;
    }
# 189 "/usr/local/include/c++/10.0.0/tr1/beta_function.tcc" 3
    template<typename _Tp>
    inline _Tp
    __beta(_Tp __x, _Tp __y)
    {
      if (__isnan(__x) || __isnan(__y))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __beta_lgamma(__x, __y);
    }
  }






}
# 52 "/usr/local/include/c++/10.0.0/bits/specfun.h" 2 3
# 1 "/usr/local/include/c++/10.0.0/tr1/ell_integral.tcc" 1 3
# 45 "/usr/local/include/c++/10.0.0/tr1/ell_integral.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 59 "/usr/local/include/c++/10.0.0/tr1/ell_integral.tcc" 3
  namespace __detail
  {
# 76 "/usr/local/include/c++/10.0.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_rf(_Tp __x, _Tp __y, _Tp __z)
    {
      const _Tp __min = std::numeric_limits<_Tp>::min();
      const _Tp __max = std::numeric_limits<_Tp>::max();
      const _Tp __lolim = _Tp(5) * __min;
      const _Tp __uplim = __max / _Tp(5);

      if (__x < _Tp(0) || __y < _Tp(0) || __z < _Tp(0))
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rf.")
                                                        );
      else if (__x + __y < __lolim || __x + __z < __lolim
            || __y + __z < __lolim)
        std::__throw_domain_error(("Argument too small in __ellint_rf"));
      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(1) / _Tp(24);
          const _Tp __c2 = _Tp(1) / _Tp(10);
          const _Tp __c3 = _Tp(3) / _Tp(44);
          const _Tp __c4 = _Tp(1) / _Tp(14);

          _Tp __xn = __x;
          _Tp __yn = __y;
          _Tp __zn = __z;

          const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
          const _Tp __errtol = std::pow(__eps, _Tp(1) / _Tp(6));
          _Tp __mu;
          _Tp __xndev, __yndev, __zndev;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + __yn + __zn) / _Tp(3);
              __xndev = 2 - (__mu + __xn) / __mu;
              __yndev = 2 - (__mu + __yn) / __mu;
              __zndev = 2 - (__mu + __zn) / __mu;
              _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
              __epsilon = std::max(__epsilon, std::abs(__zndev));
              if (__epsilon < __errtol)
                break;
              const _Tp __xnroot = std::sqrt(__xn);
              const _Tp __ynroot = std::sqrt(__yn);
              const _Tp __znroot = std::sqrt(__zn);
              const _Tp __lambda = __xnroot * (__ynroot + __znroot)
                                 + __ynroot * __znroot;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
              __zn = __c0 * (__zn + __lambda);
            }

          const _Tp __e2 = __xndev * __yndev - __zndev * __zndev;
          const _Tp __e3 = __xndev * __yndev * __zndev;
          const _Tp __s = _Tp(1) + (__c1 * __e2 - __c2 - __c3 * __e3) * __e2
                   + __c4 * __e3;

          return __s / std::sqrt(__mu);
        }
    }
# 155 "/usr/local/include/c++/10.0.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_1_series(_Tp __k)
    {

      const _Tp __kk = __k * __k;

      _Tp __term = __kk / _Tp(4);
      _Tp __sum = _Tp(1) + __term;

      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 2; __i < __max_iter; ++__i)
        {
          __term *= (2 * __i - 1) * __kk / (2 * __i);
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term;
        }

      return __numeric_constants<_Tp>::__pi_2() * __sum;
    }
# 193 "/usr/local/include/c++/10.0.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_1(_Tp __k)
    {

      if (__isnan(__k))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) >= _Tp(1))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __ellint_rf(_Tp(0), _Tp(1) - __k * __k, _Tp(1));
    }
# 221 "/usr/local/include/c++/10.0.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_1(_Tp __k, _Tp __phi)
    {

      if (__isnan(__k) || __isnan(__phi))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __ellint_1."));
      else
        {

          const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi()
                                   + _Tp(0.5L));
          const _Tp __phi_red = __phi
                              - __n * __numeric_constants<_Tp>::__pi();

          const _Tp __s = std::sin(__phi_red);
          const _Tp __c = std::cos(__phi_red);

          const _Tp __F = __s
                        * __ellint_rf(__c * __c,
                                _Tp(1) - __k * __k * __s * __s, _Tp(1));

          if (__n == 0)
            return __F;
          else
            return __F + _Tp(2) * __n * __comp_ellint_1(__k);
        }
    }
# 268 "/usr/local/include/c++/10.0.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_2_series(_Tp __k)
    {

      const _Tp __kk = __k * __k;

      _Tp __term = __kk;
      _Tp __sum = __term;

      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 2; __i < __max_iter; ++__i)
        {
          const _Tp __i2m = 2 * __i - 1;
          const _Tp __i2 = 2 * __i;
          __term *= __i2m * __i2m * __kk / (__i2 * __i2);
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term / __i2m;
        }

      return __numeric_constants<_Tp>::__pi_2() * (_Tp(1) - __sum);
    }
# 316 "/usr/local/include/c++/10.0.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_rd(_Tp __x, _Tp __y, _Tp __z)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __errtol = std::pow(__eps / _Tp(8), _Tp(1) / _Tp(6));
      const _Tp __min = std::numeric_limits<_Tp>::min();
      const _Tp __max = std::numeric_limits<_Tp>::max();
      const _Tp __lolim = _Tp(2) / std::pow(__max, _Tp(2) / _Tp(3));
      const _Tp __uplim = std::pow(_Tp(0.1L) * __errtol / __min, _Tp(2) / _Tp(3));

      if (__x < _Tp(0) || __y < _Tp(0))
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rd.")
                                                        );
      else if (__x + __y < __lolim || __z < __lolim)
        std::__throw_domain_error(("Argument too small " "in __ellint_rd.")
                                                        );
      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(3) / _Tp(14);
          const _Tp __c2 = _Tp(1) / _Tp(6);
          const _Tp __c3 = _Tp(9) / _Tp(22);
          const _Tp __c4 = _Tp(3) / _Tp(26);

          _Tp __xn = __x;
          _Tp __yn = __y;
          _Tp __zn = __z;
          _Tp __sigma = _Tp(0);
          _Tp __power4 = _Tp(1);

          _Tp __mu;
          _Tp __xndev, __yndev, __zndev;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + __yn + _Tp(3) * __zn) / _Tp(5);
              __xndev = (__mu - __xn) / __mu;
              __yndev = (__mu - __yn) / __mu;
              __zndev = (__mu - __zn) / __mu;
              _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
              __epsilon = std::max(__epsilon, std::abs(__zndev));
              if (__epsilon < __errtol)
                break;
              _Tp __xnroot = std::sqrt(__xn);
              _Tp __ynroot = std::sqrt(__yn);
              _Tp __znroot = std::sqrt(__zn);
              _Tp __lambda = __xnroot * (__ynroot + __znroot)
                           + __ynroot * __znroot;
              __sigma += __power4 / (__znroot * (__zn + __lambda));
              __power4 *= __c0;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
              __zn = __c0 * (__zn + __lambda);
            }

          _Tp __ea = __xndev * __yndev;
          _Tp __eb = __zndev * __zndev;
          _Tp __ec = __ea - __eb;
          _Tp __ed = __ea - _Tp(6) * __eb;
          _Tp __ef = __ed + __ec + __ec;
          _Tp __s1 = __ed * (-__c1 + __c3 * __ed
                                   / _Tp(3) - _Tp(3) * __c4 * __zndev * __ef
                                   / _Tp(2));
          _Tp __s2 = __zndev
                   * (__c2 * __ef
                    + __zndev * (-__c3 * __ec - __zndev * __c4 - __ea));

          return _Tp(3) * __sigma + __power4 * (_Tp(1) + __s1 + __s2)
                                        / (__mu * std::sqrt(__mu));
        }
    }
# 403 "/usr/local/include/c++/10.0.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_2(_Tp __k)
    {

      if (__isnan(__k))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) == 1)
        return _Tp(1);
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __comp_ellint_2."));
      else
        {
          const _Tp __kk = __k * __k;

          return __ellint_rf(_Tp(0), _Tp(1) - __kk, _Tp(1))
               - __kk * __ellint_rd(_Tp(0), _Tp(1) - __kk, _Tp(1)) / _Tp(3);
        }
    }
# 437 "/usr/local/include/c++/10.0.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_2(_Tp __k, _Tp __phi)
    {

      if (__isnan(__k) || __isnan(__phi))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __ellint_2."));
      else
        {

          const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi()
                                   + _Tp(0.5L));
          const _Tp __phi_red = __phi
                              - __n * __numeric_constants<_Tp>::__pi();

          const _Tp __kk = __k * __k;
          const _Tp __s = std::sin(__phi_red);
          const _Tp __ss = __s * __s;
          const _Tp __sss = __ss * __s;
          const _Tp __c = std::cos(__phi_red);
          const _Tp __cc = __c * __c;

          const _Tp __E = __s
                        * __ellint_rf(__cc, _Tp(1) - __kk * __ss, _Tp(1))
                        - __kk * __sss
                        * __ellint_rd(__cc, _Tp(1) - __kk * __ss, _Tp(1))
                        / _Tp(3);

          if (__n == 0)
            return __E;
          else
            return __E + _Tp(2) * __n * __comp_ellint_2(__k);
        }
    }
# 496 "/usr/local/include/c++/10.0.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_rc(_Tp __x, _Tp __y)
    {
      const _Tp __min = std::numeric_limits<_Tp>::min();
      const _Tp __max = std::numeric_limits<_Tp>::max();
      const _Tp __lolim = _Tp(5) * __min;
      const _Tp __uplim = __max / _Tp(5);

      if (__x < _Tp(0) || __y < _Tp(0) || __x + __y < __lolim)
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rc.")
                                                        );
      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(1) / _Tp(7);
          const _Tp __c2 = _Tp(9) / _Tp(22);
          const _Tp __c3 = _Tp(3) / _Tp(10);
          const _Tp __c4 = _Tp(3) / _Tp(8);

          _Tp __xn = __x;
          _Tp __yn = __y;

          const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
          const _Tp __errtol = std::pow(__eps / _Tp(30), _Tp(1) / _Tp(6));
          _Tp __mu;
          _Tp __sn;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + _Tp(2) * __yn) / _Tp(3);
              __sn = (__yn + __mu) / __mu - _Tp(2);
              if (std::abs(__sn) < __errtol)
                break;
              const _Tp __lambda = _Tp(2) * std::sqrt(__xn) * std::sqrt(__yn)
                             + __yn;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
            }

          _Tp __s = __sn * __sn
                  * (__c3 + __sn*(__c1 + __sn * (__c4 + __sn * __c2)));

          return (_Tp(1) + __s) / std::sqrt(__mu);
        }
    }
# 567 "/usr/local/include/c++/10.0.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_rj(_Tp __x, _Tp __y, _Tp __z, _Tp __p)
    {
      const _Tp __min = std::numeric_limits<_Tp>::min();
      const _Tp __max = std::numeric_limits<_Tp>::max();
      const _Tp __lolim = std::pow(_Tp(5) * __min, _Tp(1)/_Tp(3));
      const _Tp __uplim = _Tp(0.3L)
                        * std::pow(_Tp(0.2L) * __max, _Tp(1)/_Tp(3));

      if (__x < _Tp(0) || __y < _Tp(0) || __z < _Tp(0))
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rj.")
                                                        );
      else if (__x + __y < __lolim || __x + __z < __lolim
            || __y + __z < __lolim || __p < __lolim)
        std::__throw_domain_error(("Argument too small " "in __ellint_rj")
                                                       );
      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(3) / _Tp(14);
          const _Tp __c2 = _Tp(1) / _Tp(3);
          const _Tp __c3 = _Tp(3) / _Tp(22);
          const _Tp __c4 = _Tp(3) / _Tp(26);

          _Tp __xn = __x;
          _Tp __yn = __y;
          _Tp __zn = __z;
          _Tp __pn = __p;
          _Tp __sigma = _Tp(0);
          _Tp __power4 = _Tp(1);

          const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
          const _Tp __errtol = std::pow(__eps / _Tp(8), _Tp(1) / _Tp(6));

          _Tp __lambda, __mu;
          _Tp __xndev, __yndev, __zndev, __pndev;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + __yn + __zn + _Tp(2) * __pn) / _Tp(5);
              __xndev = (__mu - __xn) / __mu;
              __yndev = (__mu - __yn) / __mu;
              __zndev = (__mu - __zn) / __mu;
              __pndev = (__mu - __pn) / __mu;
              _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
              __epsilon = std::max(__epsilon, std::abs(__zndev));
              __epsilon = std::max(__epsilon, std::abs(__pndev));
              if (__epsilon < __errtol)
                break;
              const _Tp __xnroot = std::sqrt(__xn);
              const _Tp __ynroot = std::sqrt(__yn);
              const _Tp __znroot = std::sqrt(__zn);
              const _Tp __lambda = __xnroot * (__ynroot + __znroot)
                                 + __ynroot * __znroot;
              const _Tp __alpha1 = __pn * (__xnroot + __ynroot + __znroot)
                                + __xnroot * __ynroot * __znroot;
              const _Tp __alpha2 = __alpha1 * __alpha1;
              const _Tp __beta = __pn * (__pn + __lambda)
                                      * (__pn + __lambda);
              __sigma += __power4 * __ellint_rc(__alpha2, __beta);
              __power4 *= __c0;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
              __zn = __c0 * (__zn + __lambda);
              __pn = __c0 * (__pn + __lambda);
            }

          _Tp __ea = __xndev * (__yndev + __zndev) + __yndev * __zndev;
          _Tp __eb = __xndev * __yndev * __zndev;
          _Tp __ec = __pndev * __pndev;
          _Tp __e2 = __ea - _Tp(3) * __ec;
          _Tp __e3 = __eb + _Tp(2) * __pndev * (__ea - __ec);
          _Tp __s1 = _Tp(1) + __e2 * (-__c1 + _Tp(3) * __c3 * __e2 / _Tp(4)
                            - _Tp(3) * __c4 * __e3 / _Tp(2));
          _Tp __s2 = __eb * (__c2 / _Tp(2)
                   + __pndev * (-__c3 - __c3 + __pndev * __c4));
          _Tp __s3 = __pndev * __ea * (__c2 - __pndev * __c3)
                   - __c2 * __pndev * __ec;

          return _Tp(3) * __sigma + __power4 * (__s1 + __s2 + __s3)
                                             / (__mu * std::sqrt(__mu));
        }
    }
# 670 "/usr/local/include/c++/10.0.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_3(_Tp __k, _Tp __nu)
    {

      if (__isnan(__k) || __isnan(__nu))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__nu == _Tp(1))
        return std::numeric_limits<_Tp>::infinity();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __comp_ellint_3."));
      else
        {
          const _Tp __kk = __k * __k;

          return __ellint_rf(_Tp(0), _Tp(1) - __kk, _Tp(1))
               + __nu
               * __ellint_rj(_Tp(0), _Tp(1) - __kk, _Tp(1), _Tp(1) - __nu)
               / _Tp(3);
        }
    }
# 710 "/usr/local/include/c++/10.0.0/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_3(_Tp __k, _Tp __nu, _Tp __phi)
    {

      if (__isnan(__k) || __isnan(__nu) || __isnan(__phi))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __ellint_3."));
      else
        {

          const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi()
                                   + _Tp(0.5L));
          const _Tp __phi_red = __phi
                              - __n * __numeric_constants<_Tp>::__pi();

          const _Tp __kk = __k * __k;
          const _Tp __s = std::sin(__phi_red);
          const _Tp __ss = __s * __s;
          const _Tp __sss = __ss * __s;
          const _Tp __c = std::cos(__phi_red);
          const _Tp __cc = __c * __c;

          const _Tp __Pi = __s
                         * __ellint_rf(__cc, _Tp(1) - __kk * __ss, _Tp(1))
                         + __nu * __sss
                         * __ellint_rj(__cc, _Tp(1) - __kk * __ss, _Tp(1),
                                       _Tp(1) - __nu * __ss) / _Tp(3);

          if (__n == 0)
            return __Pi;
          else
            return __Pi + _Tp(2) * __n * __comp_ellint_3(__k, __nu);
        }
    }
  }





}
# 53 "/usr/local/include/c++/10.0.0/bits/specfun.h" 2 3
# 1 "/usr/local/include/c++/10.0.0/tr1/exp_integral.tcc" 1 3
# 50 "/usr/local/include/c++/10.0.0/tr1/exp_integral.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 64 "/usr/local/include/c++/10.0.0/tr1/exp_integral.tcc" 3
  namespace __detail
  {
    template<typename _Tp> _Tp __expint_E1(_Tp);
# 81 "/usr/local/include/c++/10.0.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_E1_series(_Tp __x)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      _Tp __term = _Tp(1);
      _Tp __esum = _Tp(0);
      _Tp __osum = _Tp(0);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          __term *= - __x / __i;
          if (std::abs(__term) < __eps)
            break;
          if (__term >= _Tp(0))
            __esum += __term / __i;
          else
            __osum += __term / __i;
        }

      return - __esum - __osum
             - __numeric_constants<_Tp>::__gamma_e() - std::log(__x);
    }
# 118 "/usr/local/include/c++/10.0.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_E1_asymp(_Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __esum = _Tp(1);
      _Tp __osum = _Tp(0);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          _Tp __prev = __term;
          __term *= - __i / __x;
          if (std::abs(__term) > std::abs(__prev))
            break;
          if (__term >= _Tp(0))
            __esum += __term;
          else
            __osum += __term;
        }

      return std::exp(- __x) * (__esum + __osum) / __x;
    }
# 155 "/usr/local/include/c++/10.0.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_En_series(unsigned int __n, _Tp __x)
    {
      const unsigned int __max_iter = 1000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const int __nm1 = __n - 1;
      _Tp __ans = (__nm1 != 0
                ? _Tp(1) / __nm1 : -std::log(__x)
                                   - __numeric_constants<_Tp>::__gamma_e());
      _Tp __fact = _Tp(1);
      for (int __i = 1; __i <= __max_iter; ++__i)
        {
          __fact *= -__x / _Tp(__i);
          _Tp __del;
          if ( __i != __nm1 )
            __del = -__fact / _Tp(__i - __nm1);
          else
            {
              _Tp __psi = -__numeric_constants<_Tp>::gamma_e();
              for (int __ii = 1; __ii <= __nm1; ++__ii)
                __psi += _Tp(1) / _Tp(__ii);
              __del = __fact * (__psi - std::log(__x));
            }
          __ans += __del;
          if (std::abs(__del) < __eps * std::abs(__ans))
            return __ans;
        }
      std::__throw_runtime_error(("Series summation failed " "in __expint_En_series.")
                                                              );
    }
# 201 "/usr/local/include/c++/10.0.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_En_cont_frac(unsigned int __n, _Tp __x)
    {
      const unsigned int __max_iter = 1000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __fp_min = std::numeric_limits<_Tp>::min();
      const int __nm1 = __n - 1;
      _Tp __b = __x + _Tp(__n);
      _Tp __c = _Tp(1) / __fp_min;
      _Tp __d = _Tp(1) / __b;
      _Tp __h = __d;
      for ( unsigned int __i = 1; __i <= __max_iter; ++__i )
        {
          _Tp __a = -_Tp(__i * (__nm1 + __i));
          __b += _Tp(2);
          __d = _Tp(1) / (__a * __d + __b);
          __c = __b + __a / __c;
          const _Tp __del = __c * __d;
          __h *= __del;
          if (std::abs(__del - _Tp(1)) < __eps)
            {
              const _Tp __ans = __h * std::exp(-__x);
              return __ans;
            }
        }
      std::__throw_runtime_error(("Continued fraction failed " "in __expint_En_cont_frac.")
                                                                 );
    }
# 246 "/usr/local/include/c++/10.0.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_En_recursion(unsigned int __n, _Tp __x)
    {
      _Tp __En;
      _Tp __E1 = __expint_E1(__x);
      if (__x < _Tp(__n))
        {

          __En = __E1;
          for (unsigned int __j = 2; __j < __n; ++__j)
            __En = (std::exp(-__x) - __x * __En) / _Tp(__j - 1);
        }
      else
        {

          __En = _Tp(1);
          const int __N = __n + 20;
          _Tp __save = _Tp(0);
          for (int __j = __N; __j > 0; --__j)
            {
              __En = (std::exp(-__x) - __j * __En) / __x;
              if (__j == __n)
                __save = __En;
            }
            _Tp __norm = __En / __E1;
            __En /= __norm;
        }

      return __En;
    }
# 290 "/usr/local/include/c++/10.0.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_Ei_series(_Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(0);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          __term *= __x / __i;
          __sum += __term / __i;
          if (__term < std::numeric_limits<_Tp>::epsilon() * __sum)
            break;
        }

      return __numeric_constants<_Tp>::__gamma_e() + __sum + std::log(__x);
    }
# 321 "/usr/local/include/c++/10.0.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_Ei_asymp(_Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(1);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          _Tp __prev = __term;
          __term *= __i / __x;
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          if (__term >= __prev)
            break;
          __sum += __term;
        }

      return std::exp(__x) * __sum / __x;
    }
# 354 "/usr/local/include/c++/10.0.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_Ei(_Tp __x)
    {
      if (__x < _Tp(0))
        return -__expint_E1(-__x);
      else if (__x < -std::log(std::numeric_limits<_Tp>::epsilon()))
        return __expint_Ei_series(__x);
      else
        return __expint_Ei_asymp(__x);
    }
# 378 "/usr/local/include/c++/10.0.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_E1(_Tp __x)
    {
      if (__x < _Tp(0))
        return -__expint_Ei(-__x);
      else if (__x < _Tp(1))
        return __expint_E1_series(__x);
      else if (__x < _Tp(100))
        return __expint_En_cont_frac(1, __x);
      else
        return __expint_E1_asymp(__x);
    }
# 408 "/usr/local/include/c++/10.0.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_asymp(unsigned int __n, _Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(1);
      for (unsigned int __i = 1; __i <= __n; ++__i)
        {
          _Tp __prev = __term;
          __term *= -(__n - __i + 1) / __x;
          if (std::abs(__term) > std::abs(__prev))
            break;
          __sum += __term;
        }

      return std::exp(-__x) * __sum / __x;
    }
# 442 "/usr/local/include/c++/10.0.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_large_n(unsigned int __n, _Tp __x)
    {
      const _Tp __xpn = __x + __n;
      const _Tp __xpn2 = __xpn * __xpn;
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(1);
      for (unsigned int __i = 1; __i <= __n; ++__i)
        {
          _Tp __prev = __term;
          __term *= (__n - 2 * (__i - 1) * __x) / __xpn2;
          if (std::abs(__term) < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term;
        }

      return std::exp(-__x) * __sum / __xpn;
    }
# 476 "/usr/local/include/c++/10.0.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint(unsigned int __n, _Tp __x)
    {

      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__n <= 1 && __x == _Tp(0))
        return std::numeric_limits<_Tp>::infinity();
      else
        {
          _Tp __E0 = std::exp(__x) / __x;
          if (__n == 0)
            return __E0;

          _Tp __E1 = __expint_E1(__x);
          if (__n == 1)
            return __E1;

          if (__x == _Tp(0))
            return _Tp(1) / static_cast<_Tp>(__n - 1);

          _Tp __En = __expint_En_recursion(__n, __x);

          return __En;
        }
    }
# 516 "/usr/local/include/c++/10.0.0/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    inline _Tp
    __expint(_Tp __x)
    {
      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __expint_Ei(__x);
    }
  }





}
# 54 "/usr/local/include/c++/10.0.0/bits/specfun.h" 2 3
# 1 "/usr/local/include/c++/10.0.0/tr1/hypergeometric.tcc" 1 3
# 44 "/usr/local/include/c++/10.0.0/tr1/hypergeometric.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 60 "/usr/local/include/c++/10.0.0/tr1/hypergeometric.tcc" 3
  namespace __detail
  {
# 83 "/usr/local/include/c++/10.0.0/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __conf_hyperg_series(_Tp __a, _Tp __c, _Tp __x)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      _Tp __term = _Tp(1);
      _Tp __Fac = _Tp(1);
      const unsigned int __max_iter = 100000;
      unsigned int __i;
      for (__i = 0; __i < __max_iter; ++__i)
        {
          __term *= (__a + _Tp(__i)) * __x
                  / ((__c + _Tp(__i)) * _Tp(1 + __i));
          if (std::abs(__term) < __eps)
            {
              break;
            }
          __Fac += __term;
        }
      if (__i == __max_iter)
        std::__throw_runtime_error(("Series failed to converge " "in __conf_hyperg_series.")
                                                                  );

      return __Fac;
    }
# 120 "/usr/local/include/c++/10.0.0/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __conf_hyperg_luke(_Tp __a, _Tp __c, _Tp __xin)
    {
      const _Tp __big = std::pow(std::numeric_limits<_Tp>::max(), _Tp(0.16L));
      const int __nmax = 20000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __x = -__xin;
      const _Tp __x3 = __x * __x * __x;
      const _Tp __t0 = __a / __c;
      const _Tp __t1 = (__a + _Tp(1)) / (_Tp(2) * __c);
      const _Tp __t2 = (__a + _Tp(2)) / (_Tp(2) * (__c + _Tp(1)));
      _Tp __F = _Tp(1);
      _Tp __prec;

      _Tp __Bnm3 = _Tp(1);
      _Tp __Bnm2 = _Tp(1) + __t1 * __x;
      _Tp __Bnm1 = _Tp(1) + __t2 * __x * (_Tp(1) + __t1 / _Tp(3) * __x);

      _Tp __Anm3 = _Tp(1);
      _Tp __Anm2 = __Bnm2 - __t0 * __x;
      _Tp __Anm1 = __Bnm1 - __t0 * (_Tp(1) + __t2 * __x) * __x
                 + __t0 * __t1 * (__c / (__c + _Tp(1))) * __x * __x;

      int __n = 3;
      while(1)
        {
          _Tp __npam1 = _Tp(__n - 1) + __a;
          _Tp __npcm1 = _Tp(__n - 1) + __c;
          _Tp __npam2 = _Tp(__n - 2) + __a;
          _Tp __npcm2 = _Tp(__n - 2) + __c;
          _Tp __tnm1 = _Tp(2 * __n - 1);
          _Tp __tnm3 = _Tp(2 * __n - 3);
          _Tp __tnm5 = _Tp(2 * __n - 5);
          _Tp __F1 = (_Tp(__n - 2) - __a) / (_Tp(2) * __tnm3 * __npcm1);
          _Tp __F2 = (_Tp(__n) + __a) * __npam1
                   / (_Tp(4) * __tnm1 * __tnm3 * __npcm2 * __npcm1);
          _Tp __F3 = -__npam2 * __npam1 * (_Tp(__n - 2) - __a)
                   / (_Tp(8) * __tnm3 * __tnm3 * __tnm5
                   * (_Tp(__n - 3) + __c) * __npcm2 * __npcm1);
          _Tp __E = -__npam1 * (_Tp(__n - 1) - __c)
                   / (_Tp(2) * __tnm3 * __npcm2 * __npcm1);

          _Tp __An = (_Tp(1) + __F1 * __x) * __Anm1
                   + (__E + __F2 * __x) * __x * __Anm2 + __F3 * __x3 * __Anm3;
          _Tp __Bn = (_Tp(1) + __F1 * __x) * __Bnm1
                   + (__E + __F2 * __x) * __x * __Bnm2 + __F3 * __x3 * __Bnm3;
          _Tp __r = __An / __Bn;

          __prec = std::abs((__F - __r) / __F);
          __F = __r;

          if (__prec < __eps || __n > __nmax)
            break;

          if (std::abs(__An) > __big || std::abs(__Bn) > __big)
            {
              __An /= __big;
              __Bn /= __big;
              __Anm1 /= __big;
              __Bnm1 /= __big;
              __Anm2 /= __big;
              __Bnm2 /= __big;
              __Anm3 /= __big;
              __Bnm3 /= __big;
            }
          else if (std::abs(__An) < _Tp(1) / __big
                || std::abs(__Bn) < _Tp(1) / __big)
            {
              __An *= __big;
              __Bn *= __big;
              __Anm1 *= __big;
              __Bnm1 *= __big;
              __Anm2 *= __big;
              __Bnm2 *= __big;
              __Anm3 *= __big;
              __Bnm3 *= __big;
            }

          ++__n;
          __Bnm3 = __Bnm2;
          __Bnm2 = __Bnm1;
          __Bnm1 = __Bn;
          __Anm3 = __Anm2;
          __Anm2 = __Anm1;
          __Anm1 = __An;
        }

      if (__n >= __nmax)
        std::__throw_runtime_error(("Iteration failed to converge " "in __conf_hyperg_luke.")
                                                                );

      return __F;
    }
# 227 "/usr/local/include/c++/10.0.0/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __conf_hyperg(_Tp __a, _Tp __c, _Tp __x)
    {

      const _Tp __c_nint = ::std::nearbyint(__c);



      if (__isnan(__a) || __isnan(__c) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__c_nint == __c && __c_nint <= 0)
        return std::numeric_limits<_Tp>::infinity();
      else if (__a == _Tp(0))
        return _Tp(1);
      else if (__c == __a)
        return std::exp(__x);
      else if (__x < _Tp(0))
        return __conf_hyperg_luke(__a, __c, __x);
      else
        return __conf_hyperg_series(__a, __c, __x);
    }
# 271 "/usr/local/include/c++/10.0.0/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __hyperg_series(_Tp __a, _Tp __b, _Tp __c, _Tp __x)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      _Tp __term = _Tp(1);
      _Tp __Fabc = _Tp(1);
      const unsigned int __max_iter = 100000;
      unsigned int __i;
      for (__i = 0; __i < __max_iter; ++__i)
        {
          __term *= (__a + _Tp(__i)) * (__b + _Tp(__i)) * __x
                  / ((__c + _Tp(__i)) * _Tp(1 + __i));
          if (std::abs(__term) < __eps)
            {
              break;
            }
          __Fabc += __term;
        }
      if (__i == __max_iter)
        std::__throw_runtime_error(("Series failed to converge " "in __hyperg_series.")
                                                             );

      return __Fabc;
    }







    template<typename _Tp>
    _Tp
    __hyperg_luke(_Tp __a, _Tp __b, _Tp __c, _Tp __xin)
    {
      const _Tp __big = std::pow(std::numeric_limits<_Tp>::max(), _Tp(0.16L));
      const int __nmax = 20000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __x = -__xin;
      const _Tp __x3 = __x * __x * __x;
      const _Tp __t0 = __a * __b / __c;
      const _Tp __t1 = (__a + _Tp(1)) * (__b + _Tp(1)) / (_Tp(2) * __c);
      const _Tp __t2 = (__a + _Tp(2)) * (__b + _Tp(2))
                     / (_Tp(2) * (__c + _Tp(1)));

      _Tp __F = _Tp(1);

      _Tp __Bnm3 = _Tp(1);
      _Tp __Bnm2 = _Tp(1) + __t1 * __x;
      _Tp __Bnm1 = _Tp(1) + __t2 * __x * (_Tp(1) + __t1 / _Tp(3) * __x);

      _Tp __Anm3 = _Tp(1);
      _Tp __Anm2 = __Bnm2 - __t0 * __x;
      _Tp __Anm1 = __Bnm1 - __t0 * (_Tp(1) + __t2 * __x) * __x
                 + __t0 * __t1 * (__c / (__c + _Tp(1))) * __x * __x;

      int __n = 3;
      while (1)
        {
          const _Tp __npam1 = _Tp(__n - 1) + __a;
          const _Tp __npbm1 = _Tp(__n - 1) + __b;
          const _Tp __npcm1 = _Tp(__n - 1) + __c;
          const _Tp __npam2 = _Tp(__n - 2) + __a;
          const _Tp __npbm2 = _Tp(__n - 2) + __b;
          const _Tp __npcm2 = _Tp(__n - 2) + __c;
          const _Tp __tnm1 = _Tp(2 * __n - 1);
          const _Tp __tnm3 = _Tp(2 * __n - 3);
          const _Tp __tnm5 = _Tp(2 * __n - 5);
          const _Tp __n2 = __n * __n;
          const _Tp __F1 = (_Tp(3) * __n2 + (__a + __b - _Tp(6)) * __n
                         + _Tp(2) - __a * __b - _Tp(2) * (__a + __b))
                         / (_Tp(2) * __tnm3 * __npcm1);
          const _Tp __F2 = -(_Tp(3) * __n2 - (__a + __b + _Tp(6)) * __n
                         + _Tp(2) - __a * __b) * __npam1 * __npbm1
                         / (_Tp(4) * __tnm1 * __tnm3 * __npcm2 * __npcm1);
          const _Tp __F3 = (__npam2 * __npam1 * __npbm2 * __npbm1
                         * (_Tp(__n - 2) - __a) * (_Tp(__n - 2) - __b))
                         / (_Tp(8) * __tnm3 * __tnm3 * __tnm5
                         * (_Tp(__n - 3) + __c) * __npcm2 * __npcm1);
          const _Tp __E = -__npam1 * __npbm1 * (_Tp(__n - 1) - __c)
                         / (_Tp(2) * __tnm3 * __npcm2 * __npcm1);

          _Tp __An = (_Tp(1) + __F1 * __x) * __Anm1
                   + (__E + __F2 * __x) * __x * __Anm2 + __F3 * __x3 * __Anm3;
          _Tp __Bn = (_Tp(1) + __F1 * __x) * __Bnm1
                   + (__E + __F2 * __x) * __x * __Bnm2 + __F3 * __x3 * __Bnm3;
          const _Tp __r = __An / __Bn;

          const _Tp __prec = std::abs((__F - __r) / __F);
          __F = __r;

          if (__prec < __eps || __n > __nmax)
            break;

          if (std::abs(__An) > __big || std::abs(__Bn) > __big)
            {
              __An /= __big;
              __Bn /= __big;
              __Anm1 /= __big;
              __Bnm1 /= __big;
              __Anm2 /= __big;
              __Bnm2 /= __big;
              __Anm3 /= __big;
              __Bnm3 /= __big;
            }
          else if (std::abs(__An) < _Tp(1) / __big
                || std::abs(__Bn) < _Tp(1) / __big)
            {
              __An *= __big;
              __Bn *= __big;
              __Anm1 *= __big;
              __Bnm1 *= __big;
              __Anm2 *= __big;
              __Bnm2 *= __big;
              __Anm3 *= __big;
              __Bnm3 *= __big;
            }

          ++__n;
          __Bnm3 = __Bnm2;
          __Bnm2 = __Bnm1;
          __Bnm1 = __Bn;
          __Anm3 = __Anm2;
          __Anm2 = __Anm1;
          __Anm1 = __An;
        }

      if (__n >= __nmax)
        std::__throw_runtime_error(("Iteration failed to converge " "in __hyperg_luke.")
                                                           );

      return __F;
    }
# 438 "/usr/local/include/c++/10.0.0/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __hyperg_reflect(_Tp __a, _Tp __b, _Tp __c, _Tp __x)
    {
      const _Tp __d = __c - __a - __b;
      const int __intd = std::floor(__d + _Tp(0.5L));
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __toler = _Tp(1000) * __eps;
      const _Tp __log_max = std::log(std::numeric_limits<_Tp>::max());
      const bool __d_integer = (std::abs(__d - __intd) < __toler);

      if (__d_integer)
        {
          const _Tp __ln_omx = std::log(_Tp(1) - __x);
          const _Tp __ad = std::abs(__d);
          _Tp __F1, __F2;

          _Tp __d1, __d2;
          if (__d >= _Tp(0))
            {
              __d1 = __d;
              __d2 = _Tp(0);
            }
          else
            {
              __d1 = _Tp(0);
              __d2 = __d;
            }

          const _Tp __lng_c = __log_gamma(__c);


          if (__ad < __eps)
            {

              __F1 = _Tp(0);
            }
          else
            {

              bool __ok_d1 = true;
              _Tp __lng_ad, __lng_ad1, __lng_bd1;
              try
                {
                  __lng_ad = __log_gamma(__ad);
                  __lng_ad1 = __log_gamma(__a + __d1);
                  __lng_bd1 = __log_gamma(__b + __d1);
                }
              catch(...)
                {
                  __ok_d1 = false;
                }

              if (__ok_d1)
                {



                  _Tp __sum1 = _Tp(1);
                  _Tp __term = _Tp(1);
                  _Tp __ln_pre1 = __lng_ad + __lng_c + __d2 * __ln_omx
                                - __lng_ad1 - __lng_bd1;



                  for (int __i = 1; __i < __ad; ++__i)
                    {
                      const int __j = __i - 1;
                      __term *= (__a + __d2 + __j) * (__b + __d2 + __j)
                              / (_Tp(1) + __d2 + __j) / __i * (_Tp(1) - __x);
                      __sum1 += __term;
                    }

                  if (__ln_pre1 > __log_max)
                    std::__throw_runtime_error(("Overflow of gamma functions" " in __hyperg_luke.")
                                                                        );
                  else
                    __F1 = std::exp(__ln_pre1) * __sum1;
                }
              else
                {


                  __F1 = _Tp(0);
                }
            }


          bool __ok_d2 = true;
          _Tp __lng_ad2, __lng_bd2;
          try
            {
              __lng_ad2 = __log_gamma(__a + __d2);
              __lng_bd2 = __log_gamma(__b + __d2);
            }
          catch(...)
            {
              __ok_d2 = false;
            }

          if (__ok_d2)
            {


              const int __maxiter = 2000;
              const _Tp __psi_1 = -__numeric_constants<_Tp>::__gamma_e();
              const _Tp __psi_1pd = __psi(_Tp(1) + __ad);
              const _Tp __psi_apd1 = __psi(__a + __d1);
              const _Tp __psi_bpd1 = __psi(__b + __d1);

              _Tp __psi_term = __psi_1 + __psi_1pd - __psi_apd1
                             - __psi_bpd1 - __ln_omx;
              _Tp __fact = _Tp(1);
              _Tp __sum2 = __psi_term;
              _Tp __ln_pre2 = __lng_c + __d1 * __ln_omx
                            - __lng_ad2 - __lng_bd2;


              int __j;
              for (__j = 1; __j < __maxiter; ++__j)
                {


                  const _Tp __term1 = _Tp(1) / _Tp(__j)
                                    + _Tp(1) / (__ad + __j);
                  const _Tp __term2 = _Tp(1) / (__a + __d1 + _Tp(__j - 1))
                                    + _Tp(1) / (__b + __d1 + _Tp(__j - 1));
                  __psi_term += __term1 - __term2;
                  __fact *= (__a + __d1 + _Tp(__j - 1))
                          * (__b + __d1 + _Tp(__j - 1))
                          / ((__ad + __j) * __j) * (_Tp(1) - __x);
                  const _Tp __delta = __fact * __psi_term;
                  __sum2 += __delta;
                  if (std::abs(__delta) < __eps * std::abs(__sum2))
                    break;
                }
              if (__j == __maxiter)
                std::__throw_runtime_error(("Sum F2 failed to converge " "in __hyperg_reflect")
                                                                     );

              if (__sum2 == _Tp(0))
                __F2 = _Tp(0);
              else
                __F2 = std::exp(__ln_pre2) * __sum2;
            }
          else
            {


              __F2 = _Tp(0);
            }

          const _Tp __sgn_2 = (__intd % 2 == 1 ? -_Tp(1) : _Tp(1));
          const _Tp __F = __F1 + __sgn_2 * __F2;

          return __F;
        }
      else
        {




          bool __ok1 = true;
          _Tp __sgn_g1ca = _Tp(0), __ln_g1ca = _Tp(0);
          _Tp __sgn_g1cb = _Tp(0), __ln_g1cb = _Tp(0);
          try
            {
              __sgn_g1ca = __log_gamma_sign(__c - __a);
              __ln_g1ca = __log_gamma(__c - __a);
              __sgn_g1cb = __log_gamma_sign(__c - __b);
              __ln_g1cb = __log_gamma(__c - __b);
            }
          catch(...)
            {
              __ok1 = false;
            }

          bool __ok2 = true;
          _Tp __sgn_g2a = _Tp(0), __ln_g2a = _Tp(0);
          _Tp __sgn_g2b = _Tp(0), __ln_g2b = _Tp(0);
          try
            {
              __sgn_g2a = __log_gamma_sign(__a);
              __ln_g2a = __log_gamma(__a);
              __sgn_g2b = __log_gamma_sign(__b);
              __ln_g2b = __log_gamma(__b);
            }
          catch(...)
            {
              __ok2 = false;
            }

          const _Tp __sgn_gc = __log_gamma_sign(__c);
          const _Tp __ln_gc = __log_gamma(__c);
          const _Tp __sgn_gd = __log_gamma_sign(__d);
          const _Tp __ln_gd = __log_gamma(__d);
          const _Tp __sgn_gmd = __log_gamma_sign(-__d);
          const _Tp __ln_gmd = __log_gamma(-__d);

          const _Tp __sgn1 = __sgn_gc * __sgn_gd * __sgn_g1ca * __sgn_g1cb;
          const _Tp __sgn2 = __sgn_gc * __sgn_gmd * __sgn_g2a * __sgn_g2b;

          _Tp __pre1, __pre2;
          if (__ok1 && __ok2)
            {
              _Tp __ln_pre1 = __ln_gc + __ln_gd - __ln_g1ca - __ln_g1cb;
              _Tp __ln_pre2 = __ln_gc + __ln_gmd - __ln_g2a - __ln_g2b
                            + __d * std::log(_Tp(1) - __x);
              if (__ln_pre1 < __log_max && __ln_pre2 < __log_max)
                {
                  __pre1 = std::exp(__ln_pre1);
                  __pre2 = std::exp(__ln_pre2);
                  __pre1 *= __sgn1;
                  __pre2 *= __sgn2;
                }
              else
                {
                  std::__throw_runtime_error(("Overflow of gamma functions " "in __hyperg_reflect")
                                                                       );
                }
            }
          else if (__ok1 && !__ok2)
            {
              _Tp __ln_pre1 = __ln_gc + __ln_gd - __ln_g1ca - __ln_g1cb;
              if (__ln_pre1 < __log_max)
                {
                  __pre1 = std::exp(__ln_pre1);
                  __pre1 *= __sgn1;
                  __pre2 = _Tp(0);
                }
              else
                {
                  std::__throw_runtime_error(("Overflow of gamma functions " "in __hyperg_reflect")
                                                                       );
                }
            }
          else if (!__ok1 && __ok2)
            {
              _Tp __ln_pre2 = __ln_gc + __ln_gmd - __ln_g2a - __ln_g2b
                            + __d * std::log(_Tp(1) - __x);
              if (__ln_pre2 < __log_max)
                {
                  __pre1 = _Tp(0);
                  __pre2 = std::exp(__ln_pre2);
                  __pre2 *= __sgn2;
                }
              else
                {
                  std::__throw_runtime_error(("Overflow of gamma functions " "in __hyperg_reflect")
                                                                       );
                }
            }
          else
            {
              __pre1 = _Tp(0);
              __pre2 = _Tp(0);
              std::__throw_runtime_error(("Underflow of gamma functions " "in __hyperg_reflect")
                                                                   );
            }

          const _Tp __F1 = __hyperg_series(__a, __b, _Tp(1) - __d,
                                           _Tp(1) - __x);
          const _Tp __F2 = __hyperg_series(__c - __a, __c - __b, _Tp(1) + __d,
                                           _Tp(1) - __x);

          const _Tp __F = __pre1 * __F1 + __pre2 * __F2;

          return __F;
        }
    }
# 728 "/usr/local/include/c++/10.0.0/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __hyperg(_Tp __a, _Tp __b, _Tp __c, _Tp __x)
    {

      const _Tp __a_nint = ::std::nearbyint(__a);
      const _Tp __b_nint = ::std::nearbyint(__b);
      const _Tp __c_nint = ::std::nearbyint(__c);





      const _Tp __toler = _Tp(1000) * std::numeric_limits<_Tp>::epsilon();
      if (std::abs(__x) >= _Tp(1))
        std::__throw_domain_error(("Argument outside unit circle " "in __hyperg.")
                                                     );
      else if (__isnan(__a) || __isnan(__b)
            || __isnan(__c) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__c_nint == __c && __c_nint <= _Tp(0))
        return std::numeric_limits<_Tp>::infinity();
      else if (std::abs(__c - __b) < __toler || std::abs(__c - __a) < __toler)
        return std::pow(_Tp(1) - __x, __c - __a - __b);
      else if (__a >= _Tp(0) && __b >= _Tp(0) && __c >= _Tp(0)
            && __x >= _Tp(0) && __x < _Tp(0.995L))
        return __hyperg_series(__a, __b, __c, __x);
      else if (std::abs(__a) < _Tp(10) && std::abs(__b) < _Tp(10))
        {


          if (__a < _Tp(0) && std::abs(__a - __a_nint) < __toler)
            return __hyperg_series(__a_nint, __b, __c, __x);
          else if (__b < _Tp(0) && std::abs(__b - __b_nint) < __toler)
            return __hyperg_series(__a, __b_nint, __c, __x);
          else if (__x < -_Tp(0.25L))
            return __hyperg_luke(__a, __b, __c, __x);
          else if (__x < _Tp(0.5L))
            return __hyperg_series(__a, __b, __c, __x);
          else
            if (std::abs(__c) > _Tp(10))
              return __hyperg_series(__a, __b, __c, __x);
            else
              return __hyperg_reflect(__a, __b, __c, __x);
        }
      else
        return __hyperg_luke(__a, __b, __c, __x);
    }
  }






}
# 55 "/usr/local/include/c++/10.0.0/bits/specfun.h" 2 3
# 1 "/usr/local/include/c++/10.0.0/tr1/legendre_function.tcc" 1 3
# 49 "/usr/local/include/c++/10.0.0/tr1/legendre_function.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 65 "/usr/local/include/c++/10.0.0/tr1/legendre_function.tcc" 3
  namespace __detail
  {
# 80 "/usr/local/include/c++/10.0.0/tr1/legendre_function.tcc" 3
    template<typename _Tp>
    _Tp
    __poly_legendre_p(unsigned int __l, _Tp __x)
    {

      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x == +_Tp(1))
        return +_Tp(1);
      else if (__x == -_Tp(1))
        return (__l % 2 == 1 ? -_Tp(1) : +_Tp(1));
      else
        {
          _Tp __p_lm2 = _Tp(1);
          if (__l == 0)
            return __p_lm2;

          _Tp __p_lm1 = __x;
          if (__l == 1)
            return __p_lm1;

          _Tp __p_l = 0;
          for (unsigned int __ll = 2; __ll <= __l; ++__ll)
            {


              __p_l = _Tp(2) * __x * __p_lm1 - __p_lm2
                    - (__x * __p_lm1 - __p_lm2) / _Tp(__ll);
              __p_lm2 = __p_lm1;
              __p_lm1 = __p_l;
            }

          return __p_l;
        }
    }
# 136 "/usr/local/include/c++/10.0.0/tr1/legendre_function.tcc" 3
    template<typename _Tp>
    _Tp
    __assoc_legendre_p(unsigned int __l, unsigned int __m, _Tp __x,
         _Tp __phase = _Tp(+1))
    {

      if (__m > __l)
        return _Tp(0);
      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__m == 0)
        return __poly_legendre_p(__l, __x);
      else
        {
          _Tp __p_mm = _Tp(1);
          if (__m > 0)
            {


              _Tp __root = std::sqrt(_Tp(1) - __x) * std::sqrt(_Tp(1) + __x);
              _Tp __fact = _Tp(1);
              for (unsigned int __i = 1; __i <= __m; ++__i)
                {
                  __p_mm *= __phase * __fact * __root;
                  __fact += _Tp(2);
                }
            }
          if (__l == __m)
            return __p_mm;

          _Tp __p_mp1m = _Tp(2 * __m + 1) * __x * __p_mm;
          if (__l == __m + 1)
            return __p_mp1m;

          _Tp __p_lm2m = __p_mm;
          _Tp __P_lm1m = __p_mp1m;
          _Tp __p_lm = _Tp(0);
          for (unsigned int __j = __m + 2; __j <= __l; ++__j)
            {
              __p_lm = (_Tp(2 * __j - 1) * __x * __P_lm1m
                      - _Tp(__j + __m - 1) * __p_lm2m) / _Tp(__j - __m);
              __p_lm2m = __P_lm1m;
              __P_lm1m = __p_lm;
            }

          return __p_lm;
        }
    }
# 214 "/usr/local/include/c++/10.0.0/tr1/legendre_function.tcc" 3
    template <typename _Tp>
    _Tp
    __sph_legendre(unsigned int __l, unsigned int __m, _Tp __theta)
    {
      if (__isnan(__theta))
        return std::numeric_limits<_Tp>::quiet_NaN();

      const _Tp __x = std::cos(__theta);

      if (__m > __l)
        return _Tp(0);
      else if (__m == 0)
        {
          _Tp __P = __poly_legendre_p(__l, __x);
          _Tp __fact = std::sqrt(_Tp(2 * __l + 1)
                     / (_Tp(4) * __numeric_constants<_Tp>::__pi()));
          __P *= __fact;
          return __P;
        }
      else if (__x == _Tp(1) || __x == -_Tp(1))
        {

          return _Tp(0);
        }
      else
        {





          const _Tp __sgn = ( __m % 2 == 1 ? -_Tp(1) : _Tp(1));
          const _Tp __y_mp1m_factor = __x * std::sqrt(_Tp(2 * __m + 3));

          const _Tp __lncirc = ::std::log1p(-__x * __x);





          const _Tp __lnpoch = ::std::lgamma(_Tp(__m + _Tp(0.5L)))
                             - ::std::lgamma(_Tp(__m));




          const _Tp __lnpre_val =
                    -_Tp(0.25L) * __numeric_constants<_Tp>::__lnpi()
                    + _Tp(0.5L) * (__lnpoch + __m * __lncirc);
          const _Tp __sr = std::sqrt((_Tp(2) + _Tp(1) / __m)
                         / (_Tp(4) * __numeric_constants<_Tp>::__pi()));
          _Tp __y_mm = __sgn * __sr * std::exp(__lnpre_val);
          _Tp __y_mp1m = __y_mp1m_factor * __y_mm;

          if (__l == __m)
            return __y_mm;
          else if (__l == __m + 1)
            return __y_mp1m;
          else
            {
              _Tp __y_lm = _Tp(0);


              for (int __ll = __m + 2; __ll <= __l; ++__ll)
                {
                  const _Tp __rat1 = _Tp(__ll - __m) / _Tp(__ll + __m);
                  const _Tp __rat2 = _Tp(__ll - __m - 1) / _Tp(__ll + __m - 1);
                  const _Tp __fact1 = std::sqrt(__rat1 * _Tp(2 * __ll + 1)
                                                       * _Tp(2 * __ll - 1));
                  const _Tp __fact2 = std::sqrt(__rat1 * __rat2 * _Tp(2 * __ll + 1)
                                                                / _Tp(2 * __ll - 3));
                  __y_lm = (__x * __y_mp1m * __fact1
                         - (__ll + __m - 1) * __y_mm * __fact2) / _Tp(__ll - __m);
                  __y_mm = __y_mp1m;
                  __y_mp1m = __y_lm;
                }

              return __y_lm;
            }
        }
    }
  }






}
# 56 "/usr/local/include/c++/10.0.0/bits/specfun.h" 2 3
# 1 "/usr/local/include/c++/10.0.0/tr1/modified_bessel_func.tcc" 1 3
# 51 "/usr/local/include/c++/10.0.0/tr1/modified_bessel_func.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 65 "/usr/local/include/c++/10.0.0/tr1/modified_bessel_func.tcc" 3
  namespace __detail
  {
# 83 "/usr/local/include/c++/10.0.0/tr1/modified_bessel_func.tcc" 3
    template <typename _Tp>
    void
    __bessel_ik(_Tp __nu, _Tp __x,
                _Tp & __Inu, _Tp & __Knu, _Tp & __Ipnu, _Tp & __Kpnu)
    {
      if (__x == _Tp(0))
        {
          if (__nu == _Tp(0))
            {
              __Inu = _Tp(1);
              __Ipnu = _Tp(0);
            }
          else if (__nu == _Tp(1))
            {
              __Inu = _Tp(0);
              __Ipnu = _Tp(0.5L);
            }
          else
            {
              __Inu = _Tp(0);
              __Ipnu = _Tp(0);
            }
          __Knu = std::numeric_limits<_Tp>::infinity();
          __Kpnu = -std::numeric_limits<_Tp>::infinity();
          return;
        }

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __fp_min = _Tp(10) * std::numeric_limits<_Tp>::epsilon();
      const int __max_iter = 15000;
      const _Tp __x_min = _Tp(2);

      const int __nl = static_cast<int>(__nu + _Tp(0.5L));

      const _Tp __mu = __nu - __nl;
      const _Tp __mu2 = __mu * __mu;
      const _Tp __xi = _Tp(1) / __x;
      const _Tp __xi2 = _Tp(2) * __xi;
      _Tp __h = __nu * __xi;
      if ( __h < __fp_min )
        __h = __fp_min;
      _Tp __b = __xi2 * __nu;
      _Tp __d = _Tp(0);
      _Tp __c = __h;
      int __i;
      for ( __i = 1; __i <= __max_iter; ++__i )
        {
          __b += __xi2;
          __d = _Tp(1) / (__b + __d);
          __c = __b + _Tp(1) / __c;
          const _Tp __del = __c * __d;
          __h *= __del;
          if (std::abs(__del - _Tp(1)) < __eps)
            break;
        }
      if (__i > __max_iter)
        std::__throw_runtime_error(("Argument x too large " "in __bessel_ik; " "try asymptotic expansion.")

                                                                   );
      _Tp __Inul = __fp_min;
      _Tp __Ipnul = __h * __Inul;
      _Tp __Inul1 = __Inul;
      _Tp __Ipnu1 = __Ipnul;
      _Tp __fact = __nu * __xi;
      for (int __l = __nl; __l >= 1; --__l)
        {
          const _Tp __Inutemp = __fact * __Inul + __Ipnul;
          __fact -= __xi;
          __Ipnul = __fact * __Inutemp + __Inul;
          __Inul = __Inutemp;
        }
      _Tp __f = __Ipnul / __Inul;
      _Tp __Kmu, __Knu1;
      if (__x < __x_min)
        {
          const _Tp __x2 = __x / _Tp(2);
          const _Tp __pimu = __numeric_constants<_Tp>::__pi() * __mu;
          const _Tp __fact = (std::abs(__pimu) < __eps
                            ? _Tp(1) : __pimu / std::sin(__pimu));
          _Tp __d = -std::log(__x2);
          _Tp __e = __mu * __d;
          const _Tp __fact2 = (std::abs(__e) < __eps
                            ? _Tp(1) : std::sinh(__e) / __e);
          _Tp __gam1, __gam2, __gampl, __gammi;
          __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
          _Tp __ff = __fact
                   * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
          _Tp __sum = __ff;
          __e = std::exp(__e);
          _Tp __p = __e / (_Tp(2) * __gampl);
          _Tp __q = _Tp(1) / (_Tp(2) * __e * __gammi);
          _Tp __c = _Tp(1);
          __d = __x2 * __x2;
          _Tp __sum1 = __p;
          int __i;
          for (__i = 1; __i <= __max_iter; ++__i)
            {
              __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
              __c *= __d / __i;
              __p /= __i - __mu;
              __q /= __i + __mu;
              const _Tp __del = __c * __ff;
              __sum += __del;
              const _Tp __del1 = __c * (__p - __i * __ff);
              __sum1 += __del1;
              if (std::abs(__del) < __eps * std::abs(__sum))
                break;
            }
          if (__i > __max_iter)
            std::__throw_runtime_error(("Bessel k series failed to converge " "in __bessel_ik.")
                                                             );
          __Kmu = __sum;
          __Knu1 = __sum1 * __xi2;
        }
      else
        {
          _Tp __b = _Tp(2) * (_Tp(1) + __x);
          _Tp __d = _Tp(1) / __b;
          _Tp __delh = __d;
          _Tp __h = __delh;
          _Tp __q1 = _Tp(0);
          _Tp __q2 = _Tp(1);
          _Tp __a1 = _Tp(0.25L) - __mu2;
          _Tp __q = __c = __a1;
          _Tp __a = -__a1;
          _Tp __s = _Tp(1) + __q * __delh;
          int __i;
          for (__i = 2; __i <= __max_iter; ++__i)
            {
              __a -= 2 * (__i - 1);
              __c = -__a * __c / __i;
              const _Tp __qnew = (__q1 - __b * __q2) / __a;
              __q1 = __q2;
              __q2 = __qnew;
              __q += __c * __qnew;
              __b += _Tp(2);
              __d = _Tp(1) / (__b + __a * __d);
              __delh = (__b * __d - _Tp(1)) * __delh;
              __h += __delh;
              const _Tp __dels = __q * __delh;
              __s += __dels;
              if ( std::abs(__dels / __s) < __eps )
                break;
            }
          if (__i > __max_iter)
            std::__throw_runtime_error(("Steed's method failed " "in __bessel_ik.")
                                                             );
          __h = __a1 * __h;
          __Kmu = std::sqrt(__numeric_constants<_Tp>::__pi() / (_Tp(2) * __x))
                * std::exp(-__x) / __s;
          __Knu1 = __Kmu * (__mu + __x + _Tp(0.5L) - __h) * __xi;
        }

      _Tp __Kpmu = __mu * __xi * __Kmu - __Knu1;
      _Tp __Inumu = __xi / (__f * __Kmu - __Kpmu);
      __Inu = __Inumu * __Inul1 / __Inul;
      __Ipnu = __Inumu * __Ipnu1 / __Inul;
      for ( __i = 1; __i <= __nl; ++__i )
        {
          const _Tp __Knutemp = (__mu + __i) * __xi2 * __Knu1 + __Kmu;
          __Kmu = __Knu1;
          __Knu1 = __Knutemp;
        }
      __Knu = __Kmu;
      __Kpnu = __nu * __xi * __Kmu - __Knu1;

      return;
    }
# 267 "/usr/local/include/c++/10.0.0/tr1/modified_bessel_func.tcc" 3
    template<typename _Tp>
    _Tp
    __cyl_bessel_i(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_bessel_i.")
                                                           );
      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x * __x < _Tp(10) * (__nu + _Tp(1)))
        return __cyl_bessel_ij_series(__nu, __x, +_Tp(1), 200);
      else
        {
          _Tp __I_nu, __K_nu, __Ip_nu, __Kp_nu;
          __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          return __I_nu;
        }
    }
# 303 "/usr/local/include/c++/10.0.0/tr1/modified_bessel_func.tcc" 3
    template<typename _Tp>
    _Tp
    __cyl_bessel_k(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_bessel_k.")
                                                           );
      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        {
          _Tp __I_nu, __K_nu, __Ip_nu, __Kp_nu;
          __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          return __K_nu;
        }
    }
# 337 "/usr/local/include/c++/10.0.0/tr1/modified_bessel_func.tcc" 3
    template <typename _Tp>
    void
    __sph_bessel_ik(unsigned int __n, _Tp __x,
                    _Tp & __i_n, _Tp & __k_n, _Tp & __ip_n, _Tp & __kp_n)
    {
      const _Tp __nu = _Tp(__n) + _Tp(0.5L);

      _Tp __I_nu, __Ip_nu, __K_nu, __Kp_nu;
      __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);

      const _Tp __factor = __numeric_constants<_Tp>::__sqrtpio2()
                         / std::sqrt(__x);

      __i_n = __factor * __I_nu;
      __k_n = __factor * __K_nu;
      __ip_n = __factor * __Ip_nu - __i_n / (_Tp(2) * __x);
      __kp_n = __factor * __Kp_nu - __k_n / (_Tp(2) * __x);

      return;
    }
# 373 "/usr/local/include/c++/10.0.0/tr1/modified_bessel_func.tcc" 3
    template <typename _Tp>
    void
    __airy(_Tp __x, _Tp & __Ai, _Tp & __Bi, _Tp & __Aip, _Tp & __Bip)
    {
      const _Tp __absx = std::abs(__x);
      const _Tp __rootx = std::sqrt(__absx);
      const _Tp __z = _Tp(2) * __absx * __rootx / _Tp(3);
      const _Tp _S_NaN = std::numeric_limits<_Tp>::quiet_NaN();
      const _Tp _S_inf = std::numeric_limits<_Tp>::infinity();

      if (__isnan(__x))
        __Bip = __Aip = __Bi = __Ai = std::numeric_limits<_Tp>::quiet_NaN();
      else if (__z == _S_inf)
        {
   __Aip = __Ai = _Tp(0);
   __Bip = __Bi = _S_inf;
 }
      else if (__z == -_S_inf)
 __Bip = __Aip = __Bi = __Ai = _Tp(0);
      else if (__x > _Tp(0))
        {
          _Tp __I_nu, __Ip_nu, __K_nu, __Kp_nu;

          __bessel_ik(_Tp(1) / _Tp(3), __z, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          __Ai = __rootx * __K_nu
               / (__numeric_constants<_Tp>::__sqrt3()
                * __numeric_constants<_Tp>::__pi());
          __Bi = __rootx * (__K_nu / __numeric_constants<_Tp>::__pi()
                 + _Tp(2) * __I_nu / __numeric_constants<_Tp>::__sqrt3());

          __bessel_ik(_Tp(2) / _Tp(3), __z, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          __Aip = -__x * __K_nu
                / (__numeric_constants<_Tp>::__sqrt3()
                 * __numeric_constants<_Tp>::__pi());
          __Bip = __x * (__K_nu / __numeric_constants<_Tp>::__pi()
                      + _Tp(2) * __I_nu
                      / __numeric_constants<_Tp>::__sqrt3());
        }
      else if (__x < _Tp(0))
        {
          _Tp __J_nu, __Jp_nu, __N_nu, __Np_nu;

          __bessel_jn(_Tp(1) / _Tp(3), __z, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          __Ai = __rootx * (__J_nu
                    - __N_nu / __numeric_constants<_Tp>::__sqrt3()) / _Tp(2);
          __Bi = -__rootx * (__N_nu
                    + __J_nu / __numeric_constants<_Tp>::__sqrt3()) / _Tp(2);

          __bessel_jn(_Tp(2) / _Tp(3), __z, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          __Aip = __absx * (__N_nu / __numeric_constants<_Tp>::__sqrt3()
                          + __J_nu) / _Tp(2);
          __Bip = __absx * (__J_nu / __numeric_constants<_Tp>::__sqrt3()
                          - __N_nu) / _Tp(2);
        }
      else
        {



          __Ai = _Tp(0.35502805388781723926L);
          __Bi = __Ai * __numeric_constants<_Tp>::__sqrt3();




          __Aip = -_Tp(0.25881940379280679840L);
          __Bip = -__Aip * __numeric_constants<_Tp>::__sqrt3();
        }

      return;
    }
  }





}
# 57 "/usr/local/include/c++/10.0.0/bits/specfun.h" 2 3
# 1 "/usr/local/include/c++/10.0.0/tr1/poly_hermite.tcc" 1 3
# 42 "/usr/local/include/c++/10.0.0/tr1/poly_hermite.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 56 "/usr/local/include/c++/10.0.0/tr1/poly_hermite.tcc" 3
  namespace __detail
  {
# 72 "/usr/local/include/c++/10.0.0/tr1/poly_hermite.tcc" 3
    template<typename _Tp>
    _Tp
    __poly_hermite_recursion(unsigned int __n, _Tp __x)
    {

      _Tp __H_0 = 1;
      if (__n == 0)
        return __H_0;


      _Tp __H_1 = 2 * __x;
      if (__n == 1)
        return __H_1;


      _Tp __H_n, __H_nm1, __H_nm2;
      unsigned int __i;
      for (__H_nm2 = __H_0, __H_nm1 = __H_1, __i = 2; __i <= __n; ++__i)
        {
          __H_n = 2 * (__x * __H_nm1 - (__i - 1) * __H_nm2);
          __H_nm2 = __H_nm1;
          __H_nm1 = __H_n;
        }

      return __H_n;
    }
# 114 "/usr/local/include/c++/10.0.0/tr1/poly_hermite.tcc" 3
    template<typename _Tp>
    inline _Tp
    __poly_hermite(unsigned int __n, _Tp __x)
    {
      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __poly_hermite_recursion(__n, __x);
    }
  }





}
# 58 "/usr/local/include/c++/10.0.0/bits/specfun.h" 2 3
# 1 "/usr/local/include/c++/10.0.0/tr1/poly_laguerre.tcc" 1 3
# 44 "/usr/local/include/c++/10.0.0/tr1/poly_laguerre.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 60 "/usr/local/include/c++/10.0.0/tr1/poly_laguerre.tcc" 3
  namespace __detail
  {
# 75 "/usr/local/include/c++/10.0.0/tr1/poly_laguerre.tcc" 3
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre_large_n(unsigned __n, _Tpa __alpha1, _Tp __x)
    {
      const _Tp __a = -_Tp(__n);
      const _Tp __b = _Tp(__alpha1) + _Tp(1);
      const _Tp __eta = _Tp(2) * __b - _Tp(4) * __a;
      const _Tp __cos2th = __x / __eta;
      const _Tp __sin2th = _Tp(1) - __cos2th;
      const _Tp __th = std::acos(std::sqrt(__cos2th));
      const _Tp __pre_h = __numeric_constants<_Tp>::__pi_2()
                        * __numeric_constants<_Tp>::__pi_2()
                        * __eta * __eta * __cos2th * __sin2th;


      const _Tp __lg_b = ::std::lgamma(_Tp(__n) + __b);
      const _Tp __lnfact = ::std::lgamma(_Tp(__n + 1));





      _Tp __pre_term1 = _Tp(0.5L) * (_Tp(1) - __b)
                      * std::log(_Tp(0.25L) * __x * __eta);
      _Tp __pre_term2 = _Tp(0.25L) * std::log(__pre_h);
      _Tp __lnpre = __lg_b - __lnfact + _Tp(0.5L) * __x
                      + __pre_term1 - __pre_term2;
      _Tp __ser_term1 = std::sin(__a * __numeric_constants<_Tp>::__pi());
      _Tp __ser_term2 = std::sin(_Tp(0.25L) * __eta
                              * (_Tp(2) * __th
                               - std::sin(_Tp(2) * __th))
                               + __numeric_constants<_Tp>::__pi_4());
      _Tp __ser = __ser_term1 + __ser_term2;

      return std::exp(__lnpre) * __ser;
    }
# 129 "/usr/local/include/c++/10.0.0/tr1/poly_laguerre.tcc" 3
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre_hyperg(unsigned int __n, _Tpa __alpha1, _Tp __x)
    {
      const _Tp __b = _Tp(__alpha1) + _Tp(1);
      const _Tp __mx = -__x;
      const _Tp __tc_sgn = (__x < _Tp(0) ? _Tp(1)
                         : ((__n % 2 == 1) ? -_Tp(1) : _Tp(1)));

      _Tp __tc = _Tp(1);
      const _Tp __ax = std::abs(__x);
      for (unsigned int __k = 1; __k <= __n; ++__k)
        __tc *= (__ax / __k);

      _Tp __term = __tc * __tc_sgn;
      _Tp __sum = __term;
      for (int __k = int(__n) - 1; __k >= 0; --__k)
        {
          __term *= ((__b + _Tp(__k)) / _Tp(int(__n) - __k))
                  * _Tp(__k + 1) / __mx;
          __sum += __term;
        }

      return __sum;
    }
# 185 "/usr/local/include/c++/10.0.0/tr1/poly_laguerre.tcc" 3
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre_recursion(unsigned int __n, _Tpa __alpha1, _Tp __x)
    {

      _Tp __l_0 = _Tp(1);
      if (__n == 0)
        return __l_0;


      _Tp __l_1 = -__x + _Tp(1) + _Tp(__alpha1);
      if (__n == 1)
        return __l_1;


      _Tp __l_n2 = __l_0;
      _Tp __l_n1 = __l_1;
      _Tp __l_n = _Tp(0);
      for (unsigned int __nn = 2; __nn <= __n; ++__nn)
        {
            __l_n = (_Tp(2 * __nn - 1) + _Tp(__alpha1) - __x)
                  * __l_n1 / _Tp(__nn)
                  - (_Tp(__nn - 1) + _Tp(__alpha1)) * __l_n2 / _Tp(__nn);
            __l_n2 = __l_n1;
            __l_n1 = __l_n;
        }

      return __l_n;
    }
# 244 "/usr/local/include/c++/10.0.0/tr1/poly_laguerre.tcc" 3
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre(unsigned int __n, _Tpa __alpha1, _Tp __x)
    {
      if (__x < _Tp(0))
        std::__throw_domain_error(("Negative argument " "in __poly_laguerre.")
                                                            );

      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__n == 0)
        return _Tp(1);
      else if (__n == 1)
        return _Tp(1) + _Tp(__alpha1) - __x;
      else if (__x == _Tp(0))
        {
          _Tp __prod = _Tp(__alpha1) + _Tp(1);
          for (unsigned int __k = 2; __k <= __n; ++__k)
            __prod *= (_Tp(__alpha1) + _Tp(__k)) / _Tp(__k);
          return __prod;
        }
      else if (__n > 10000000 && _Tp(__alpha1) > -_Tp(1)
            && __x < _Tp(2) * (_Tp(__alpha1) + _Tp(1)) + _Tp(4 * __n))
        return __poly_laguerre_large_n(__n, __alpha1, __x);
      else if (_Tp(__alpha1) >= _Tp(0)
           || (__x > _Tp(0) && _Tp(__alpha1) < -_Tp(__n + 1)))
        return __poly_laguerre_recursion(__n, __alpha1, __x);
      else
        return __poly_laguerre_hyperg(__n, __alpha1, __x);
    }
# 296 "/usr/local/include/c++/10.0.0/tr1/poly_laguerre.tcc" 3
    template<typename _Tp>
    inline _Tp
    __assoc_laguerre(unsigned int __n, unsigned int __m, _Tp __x)
    { return __poly_laguerre<unsigned int, _Tp>(__n, __m, __x); }
# 316 "/usr/local/include/c++/10.0.0/tr1/poly_laguerre.tcc" 3
    template<typename _Tp>
    inline _Tp
    __laguerre(unsigned int __n, _Tp __x)
    { return __poly_laguerre<unsigned int, _Tp>(__n, 0, __x); }
  }






}
# 59 "/usr/local/include/c++/10.0.0/bits/specfun.h" 2 3
# 1 "/usr/local/include/c++/10.0.0/tr1/riemann_zeta.tcc" 1 3
# 47 "/usr/local/include/c++/10.0.0/tr1/riemann_zeta.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 63 "/usr/local/include/c++/10.0.0/tr1/riemann_zeta.tcc" 3
  namespace __detail
  {
# 78 "/usr/local/include/c++/10.0.0/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta_sum(_Tp __s)
    {

      if (__s < _Tp(1))
        std::__throw_domain_error(("Bad argument in zeta sum."));

      const unsigned int max_iter = 10000;
      _Tp __zeta = _Tp(0);
      for (unsigned int __k = 1; __k < max_iter; ++__k)
        {
          _Tp __term = std::pow(static_cast<_Tp>(__k), -__s);
          if (__term < std::numeric_limits<_Tp>::epsilon())
            {
              break;
            }
          __zeta += __term;
        }

      return __zeta;
    }
# 115 "/usr/local/include/c++/10.0.0/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta_alt(_Tp __s)
    {
      _Tp __sgn = _Tp(1);
      _Tp __zeta = _Tp(0);
      for (unsigned int __i = 1; __i < 10000000; ++__i)
        {
          _Tp __term = __sgn / std::pow(__i, __s);
          if (std::abs(__term) < std::numeric_limits<_Tp>::epsilon())
            break;
          __zeta += __term;
          __sgn *= _Tp(-1);
        }
      __zeta /= _Tp(1) - std::pow(_Tp(2), _Tp(1) - __s);

      return __zeta;
    }
# 157 "/usr/local/include/c++/10.0.0/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta_glob(_Tp __s)
    {
      _Tp __zeta = _Tp(0);

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      const _Tp __max_bincoeff = std::numeric_limits<_Tp>::max_exponent10
                               * std::log(_Tp(10)) - _Tp(1);



      if (__s < _Tp(0))
        {

          if (::std::fmod(__s,_Tp(2)) == _Tp(0))
            return _Tp(0);
          else

            {
              _Tp __zeta = __riemann_zeta_glob(_Tp(1) - __s);
              __zeta *= std::pow(_Tp(2)
                     * __numeric_constants<_Tp>::__pi(), __s)
                     * std::sin(__numeric_constants<_Tp>::__pi_2() * __s)

                     * std::exp(::std::lgamma(_Tp(1) - __s))



                     / __numeric_constants<_Tp>::__pi();
              return __zeta;
            }
        }

      _Tp __num = _Tp(0.5L);
      const unsigned int __maxit = 10000;
      for (unsigned int __i = 0; __i < __maxit; ++__i)
        {
          bool __punt = false;
          _Tp __sgn = _Tp(1);
          _Tp __term = _Tp(0);
          for (unsigned int __j = 0; __j <= __i; ++__j)
            {

              _Tp __bincoeff = ::std::lgamma(_Tp(1 + __i))
                              - ::std::lgamma(_Tp(1 + __j))
                              - ::std::lgamma(_Tp(1 + __i - __j));





              if (__bincoeff > __max_bincoeff)
                {

                  __punt = true;
                  break;
                }
              __bincoeff = std::exp(__bincoeff);
              __term += __sgn * __bincoeff * std::pow(_Tp(1 + __j), -__s);
              __sgn *= _Tp(-1);
            }
          if (__punt)
            break;
          __term *= __num;
          __zeta += __term;
          if (std::abs(__term/__zeta) < __eps)
            break;
          __num *= _Tp(0.5L);
        }

      __zeta /= _Tp(1) - std::pow(_Tp(2), _Tp(1) - __s);

      return __zeta;
    }
# 252 "/usr/local/include/c++/10.0.0/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta_product(_Tp __s)
    {
      static const _Tp __prime[] = {
        _Tp(2), _Tp(3), _Tp(5), _Tp(7), _Tp(11), _Tp(13), _Tp(17), _Tp(19),
        _Tp(23), _Tp(29), _Tp(31), _Tp(37), _Tp(41), _Tp(43), _Tp(47),
        _Tp(53), _Tp(59), _Tp(61), _Tp(67), _Tp(71), _Tp(73), _Tp(79),
        _Tp(83), _Tp(89), _Tp(97), _Tp(101), _Tp(103), _Tp(107), _Tp(109)
      };
      static const unsigned int __num_primes = sizeof(__prime) / sizeof(_Tp);

      _Tp __zeta = _Tp(1);
      for (unsigned int __i = 0; __i < __num_primes; ++__i)
        {
          const _Tp __fact = _Tp(1) - std::pow(__prime[__i], -__s);
          __zeta *= __fact;
          if (_Tp(1) - __fact < std::numeric_limits<_Tp>::epsilon())
            break;
        }

      __zeta = _Tp(1) / __zeta;

      return __zeta;
    }
# 293 "/usr/local/include/c++/10.0.0/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta(_Tp __s)
    {
      if (__isnan(__s))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__s == _Tp(1))
        return std::numeric_limits<_Tp>::infinity();
      else if (__s < -_Tp(19))
        {
          _Tp __zeta = __riemann_zeta_product(_Tp(1) - __s);
          __zeta *= std::pow(_Tp(2) * __numeric_constants<_Tp>::__pi(), __s)
                 * std::sin(__numeric_constants<_Tp>::__pi_2() * __s)

                 * std::exp(::std::lgamma(_Tp(1) - __s))



                 / __numeric_constants<_Tp>::__pi();
          return __zeta;
        }
      else if (__s < _Tp(20))
        {

          bool __glob = true;
          if (__glob)
            return __riemann_zeta_glob(__s);
          else
            {
              if (__s > _Tp(1))
                return __riemann_zeta_sum(__s);
              else
                {
                  _Tp __zeta = std::pow(_Tp(2)
                                * __numeric_constants<_Tp>::__pi(), __s)
                         * std::sin(__numeric_constants<_Tp>::__pi_2() * __s)

                             * ::std::tgamma(_Tp(1) - __s)



                             * __riemann_zeta_sum(_Tp(1) - __s);
                  return __zeta;
                }
            }
        }
      else
        return __riemann_zeta_product(__s);
    }
# 365 "/usr/local/include/c++/10.0.0/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __hurwitz_zeta_glob(_Tp __a, _Tp __s)
    {
      _Tp __zeta = _Tp(0);

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      const _Tp __max_bincoeff = std::numeric_limits<_Tp>::max_exponent10
                               * std::log(_Tp(10)) - _Tp(1);

      const unsigned int __maxit = 10000;
      for (unsigned int __i = 0; __i < __maxit; ++__i)
        {
          bool __punt = false;
          _Tp __sgn = _Tp(1);
          _Tp __term = _Tp(0);
          for (unsigned int __j = 0; __j <= __i; ++__j)
            {

              _Tp __bincoeff = ::std::lgamma(_Tp(1 + __i))
                              - ::std::lgamma(_Tp(1 + __j))
                              - ::std::lgamma(_Tp(1 + __i - __j));





              if (__bincoeff > __max_bincoeff)
                {

                  __punt = true;
                  break;
                }
              __bincoeff = std::exp(__bincoeff);
              __term += __sgn * __bincoeff * std::pow(_Tp(__a + __j), -__s);
              __sgn *= _Tp(-1);
            }
          if (__punt)
            break;
          __term /= _Tp(__i + 1);
          if (std::abs(__term / __zeta) < __eps)
            break;
          __zeta += __term;
        }

      __zeta /= __s - _Tp(1);

      return __zeta;
    }
# 430 "/usr/local/include/c++/10.0.0/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    inline _Tp
    __hurwitz_zeta(_Tp __a, _Tp __s)
    { return __hurwitz_zeta_glob(__a, __s); }
  }






}
# 60 "/usr/local/include/c++/10.0.0/bits/specfun.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 205 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  inline float
  assoc_laguerref(unsigned int __n, unsigned int __m, float __x)
  { return __detail::__assoc_laguerre<float>(__n, __m, __x); }







  inline long double
  assoc_laguerrel(unsigned int __n, unsigned int __m, long double __x)
  { return __detail::__assoc_laguerre<long double>(__n, __m, __x); }
# 250 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    assoc_laguerre(unsigned int __n, unsigned int __m, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__assoc_laguerre<__type>(__n, __m, __x);
    }
# 266 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  inline float
  assoc_legendref(unsigned int __l, unsigned int __m, float __x)
  { return __detail::__assoc_legendre_p<float>(__l, __m, __x); }






  inline long double
  assoc_legendrel(unsigned int __l, unsigned int __m, long double __x)
  { return __detail::__assoc_legendre_p<long double>(__l, __m, __x); }
# 296 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    assoc_legendre(unsigned int __l, unsigned int __m, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__assoc_legendre_p<__type>(__l, __m, __x);
    }
# 311 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  inline float
  betaf(float __a, float __b)
  { return __detail::__beta<float>(__a, __b); }







  inline long double
  betal(long double __a, long double __b)
  { return __detail::__beta<long double>(__a, __b); }
# 341 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  template<typename _Tpa, typename _Tpb>
    inline typename __gnu_cxx::__promote_2<_Tpa, _Tpb>::__type
    beta(_Tpa __a, _Tpb __b)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpa, _Tpb>::__type __type;
      return __detail::__beta<__type>(__a, __b);
    }
# 357 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  inline float
  comp_ellint_1f(float __k)
  { return __detail::__comp_ellint_1<float>(__k); }







  inline long double
  comp_ellint_1l(long double __k)
  { return __detail::__comp_ellint_1<long double>(__k); }
# 389 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    comp_ellint_1(_Tp __k)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__comp_ellint_1<__type>(__k);
    }
# 405 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  inline float
  comp_ellint_2f(float __k)
  { return __detail::__comp_ellint_2<float>(__k); }







  inline long double
  comp_ellint_2l(long double __k)
  { return __detail::__comp_ellint_2<long double>(__k); }
# 436 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    comp_ellint_2(_Tp __k)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__comp_ellint_2<__type>(__k);
    }
# 452 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  inline float
  comp_ellint_3f(float __k, float __nu)
  { return __detail::__comp_ellint_3<float>(__k, __nu); }







  inline long double
  comp_ellint_3l(long double __k, long double __nu)
  { return __detail::__comp_ellint_3<long double>(__k, __nu); }
# 487 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  template<typename _Tp, typename _Tpn>
    inline typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type
    comp_ellint_3(_Tp __k, _Tpn __nu)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type __type;
      return __detail::__comp_ellint_3<__type>(__k, __nu);
    }
# 503 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  inline float
  cyl_bessel_if(float __nu, float __x)
  { return __detail::__cyl_bessel_i<float>(__nu, __x); }







  inline long double
  cyl_bessel_il(long double __nu, long double __x)
  { return __detail::__cyl_bessel_i<long double>(__nu, __x); }
# 533 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_bessel_i(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_bessel_i<__type>(__nu, __x);
    }
# 549 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  inline float
  cyl_bessel_jf(float __nu, float __x)
  { return __detail::__cyl_bessel_j<float>(__nu, __x); }







  inline long double
  cyl_bessel_jl(long double __nu, long double __x)
  { return __detail::__cyl_bessel_j<long double>(__nu, __x); }
# 579 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_bessel_j(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_bessel_j<__type>(__nu, __x);
    }
# 595 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  inline float
  cyl_bessel_kf(float __nu, float __x)
  { return __detail::__cyl_bessel_k<float>(__nu, __x); }







  inline long double
  cyl_bessel_kl(long double __nu, long double __x)
  { return __detail::__cyl_bessel_k<long double>(__nu, __x); }
# 631 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_bessel_k(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_bessel_k<__type>(__nu, __x);
    }
# 647 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  inline float
  cyl_neumannf(float __nu, float __x)
  { return __detail::__cyl_neumann_n<float>(__nu, __x); }







  inline long double
  cyl_neumannl(long double __nu, long double __x)
  { return __detail::__cyl_neumann_n<long double>(__nu, __x); }
# 679 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_neumann(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_neumann_n<__type>(__nu, __x);
    }
# 695 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  inline float
  ellint_1f(float __k, float __phi)
  { return __detail::__ellint_1<float>(__k, __phi); }







  inline long double
  ellint_1l(long double __k, long double __phi)
  { return __detail::__ellint_1<long double>(__k, __phi); }
# 727 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  template<typename _Tp, typename _Tpp>
    inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type
    ellint_1(_Tp __k, _Tpp __phi)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type __type;
      return __detail::__ellint_1<__type>(__k, __phi);
    }
# 743 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  inline float
  ellint_2f(float __k, float __phi)
  { return __detail::__ellint_2<float>(__k, __phi); }







  inline long double
  ellint_2l(long double __k, long double __phi)
  { return __detail::__ellint_2<long double>(__k, __phi); }
# 775 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  template<typename _Tp, typename _Tpp>
    inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type
    ellint_2(_Tp __k, _Tpp __phi)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type __type;
      return __detail::__ellint_2<__type>(__k, __phi);
    }
# 791 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  inline float
  ellint_3f(float __k, float __nu, float __phi)
  { return __detail::__ellint_3<float>(__k, __nu, __phi); }







  inline long double
  ellint_3l(long double __k, long double __nu, long double __phi)
  { return __detail::__ellint_3<long double>(__k, __nu, __phi); }
# 828 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  template<typename _Tp, typename _Tpn, typename _Tpp>
    inline typename __gnu_cxx::__promote_3<_Tp, _Tpn, _Tpp>::__type
    ellint_3(_Tp __k, _Tpn __nu, _Tpp __phi)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Tpn, _Tpp>::__type __type;
      return __detail::__ellint_3<__type>(__k, __nu, __phi);
    }
# 843 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  inline float
  expintf(float __x)
  { return __detail::__expint<float>(__x); }







  inline long double
  expintl(long double __x)
  { return __detail::__expint<long double>(__x); }
# 868 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    expint(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__expint<__type>(__x);
    }
# 884 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  inline float
  hermitef(unsigned int __n, float __x)
  { return __detail::__poly_hermite<float>(__n, __x); }







  inline long double
  hermitel(unsigned int __n, long double __x)
  { return __detail::__poly_hermite<long double>(__n, __x); }
# 916 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    hermite(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__poly_hermite<__type>(__n, __x);
    }
# 932 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  inline float
  laguerref(unsigned int __n, float __x)
  { return __detail::__laguerre<float>(__n, __x); }







  inline long double
  laguerrel(unsigned int __n, long double __x)
  { return __detail::__laguerre<long double>(__n, __x); }
# 960 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    laguerre(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__laguerre<__type>(__n, __x);
    }
# 976 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  inline float
  legendref(unsigned int __l, float __x)
  { return __detail::__poly_legendre_p<float>(__l, __x); }







  inline long double
  legendrel(unsigned int __l, long double __x)
  { return __detail::__poly_legendre_p<long double>(__l, __x); }
# 1005 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    legendre(unsigned int __l, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__poly_legendre_p<__type>(__l, __x);
    }
# 1021 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  inline float
  riemann_zetaf(float __s)
  { return __detail::__riemann_zeta<float>(__s); }







  inline long double
  riemann_zetal(long double __s)
  { return __detail::__riemann_zeta<long double>(__s); }
# 1056 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    riemann_zeta(_Tp __s)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__riemann_zeta<__type>(__s);
    }
# 1072 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  inline float
  sph_besself(unsigned int __n, float __x)
  { return __detail::__sph_bessel<float>(__n, __x); }







  inline long double
  sph_bessell(unsigned int __n, long double __x)
  { return __detail::__sph_bessel<long double>(__n, __x); }
# 1100 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    sph_bessel(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__sph_bessel<__type>(__n, __x);
    }
# 1116 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  inline float
  sph_legendref(unsigned int __l, unsigned int __m, float __theta)
  { return __detail::__sph_legendre<float>(__l, __m, __theta); }
# 1127 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  inline long double
  sph_legendrel(unsigned int __l, unsigned int __m, long double __theta)
  { return __detail::__sph_legendre<long double>(__l, __m, __theta); }
# 1147 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    sph_legendre(unsigned int __l, unsigned int __m, _Tp __theta)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__sph_legendre<__type>(__l, __m, __theta);
    }
# 1163 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  inline float
  sph_neumannf(unsigned int __n, float __x)
  { return __detail::__sph_neumann<float>(__n, __x); }







  inline long double
  sph_neumannl(unsigned int __n, long double __x)
  { return __detail::__sph_neumann<long double>(__n, __x); }
# 1191 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    sph_neumann(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__sph_neumann<__type>(__n, __x);
    }




}
# 1388 "/usr/local/include/c++/10.0.0/bits/specfun.h" 3
#pragma GCC visibility pop
# 1928 "/usr/local/include/c++/10.0.0/cmath" 2 3


}
# 45 "/usr/local/include/c++/10.0.0/complex" 2 3
# 1 "/usr/local/include/c++/10.0.0/sstream" 1 3
# 36 "/usr/local/include/c++/10.0.0/sstream" 3
       
# 37 "/usr/local/include/c++/10.0.0/sstream" 3

# 1 "/usr/local/include/c++/10.0.0/istream" 1 3
# 36 "/usr/local/include/c++/10.0.0/istream" 3
       
# 37 "/usr/local/include/c++/10.0.0/istream" 3

# 1 "/usr/local/include/c++/10.0.0/ios" 1 3
# 36 "/usr/local/include/c++/10.0.0/ios" 3
       
# 37 "/usr/local/include/c++/10.0.0/ios" 3







# 1 "/usr/local/include/c++/10.0.0/bits/basic_ios.h" 1 3
# 33 "/usr/local/include/c++/10.0.0/bits/basic_ios.h" 3
       
# 34 "/usr/local/include/c++/10.0.0/bits/basic_ios.h" 3



# 1 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 1 3
# 37 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
       
# 38 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3

# 1 "/usr/local/include/c++/10.0.0/cwctype" 1 3
# 39 "/usr/local/include/c++/10.0.0/cwctype" 3
       
# 40 "/usr/local/include/c++/10.0.0/cwctype" 3
# 50 "/usr/local/include/c++/10.0.0/cwctype" 3
# 1 "/usr/include/wctype.h" 1 3 4
# 38 "/usr/include/wctype.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3 4
typedef unsigned long int wctype_t;
# 56 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3 4
enum
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};



extern "C" {







extern int iswalnum (wint_t __wc) throw ();





extern int iswalpha (wint_t __wc) throw ();


extern int iswcntrl (wint_t __wc) throw ();



extern int iswdigit (wint_t __wc) throw ();



extern int iswgraph (wint_t __wc) throw ();




extern int iswlower (wint_t __wc) throw ();


extern int iswprint (wint_t __wc) throw ();




extern int iswpunct (wint_t __wc) throw ();




extern int iswspace (wint_t __wc) throw ();




extern int iswupper (wint_t __wc) throw ();




extern int iswxdigit (wint_t __wc) throw ();





extern int iswblank (wint_t __wc) throw ();
# 155 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h" 3 4
extern wctype_t wctype (const char *__property) throw ();



extern int iswctype (wint_t __wc, wctype_t __desc) throw ();






extern wint_t towlower (wint_t __wc) throw ();


extern wint_t towupper (wint_t __wc) throw ();

}
# 39 "/usr/include/wctype.h" 2 3 4





extern "C" {



typedef const __int32_t *wctrans_t;



extern wctrans_t wctrans (const char *__property) throw ();


extern wint_t towctrans (wint_t __wc, wctrans_t __desc) throw ();







extern int iswalnum_l (wint_t __wc, locale_t __locale) throw ();





extern int iswalpha_l (wint_t __wc, locale_t __locale) throw ();


extern int iswcntrl_l (wint_t __wc, locale_t __locale) throw ();



extern int iswdigit_l (wint_t __wc, locale_t __locale) throw ();



extern int iswgraph_l (wint_t __wc, locale_t __locale) throw ();




extern int iswlower_l (wint_t __wc, locale_t __locale) throw ();


extern int iswprint_l (wint_t __wc, locale_t __locale) throw ();




extern int iswpunct_l (wint_t __wc, locale_t __locale) throw ();




extern int iswspace_l (wint_t __wc, locale_t __locale) throw ();




extern int iswupper_l (wint_t __wc, locale_t __locale) throw ();




extern int iswxdigit_l (wint_t __wc, locale_t __locale) throw ();




extern int iswblank_l (wint_t __wc, locale_t __locale) throw ();



extern wctype_t wctype_l (const char *__property, locale_t __locale)
     throw ();



extern int iswctype_l (wint_t __wc, wctype_t __desc, locale_t __locale)
     throw ();






extern wint_t towlower_l (wint_t __wc, locale_t __locale) throw ();


extern wint_t towupper_l (wint_t __wc, locale_t __locale) throw ();



extern wctrans_t wctrans_l (const char *__property, locale_t __locale)
     throw ();


extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
      locale_t __locale) throw ();



}
# 51 "/usr/local/include/c++/10.0.0/cwctype" 2 3
# 80 "/usr/local/include/c++/10.0.0/cwctype" 3
namespace std
{
  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
}
# 40 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 2 3
# 1 "/usr/local/include/c++/10.0.0/cctype" 1 3
# 39 "/usr/local/include/c++/10.0.0/cctype" 3
       
# 40 "/usr/local/include/c++/10.0.0/cctype" 3
# 41 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 2 3
# 1 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/ctype_base.h" 1 3
# 36 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/ctype_base.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = _ISupper;
    static const mask lower = _ISlower;
    static const mask alpha = _ISalpha;
    static const mask digit = _ISdigit;
    static const mask xdigit = _ISxdigit;
    static const mask space = _ISspace;
    static const mask print = _ISprint;
    static const mask graph = _ISalpha | _ISdigit | _ISpunct;
    static const mask cntrl = _IScntrl;
    static const mask punct = _ISpunct;
    static const mask alnum = _ISalpha | _ISdigit;

    static const mask blank = _ISblank;

  };


}
# 42 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 2 3
# 50 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 71 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
  template<typename _Tp>
    void
    __convert_to_v(const char*, _Tp&, ios_base::iostate&,
     const __c_locale&) throw();


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&) throw();



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
# 149 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
# 168 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
# 185 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
# 201 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
# 217 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
# 231 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 246 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 260 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 275 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 292 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
# 311 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
# 330 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
# 352 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char* __to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
# 377 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
# 396 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
# 415 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
# 434 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
# 452 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const = 0;
# 469 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
# 485 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const = 0;
# 502 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
# 521 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const = 0;
# 542 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const = 0;
# 563 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const = 0;
# 588 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const = 0;
    };
# 611 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
# 680 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 717 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
# 730 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
# 743 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
# 758 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
# 772 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
# 786 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
# 801 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 818 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 834 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 851 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 871 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
# 898 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     if (__builtin_expect(__hi != __lo, true))
       __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
# 930 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
# 963 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char* __to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     if (__builtin_expect(__hi != __lo, true))
       __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }





      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();
    protected:







      virtual
      ~ctype();
# 1013 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1030 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1046 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1063 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1083 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
# 1106 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (__builtin_expect(__hi != __lo, true))
   __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }
# 1133 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault __attribute__((__unused__))) const
      { return __c; }
# 1159 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault __attribute__((__unused__)), char* __to) const
      {
 if (__builtin_expect(__hi != __lo, true))
   __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }

    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };
# 1185 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
# 1218 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
# 1229 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const throw();


      virtual
      ~ctype();
# 1253 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const;
# 1272 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
# 1290 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
# 1308 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
# 1325 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1342 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1358 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1375 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1395 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const;
# 1417 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const;
# 1440 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const;
# 1466 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;


      void
      _M_initialize_ctype() throw();
    };



  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0)
      : ctype_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~ctype_byname() { }
    };


  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0);


    protected:
      virtual
      ~ctype_byname();
    };


  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0);


    protected:
      virtual
      ~ctype_byname();
    };



}


# 1 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/ctype_inline.h" 1 3
# 37 "/usr/local/include/c++/10.0.0/x86_64-pc-linux-gnu/bits/ctype_inline.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return _M_table[static_cast<unsigned char>(__c)] & __m; }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      ++__low;
    return __low;
  }


}
# 1539 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  class __num_base
  {
  public:


    enum
      {
 _S_ominus,
 _S_oplus,
 _S_ox,
 _S_oX,
 _S_odigits,
 _S_odigits_end = _S_odigits + 16,
 _S_oudigits = _S_odigits_end,
 _S_oudigits_end = _S_oudigits + 16,
 _S_oe = _S_odigits + 14,
 _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod) throw();
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0)
      : facet(__refs), _M_grouping(0), _M_grouping_size(0),
 _M_use_grouping(false),
 _M_truename(0), _M_truename_size(0), _M_falsename(0),
 _M_falsename_size(0), _M_decimal_point(_CharT()),
 _M_thousands_sep(_CharT()), _M_allocated(false)
 { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }

namespace __cxx11 {
# 1669 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(); }
# 1707 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
# 1721 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(__cloc); }
# 1735 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1748 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1779 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1792 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
# 1805 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
# 1822 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1834 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1847 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1860 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
# 1873 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }


      explicit
      numpunct_byname(const string& __s, size_t __refs = 0)
      : numpunct_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~numpunct_byname() { }
    };

}


# 1951 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 1972 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
# 1998 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2035 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2095 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2138 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      __attribute ((__abi_tag__ ("cxx11")))
      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string&) const;

      template<typename _ValueT>
 __attribute ((__abi_tag__ ("cxx11")))
 iter_type
 _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT&) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
 _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
 _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
# 2211 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      double&) const;







      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, void*&) const;
# 2274 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 2292 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 2313 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
# 2331 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2373 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __io, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2436 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2461 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __io, __fill, __v); }

    protected:
      template<typename _ValueT>
 iter_type
 _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
 iter_type
 _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { }
# 2509 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, double) const;






      virtual iter_type
      do_put(iter_type, ios_base&, char_type, long double) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, const void*) const;







    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;









  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }



  template<typename _CharT>
    inline bool
    isblank(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::blank, __c); }



  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }


}

# 1 "/usr/local/include/c++/10.0.0/bits/locale_facets.tcc" 1 3
# 33 "/usr/local/include/c++/10.0.0/bits/locale_facets.tcc" 3
       
# 34 "/usr/local/include/c++/10.0.0/bits/locale_facets.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = 0;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      char* __grouping = 0;
      _CharT* __truename = 0;
      _CharT* __falsename = 0;
      try
 {
   const string& __g = __np.grouping();
   _M_grouping_size = __g.size();
   __grouping = new char[_M_grouping_size];
   __g.copy(__grouping, _M_grouping_size);
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(__grouping[0]) > 0
        && (__grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   const basic_string<_CharT>& __tn = __np.truename();
   _M_truename_size = __tn.size();
   __truename = new _CharT[_M_truename_size];
   __tn.copy(__truename, _M_truename_size);

   const basic_string<_CharT>& __fn = __np.falsename();
   _M_falsename_size = __fn.size();
   __falsename = new _CharT[_M_falsename_size];
   __fn.copy(__falsename, _M_falsename_size);

   _M_decimal_point = __np.decimal_point();
   _M_thousands_sep = __np.thousands_sep();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(__num_base::_S_atoms_out,
       __num_base::_S_atoms_out
       + __num_base::_S_oend, _M_atoms_out);
   __ct.widen(__num_base::_S_atoms_in,
       __num_base::_S_atoms_in
       + __num_base::_S_iend, _M_atoms_in);

   _M_grouping = __grouping;
   _M_truename = __truename;
   _M_falsename = __falsename;
   _M_allocated = true;
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __truename;
   delete [] __falsename;
   throw;
 }
    }
# 139 "/usr/local/include/c++/10.0.0/bits/locale_facets.tcc" 3
  __attribute__ ((__pure__)) bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp) throw ();



  template<typename _CharT, typename _InIter>
    __attribute ((__abi_tag__ ("cxx11")))
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err = ios_base::failbit;
        }

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      __attribute ((__abi_tag__ ("cxx11")))
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 typedef __gnu_cxx::__numeric_traits<_ValueT> __num_traits;
 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   (__negative && __num_traits::__is_signed)
   ? -static_cast<__unsigned_type>(__num_traits::__min)
   : __num_traits::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err = ios_base::failbit;
   }



 if ((!__sep_pos && !__found_zero && !__found_grouping.size())
     || __testfail)
   {
     __v = 0;
     __err = ios_base::failbit;
   }
 else if (__testoverflow)
   {
     if (__negative && __num_traits::__is_signed)
       __v = __num_traits::__min;
     else
       __v = __num_traits::__max;
     __err = ios_base::failbit;
   }
 else
   __v = __negative ? -__result : __result;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
     {


       __v = true;
       __err = ios_base::failbit;
       if (__beg == __end)
  __err |= ios_base::eofbit;
     }
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc->_M_falsename_size == 0;
   bool __donet = __lc->_M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while (!__donef || !__donet)
     {
       if (__beg == __end)
  {
    __testeof = true;
    break;
  }

       const char_type __c = *__beg;

       if (!__donef)
  __testf = __c == __lc->_M_falsename[__n];

       if (!__testf && __donet)
  break;

       if (!__donet)
  __testt = __c == __lc->_M_truename[__n];

       if (!__testt && __donef)
  break;

       if (!__testt && !__testf)
  break;

       ++__n;
       ++__beg;

       __donef = !__testf || __n >= __lc->_M_falsename_size;
       __donet = !__testt || __n >= __lc->_M_truename_size;
     }
   if (__testf && __n == __lc->_M_falsename_size && __n)
     {
       __v = false;
       if (__testt && __n == __lc->_M_truename_size)
  __err = ios_base::failbit;
       else
  __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else if (__testt && __n == __lc->_M_truename_size && __n)
     {
       __v = true;
       __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else
     {


       __v = false;
       __err = ios_base::failbit;
       if (__testeof)
  __err |= ios_base::eofbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
# 735 "/usr/local/include/c++/10.0.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
# 971 "/usr/local/include/c++/10.0.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);



 const bool __use_prec =
   (__io.flags() & ios_base::floatfield) != ios_base::floatfield;



 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 if (__use_prec)
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     __fbuf, __prec, __v);
 else
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     __fbuf, __v);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     if (__use_prec)
       __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
         __fbuf, __prec, __v);
     else
       __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
         __fbuf, __v);
   }
# 1044 "/usr/local/include/c++/10.0.0/bits/locale_facets.tcc" 3
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       const streamsize __plen = __w - __len;
       _CharT* __ps
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __plen));

       char_traits<_CharT>::assign(__ps, __plen, __fill);
       __io.width(0);

       if ((__flags & ios_base::adjustfield) == ios_base::left)
  {
    __s = std::__write(__s, __name, __len);
    __s = std::__write(__s, __ps, __plen);
  }
       else
  {
    __s = std::__write(__s, __ps, __plen);
    __s = std::__write(__s, __name, __len);
  }
       return __s;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
# 1169 "/usr/local/include/c++/10.0.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }


# 1206 "/usr/local/include/c++/10.0.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0
      && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }




  extern template class __cxx11:: numpunct<char>;
  extern template class __cxx11:: numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);


  extern template class __cxx11:: numpunct<wchar_t>;
  extern template class __cxx11:: numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);




}
# 2656 "/usr/local/include/c++/10.0.0/bits/locale_facets.h" 2 3
# 38 "/usr/local/include/c++/10.0.0/bits/basic_ios.h" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
# 66 "/usr/local/include/c++/10.0.0/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;






      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:
# 117 "/usr/local/include/c++/10.0.0/bits/basic_ios.h" 3
      explicit operator bool() const
      { return !this->fail(); }





      bool
      operator!() const
      { return this->fail(); }
# 136 "/usr/local/include/c++/10.0.0/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 147 "/usr/local/include/c++/10.0.0/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 200 "/usr/local/include/c++/10.0.0/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 221 "/usr/local/include/c++/10.0.0/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 256 "/usr/local/include/c++/10.0.0/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 294 "/usr/local/include/c++/10.0.0/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 306 "/usr/local/include/c++/10.0.0/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 346 "/usr/local/include/c++/10.0.0/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
# 360 "/usr/local/include/c++/10.0.0/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
# 389 "/usr/local/include/c++/10.0.0/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
# 409 "/usr/local/include/c++/10.0.0/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 429 "/usr/local/include/c++/10.0.0/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
# 448 "/usr/local/include/c++/10.0.0/bits/basic_ios.h" 3
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);


      basic_ios(const basic_ios&) = delete;
      basic_ios& operator=(const basic_ios&) = delete;

      void
      move(basic_ios& __rhs)
      {
 ios_base::_M_move(__rhs);
 _M_cache_locale(_M_ios_locale);
 this->tie(__rhs.tie(nullptr));
 _M_fill = __rhs._M_fill;
 _M_fill_init = __rhs._M_fill_init;
 _M_streambuf = nullptr;
      }

      void
      move(basic_ios&& __rhs)
      { this->move(__rhs); }

      void
      swap(basic_ios& __rhs) noexcept
      {
 ios_base::_M_swap(__rhs);
 _M_cache_locale(_M_ios_locale);
 __rhs._M_cache_locale(__rhs._M_ios_locale);
 std::swap(_M_tie, __rhs._M_tie);
 std::swap(_M_fill, __rhs._M_fill);
 std::swap(_M_fill_init, __rhs._M_fill_init);
      }

      void
      set_rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
      { _M_streambuf = __sb; }


      void
      _M_cache_locale(const locale& __loc);
    };


}

# 1 "/usr/local/include/c++/10.0.0/bits/basic_ios.tcc" 1 3
# 33 "/usr/local/include/c++/10.0.0/bits/basic_ios.tcc" 3
       
# 34 "/usr/local/include/c++/10.0.0/bits/basic_ios.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
# 146 "/usr/local/include/c++/10.0.0/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = std::__addressof(use_facet<__ctype_type>(__loc));
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = std::__addressof(use_facet<__num_put_type>(__loc));
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = std::__addressof(use_facet<__num_get_type>(__loc));
      else
 _M_num_get = 0;
    }




  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;




}
# 517 "/usr/local/include/c++/10.0.0/bits/basic_ios.h" 2 3
# 45 "/usr/local/include/c++/10.0.0/ios" 2 3
# 39 "/usr/local/include/c++/10.0.0/istream" 2 3
# 1 "/usr/local/include/c++/10.0.0/ostream" 1 3
# 36 "/usr/local/include/c++/10.0.0/ostream" 3
       
# 37 "/usr/local/include/c++/10.0.0/ostream" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 57 "/usr/local/include/c++/10.0.0/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
# 83 "/usr/local/include/c++/10.0.0/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 107 "/usr/local/include/c++/10.0.0/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
# 165 "/usr/local/include/c++/10.0.0/ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }
# 219 "/usr/local/include/c++/10.0.0/ostream" 3
      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }
# 244 "/usr/local/include/c++/10.0.0/ostream" 3
      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }


      __ostream_type&
      operator<<(nullptr_t)
      { return *this << "nullptr"; }
# 275 "/usr/local/include/c++/10.0.0/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 308 "/usr/local/include/c++/10.0.0/ostream" 3
      __ostream_type&
      put(char_type __c);






      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
# 340 "/usr/local/include/c++/10.0.0/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 353 "/usr/local/include/c++/10.0.0/ostream" 3
      __ostream_type&
      flush();
# 363 "/usr/local/include/c++/10.0.0/ostream" 3
      pos_type
      tellp();
# 374 "/usr/local/include/c++/10.0.0/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 386 "/usr/local/include/c++/10.0.0/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }



      basic_ostream(basic_iostream<_CharT, _Traits>&) { }

      basic_ostream(const basic_ostream&) = delete;

      basic_ostream(basic_ostream&& __rhs)
      : __ios_type()
      { __ios_type::move(__rhs); }



      basic_ostream& operator=(const basic_ostream&) = delete;

      basic_ostream&
      operator=(basic_ostream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_ostream& __rhs)
      { __ios_type::swap(__rhs); }


      template<typename _ValueT>
 __ostream_type&
 _M_insert(_ValueT __v);
    };
# 431 "/usr/local/include/c++/10.0.0/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
# 450 "/usr/local/include/c++/10.0.0/ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"







      ~sentry()
      {

 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
#pragma GCC diagnostic pop
# 482 "/usr/local/include/c++/10.0.0/ostream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 504 "/usr/local/include/c++/10.0.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template<typename _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }


  template<typename _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<typename _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }






  template<typename _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>&, wchar_t) = delete;



  template<typename _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>&, char8_t) = delete;


  template<typename _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>&, char16_t) = delete;

  template<typename _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>&, char32_t) = delete;



  template<typename _Traits>
    basic_ostream<wchar_t, _Traits>&
    operator<<(basic_ostream<wchar_t, _Traits>&, char8_t) = delete;


  template<typename _Traits>
    basic_ostream<wchar_t, _Traits>&
    operator<<(basic_ostream<wchar_t, _Traits>&, char16_t) = delete;

  template<typename _Traits>
    basic_ostream<wchar_t, _Traits>&
    operator<<(basic_ostream<wchar_t, _Traits>&, char32_t) = delete;
# 587 "/usr/local/include/c++/10.0.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<typename _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<typename _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<typename _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }






  template<typename _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>&, const wchar_t*) = delete;



  template<typename _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>&, const char8_t*) = delete;


  template<typename _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>&, const char16_t*) = delete;

  template<typename _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>&, const char32_t*) = delete;



  template<typename _Traits>
    basic_ostream<wchar_t, _Traits>&
    operator<<(basic_ostream<wchar_t, _Traits>&, const char8_t*) = delete;


  template<typename _Traits>
    basic_ostream<wchar_t, _Traits>&
    operator<<(basic_ostream<wchar_t, _Traits>&, const char16_t*) = delete;

  template<typename _Traits>
    basic_ostream<wchar_t, _Traits>&
    operator<<(basic_ostream<wchar_t, _Traits>&, const char32_t*) = delete;
# 679 "/usr/local/include/c++/10.0.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
# 691 "/usr/local/include/c++/10.0.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }


  template<typename _Ch, typename _Up>
    basic_ostream<_Ch, _Up>&
    __is_convertible_to_basic_ostream_test(basic_ostream<_Ch, _Up>*);

  template<typename _Tp, typename = void>
    struct __is_convertible_to_basic_ostream_impl
    {
      using __ostream_type = void;
    };

  template<typename _Tp>
    using __do_is_convertible_to_basic_ostream_impl =
    decltype(__is_convertible_to_basic_ostream_test
      (declval<typename remove_reference<_Tp>::type*>()));

  template<typename _Tp>
    struct __is_convertible_to_basic_ostream_impl
    <_Tp,
     __void_t<__do_is_convertible_to_basic_ostream_impl<_Tp>>>
    {
      using __ostream_type =
 __do_is_convertible_to_basic_ostream_impl<_Tp>;
    };

  template<typename _Tp>
    struct __is_convertible_to_basic_ostream
    : __is_convertible_to_basic_ostream_impl<_Tp>
    {
    public:
      using type = __not_<is_void<
        typename __is_convertible_to_basic_ostream_impl<_Tp>::__ostream_type>>;
      constexpr static bool value = type::value;
    };

  template<typename _Ostream, typename _Tp, typename = void>
    struct __is_insertable : false_type {};

  template<typename _Ostream, typename _Tp>
    struct __is_insertable<_Ostream, _Tp,
      __void_t<decltype(declval<_Ostream&>()
          << declval<const _Tp&>())>>
        : true_type {};

  template<typename _Ostream>
    using __rvalue_ostream_type =
      typename __is_convertible_to_basic_ostream<
 _Ostream>::__ostream_type;
# 765 "/usr/local/include/c++/10.0.0/ostream" 3
  template<typename _Ostream, typename _Tp>
    inline
    typename enable_if<__and_<__not_<is_lvalue_reference<_Ostream>>,
         __is_convertible_to_basic_ostream<_Ostream>,
         __is_insertable<
    __rvalue_ostream_type<_Ostream>,
    const _Tp&>>::value,
         __rvalue_ostream_type<_Ostream>>::type
    operator<<(_Ostream&& __os, const _Tp& __x)
    {
      __rvalue_ostream_type<_Ostream> __ret_os = __os;
      __ret_os << __x;
      return __ret_os;
    }



}

# 1 "/usr/local/include/c++/10.0.0/bits/ostream.tcc" 1 3
# 37 "/usr/local/include/c++/10.0.0/bits/ostream.tcc" 3
       
# 38 "/usr/local/include/c++/10.0.0/bits/ostream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   try
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);

       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }




  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);




}
# 785 "/usr/local/include/c++/10.0.0/ostream" 2 3
# 40 "/usr/local/include/c++/10.0.0/istream" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 57 "/usr/local/include/c++/10.0.0/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

    protected:





      streamsize _M_gcount;

    public:







      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 119 "/usr/local/include/c++/10.0.0/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
# 167 "/usr/local/include/c++/10.0.0/istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }
# 213 "/usr/local/include/c++/10.0.0/istream" 3
      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }
# 234 "/usr/local/include/c++/10.0.0/istream" 3
      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
# 258 "/usr/local/include/c++/10.0.0/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 268 "/usr/local/include/c++/10.0.0/istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
# 301 "/usr/local/include/c++/10.0.0/istream" 3
      int_type
      get();
# 315 "/usr/local/include/c++/10.0.0/istream" 3
      __istream_type&
      get(char_type& __c);
# 342 "/usr/local/include/c++/10.0.0/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 353 "/usr/local/include/c++/10.0.0/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 376 "/usr/local/include/c++/10.0.0/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 386 "/usr/local/include/c++/10.0.0/istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 415 "/usr/local/include/c++/10.0.0/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 426 "/usr/local/include/c++/10.0.0/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 450 "/usr/local/include/c++/10.0.0/istream" 3
      __istream_type&
      ignore(streamsize __n, int_type __delim);

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore();
# 467 "/usr/local/include/c++/10.0.0/istream" 3
      int_type
      peek();
# 485 "/usr/local/include/c++/10.0.0/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 504 "/usr/local/include/c++/10.0.0/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 521 "/usr/local/include/c++/10.0.0/istream" 3
      __istream_type&
      putback(char_type __c);
# 537 "/usr/local/include/c++/10.0.0/istream" 3
      __istream_type&
      unget();
# 555 "/usr/local/include/c++/10.0.0/istream" 3
      int
      sync();
# 570 "/usr/local/include/c++/10.0.0/istream" 3
      pos_type
      tellg();
# 585 "/usr/local/include/c++/10.0.0/istream" 3
      __istream_type&
      seekg(pos_type);
# 601 "/usr/local/include/c++/10.0.0/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }


      basic_istream(const basic_istream&) = delete;

      basic_istream(basic_istream&& __rhs)
      : __ios_type(), _M_gcount(__rhs._M_gcount)
      {
 __ios_type::move(__rhs);
 __rhs._M_gcount = 0;
      }



      basic_istream& operator=(const basic_istream&) = delete;

      basic_istream&
      operator=(basic_istream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_istream& __rhs)
      {
 __ios_type::swap(__rhs);
 std::swap(_M_gcount, __rhs._M_gcount);
      }


      template<typename _ValueT>
 __istream_type&
 _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
# 685 "/usr/local/include/c++/10.0.0/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {

      bool _M_ok;

    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 721 "/usr/local/include/c++/10.0.0/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 732 "/usr/local/include/c++/10.0.0/istream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 750 "/usr/local/include/c++/10.0.0/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
# 792 "/usr/local/include/c++/10.0.0/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);


  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
# 823 "/usr/local/include/c++/10.0.0/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }




      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }


      basic_iostream(const basic_iostream&) = delete;

      basic_iostream(basic_iostream&& __rhs)
      : __istream_type(std::move(__rhs)), __ostream_type(*this)
      { }



      basic_iostream& operator=(const basic_iostream&) = delete;

      basic_iostream&
      operator=(basic_iostream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_iostream& __rhs)
      { __istream_type::swap(__rhs); }

    };
# 906 "/usr/local/include/c++/10.0.0/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);


  template<typename _Ch, typename _Up>
    basic_istream<_Ch, _Up>&
    __is_convertible_to_basic_istream_test(basic_istream<_Ch, _Up>*);

  template<typename _Tp, typename = void>
    struct __is_convertible_to_basic_istream_impl
    {
      using __istream_type = void;
    };

  template<typename _Tp>
    using __do_is_convertible_to_basic_istream_impl =
    decltype(__is_convertible_to_basic_istream_test
      (declval<typename remove_reference<_Tp>::type*>()));

  template<typename _Tp>
    struct __is_convertible_to_basic_istream_impl
    <_Tp,
     __void_t<__do_is_convertible_to_basic_istream_impl<_Tp>>>
    {
      using __istream_type =
 __do_is_convertible_to_basic_istream_impl<_Tp>;
    };

  template<typename _Tp>
    struct __is_convertible_to_basic_istream
    : __is_convertible_to_basic_istream_impl<_Tp>
    {
    public:
      using type = __not_<is_void<
        typename __is_convertible_to_basic_istream_impl<_Tp>::__istream_type>>;
      constexpr static bool value = type::value;
    };

  template<typename _Istream, typename _Tp, typename = void>
    struct __is_extractable : false_type {};

  template<typename _Istream, typename _Tp>
    struct __is_extractable<_Istream, _Tp,
       __void_t<decltype(declval<_Istream&>()
           >> declval<_Tp>())>>
    : true_type {};

  template<typename _Istream>
    using __rvalue_istream_type =
      typename __is_convertible_to_basic_istream<
 _Istream>::__istream_type;
# 972 "/usr/local/include/c++/10.0.0/istream" 3
  template<typename _Istream, typename _Tp>
    inline
    typename enable_if<__and_<__not_<is_lvalue_reference<_Istream>>,
         __is_convertible_to_basic_istream<_Istream>,
         __is_extractable<
    __rvalue_istream_type<_Istream>,
    _Tp&&>>::value,
         __rvalue_istream_type<_Istream>>::type
    operator>>(_Istream&& __is, _Tp&& __x)
    {
      __rvalue_istream_type<_Istream> __ret_is = __is;
      __ret_is >> std::forward<_Tp>(__x);
      return __ret_is;
    }



}

# 1 "/usr/local/include/c++/10.0.0/bits/istream.tcc" 1 3
# 37 "/usr/local/include/c++/10.0.0/bits/istream.tcc" 3
       
# 38 "/usr/local/include/c++/10.0.0/bits/istream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (__in.good())
 try
   {
     if (__in.tie())
       __in.tie()->flush();
     if (!__noskip && bool(__in.flags() & ios_base::skipws))
       {
  const __int_type __eof = traits_type::eof();
  __streambuf_type* __sb = __in.rdbuf();
  __int_type __c = __sb->sgetc();

  const __ctype_type& __ct = __check_facet(__in._M_ctype);
  while (!traits_type::eq_int_type(__c, __eof)
         && __ct.is(ctype_base::space,
      traits_type::to_char_type(__c)))
    __c = __sb->snextc();




  if (traits_type::eq_int_type(__c, __eof))
    __err |= ios_base::eofbit;
       }
   }
 catch(__cxxabiv1::__forced_unwind&)
   {
     __in._M_setstate(ios_base::badbit);
     throw;
   }
 catch(...)
   { __in._M_setstate(ios_base::badbit); }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<short>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<short>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__max;
  }
       else
  __n = short(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<int>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<int>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__max;
  }
       else
  __n = int(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::failbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
# 521 "/usr/local/include/c++/10.0.0/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount
        < __gnu_cxx::__numeric_traits<streamsize>::__max)
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       if (!this->fail())
  __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
        ios_base::in);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekpos(__pos,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = __gnu_cxx::__numeric_traits<streamsize>::__max;

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }




  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;




}
# 992 "/usr/local/include/c++/10.0.0/istream" 2 3
# 39 "/usr/local/include/c++/10.0.0/sstream" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

namespace __cxx11 {
# 64 "/usr/local/include/c++/10.0.0/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
    {
      struct __xfer_bufptrs;
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_string<char_type, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

    protected:

      ios_base::openmode _M_mode;


      __string_type _M_string;

    public:
# 99 "/usr/local/include/c++/10.0.0/sstream" 3
      basic_stringbuf()
      : __streambuf_type(), _M_mode(ios_base::in | ios_base::out), _M_string()
      { }
# 110 "/usr/local/include/c++/10.0.0/sstream" 3
      explicit
      basic_stringbuf(ios_base::openmode __mode)
      : __streambuf_type(), _M_mode(__mode), _M_string()
      { }
# 123 "/usr/local/include/c++/10.0.0/sstream" 3
      explicit
      basic_stringbuf(const __string_type& __str,
        ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(),
 _M_string(__str.data(), __str.size(), __str.get_allocator())
      { _M_stringbuf_init(__mode); }


      basic_stringbuf(const basic_stringbuf&) = delete;

      basic_stringbuf(basic_stringbuf&& __rhs)
      : basic_stringbuf(std::move(__rhs), __xfer_bufptrs(__rhs, this))
      { __rhs._M_sync(const_cast<char_type*>(__rhs._M_string.data()), 0, 0); }



      basic_stringbuf&
      operator=(const basic_stringbuf&) = delete;

      basic_stringbuf&
      operator=(basic_stringbuf&& __rhs)
      {
 __xfer_bufptrs __st{__rhs, this};
 const __streambuf_type& __base = __rhs;
 __streambuf_type::operator=(__base);
 this->pubimbue(__rhs.getloc());
 _M_mode = __rhs._M_mode;
 _M_string = std::move(__rhs._M_string);
 __rhs._M_sync(const_cast<char_type*>(__rhs._M_string.data()), 0, 0);
 return *this;
      }

      void
      swap(basic_stringbuf& __rhs)
      {
 __xfer_bufptrs __l_st{*this, std::__addressof(__rhs)};
 __xfer_bufptrs __r_st{__rhs, this};
 __streambuf_type& __base = __rhs;
 __streambuf_type::swap(__base);
 __rhs.pubimbue(this->pubimbue(__rhs.getloc()));
 std::swap(_M_mode, __rhs._M_mode);
 std::swap(_M_string, __rhs._M_string);
      }
# 177 "/usr/local/include/c++/10.0.0/sstream" 3
      __string_type
      str() const
      {
 __string_type __ret(_M_string.get_allocator());
 if (this->pptr())
   {

     if (this->pptr() > this->egptr())
       __ret.assign(this->pbase(), this->pptr());
     else
       __ret.assign(this->pbase(), this->egptr());
   }
 else
   __ret = _M_string;
 return __ret;
      }
# 201 "/usr/local/include/c++/10.0.0/sstream" 3
      void
      str(const __string_type& __s)
      {


 _M_string.assign(__s.data(), __s.size());
 _M_stringbuf_init(_M_mode);
      }

    protected:

      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
 _M_mode = __mode;
 __size_type __len = 0;
 if (_M_mode & (ios_base::ate | ios_base::app))
   __len = _M_string.size();
 _M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
      }

      virtual streamsize
      showmanyc()
      {
 streamsize __ret = -1;
 if (_M_mode & ios_base::in)
   {
     _M_update_egptr();
     __ret = this->egptr() - this->gptr();
   }
 return __ret;
      }

      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = traits_type::eof());

      virtual int_type
      overflow(int_type __c = traits_type::eof());
# 254 "/usr/local/include/c++/10.0.0/sstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n)
      {
 if (__s && __n >= 0)
   {






     _M_string.clear();


     _M_sync(__s, __n, 0);
   }
 return this;
      }

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __sp,
       ios_base::openmode __mode = ios_base::in | ios_base::out);




      void
      _M_sync(char_type* __base, __size_type __i, __size_type __o);



      void
      _M_update_egptr()
      {
 const bool __testin = _M_mode & ios_base::in;
 if (this->pptr() && this->pptr() > this->egptr())
   {
     if (__testin)
       this->setg(this->eback(), this->gptr(), this->pptr());
     else
       this->setg(this->pptr(), this->pptr(), this->pptr());
   }
      }



      void
      _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off);

    private:




      struct __xfer_bufptrs
      {
 __xfer_bufptrs(const basic_stringbuf& __from, basic_stringbuf* __to)
 : _M_to{__to}, _M_goff{-1, -1, -1}, _M_poff{-1, -1, -1}
 {
   const _CharT* const __str = __from._M_string.data();
   const _CharT* __end = nullptr;
   if (__from.eback())
     {
       _M_goff[0] = __from.eback() - __str;
       _M_goff[1] = __from.gptr() - __str;
       _M_goff[2] = __from.egptr() - __str;
       __end = __from.egptr();
     }
   if (__from.pbase())
     {
       _M_poff[0] = __from.pbase() - __str;
       _M_poff[1] = __from.pptr() - __from.pbase();
       _M_poff[2] = __from.epptr() - __str;
       if (__from.pptr() > __end)
  __end = __from.pptr();
     }


   if (__end)
     {


       auto& __mut_from = const_cast<basic_stringbuf&>(__from);
       __mut_from._M_string._M_length(__end - __str);
     }
 }

 ~__xfer_bufptrs()
 {
   char_type* __str = const_cast<char_type*>(_M_to->_M_string.data());
   if (_M_goff[0] != -1)
     _M_to->setg(__str+_M_goff[0], __str+_M_goff[1], __str+_M_goff[2]);
   if (_M_poff[0] != -1)
     _M_to->_M_pbump(__str+_M_poff[0], __str+_M_poff[2], _M_poff[1]);
 }

 basic_stringbuf* _M_to;
 off_type _M_goff[3];
 off_type _M_poff[3];
      };
# 368 "/usr/local/include/c++/10.0.0/sstream" 3
      basic_stringbuf(basic_stringbuf&& __rhs, __xfer_bufptrs&&)
      : __streambuf_type(static_cast<const __streambuf_type&>(__rhs)),
      _M_mode(__rhs._M_mode), _M_string(std::move(__rhs._M_string))
      { }

    };
# 391 "/usr/local/include/c++/10.0.0/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_istringstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 425 "/usr/local/include/c++/10.0.0/sstream" 3
      basic_istringstream()
      : __istream_type(), _M_stringbuf(ios_base::in)
      { this->init(&_M_stringbuf); }
# 441 "/usr/local/include/c++/10.0.0/sstream" 3
      explicit
      basic_istringstream(ios_base::openmode __mode)
      : __istream_type(), _M_stringbuf(__mode | ios_base::in)
      { this->init(&_M_stringbuf); }
# 459 "/usr/local/include/c++/10.0.0/sstream" 3
      explicit
      basic_istringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }







      ~basic_istringstream()
      { }


      basic_istringstream(const basic_istringstream&) = delete;

      basic_istringstream(basic_istringstream&& __rhs)
      : __istream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __istream_type::set_rdbuf(&_M_stringbuf); }



      basic_istringstream&
      operator=(const basic_istringstream&) = delete;

      basic_istringstream&
      operator=(basic_istringstream&& __rhs)
      {
 __istream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_istringstream& __rhs)
      {
 __istream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 510 "/usr/local/include/c++/10.0.0/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 549 "/usr/local/include/c++/10.0.0/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_ostringstream : public basic_ostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 583 "/usr/local/include/c++/10.0.0/sstream" 3
      basic_ostringstream()
      : __ostream_type(), _M_stringbuf(ios_base::out)
      { this->init(&_M_stringbuf); }
# 599 "/usr/local/include/c++/10.0.0/sstream" 3
      explicit
      basic_ostringstream(ios_base::openmode __mode)
      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)
      { this->init(&_M_stringbuf); }
# 617 "/usr/local/include/c++/10.0.0/sstream" 3
      explicit
      basic_ostringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)
      { this->init(&_M_stringbuf); }







      ~basic_ostringstream()
      { }


      basic_ostringstream(const basic_ostringstream&) = delete;

      basic_ostringstream(basic_ostringstream&& __rhs)
      : __ostream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __ostream_type::set_rdbuf(&_M_stringbuf); }



      basic_ostringstream&
      operator=(const basic_ostringstream&) = delete;

      basic_ostringstream&
      operator=(basic_ostringstream&& __rhs)
      {
 __ostream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_ostringstream& __rhs)
      {
 __ostream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 668 "/usr/local/include/c++/10.0.0/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 707 "/usr/local/include/c++/10.0.0/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 741 "/usr/local/include/c++/10.0.0/sstream" 3
      basic_stringstream()
      : __iostream_type(), _M_stringbuf(ios_base::out | ios_base::in)
      { this->init(&_M_stringbuf); }
# 755 "/usr/local/include/c++/10.0.0/sstream" 3
      explicit
      basic_stringstream(ios_base::openmode __m)
      : __iostream_type(), _M_stringbuf(__m)
      { this->init(&_M_stringbuf); }
# 771 "/usr/local/include/c++/10.0.0/sstream" 3
      explicit
      basic_stringstream(const __string_type& __str,
    ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__str, __m)
      { this->init(&_M_stringbuf); }







      ~basic_stringstream()
      { }


      basic_stringstream(const basic_stringstream&) = delete;

      basic_stringstream(basic_stringstream&& __rhs)
      : __iostream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __iostream_type::set_rdbuf(&_M_stringbuf); }



      basic_stringstream&
      operator=(const basic_stringstream&) = delete;

      basic_stringstream&
      operator=(basic_stringstream&& __rhs)
      {
 __iostream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_stringstream& __rhs)
      {
 __iostream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 822 "/usr/local/include/c++/10.0.0/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };



  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_stringbuf<_CharT, _Traits, _Allocator>& __x,
  basic_stringbuf<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_istringstream<_CharT, _Traits, _Allocator>& __x,
  basic_istringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_ostringstream<_CharT, _Traits, _Allocator>& __x,
  basic_ostringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_stringstream<_CharT, _Traits, _Allocator>& __x,
  basic_stringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


}

}

# 1 "/usr/local/include/c++/10.0.0/bits/sstream.tcc" 1 3
# 37 "/usr/local/include/c++/10.0.0/bits/sstream.tcc" 3
       
# 38 "/usr/local/include/c++/10.0.0/bits/sstream.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    pbackfail(int_type __c)
    {
      int_type __ret = traits_type::eof();
      if (this->eback() < this->gptr())
 {


   const bool __testeof = traits_type::eq_int_type(__c, __ret);
   if (!__testeof)
     {
       const bool __testeq = traits_type::eq(traits_type::
          to_char_type(__c),
          this->gptr()[-1]);
       const bool __testout = this->_M_mode & ios_base::out;
       if (__testeq || __testout)
  {
    this->gbump(-1);
    if (!__testeq)
      *this->gptr() = traits_type::to_char_type(__c);
    __ret = __c;
  }
     }
   else
     {
       this->gbump(-1);
       __ret = traits_type::not_eof(__c);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    overflow(int_type __c)
    {
      const bool __testout = this->_M_mode & ios_base::out;
      if (__builtin_expect(!__testout, false))
 return traits_type::eof();

      const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());
      if (__builtin_expect(__testeof, false))
 return traits_type::not_eof(__c);

      const __size_type __capacity = _M_string.capacity();


      if ((this->epptr() - this->pbase()) < __capacity)
 {

   char_type* __base = const_cast<char_type*>(_M_string.data());
   _M_pbump(__base, __base + __capacity, this->pptr() - this->pbase());
   if (_M_mode & ios_base::in)
     {
       const __size_type __nget = this->gptr() - this->eback();
       const __size_type __eget = this->egptr() - this->eback();
       this->setg(__base, __base + __nget, __base + __eget + 1);
     }
   *this->pptr() = traits_type::to_char_type(__c);
   this->pbump(1);
   return __c;
 }


      const __size_type __max_size = _M_string.max_size();
      const bool __testput = this->pptr() < this->epptr();
      if (__builtin_expect(!__testput && __capacity == __max_size, false))
 return traits_type::eof();



      const char_type __conv = traits_type::to_char_type(__c);
      if (!__testput)
 {
# 129 "/usr/local/include/c++/10.0.0/bits/sstream.tcc" 3
   const __size_type __opt_len = std::max(__size_type(2 * __capacity),
       __size_type(512));
   const __size_type __len = std::min(__opt_len, __max_size);
   __string_type __tmp(_M_string.get_allocator());
   __tmp.reserve(__len);
   if (this->pbase())
     __tmp.assign(this->pbase(), this->epptr() - this->pbase());
   __tmp.push_back(__conv);
   _M_string.swap(__tmp);
   _M_sync(const_cast<char_type*>(_M_string.data()),
    this->gptr() - this->eback(), this->pptr() - this->pbase());
 }
      else
 *this->pptr() = __conv;
      this->pbump(1);
      return __c;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin)
 {

   _M_update_egptr();

   if (this->gptr() < this->egptr())
     __ret = traits_type::to_int_type(*this->gptr());
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
      const bool __testboth = __testin && __testout && __way != ios_base::cur;
      __testin &= !(__mode & ios_base::out);
      __testout &= !(__mode & ios_base::in);



      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !__off) && (__testin || __testout || __testboth))
 {
   _M_update_egptr();

   off_type __newoffi = __off;
   off_type __newoffo = __newoffi;
   if (__way == ios_base::cur)
     {
       __newoffi += this->gptr() - __beg;
       __newoffo += this->pptr() - __beg;
     }
   else if (__way == ios_base::end)
     __newoffo = __newoffi += this->egptr() - __beg;

   if ((__testin || __testboth)
       && __newoffi >= 0
       && this->egptr() - __beg >= __newoffi)
     {
       this->setg(this->eback(), this->eback() + __newoffi,
    this->egptr());
       __ret = pos_type(__newoffi);
     }
   if ((__testout || __testboth)
       && __newoffo >= 0
       && this->egptr() - __beg >= __newoffo)
     {
       _M_pbump(this->pbase(), this->epptr(), __newoffo);
       __ret = pos_type(__newoffo);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekpos(pos_type __sp, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;

      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !off_type(__sp)) && (__testin || __testout))
 {
   _M_update_egptr();

   const off_type __pos(__sp);
   const bool __testpos = (0 <= __pos
      && __pos <= this->egptr() - __beg);
   if (__testpos)
     {
       if (__testin)
  this->setg(this->eback(), this->eback() + __pos,
      this->egptr());
       if (__testout)
  _M_pbump(this->pbase(), this->epptr(), __pos);
       __ret = __sp;
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_sync(char_type* __base, __size_type __i, __size_type __o)
    {
      const bool __testin = _M_mode & ios_base::in;
      const bool __testout = _M_mode & ios_base::out;
      char_type* __endg = __base + _M_string.size();
      char_type* __endp = __base + _M_string.capacity();

      if (__base != _M_string.data())
 {

   __endg += __i;
   __i = 0;
   __endp = __endg;
 }

      if (__testin)
 this->setg(__base, __base + __i, __endg);
      if (__testout)
 {
   _M_pbump(__base, __endp, __o);



   if (!__testin)
     this->setg(__endg, __endg, __endg);
 }
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off)
    {
      this->setp(__pbeg, __pend);
      while (__off > __gnu_cxx::__numeric_traits<int>::__max)
 {
   this->pbump(__gnu_cxx::__numeric_traits<int>::__max);
   __off -= __gnu_cxx::__numeric_traits<int>::__max;
 }
      this->pbump(__off);
    }




  extern template class basic_stringbuf<char>;
  extern template class basic_istringstream<char>;
  extern template class basic_ostringstream<char>;
  extern template class basic_stringstream<char>;


  extern template class basic_stringbuf<wchar_t>;
  extern template class basic_istringstream<wchar_t>;
  extern template class basic_ostringstream<wchar_t>;
  extern template class basic_stringstream<wchar_t>;




}
# 880 "/usr/local/include/c++/10.0.0/sstream" 2 3
# 46 "/usr/local/include/c++/10.0.0/complex" 2 3
# 54 "/usr/local/include/c++/10.0.0/complex" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 67 "/usr/local/include/c++/10.0.0/complex" 3
  template<typename _Tp> class complex;
  template<> class complex<float>;
  template<> class complex<double>;
  template<> class complex<long double>;


  template<typename _Tp> _Tp abs(const complex<_Tp>&);

  template<typename _Tp> _Tp arg(const complex<_Tp>&);

  template<typename _Tp> _Tp constexpr norm(const complex<_Tp>&);


  template<typename _Tp>
    constexpr complex<_Tp> conj(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> polar(const _Tp&, const _Tp& = 0);



  template<typename _Tp> complex<_Tp> cos(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> cosh(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> exp(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> log(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> log10(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, int);

  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, const _Tp&);

  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&,
                                          const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> pow(const _Tp&, const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> sin(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> sinh(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> sqrt(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> tan(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> tanh(const complex<_Tp>&);
# 126 "/usr/local/include/c++/10.0.0/complex" 3
  template<typename _Tp>
    struct complex
    {

      typedef _Tp value_type;



      constexpr complex(const _Tp& __r = _Tp(), const _Tp& __i = _Tp())
      : _M_real(__r), _M_imag(__i) { }



      constexpr complex(const complex&) = default;



      template<typename _Up>
        constexpr complex(const complex<_Up>& __z)
 : _M_real(__z.real()), _M_imag(__z.imag()) { }




      __attribute ((__abi_tag__ ("cxx11")))
      constexpr _Tp
      real() const { return _M_real; }

      __attribute ((__abi_tag__ ("cxx11")))
      constexpr _Tp
      imag() const { return _M_imag; }
# 177 "/usr/local/include/c++/10.0.0/complex" 3
      constexpr void
      real(_Tp __val) { _M_real = __val; }

      constexpr void
      imag(_Tp __val) { _M_imag = __val; }


      constexpr complex<_Tp>& operator=(const _Tp&);



      constexpr complex<_Tp>&
      operator+=(const _Tp& __t)
      {
 _M_real += __t;
 return *this;
      }



      constexpr complex<_Tp>&
      operator-=(const _Tp& __t)
      {
 _M_real -= __t;
 return *this;
      }


      constexpr complex<_Tp>& operator*=(const _Tp&);

      constexpr complex<_Tp>& operator/=(const _Tp&);



      constexpr complex& operator=(const complex&) = default;



      template<typename _Up>
        constexpr complex<_Tp>& operator=(const complex<_Up>&);

      template<typename _Up>
        constexpr complex<_Tp>& operator+=(const complex<_Up>&);

      template<typename _Up>
        constexpr complex<_Tp>& operator-=(const complex<_Up>&);

      template<typename _Up>
        constexpr complex<_Tp>& operator*=(const complex<_Up>&);

      template<typename _Up>
        constexpr complex<_Tp>& operator/=(const complex<_Up>&);

      constexpr complex __rep() const
      { return *this; }

    private:
      _Tp _M_real;
      _Tp _M_imag;
    };

  template<typename _Tp>
    constexpr complex<_Tp>&
    complex<_Tp>::operator=(const _Tp& __t)
    {
     _M_real = __t;
     _M_imag = _Tp();
     return *this;
    }


  template<typename _Tp>
    constexpr complex<_Tp>&
    complex<_Tp>::operator*=(const _Tp& __t)
    {
      _M_real *= __t;
      _M_imag *= __t;
      return *this;
    }


  template<typename _Tp>
    constexpr complex<_Tp>&
    complex<_Tp>::operator/=(const _Tp& __t)
    {
      _M_real /= __t;
      _M_imag /= __t;
      return *this;
    }

  template<typename _Tp>
    template<typename _Up>
    constexpr complex<_Tp>&
    complex<_Tp>::operator=(const complex<_Up>& __z)
    {
      _M_real = __z.real();
      _M_imag = __z.imag();
      return *this;
    }


  template<typename _Tp>
    template<typename _Up>
    constexpr complex<_Tp>&
    complex<_Tp>::operator+=(const complex<_Up>& __z)
    {
      _M_real += __z.real();
      _M_imag += __z.imag();
      return *this;
    }


  template<typename _Tp>
    template<typename _Up>
    constexpr complex<_Tp>&
    complex<_Tp>::operator-=(const complex<_Up>& __z)
    {
      _M_real -= __z.real();
      _M_imag -= __z.imag();
      return *this;
    }



  template<typename _Tp>
    template<typename _Up>
    constexpr complex<_Tp>&
    complex<_Tp>::operator*=(const complex<_Up>& __z)
    {
      const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
      _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
      _M_real = __r;
      return *this;
    }



  template<typename _Tp>
    template<typename _Up>
    constexpr complex<_Tp>&
    complex<_Tp>::operator/=(const complex<_Up>& __z)
    {
      const _Tp __r = _M_real * __z.real() + _M_imag * __z.imag();
      const _Tp __n = std::norm(__z);
      _M_imag = (_M_imag * __z.real() - _M_real * __z.imag()) / __n;
      _M_real = __r / __n;
      return *this;
    }




  template<typename _Tp>
    inline constexpr complex<_Tp>
    operator+(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r += __y;
      return __r;
    }

  template<typename _Tp>
    inline constexpr complex<_Tp>
    operator+(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r += __y;
      return __r;
    }

  template<typename _Tp>
    inline constexpr complex<_Tp>
    operator+(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __y;
      __r += __x;
      return __r;
    }




  template<typename _Tp>
    inline constexpr complex<_Tp>
    operator-(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r -= __y;
      return __r;
    }

  template<typename _Tp>
    inline constexpr complex<_Tp>
    operator-(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r -= __y;
      return __r;
    }

  template<typename _Tp>
    inline constexpr complex<_Tp>
    operator-(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = -__y;
      __r += __x;
      return __r;
    }




  template<typename _Tp>
    inline constexpr complex<_Tp>
    operator*(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r *= __y;
      return __r;
    }

  template<typename _Tp>
    inline constexpr complex<_Tp>
    operator*(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r *= __y;
      return __r;
    }

  template<typename _Tp>
    inline constexpr complex<_Tp>
    operator*(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __y;
      __r *= __x;
      return __r;
    }




  template<typename _Tp>
    inline constexpr complex<_Tp>
    operator/(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r /= __y;
      return __r;
    }

  template<typename _Tp>
    inline constexpr complex<_Tp>
    operator/(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r /= __y;
      return __r;
    }

  template<typename _Tp>
    inline constexpr complex<_Tp>
    operator/(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r /= __y;
      return __r;
    }



  template<typename _Tp>
    inline constexpr complex<_Tp>
    operator+(const complex<_Tp>& __x)
    { return __x; }


  template<typename _Tp>
    inline constexpr complex<_Tp>
    operator-(const complex<_Tp>& __x)
    { return complex<_Tp>(-__x.real(), -__x.imag()); }



  template<typename _Tp>
    inline constexpr bool
    operator==(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __x.real() == __y.real() && __x.imag() == __y.imag(); }

  template<typename _Tp>
    inline constexpr bool
    operator==(const complex<_Tp>& __x, const _Tp& __y)
    { return __x.real() == __y && __x.imag() == _Tp(); }

  template<typename _Tp>
    inline constexpr bool
    operator==(const _Tp& __x, const complex<_Tp>& __y)
    { return __x == __y.real() && _Tp() == __y.imag(); }




  template<typename _Tp>
    inline constexpr bool
    operator!=(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __x.real() != __y.real() || __x.imag() != __y.imag(); }

  template<typename _Tp>
    inline constexpr bool
    operator!=(const complex<_Tp>& __x, const _Tp& __y)
    { return __x.real() != __y || __x.imag() != _Tp(); }

  template<typename _Tp>
    inline constexpr bool
    operator!=(const _Tp& __x, const complex<_Tp>& __y)
    { return __x != __y.real() || _Tp() != __y.imag(); }



  template<typename _Tp, typename _CharT, class _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, complex<_Tp>& __x)
    {
      bool __fail = true;
      _CharT __ch;
      if (__is >> __ch)
 {
   if (_Traits::eq(__ch, __is.widen('(')))
     {
       _Tp __u;
       if (__is >> __u >> __ch)
  {
    const _CharT __rparen = __is.widen(')');
    if (_Traits::eq(__ch, __rparen))
      {
        __x = __u;
        __fail = false;
      }
    else if (_Traits::eq(__ch, __is.widen(',')))
      {
        _Tp __v;
        if (__is >> __v >> __ch)
   {
     if (_Traits::eq(__ch, __rparen))
       {
         __x = complex<_Tp>(__u, __v);
         __fail = false;
       }
     else
       __is.putback(__ch);
   }
      }
    else
      __is.putback(__ch);
  }
     }
   else
     {
       __is.putback(__ch);
       _Tp __u;
       if (__is >> __u)
  {
    __x = __u;
    __fail = false;
  }
     }
 }
      if (__fail)
 __is.setstate(ios_base::failbit);
      return __is;
    }


  template<typename _Tp, typename _CharT, class _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const complex<_Tp>& __x)
    {
      basic_ostringstream<_CharT, _Traits> __s;
      __s.flags(__os.flags());
      __s.imbue(__os.getloc());
      __s.precision(__os.precision());
      __s << '(' << __x.real() << ',' << __x.imag() << ')';
      return __os << __s.str();
    }



  template<typename _Tp>
    constexpr _Tp
    real(const complex<_Tp>& __z)
    { return __z.real(); }

  template<typename _Tp>
    constexpr _Tp
    imag(const complex<_Tp>& __z)
    { return __z.imag(); }
# 596 "/usr/local/include/c++/10.0.0/complex" 3
  template<typename _Tp>
    inline _Tp
    __complex_abs(const complex<_Tp>& __z)
    {
      _Tp __x = __z.real();
      _Tp __y = __z.imag();
      const _Tp __s = std::max(abs(__x), abs(__y));
      if (__s == _Tp())
        return __s;
      __x /= __s;
      __y /= __s;
      return __s * sqrt(__x * __x + __y * __y);
    }


  inline float
  __complex_abs(__complex__ float __z) { return __builtin_cabsf(__z); }

  inline double
  __complex_abs(__complex__ double __z) { return __builtin_cabs(__z); }

  inline long double
  __complex_abs(const __complex__ long double& __z)
  { return __builtin_cabsl(__z); }

  template<typename _Tp>
    inline _Tp
    abs(const complex<_Tp>& __z) { return __complex_abs(__z.__rep()); }
# 632 "/usr/local/include/c++/10.0.0/complex" 3
  template<typename _Tp>
    inline _Tp
    __complex_arg(const complex<_Tp>& __z)
    { return atan2(__z.imag(), __z.real()); }


  inline float
  __complex_arg(__complex__ float __z) { return __builtin_cargf(__z); }

  inline double
  __complex_arg(__complex__ double __z) { return __builtin_carg(__z); }

  inline long double
  __complex_arg(const __complex__ long double& __z)
  { return __builtin_cargl(__z); }

  template<typename _Tp>
    inline _Tp
    arg(const complex<_Tp>& __z) { return __complex_arg(__z.__rep()); }
# 662 "/usr/local/include/c++/10.0.0/complex" 3
  template<bool>
    struct _Norm_helper
    {
      template<typename _Tp>
        static inline constexpr _Tp _S_do_it(const complex<_Tp>& __z)
        {
          const _Tp __x = __z.real();
          const _Tp __y = __z.imag();
          return __x * __x + __y * __y;
        }
    };

  template<>
    struct _Norm_helper<true>
    {
      template<typename _Tp>
        static inline constexpr _Tp _S_do_it(const complex<_Tp>& __z)
        {


          const _Tp __x = __z.real();
          const _Tp __y = __z.imag();
          return __x * __x + __y * __y;
        }
    };

  template<typename _Tp>
    inline constexpr _Tp
    norm(const complex<_Tp>& __z)
    {
      return _Norm_helper<__is_floating<_Tp>::__value
 && !0>::_S_do_it(__z);
    }

  template<typename _Tp>
    inline complex<_Tp>
    polar(const _Tp& __rho, const _Tp& __theta)
    {
      ;
      return complex<_Tp>(__rho * cos(__theta), __rho * sin(__theta));
    }

  template<typename _Tp>
    inline constexpr complex<_Tp>
    conj(const complex<_Tp>& __z)
    { return complex<_Tp>(__z.real(), -__z.imag()); }




  template<typename _Tp>
    inline complex<_Tp>
    __complex_cos(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(cos(__x) * cosh(__y), -sin(__x) * sinh(__y));
    }


  inline __complex__ float
  __complex_cos(__complex__ float __z) { return __builtin_ccosf(__z); }

  inline __complex__ double
  __complex_cos(__complex__ double __z) { return __builtin_ccos(__z); }

  inline __complex__ long double
  __complex_cos(const __complex__ long double& __z)
  { return __builtin_ccosl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    cos(const complex<_Tp>& __z) { return __complex_cos(__z.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    __complex_cosh(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(cosh(__x) * cos(__y), sinh(__x) * sin(__y));
    }


  inline __complex__ float
  __complex_cosh(__complex__ float __z) { return __builtin_ccoshf(__z); }

  inline __complex__ double
  __complex_cosh(__complex__ double __z) { return __builtin_ccosh(__z); }

  inline __complex__ long double
  __complex_cosh(const __complex__ long double& __z)
  { return __builtin_ccoshl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    cosh(const complex<_Tp>& __z) { return __complex_cosh(__z.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    __complex_exp(const complex<_Tp>& __z)
    { return std::polar<_Tp>(exp(__z.real()), __z.imag()); }


  inline __complex__ float
  __complex_exp(__complex__ float __z) { return __builtin_cexpf(__z); }

  inline __complex__ double
  __complex_exp(__complex__ double __z) { return __builtin_cexp(__z); }

  inline __complex__ long double
  __complex_exp(const __complex__ long double& __z)
  { return __builtin_cexpl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    exp(const complex<_Tp>& __z) { return __complex_exp(__z.__rep()); }
# 799 "/usr/local/include/c++/10.0.0/complex" 3
  template<typename _Tp>
    inline complex<_Tp>
    __complex_log(const complex<_Tp>& __z)
    { return complex<_Tp>(log(std::abs(__z)), std::arg(__z)); }


  inline __complex__ float
  __complex_log(__complex__ float __z) { return __builtin_clogf(__z); }

  inline __complex__ double
  __complex_log(__complex__ double __z) { return __builtin_clog(__z); }

  inline __complex__ long double
  __complex_log(const __complex__ long double& __z)
  { return __builtin_clogl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    log(const complex<_Tp>& __z) { return __complex_log(__z.__rep()); }






  template<typename _Tp>
    inline complex<_Tp>
    log10(const complex<_Tp>& __z)
    { return std::log(__z) / log(_Tp(10.0)); }


  template<typename _Tp>
    inline complex<_Tp>
    __complex_sin(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(sin(__x) * cosh(__y), cos(__x) * sinh(__y));
    }


  inline __complex__ float
  __complex_sin(__complex__ float __z) { return __builtin_csinf(__z); }

  inline __complex__ double
  __complex_sin(__complex__ double __z) { return __builtin_csin(__z); }

  inline __complex__ long double
  __complex_sin(const __complex__ long double& __z)
  { return __builtin_csinl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    sin(const complex<_Tp>& __z) { return __complex_sin(__z.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    __complex_sinh(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(sinh(__x) * cos(__y), cosh(__x) * sin(__y));
    }


  inline __complex__ float
  __complex_sinh(__complex__ float __z) { return __builtin_csinhf(__z); }

  inline __complex__ double
  __complex_sinh(__complex__ double __z) { return __builtin_csinh(__z); }

  inline __complex__ long double
  __complex_sinh(const __complex__ long double& __z)
  { return __builtin_csinhl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    sinh(const complex<_Tp>& __z) { return __complex_sinh(__z.__rep()); }
# 891 "/usr/local/include/c++/10.0.0/complex" 3
  template<typename _Tp>
    complex<_Tp>
    __complex_sqrt(const complex<_Tp>& __z)
    {
      _Tp __x = __z.real();
      _Tp __y = __z.imag();

      if (__x == _Tp())
        {
          _Tp __t = sqrt(abs(__y) / 2);
          return complex<_Tp>(__t, __y < _Tp() ? -__t : __t);
        }
      else
        {
          _Tp __t = sqrt(2 * (std::abs(__z) + abs(__x)));
          _Tp __u = __t / 2;
          return __x > _Tp()
            ? complex<_Tp>(__u, __y / __t)
            : complex<_Tp>(abs(__y) / __t, __y < _Tp() ? -__u : __u);
        }
    }


  inline __complex__ float
  __complex_sqrt(__complex__ float __z) { return __builtin_csqrtf(__z); }

  inline __complex__ double
  __complex_sqrt(__complex__ double __z) { return __builtin_csqrt(__z); }

  inline __complex__ long double
  __complex_sqrt(const __complex__ long double& __z)
  { return __builtin_csqrtl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    sqrt(const complex<_Tp>& __z) { return __complex_sqrt(__z.__rep()); }
# 935 "/usr/local/include/c++/10.0.0/complex" 3
  template<typename _Tp>
    inline complex<_Tp>
    __complex_tan(const complex<_Tp>& __z)
    { return std::sin(__z) / std::cos(__z); }


  inline __complex__ float
  __complex_tan(__complex__ float __z) { return __builtin_ctanf(__z); }

  inline __complex__ double
  __complex_tan(__complex__ double __z) { return __builtin_ctan(__z); }

  inline __complex__ long double
  __complex_tan(const __complex__ long double& __z)
  { return __builtin_ctanl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    tan(const complex<_Tp>& __z) { return __complex_tan(__z.__rep()); }
# 963 "/usr/local/include/c++/10.0.0/complex" 3
  template<typename _Tp>
    inline complex<_Tp>
    __complex_tanh(const complex<_Tp>& __z)
    { return std::sinh(__z) / std::cosh(__z); }


  inline __complex__ float
  __complex_tanh(__complex__ float __z) { return __builtin_ctanhf(__z); }

  inline __complex__ double
  __complex_tanh(__complex__ double __z) { return __builtin_ctanh(__z); }

  inline __complex__ long double
  __complex_tanh(const __complex__ long double& __z)
  { return __builtin_ctanhl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    tanh(const complex<_Tp>& __z) { return __complex_tanh(__z.__rep()); }
# 992 "/usr/local/include/c++/10.0.0/complex" 3
  template<typename _Tp>
    complex<_Tp>
    __complex_pow_unsigned(complex<_Tp> __x, unsigned __n)
    {
      complex<_Tp> __y = __n % 2 ? __x : complex<_Tp>(1);

      while (__n >>= 1)
        {
          __x *= __x;
          if (__n % 2)
            __y *= __x;
        }

      return __y;
    }







  template<typename _Tp>
    inline complex<_Tp>
    pow(const complex<_Tp>& __z, int __n)
    {
      return __n < 0
 ? complex<_Tp>(1) / std::__complex_pow_unsigned(__z, -(unsigned)__n)
        : std::__complex_pow_unsigned(__z, __n);
    }

  template<typename _Tp>
    complex<_Tp>
    pow(const complex<_Tp>& __x, const _Tp& __y)
    {




      if (__x.imag() == _Tp() && __x.real() > _Tp())
        return pow(__x.real(), __y);

      complex<_Tp> __t = std::log(__x);
      return std::polar<_Tp>(exp(__y * __t.real()), __y * __t.imag());
    }

  template<typename _Tp>
    inline complex<_Tp>
    __complex_pow(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __x == _Tp() ? _Tp() : std::exp(__y * std::log(__x)); }


  inline __complex__ float
  __complex_pow(__complex__ float __x, __complex__ float __y)
  { return __builtin_cpowf(__x, __y); }

  inline __complex__ double
  __complex_pow(__complex__ double __x, __complex__ double __y)
  { return __builtin_cpow(__x, __y); }

  inline __complex__ long double
  __complex_pow(const __complex__ long double& __x,
  const __complex__ long double& __y)
  { return __builtin_cpowl(__x, __y); }

  template<typename _Tp>
    inline complex<_Tp>
    pow(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __complex_pow(__x.__rep(), __y.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    pow(const _Tp& __x, const complex<_Tp>& __y)
    {
      return __x > _Tp() ? std::polar<_Tp>(pow(__x, __y.real()),
        __y.imag() * log(__x))
                  : std::pow(complex<_Tp>(__x), __y);
    }



  template<>
    struct complex<float>
    {
      typedef float value_type;
      typedef __complex__ float _ComplexT;

      constexpr complex(_ComplexT __z) : _M_value(__z) { }

      constexpr complex(float __r = 0.0f, float __i = 0.0f)

      : _M_value{ __r, __i } { }







      explicit constexpr complex(const complex<double>&);
      explicit constexpr complex(const complex<long double>&);




      __attribute ((__abi_tag__ ("cxx11")))
      constexpr float
      real() const { return __real__ _M_value; }

      __attribute ((__abi_tag__ ("cxx11")))
      constexpr float
      imag() const { return __imag__ _M_value; }
# 1126 "/usr/local/include/c++/10.0.0/complex" 3
      constexpr void
      real(float __val) { __real__ _M_value = __val; }

      constexpr void
      imag(float __val) { __imag__ _M_value = __val; }

      constexpr complex&
      operator=(float __f)
      {
 _M_value = __f;
 return *this;
      }

      constexpr complex&
      operator+=(float __f)
      {
 _M_value += __f;
 return *this;
      }

      constexpr complex&
      operator-=(float __f)
      {
 _M_value -= __f;
 return *this;
      }

      constexpr complex&
      operator*=(float __f)
      {
 _M_value *= __f;
 return *this;
      }

      constexpr complex&
      operator/=(float __f)
      {
 _M_value /= __f;
 return *this;
      }




      constexpr complex& operator=(const complex&) = default;


      template<typename _Tp>
        constexpr complex&
        operator=(const complex<_Tp>& __z)
 {
   __real__ _M_value = __z.real();
   __imag__ _M_value = __z.imag();
   return *this;
 }

      template<typename _Tp>
        constexpr complex&
        operator+=(const complex<_Tp>& __z)
 {
   _M_value += __z.__rep();
   return *this;
 }

      template<class _Tp>
        constexpr complex&
        operator-=(const complex<_Tp>& __z)
 {
   _M_value -= __z.__rep();
   return *this;
 }

      template<class _Tp>
        constexpr complex&
        operator*=(const complex<_Tp>& __z)
 {
   const _ComplexT __t = __z.__rep();
   _M_value *= __t;
   return *this;
 }

      template<class _Tp>
        constexpr complex&
        operator/=(const complex<_Tp>& __z)
 {
   const _ComplexT __t = __z.__rep();
   _M_value /= __t;
   return *this;
 }

      constexpr _ComplexT __rep() const { return _M_value; }

    private:
      _ComplexT _M_value;
    };



  template<>
    struct complex<double>
    {
      typedef double value_type;
      typedef __complex__ double _ComplexT;

      constexpr complex(_ComplexT __z) : _M_value(__z) { }

      constexpr complex(double __r = 0.0, double __i = 0.0)

      : _M_value{ __r, __i } { }







      constexpr complex(const complex<float>& __z)
      : _M_value(__z.__rep()) { }

      explicit constexpr complex(const complex<long double>&);




      __attribute ((__abi_tag__ ("cxx11")))
      constexpr double
      real() const { return __real__ _M_value; }

      __attribute ((__abi_tag__ ("cxx11")))
      constexpr double
      imag() const { return __imag__ _M_value; }
# 1273 "/usr/local/include/c++/10.0.0/complex" 3
      constexpr void
      real(double __val) { __real__ _M_value = __val; }

      constexpr void
      imag(double __val) { __imag__ _M_value = __val; }

      constexpr complex&
      operator=(double __d)
      {
 _M_value = __d;
 return *this;
      }

      constexpr complex&
      operator+=(double __d)
      {
 _M_value += __d;
 return *this;
      }

      constexpr complex&
      operator-=(double __d)
      {
 _M_value -= __d;
 return *this;
      }

      constexpr complex&
      operator*=(double __d)
      {
 _M_value *= __d;
 return *this;
      }

      constexpr complex&
      operator/=(double __d)
      {
 _M_value /= __d;
 return *this;
      }



      constexpr complex& operator=(const complex&) = default;


      template<typename _Tp>
        constexpr complex&
        operator=(const complex<_Tp>& __z)
 {
   _M_value = __z.__rep();
   return *this;
 }

      template<typename _Tp>
        constexpr complex&
        operator+=(const complex<_Tp>& __z)
 {
   _M_value += __z.__rep();
   return *this;
 }

      template<typename _Tp>
        constexpr complex&
        operator-=(const complex<_Tp>& __z)
 {
   _M_value -= __z.__rep();
   return *this;
 }

      template<typename _Tp>
        constexpr complex&
        operator*=(const complex<_Tp>& __z)
 {
   const _ComplexT __t = __z.__rep();
   _M_value *= __t;
   return *this;
 }

      template<typename _Tp>
        constexpr complex&
        operator/=(const complex<_Tp>& __z)
 {
   const _ComplexT __t = __z.__rep();
   _M_value /= __t;
   return *this;
 }

      constexpr _ComplexT __rep() const { return _M_value; }

    private:
      _ComplexT _M_value;
    };



  template<>
    struct complex<long double>
    {
      typedef long double value_type;
      typedef __complex__ long double _ComplexT;

      constexpr complex(_ComplexT __z) : _M_value(__z) { }

      constexpr complex(long double __r = 0.0L,
     long double __i = 0.0L)

      : _M_value{ __r, __i } { }







      constexpr complex(const complex<float>& __z)
      : _M_value(__z.__rep()) { }

      constexpr complex(const complex<double>& __z)
      : _M_value(__z.__rep()) { }




      __attribute ((__abi_tag__ ("cxx11")))
      constexpr long double
      real() const { return __real__ _M_value; }

      __attribute ((__abi_tag__ ("cxx11")))
      constexpr long double
      imag() const { return __imag__ _M_value; }
# 1420 "/usr/local/include/c++/10.0.0/complex" 3
      constexpr void
      real(long double __val) { __real__ _M_value = __val; }

      constexpr void
      imag(long double __val) { __imag__ _M_value = __val; }

      constexpr complex&
      operator=(long double __r)
      {
 _M_value = __r;
 return *this;
      }

      constexpr complex&
      operator+=(long double __r)
      {
 _M_value += __r;
 return *this;
      }

      constexpr complex&
      operator-=(long double __r)
      {
 _M_value -= __r;
 return *this;
      }

      constexpr complex&
      operator*=(long double __r)
      {
 _M_value *= __r;
 return *this;
      }

      constexpr complex&
      operator/=(long double __r)
      {
 _M_value /= __r;
 return *this;
      }



      constexpr complex& operator=(const complex&) = default;


      template<typename _Tp>
        constexpr complex&
        operator=(const complex<_Tp>& __z)
 {
   _M_value = __z.__rep();
   return *this;
 }

      template<typename _Tp>
        constexpr complex&
 operator+=(const complex<_Tp>& __z)
 {
   _M_value += __z.__rep();
   return *this;
 }

      template<typename _Tp>
        constexpr complex&
 operator-=(const complex<_Tp>& __z)
 {
   _M_value -= __z.__rep();
   return *this;
 }

      template<typename _Tp>
        constexpr complex&
 operator*=(const complex<_Tp>& __z)
 {
   const _ComplexT __t = __z.__rep();
   _M_value *= __t;
   return *this;
 }

      template<typename _Tp>
        constexpr complex&
 operator/=(const complex<_Tp>& __z)
 {
   const _ComplexT __t = __z.__rep();
   _M_value /= __t;
   return *this;
 }

      constexpr _ComplexT __rep() const { return _M_value; }

    private:
      _ComplexT _M_value;
    };



  inline constexpr
  complex<float>::complex(const complex<double>& __z)
  : _M_value(__z.__rep()) { }

  inline constexpr
  complex<float>::complex(const complex<long double>& __z)
  : _M_value(__z.__rep()) { }

  inline constexpr
  complex<double>::complex(const complex<long double>& __z)
  : _M_value(__z.__rep()) { }





  extern template istream& operator>>(istream&, complex<float>&);
  extern template ostream& operator<<(ostream&, const complex<float>&);
  extern template istream& operator>>(istream&, complex<double>&);
  extern template ostream& operator<<(ostream&, const complex<double>&);
  extern template istream& operator>>(istream&, complex<long double>&);
  extern template ostream& operator<<(ostream&, const complex<long double>&);


  extern template wistream& operator>>(wistream&, complex<float>&);
  extern template wostream& operator<<(wostream&, const complex<float>&);
  extern template wistream& operator>>(wistream&, complex<double>&);
  extern template wostream& operator<<(wostream&, const complex<double>&);
  extern template wistream& operator>>(wistream&, complex<long double>&);
  extern template wostream& operator<<(wostream&, const complex<long double>&);






}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp, typename _Up>
    struct __promote_2<std::complex<_Tp>, _Up>
    {
    public:
      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;
    };

  template<typename _Tp, typename _Up>
    struct __promote_2<_Tp, std::complex<_Up> >
    {
    public:
      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;
    };

  template<typename _Tp, typename _Up>
    struct __promote_2<std::complex<_Tp>, std::complex<_Up> >
    {
    public:
      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;
    };


}



namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp> std::complex<_Tp> acos(const std::complex<_Tp>&);
  template<typename _Tp> std::complex<_Tp> asin(const std::complex<_Tp>&);
  template<typename _Tp> std::complex<_Tp> atan(const std::complex<_Tp>&);

  template<typename _Tp> std::complex<_Tp> acosh(const std::complex<_Tp>&);
  template<typename _Tp> std::complex<_Tp> asinh(const std::complex<_Tp>&);
  template<typename _Tp> std::complex<_Tp> atanh(const std::complex<_Tp>&);

  template<typename _Tp> _Tp fabs(const std::complex<_Tp>&);

  template<typename _Tp>
    inline std::complex<_Tp>
    __complex_acos(const std::complex<_Tp>& __z)
    {
      const std::complex<_Tp> __t = std::asin(__z);
      const _Tp __pi_2 = 1.5707963267948966192313216916397514L;
      return std::complex<_Tp>(__pi_2 - __t.real(), -__t.imag());
    }


  inline __complex__ float
  __complex_acos(__complex__ float __z)
  { return __builtin_cacosf(__z); }

  inline __complex__ double
  __complex_acos(__complex__ double __z)
  { return __builtin_cacos(__z); }

  inline __complex__ long double
  __complex_acos(const __complex__ long double& __z)
  { return __builtin_cacosl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    acos(const std::complex<_Tp>& __z)
    { return __complex_acos(__z.__rep()); }
# 1636 "/usr/local/include/c++/10.0.0/complex" 3
  template<typename _Tp>
    inline std::complex<_Tp>
    __complex_asin(const std::complex<_Tp>& __z)
    {
      std::complex<_Tp> __t(-__z.imag(), __z.real());
      __t = std::asinh(__t);
      return std::complex<_Tp>(__t.imag(), -__t.real());
    }


  inline __complex__ float
  __complex_asin(__complex__ float __z)
  { return __builtin_casinf(__z); }

  inline __complex__ double
  __complex_asin(__complex__ double __z)
  { return __builtin_casin(__z); }

  inline __complex__ long double
  __complex_asin(const __complex__ long double& __z)
  { return __builtin_casinl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    asin(const std::complex<_Tp>& __z)
    { return __complex_asin(__z.__rep()); }
# 1672 "/usr/local/include/c++/10.0.0/complex" 3
  template<typename _Tp>
    std::complex<_Tp>
    __complex_atan(const std::complex<_Tp>& __z)
    {
      const _Tp __r2 = __z.real() * __z.real();
      const _Tp __x = _Tp(1.0) - __r2 - __z.imag() * __z.imag();

      _Tp __num = __z.imag() + _Tp(1.0);
      _Tp __den = __z.imag() - _Tp(1.0);

      __num = __r2 + __num * __num;
      __den = __r2 + __den * __den;

      return std::complex<_Tp>(_Tp(0.5) * atan2(_Tp(2.0) * __z.real(), __x),
          _Tp(0.25) * log(__num / __den));
    }


  inline __complex__ float
  __complex_atan(__complex__ float __z)
  { return __builtin_catanf(__z); }

  inline __complex__ double
  __complex_atan(__complex__ double __z)
  { return __builtin_catan(__z); }

  inline __complex__ long double
  __complex_atan(const __complex__ long double& __z)
  { return __builtin_catanl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    atan(const std::complex<_Tp>& __z)
    { return __complex_atan(__z.__rep()); }
# 1716 "/usr/local/include/c++/10.0.0/complex" 3
  template<typename _Tp>
    std::complex<_Tp>
    __complex_acosh(const std::complex<_Tp>& __z)
    {

      return _Tp(2.0) * std::log(std::sqrt(_Tp(0.5) * (__z + _Tp(1.0)))
     + std::sqrt(_Tp(0.5) * (__z - _Tp(1.0))));
    }


  inline __complex__ float
  __complex_acosh(__complex__ float __z)
  { return __builtin_cacoshf(__z); }

  inline __complex__ double
  __complex_acosh(__complex__ double __z)
  { return __builtin_cacosh(__z); }

  inline __complex__ long double
  __complex_acosh(const __complex__ long double& __z)
  { return __builtin_cacoshl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    acosh(const std::complex<_Tp>& __z)
    { return __complex_acosh(__z.__rep()); }
# 1752 "/usr/local/include/c++/10.0.0/complex" 3
  template<typename _Tp>
    std::complex<_Tp>
    __complex_asinh(const std::complex<_Tp>& __z)
    {
      std::complex<_Tp> __t((__z.real() - __z.imag())
       * (__z.real() + __z.imag()) + _Tp(1.0),
       _Tp(2.0) * __z.real() * __z.imag());
      __t = std::sqrt(__t);

      return std::log(__t + __z);
    }


  inline __complex__ float
  __complex_asinh(__complex__ float __z)
  { return __builtin_casinhf(__z); }

  inline __complex__ double
  __complex_asinh(__complex__ double __z)
  { return __builtin_casinh(__z); }

  inline __complex__ long double
  __complex_asinh(const __complex__ long double& __z)
  { return __builtin_casinhl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    asinh(const std::complex<_Tp>& __z)
    { return __complex_asinh(__z.__rep()); }
# 1791 "/usr/local/include/c++/10.0.0/complex" 3
  template<typename _Tp>
    std::complex<_Tp>
    __complex_atanh(const std::complex<_Tp>& __z)
    {
      const _Tp __i2 = __z.imag() * __z.imag();
      const _Tp __x = _Tp(1.0) - __i2 - __z.real() * __z.real();

      _Tp __num = _Tp(1.0) + __z.real();
      _Tp __den = _Tp(1.0) - __z.real();

      __num = __i2 + __num * __num;
      __den = __i2 + __den * __den;

      return std::complex<_Tp>(_Tp(0.25) * (log(__num) - log(__den)),
          _Tp(0.5) * atan2(_Tp(2.0) * __z.imag(), __x));
    }


  inline __complex__ float
  __complex_atanh(__complex__ float __z)
  { return __builtin_catanhf(__z); }

  inline __complex__ double
  __complex_atanh(__complex__ double __z)
  { return __builtin_catanh(__z); }

  inline __complex__ long double
  __complex_atanh(const __complex__ long double& __z)
  { return __builtin_catanhl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    atanh(const std::complex<_Tp>& __z)
    { return __complex_atanh(__z.__rep()); }
# 1835 "/usr/local/include/c++/10.0.0/complex" 3
  template<typename _Tp>
    inline _Tp



    fabs(const std::complex<_Tp>& __z)
    { return std::abs(__z); }


  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    arg(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;

      return std::signbit(__x) ? __type(3.1415926535897932384626433832795029L)
                        : __type();



    }

  template<typename _Tp>
    constexpr inline typename __gnu_cxx::__promote<_Tp>::__type
    imag(_Tp)
    { return _Tp(); }

  template<typename _Tp>
    constexpr inline typename __gnu_cxx::__promote<_Tp>::__type
    norm(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __type(__x) * __type(__x);
    }

  template<typename _Tp>
    constexpr inline typename __gnu_cxx::__promote<_Tp>::__type
    real(_Tp __x)
    { return __x; }

  template<typename _Tp, typename _Up>
    inline std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type>
    pow(const std::complex<_Tp>& __x, const _Up& __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return std::pow(std::complex<__type>(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    inline std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type>
    pow(const _Tp& __x, const std::complex<_Up>& __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return std::pow(__type(__x), std::complex<__type>(__y));
    }

  template<typename _Tp, typename _Up>
    inline std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type>
    pow(const std::complex<_Tp>& __x, const std::complex<_Up>& __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return std::pow(std::complex<__type>(__x),
        std::complex<__type>(__y));
    }



  template<typename _Tp>
    std::complex<_Tp> proj(const std::complex<_Tp>&);


  template<typename _Tp>
    inline std::complex<_Tp>
    __complex_proj(const std::complex<_Tp>& __z)
    { return __z; }


  inline complex<float>
  __complex_proj(const complex<float>& __z)
  { return __builtin_cprojf(__z.__rep()); }

  inline complex<double>
  __complex_proj(const complex<double>& __z)
  { return __builtin_cproj(__z.__rep()); }

  inline complex<long double>
  __complex_proj(const complex<long double>& __z)
  { return __builtin_cprojl(__z.__rep()); }
# 1952 "/usr/local/include/c++/10.0.0/complex" 3
  template<typename _Tp>
    inline std::complex<_Tp>
    proj(const std::complex<_Tp>& __z)
    { return __complex_proj(__z); }


  template<typename _Tp>
    inline std::complex<typename __gnu_cxx::__promote<_Tp>::__type>
    proj(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return std::proj(std::complex<__type>(__x));
    }

  template<typename _Tp>
    inline constexpr
 std::complex<typename __gnu_cxx::__promote<_Tp>::__type>
    conj(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return std::complex<__type>(__x, -__type());
    }



inline namespace literals {
inline namespace complex_literals {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wliteral-suffix"


  constexpr std::complex<float>
  operator""if(long double __num)
  { return std::complex<float>{0.0F, static_cast<float>(__num)}; }

  constexpr std::complex<float>
  operator""if(unsigned long long __num)
  { return std::complex<float>{0.0F, static_cast<float>(__num)}; }

  constexpr std::complex<double>
  operator""i(long double __num)
  { return std::complex<double>{0.0, static_cast<double>(__num)}; }

  constexpr std::complex<double>
  operator""i(unsigned long long __num)
  { return std::complex<double>{0.0, static_cast<double>(__num)}; }

  constexpr std::complex<long double>
  operator""il(long double __num)
  { return std::complex<long double>{0.0L, __num}; }

  constexpr std::complex<long double>
  operator""il(unsigned long long __num)
  { return std::complex<long double>{0.0L, static_cast<long double>(__num)}; }

#pragma GCC diagnostic pop
}
}




}
# 4 "fast_io/fast_io_freestanding_impl/natural.h" 2


# 5 "fast_io/fast_io_freestanding_impl/natural.h"
namespace fast_io
{
# 44 "fast_io/fast_io_freestanding_impl/natural.h"
class natural;

template<character_input_stream input>
inline void scan_define(input&,natural&);

class natural
{
 std::vector<std::uint64_t> cont;
public:
 natural()=default;
 explicit natural(std::uint64_t value):cont(1,value)
 {
  if(!value)
   cont.pop_back();
 }
 explicit natural(std::string_view sv)
 {
  istring_view is(sv);
  scan_define(is,*this);
 }
 auto& vec() {return cont;}
 auto& vec() const{return cont;}
 inline natural& operator+=(natural const& other)
 {
  if(cont.size()<other.cont.size())
   cont.resize(other.cont.size()+1);
  else
   cont.emplace_back(0);
  auto it(cont.begin());
  auto carry(false);
  for(auto const & e : other.cont)
  {
   auto const v(*it);
   carry=(*it+=e+carry)<v;
   ++it;
  }
  for(;carry;++it)
   carry=(++*it)==0;
  if(!cont.back())
   cont.pop_back();
  return *this;
 }
 inline natural& operator+=(std::uint64_t u)
 {
  cont.emplace_back(0);
  auto it(cont.begin());
  auto v(*it);
  for(auto carry((*it+=u)<v);carry;carry=(++*++it)==0);
  if(!cont.back())
   cont.pop_back();
  return *this;
 }
 inline natural& operator++()
 {
  *this += 1;
  return *this;
 }
 inline natural operator++(int)
 {
  auto temp(*this);
  ++*this;
  return temp;
 }
 inline natural& operator--()
 {
  *this -= 1;
  return *this;
 }
 inline natural operator--(int)
 {
  auto temp(*this);
  --*this;
  return temp;
 }
 inline natural& operator-=(std::uint64_t other)
 {
  auto it(cont.begin());
  auto v(*it);
  for(auto carry(v<=(*it-=other));carry;)
  {
   carry=(*++it)==0;
   --*it;
  };
  trim();
  return *this;
 }
 inline natural& operator-=(natural const& other)
 {
  auto it(cont.begin());
  auto carry(false);
  for(auto const & e : other.cont)
  {
   auto const v(*it);
   carry=v<=(*it-=e+carry);
   ++it;
  }
  for(;carry;++it)
  {
   carry=*it==0;
   --*it;
  }
  for(;!cont.back();cont.pop_back());
  return *this;
 }
 inline natural& operator+=(natural&& other)
 {
  if(cont.capacity()<other.cont.capacity()&&other.cont.size()!=other.cont.capacity())
  {
   using std::swap;
   swap(cont,other.cont);
  }
  return *this+=other;
 }
# 215 "fast_io/fast_io_freestanding_impl/natural.h"
 inline explicit operator bool() const
 {
  return !cont.empty();
 }
 inline natural& operator*=(natural&& other)
 {
  if(cont.capacity()<other.cont.capacity()&&cont.size()+other.cont.size()<other.cont.capacity())
  {
   using std::swap;
   swap(cont,other.cont);
  }
  return *this*=other;
 }

 inline natural& operator*=(natural const& other)
 {
  if(cont.empty()||other.cont.empty())
  {
   cont.clear();
   return *this;
  }
  std::size_t const this_size(cont.size()<<1),other_size(other.cont.size()<<1);
  std::vector<std::uint64_t> temp(this_size+other_size+1);
  auto p32(static_cast<std::uint32_t const*>(static_cast<void const*>(cont.data()))),otherp32(static_cast<std::uint32_t const*>(static_cast<void const*>(other.cont.data())));
  for(std::size_t i(0);i!=this_size;++i)
  {
   std::uint64_t const pi64(p32[i]);
   auto ci(temp.data()+i);
   for(std::size_t j(0);j!=other_size;++j)
   {
    std::uint64_t const v(pi64*otherp32[j]);
    ci[j]+=v&
# 246 "fast_io/fast_io_freestanding_impl/natural.h" 3 4
            (4294967295U)
# 246 "fast_io/fast_io_freestanding_impl/natural.h"
                      ;
    ci[j+1]+=(ci[j]>>32)+(v>>32);
    ci[j]&=
# 248 "fast_io/fast_io_freestanding_impl/natural.h" 3 4
          (4294967295U)
# 248 "fast_io/fast_io_freestanding_impl/natural.h"
                    ;
   }
  }
  for(auto i(temp.begin());i!=temp.end();++i)
  {
   i[1]+=*i>>32;
   *i&=
# 254 "fast_io/fast_io_freestanding_impl/natural.h" 3 4
      (4294967295U)
# 254 "fast_io/fast_io_freestanding_impl/natural.h"
                ;
  }
  cont.clear();
  auto i(temp.cbegin());
  for(;i+2<temp.cend();i+=2)
   cont.emplace_back(*i+(i[1]<<32));
  if(i!=temp.cend())
   cont.emplace_back(temp.back());
  for(;!cont.back();cont.pop_back());
  return *this;
 }

 inline natural& operator*=(std::uint32_t other1)
 {
  if(cont.empty()||!other1)
  {
   cont.clear();
   return *this;
  }
  std::uint64_t const other(other1);
  std::size_t const this_size(cont.size()<<1);
  auto p32(static_cast<std::uint32_t*>(static_cast<void*>(cont.data())));
  std::uint64_t carry(0);
  for(std::size_t i(0);i!=this_size;++i)
  {
   std::uint64_t const temp(p32[i]*other);
   std::uint64_t const carry_temp(temp>>32);
   std::uint64_t const temp1((temp&std::numeric_limits<std::uint32_t>::max())+carry);
   p32[i]=temp1&std::numeric_limits<std::uint32_t>::max();
   carry=carry_temp+(temp1>>32);
  }
  if(carry)
   cont.emplace_back(carry);
  return *this;
 }
 inline bool operator==(natural const& e) const
 {
  return cont==e.cont;
 }
 inline bool operator!=(natural const& e) const
 {
  return cont!=e.cont;
 }
 inline bool operator<(natural const& e) const
 {
  if(cont.size()==e.cont.size())
   return std::lexicographical_compare(cont.crbegin(),cont.crend(),e.cont.crbegin(),e.cont.crend());
  return cont.size()<e.cont.size();
 }
 inline bool operator>(natural const& e) const
 {
  return e.operator<(*this);
 }
 inline bool operator<=(natural const& e) const
 {
  return !e.operator<(*this);
 }
 inline bool operator>=(natural const& e) const
 {
  return !operator<(e);
 }
 inline bool operator==(std::uint64_t e) const
 {
  switch(cont.size())
  {
  case 0:
   return !e;
  case 1:
   return cont.front()==e;
  default:
   return false;
  }
 }
 inline bool operator<(std::uint64_t e) const
 {
  switch(cont.size())
  {
  case 0:
   return e;
  case 1:
   return cont.front()<e;
  default:
   return false;
  }
 }
 inline natural& operator<<=(std::size_t offset)
 {
  std::size_t const quo(offset/64),md(offset%64),mdp(64-md);
  cont.emplace_back(0);
  for(std::size_t i(cont.size()-1);i--;)
  {
   cont[i+1]|=cont[i]>>mdp;
   cont[i]<<=md;
  }
  cont.insert(cont.cbegin(),quo,0);
  for(;!cont.empty()&&!cont.back();cont.pop_back());
  return *this;
 }
 inline natural& operator>>=(std::size_t offset)
 {
  std::size_t const quo(offset/64),md(offset%64),mdp(64-md);
  if(cont.size()<=quo)
  {
   cont.clear();
   return *this;
  }
  cont.erase(cont.cend()-quo,cont.cend());
  cont[0]>>=md;
  for(std::size_t i(1);i!=cont.size();++i)
  {
   cont[i-1]|=cont[i]<<mdp;
   cont[i]>>=md;
  }
  for(;!cont.empty()&&!cont.back();cont.pop_back());
  return *this;
 }
 inline natural& operator^=(std::uint64_t u)
 {
  if(cont.empty())
  {
   cont.emplace_back(u);
   return *this;
  }
  cont.front()^=u;
  return *this;
 }
 inline natural& operator&=(std::uint64_t u)
 {
  if(cont.empty())
   return *this;

  auto const ret(cont.front()&u);
  cont.clear();
  if(ret)
   cont.emplace_back(ret);
  return *this;
 }
 inline natural& operator|=(std::uint64_t u)
 {
  if(cont.empty())
  {
   cont.emplace_back(u);
   return *this;
  }
  cont.front()|=u;
  return *this;
 }

 inline std::size_t size() const
 {
  std::size_t ret((cont.size() - 1) * 64);
  auto last(cont.back());
  while (last) {
   last >>= 1;
   ++ret;
  }
  return ret;
 }

 bool operator[](std::size_t b) const
 {
  return (cont[b / 64] >> (b % 64)) & 1;
 }

 inline natural& operator/=(std::uint32_t v)
 {
  if(cont.empty())
   return *this;
  std::size_t const this_size(cont.size()<<1);
  auto p32(static_cast<std::uint32_t*>(static_cast<void*>(cont.data())));
  std::uint64_t temp(0);
  for(std::size_t i(this_size);i--;)
  {
   auto const tot(p32[i]+(temp<<32));
   p32[i]=static_cast<std::uint32_t>(tot/v);
   temp=tot%v;
  }
  for(;!cont.empty()&&!cont.back();cont.pop_back());
  return *this;
 }

 inline natural& operator/=(natural const& rhs)
 {
  fast_io::natural quotient, remainder;
  for (std::size_t i(size()); i--;)
  {
   quotient <<= 1;
   remainder <<= 1;

   if ((*this)[i]) {
    ++remainder;
   }

   if (remainder >= rhs) {
    remainder -= rhs;
    ++quotient;
   }
  }

  return *this = std::move(quotient);
 }

 inline natural& operator%=(natural const& rhs)
 {
  fast_io::natural quotient, remainder;
  for (std::size_t i(size()); i--;)
  {
   quotient <<= 1;
   remainder <<= 1;

   if ((*this)[i]) {
    ++remainder;
   }

   if (remainder >= rhs) {
    remainder -= rhs;
    ++quotient;
   }
  }

  remainder.trim();
  return *this = std::move(remainder);
 }

 inline void trim()
 {
  for(;!cont.empty()&&!cont.back();cont.pop_back());
 }

 inline bool front() const
 {
  return cont.front() & 1;
 }
};



inline std::pair<natural, natural> div_mod(fast_io::natural const& lhs, fast_io::natural const& rhs)
{
 std::pair<fast_io::natural, fast_io::natural> value;
 fast_io::natural& quotient = value.first;
 fast_io::natural& remainder = value.second;
 for (std::size_t i(lhs.size()); i--;)
 {
  quotient <<= 1;
  remainder <<= 1;

  if (lhs[i]) {
   ++remainder;
  }

  if (remainder >= rhs) {
   remainder -= rhs;
   ++quotient;
  }
 }

 remainder.trim();
 return value;
}


template<typename T>
requires std::constructible_from<natural,T>
inline natural operator+(natural a,T&& b)
{
 return a+=std::forward<T>(b);
}

template<typename T>
requires std::constructible_from<natural,T>
inline natural operator-(natural a,T&& b)
{
 return a-=std::forward<T>(b);
}

inline std::uint64_t operator-(std::uint64_t a,natural b)
{
 if(b.vec().empty())
  return a;
 return a-b.vec().front();
}

template<typename T>
requires std::constructible_from<natural,T>
inline natural operator*(natural a,T&& b)
{
 return a*=std::forward<T>(b);
}

template<typename T>
requires std::constructible_from<natural,T>
inline natural operator/(natural a,T&& b)
{
 return a/=std::forward<T>(b);
}

inline std::uint32_t operator/(std::uint32_t a,natural b)
{
 return static_cast<std::uint32_t>(a/b.vec().front());
}

template<typename T>
requires std::constructible_from<natural,T>
inline natural operator%(natural a,T&& b)
{
 return a%=std::forward<T>(b);
}

inline std::uint32_t operator%(std::uint32_t a,natural b)
{
 return a%b.vec().front();
}

template<typename T>
requires std::constructible_from<natural,T>
inline natural operator&(natural a,T&& b)
{
 return a&=std::forward<T>(b);
}

template<typename T>
requires std::constructible_from<natural,T>
inline natural operator|(natural a,T&& b)
{
 return a|=std::forward<T>(b);
}

template<typename T>
requires std::constructible_from<natural,T>
inline natural operator^(natural a,T&& b)
{
 return a^=std::forward<T>(b);
}

inline bool operator==(std::uint64_t b,natural const& a)
{
 return a==b;
}
inline bool operator!=(natural const& a,std::uint64_t b)
{
 return !(a==b);
}
inline bool operator!=(std::uint64_t b,natural const& a)
{
 return a!=b;
}

inline bool operator<(std::uint64_t e,natural const& a)
{
 switch(a.vec().size())
 {
 case 0:
  return false;
 case 1:
  return e<a.vec().front();
 default:
  return true;
 }
}

inline bool operator>(natural const& a,std::uint64_t b)
{
 return b<a;
}

inline bool operator>(std::uint64_t a,natural const& b)
{
 return b<a;
}


inline bool operator<=(std::uint64_t a,natural const& b)
{
 return !(b<a);
}

inline bool operator<=(natural const& a,std::uint64_t b)
{
 return !(b<a);
}

inline bool operator>=(std::uint64_t a,natural const& b)
{
 return !(a<b);
}

inline bool operator>=(natural const& a,std::uint64_t b)
{
 return !(a<b);
}

inline natural operator<<(natural n,std::size_t offset)
{
 return n<<=offset;
}

inline natural operator>>(natural n,std::size_t offset)
{
 return n>>=offset;
}

inline std::uint32_t in_place_div_mod(fast_io::natural& n,std::uint32_t value)
{
 auto &cont(n.vec());
 if(cont.empty())
  return 0;
 std::size_t const this_size(cont.size()<<1);
 auto p32(static_cast<std::uint32_t*>(static_cast<void*>(cont.data())));
 std::uint64_t quo(0);
 for(std::size_t i(this_size);i--;)
 {
  auto const tot(p32[i]+(quo<<32));
  p32[i] = static_cast<std::uint32_t>(tot/value);
  quo=tot%value;
 }
 for(;!cont.empty()&&!cont.back();cont.pop_back());
 return static_cast<std::uint32_t>(quo);
}

inline natural pow_mod(fast_io::natural lhs, fast_io::natural rhs, fast_io::natural const& mod)
{
 natural ans(1);
 lhs %= mod;
 while (rhs)
 {
  if(rhs.front())
  {
   ans *= lhs;
   ans = ans % mod;
  }
  rhs >>= 1;
  lhs = (lhs * lhs) % mod;
 }
 return ans;
}

inline std::pair<fast_io::natural,std::uint32_t> div_mod(fast_io::natural n,std::uint32_t value)
{
 auto temp(in_place_div_mod(n,value));
 return {std::move(n),static_cast<std::uint32_t>(temp)};
}
# 832 "fast_io/fast_io_freestanding_impl/natural.h"
namespace details
{

template<std::uint8_t base,bool uppercase,character_output_stream output>
inline void output_base_natural_number(output& out,natural a)
{



 if(!a)
 {
  put(out,0x30);
  return;
 }
 std::vector<typename output::char_type> v(a.vec().size()*512/base+3);
 auto iter(v.data()+v.size());
 while(a)
 {
  auto rem=in_place_div_mod(a,base);
  if constexpr(10 < base)
  {
   if(rem<10)
    *--iter = static_cast<typename output::char_type>(rem+48);
   else
   {
    if constexpr (uppercase)
     *--iter = static_cast<typename output::char_type>(rem+55);
    else
     *--iter = static_cast<typename output::char_type>(rem+87);
   }
  }
  else
   *--iter = static_cast<typename output::char_type>(rem+48);
 }
 send(out,iter,v.data()+v.size());
}


template<std::uint8_t base,character_input_stream input>
inline constexpr void input_base_number_phase2_natural(input& in,natural& a)
{
 using unsigned_char_type = std::make_unsigned_t<decltype(get(in))>;
 unsigned_char_type constexpr baseed(std::min(static_cast<unsigned_char_type>(base),static_cast<unsigned_char_type>(10)));
 while(true)
 {
  unsigned_char_type ch(get<true>(in).first);
  if((ch-=48)<baseed)
  {
   a*=base;
   a+=ch;
  }
  else if constexpr (10 < base)
  {
   unsigned_char_type constexpr bm10(base-10);
   if((ch-=17)<bm10||(ch-=32)<bm10)
   {
    a*=base;
    a+=(ch+10);
   }
   else
    return;
  }
  else
   return;
 }
}

template<std::uint8_t base,character_input_stream input>
inline constexpr void input_base_natural_number(input& in,natural& a)
{
 using unsigned_char_type = std::make_unsigned_t<decltype(get(in))>;
 unsigned_char_type constexpr baseed(std::min(static_cast<unsigned_char_type>(base),static_cast<unsigned_char_type>(10)));
 while(true)
 {
  unsigned_char_type ch(get(in));
  if((ch-=48)<baseed)
  {
   a=static_cast<natural>(ch);
   break;
  }
  else if constexpr (10 < base)
  {
   unsigned_char_type constexpr bm10(base-10);
   if((ch-=17)<bm10||(ch-=32)<bm10)
   {
    a=static_cast<natural>(ch+10);
    break;
   }
  }
 }
 input_base_number_phase2_natural<base>(in,a);
}
}

template<character_output_stream output>
inline constexpr void print_define(output& out,natural const& a)
{
 details::output_base_natural_number<10,false>(out,a);
}

template<std::size_t base,bool uppercase,character_output_stream output>
inline constexpr void print_define(output& out,manip::base_t<base,uppercase,natural const> v)
{
 details::output_base_natural_number<base,uppercase>(out,v.reference);
}
template<std::size_t base,bool uppercase,character_output_stream output>
inline constexpr void print_define(output& out,manip::base_t<base,uppercase,natural> v)
{
 details::output_base_natural_number<base,uppercase>(out,v.reference);
}


template<std::size_t base,bool uppercase,character_input_stream input>
inline constexpr void scan_define(input& in,manip::base_t<base,uppercase,natural> v)
{
 details::input_base_natural_number<base>(in,v.reference);
}

template<character_input_stream input>
inline void scan_define(input& in,natural& a)
{
 details::input_base_natural_number<10>(in,a);
}

template<character_output_stream output>
inline void write(output& out,natural const& n)
{
 write(out,n.vec());
}

template<character_input_stream input>
inline void read_define(input& in,natural& n)
{
 read_define(in,n.vec());
}

namespace literals
{
inline natural operator "" _n(char const* cstr, size_t n)
{
 return natural(std::string_view{cstr, n});
}
inline natural operator "" _nb(char const* cstr, size_t n)
{
 istring_view view{cstr, n};
 natural nt;
 scan_define(view,bin(nt));
 return nt;
}
inline natural operator "" _no(char const* cstr, size_t n)
{
 istring_view view{cstr, n};
 natural nt;
 scan_define(view,oct(nt));
 return nt;
}
inline natural operator "" _nh(char const* cstr, size_t n)
{
 istring_view view{cstr, n};
 natural nt;
 scan_define(view,hex(nt));
 return nt;
}
}

}
# 21 "fast_io/fast_io_freestanding.h" 2
# 1 "fast_io/fast_io_freestanding_impl/ucs.h" 1
       

namespace fast_io
{

namespace details
{

template<stream T,typename CharT>
struct ucs_char_size_max_cal
{
 explicit ucs_char_size_max_cal() = default;
 static constexpr bool value = sizeof(typename T::char_type)<sizeof(CharT);
};

}

template<stream T,typename CharT>
requires details::ucs_char_size_max_cal<T,CharT>::value
class ucs
{
 T ib;
public:
 using native_interface_t = T;
 using char_type = CharT;
 using native_char_type = typename native_interface_t::char_type;
 using unsigned_char_type = std::make_unsigned_t<char_type>;
 using unsigned_native_char_type = std::make_unsigned_t<native_char_type>;
private:
 inline constexpr char_type get_impl(unsigned_native_char_type ch)
 {
  auto constexpr ch_bits(sizeof(native_char_type)*8);
  union
  {
   unsigned_native_char_type ch;
   std::bitset<ch_bits> bts;
  }u{ch};
  if(!u.bts.test(ch_bits-1))
   return u.ch;
  auto constexpr ch_bits_m2(ch_bits-2);
  auto constexpr limitm1((static_cast<unsigned_native_char_type>(1)<<ch_bits_m2)-1);
  if(!u.bts.test(ch_bits_m2))
   throw std::runtime_error("not a utf8 character");
  u.bts.reset(ch_bits-1);
  std::size_t pos(ch_bits_m2-1);
  for(;pos<ch_bits&&u.bts.test(pos);--pos)
   u.bts.reset(pos);
  std::size_t bytes(ch_bits_m2-pos);
  unsigned_char_type converted_ch(u.ch);
  for(std::size_t i(0);i!=bytes;++i)
  {
   unsigned_native_char_type t(get(ib));
   if((t>>ch_bits_m2)==2)
    converted_ch=((converted_ch<<ch_bits_m2)|(t&limitm1))&((1<<((i+2)*6)) -1);
   else
    throw std::runtime_error("not a utf8 character");
  }
  return converted_ch;
 }
public:
 template<typename ...Args>
 requires std::constructible_from<T,Args...>
 constexpr ucs(Args&& ...args):ib(std::forward<Args>(args)...){}
 constexpr auto& native_handle()
 {
  return ib;
 }
 constexpr char_type mmget() requires character_input_stream<T>
 {
  return get_impl(get(ib));
 }
 constexpr std::pair<char_type,bool> mmtry_get() requires character_input_stream<T>
 {
  auto ch(get<true>(ib));
  if(ch.second)
   return {0,true};
  return {get_impl(ch.first),false};
 }
 constexpr void mmput(char_type ch) requires character_output_stream<T>
 {
  unsigned_native_char_type constexpr native_char_bits(8*sizeof(unsigned_native_char_type));
  unsigned_native_char_type constexpr fair(1<<(native_char_bits-1));
  unsigned_native_char_type constexpr utf8_limit(1<<(native_char_bits-2));
  if(ch<fair)
  {
   put(ib,static_cast<native_char_type>(ch));
   return;
  }
  std::array<unsigned_native_char_type,sizeof(char_type)/sizeof(unsigned_native_char_type)+1> v{};
  auto ed(v.data()+v.size());
  do
  {
   *--ed = (ch%utf8_limit)|fair;
  }
  while(ch/=utf8_limit);
  std::size_t v_elements(v.data()+v.size()-ed);
  if((1<<(native_char_bits-1-v_elements))<=(*ed&~fair))
  {
   --ed;
   ++v_elements;
  }
  unsigned_native_char_type constexpr max_native_char_type(-1);
  *ed |= max_native_char_type>>(native_char_bits-v_elements-1)<<(native_char_bits-v_elements);
  send(ib,ed,v.data()+v.size());
 }
};


template<output_stream T,typename CharT>
inline constexpr void flush(ucs<T,CharT>& uc)
{
 flush(uc.native_handle());
}
template<character_output_stream T,typename char_type>
inline constexpr void put(ucs<T,char_type>& uc,typename ucs<T,char_type>::char_type ch)
{
 uc.mmput(ch);
}

template<character_output_stream T,typename char_type,std::forward_iterator Iter>
inline constexpr void send(ucs<T,char_type>& uc,Iter b,Iter e)
{
 define_send_by_put(uc,b,e);
}

template<bool err=false,character_input_stream T,typename char_type>
inline constexpr auto get(ucs<T,char_type>& uc)
{
 if constexpr(err)
  return uc.mmtry_get();
 else
  return uc.mmget();
}


template<character_input_stream T,typename char_type,std::forward_iterator Iter>
inline constexpr Iter receive(ucs<T,char_type>& uc,Iter b,Iter e)
{
 return define_receive_by_get(uc,b,e);
}

template<typename T>
inline constexpr void in_place_utf8_to_ucs(T& t,std::string_view view)
{
 basic_istring_view<std::string_view> ibsv(view);
 ucs<decltype(ibsv),typename T::value_type> uv(ibsv);
 getwhole(uv,t);
}

template<typename T=std::wstring>
inline constexpr auto utf8_to_ucs(std::string_view view)
{
 T t;
 in_place_utf8_to_ucs(t,view);
 return t;
}

namespace details
{
template<typename T>
inline void in_place_ucs_to_utf8(std::string& v,std::basic_string_view<T> view)
{
 v.clear();
 ucs<basic_ostring<std::string>,T> uv(std::move(v));
 send(uv,view.cbegin(),view.cend());
 v=std::move(uv.native_handle().str());
}

template<typename T>
inline std::string ucs_to_utf8(std::basic_string_view<T> view)
{
 ucs<basic_ostring<std::string>,T> uv;
 send(uv,view.cbegin(),view.cend());
 return std::move(uv.native_handle().str());
}
}

inline void in_place_ucs_to_utf8(std::string& v,std::wstring_view view)
{
 details::in_place_ucs_to_utf8(v,view);
}

inline std::string ucs_to_utf8(std::wstring_view v)
{
 return details::ucs_to_utf8(v);
}

inline void in_place_ucs_to_utf8(std::string& v,std::u16string_view view)
{
 details::in_place_ucs_to_utf8(v,view);
}

inline std::string ucs_to_utf8(std::u16string_view v)
{
 return details::ucs_to_utf8(v);
}

inline void in_place_ucs_to_utf8(std::string& v,std::u32string_view view)
{
 details::in_place_ucs_to_utf8(v,view);
}

inline std::string ucs_to_utf8(std::u32string_view v)
{
 return details::ucs_to_utf8(v);
}

}
# 22 "fast_io/fast_io_freestanding.h" 2

namespace fast_io
{
using ostring = basic_ostring<std::string>;
}
# 11 "fast_io/fast_io_hosted.h" 2
# 1 "fast_io/fast_io_hosted/platforms/native.h" 1
       




# 1 "fast_io/fast_io_hosted/platforms/posix.h" 1
       
# 1 "/usr/include/unistd.h" 1 3 4
# 27 "/usr/include/unistd.h" 3 4

# 27 "/usr/include/unistd.h" 3 4
extern "C" {
# 205 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
# 206 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
# 210 "/usr/include/unistd.h" 2 3 4
# 229 "/usr/include/unistd.h" 3 4
# 1 "/usr/local/lib/gcc/x86_64-pc-linux-gnu/10.0.0/include/stddef.h" 1 3 4
# 230 "/usr/include/unistd.h" 2 3 4
# 277 "/usr/include/unistd.h" 3 4
typedef __socklen_t socklen_t;
# 290 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) throw () __attribute__ ((__nonnull__ (1)));




extern int euidaccess (const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));


extern int eaccess (const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;
# 337 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) throw ();
# 348 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     throw ();






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, const void *__buf, size_t __n) ;
# 379 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset) ;
# 407 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset) ;







extern int pipe (int __pipedes[2]) throw () ;




extern int pipe2 (int __pipedes[2], int __flags) throw () ;
# 435 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) throw ();
# 447 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     throw ();






extern int usleep (__useconds_t __useconds);
# 472 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) throw () ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) throw () ;
# 514 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) throw () ;





extern char *get_current_dir_name (void) throw ();







extern char *getwd (char *__buf)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) throw () ;


extern int dup2 (int __fd, int __fd2) throw ();




extern int dup3 (int __fd, int __fd2, int __flags) throw ();



extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) throw () __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     throw () __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) throw () ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 613 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     throw () __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) throw ();


extern long int sysconf (int __name) throw ();



extern size_t confstr (int __name, char *__buf, size_t __len) throw ();




extern __pid_t getpid (void) throw ();


extern __pid_t getppid (void) throw ();


extern __pid_t getpgrp (void) throw ();


extern __pid_t __getpgid (__pid_t __pid) throw ();

extern __pid_t getpgid (__pid_t __pid) throw ();






extern int setpgid (__pid_t __pid, __pid_t __pgid) throw ();
# 663 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) throw ();






extern __pid_t setsid (void) throw ();



extern __pid_t getsid (__pid_t __pid) throw ();



extern __uid_t getuid (void) throw ();


extern __uid_t geteuid (void) throw ();


extern __gid_t getgid (void) throw ();


extern __gid_t getegid (void) throw ();




extern int getgroups (int __size, __gid_t __list[]) throw () ;



extern int group_member (__gid_t __gid) throw ();






extern int setuid (__uid_t __uid) throw () ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) throw () ;




extern int seteuid (__uid_t __uid) throw () ;






extern int setgid (__gid_t __gid) throw () ;




extern int setregid (__gid_t __rgid, __gid_t __egid) throw () ;




extern int setegid (__gid_t __gid) throw () ;





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     throw ();



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     throw ();



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     throw () ;



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     throw () ;






extern __pid_t fork (void) throw ();







extern __pid_t vfork (void) throw ();





extern char *ttyname (int __fd) throw ();



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) throw ();




extern int ttyslot (void) throw ();




extern int link (const char *__from, const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     throw () __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (const char *__from, int __tofd,
        const char *__to) throw () __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (const char *__name) throw () __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     throw () __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) throw () __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) throw ();


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) throw ();






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (const char *__name) throw () __attribute__ ((__nonnull__ (1)));







# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern "C" {







extern char *optarg;
# 50 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 91 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       throw () __attribute__ ((__nonnull__ (2, 3)));

}
# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 2 3 4

extern "C" {
# 49 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4
}
# 873 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) throw () __attribute__ ((__nonnull__ (1)));






extern int sethostname (const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) throw () ;





extern int getdomainname (char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) throw ();


extern int revoke (const char *__file) throw () __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     throw () __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) throw ();



extern char *getusershell (void) throw ();
extern void endusershell (void) throw ();
extern void setusershell (void) throw ();





extern int daemon (int __nochdir, int __noclose) throw () ;






extern int chroot (const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);





extern int syncfs (int __fd) throw ();






extern long int gethostid (void);


extern void sync (void) throw ();





extern int getpagesize (void) throw () __attribute__ ((__const__));




extern int getdtablesize (void) throw ();
# 994 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 1006 "/usr/include/unistd.h" 3 4
extern int truncate64 (const char *__file, __off64_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 1017 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) throw () ;
# 1027 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) throw () ;
# 1038 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) throw () ;





extern void *sbrk (intptr_t __delta) throw ();
# 1059 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) throw ();
# 1082 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1092 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
# 1110 "/usr/include/unistd.h" 3 4
ssize_t copy_file_range (int __infd, __off64_t *__pinoff,
    int __outfd, __off64_t *__poutoff,
    size_t __length, unsigned int __flags);





extern int fdatasync (int __fildes);







extern char *crypt (const char *__key, const char *__salt)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern void encrypt (char *__glibc_block, int __edflag)
     throw () __attribute__ ((__nonnull__ (1)));






extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));
# 1167 "/usr/include/unistd.h" 3 4
int getentropy (void *__buffer, size_t __length) ;







}
# 3 "fast_io/fast_io_hosted/platforms/posix.h" 2
# 1 "/usr/include/fcntl.h" 1 3 4
# 28 "/usr/include/fcntl.h" 3 4
extern "C" {






# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 3 4
struct flock
  {
    short int l_type;
    short int l_whence;

    __off_t l_start;
    __off_t l_len;




    __pid_t l_pid;
  };


struct flock64
  {
    short int l_type;
    short int l_whence;
    __off64_t l_start;
    __off64_t l_len;
    __pid_t l_pid;
  };



# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 3 4
# 1 "/usr/local/lib/gcc/x86_64-pc-linux-gnu/10.0.0/include/stddef.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 2 3 4


struct iovec
  {
    void *iov_base;
    size_t iov_len;
  };
# 39 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 2 3 4
# 265 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
enum __pid_type
  {
    F_OWNER_TID = 0,
    F_OWNER_PID,
    F_OWNER_PGRP,
    F_OWNER_GID = F_OWNER_PGRP
  };


struct f_owner_ex
  {
    enum __pid_type type;
    __pid_t pid;
  };
# 346 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/linux/falloc.h" 1 3 4
# 347 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 2 3 4



struct file_handle
{
  unsigned int handle_bytes;
  int handle_type;

  unsigned char f_handle[0];
};
# 380 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
extern "C" {




extern __ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
    throw ();






extern int sync_file_range (int __fd, __off64_t __offset, __off64_t __count,
       unsigned int __flags);






extern __ssize_t vmsplice (int __fdout, const struct iovec *__iov,
      size_t __count, unsigned int __flags);





extern __ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
    __off64_t *__offout, size_t __len,
    unsigned int __flags);





extern __ssize_t tee (int __fdin, int __fdout, size_t __len,
        unsigned int __flags);






extern int fallocate (int __fd, int __mode, __off_t __offset, __off_t __len);
# 435 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
extern int fallocate64 (int __fd, int __mode, __off64_t __offset,
   __off64_t __len);




extern int name_to_handle_at (int __dfd, const char *__name,
         struct file_handle *__handle, int *__mnt_id,
         int __flags) throw ();





extern int open_by_handle_at (int __mountdirfd, struct file_handle *__handle,
         int __flags);



}
# 62 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 2 3 4
# 36 "/usr/include/fcntl.h" 2 3 4
# 78 "/usr/include/fcntl.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 46 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
struct stat
  {
    __dev_t st_dev;




    __ino_t st_ino;







    __nlink_t st_nlink;
    __mode_t st_mode;

    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;

    __dev_t st_rdev;




    __off_t st_size;



    __blksize_t st_blksize;

    __blkcnt_t st_blocks;
# 91 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 106 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];
# 115 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
  };



struct stat64
  {
    __dev_t st_dev;

    __ino64_t st_ino;
    __nlink_t st_nlink;
    __mode_t st_mode;






    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;
    __dev_t st_rdev;
    __off_t st_size;





    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;







    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 164 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];



  };
# 79 "/usr/include/fcntl.h" 2 3 4
# 147 "/usr/include/fcntl.h" 3 4
extern int fcntl (int __fd, int __cmd, ...);
# 157 "/usr/include/fcntl.h" 3 4
extern int open (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 167 "/usr/include/fcntl.h" 3 4
extern int open64 (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 181 "/usr/include/fcntl.h" 3 4
extern int openat (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 192 "/usr/include/fcntl.h" 3 4
extern int openat64 (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 203 "/usr/include/fcntl.h" 3 4
extern int creat (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 213 "/usr/include/fcntl.h" 3 4
extern int creat64 (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 249 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise (int __fd, off_t __offset, off_t __len,
     int __advise) throw ();
# 261 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise64 (int __fd, off64_t __offset, off64_t __len,
       int __advise) throw ();
# 271 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate (int __fd, off_t __offset, off_t __len);
# 282 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate64 (int __fd, off64_t __offset, off64_t __len);
# 293 "/usr/include/fcntl.h" 3 4
}
# 4 "fast_io/fast_io_hosted/platforms/posix.h" 2

# 1 "/usr/include/x86_64-linux-gnu/sys/sendfile.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/sys/sendfile.h" 3 4
extern "C" {







extern ssize_t sendfile (int __out_fd, int __in_fd, off_t *__offset,
    size_t __count) throw ();
# 45 "/usr/include/x86_64-linux-gnu/sys/sendfile.h" 3 4
extern ssize_t sendfile64 (int __out_fd, int __in_fd, __off64_t *__offset,
      size_t __count) throw ();


}
# 6 "fast_io/fast_io_hosted/platforms/posix.h" 2


# 7 "fast_io/fast_io_hosted/platforms/posix.h"
namespace fast_io
{

namespace details
{
inline constexpr int calculate_posix_open_mode(open::mode const &om)
{
 using namespace open;
 std::size_t value(remove_ate_overlapped(om).value);
 int mode(0);
 if(value&binary.value)
 {



  value &= ~binary.value;
 }
 if(value&excl.value)
 {
  mode |= 
# 26 "fast_io/fast_io_hosted/platforms/posix.h" 3 4
         0100 
# 26 "fast_io/fast_io_hosted/platforms/posix.h"
                  | 
# 26 "fast_io/fast_io_hosted/platforms/posix.h" 3 4
                    0200
# 26 "fast_io/fast_io_hosted/platforms/posix.h"
                          ;
  value &= ~excl.value;
 }
 if(value&trunc.value)
 {
  mode |= 
# 31 "fast_io/fast_io_hosted/platforms/posix.h" 3 4
         01000
# 31 "fast_io/fast_io_hosted/platforms/posix.h"
                ;
  value &= ~trunc.value;
 }
 if(value&direct.value)
 {

  mode |= 
# 37 "fast_io/fast_io_hosted/platforms/posix.h" 3 4
         040000
# 37 "fast_io/fast_io_hosted/platforms/posix.h"
                 ;

  value &= ~direct.value;
 }
 if(value&sync.value)
 {

  mode |= 
# 44 "fast_io/fast_io_hosted/platforms/posix.h" 3 4
         04010000
# 44 "fast_io/fast_io_hosted/platforms/posix.h"
               ;

  value &= ~sync.value;
 }
 switch(value)
 {


 case in:
  return mode | 
# 53 "fast_io/fast_io_hosted/platforms/posix.h" 3 4
               00
# 53 "fast_io/fast_io_hosted/platforms/posix.h"
                       ;

 case out:
  return mode | 
# 56 "fast_io/fast_io_hosted/platforms/posix.h" 3 4
               01 
# 56 "fast_io/fast_io_hosted/platforms/posix.h"
                        | 
# 56 "fast_io/fast_io_hosted/platforms/posix.h" 3 4
                          0100 
# 56 "fast_io/fast_io_hosted/platforms/posix.h"
                                  | 
# 56 "fast_io/fast_io_hosted/platforms/posix.h" 3 4
                                    01000
# 56 "fast_io/fast_io_hosted/platforms/posix.h"
                                           ;

 case app:
 case out|app:
  return mode | 
# 60 "fast_io/fast_io_hosted/platforms/posix.h" 3 4
               01 
# 60 "fast_io/fast_io_hosted/platforms/posix.h"
                        | 
# 60 "fast_io/fast_io_hosted/platforms/posix.h" 3 4
                          0100 
# 60 "fast_io/fast_io_hosted/platforms/posix.h"
                                  | 
# 60 "fast_io/fast_io_hosted/platforms/posix.h" 3 4
                                    02000
# 60 "fast_io/fast_io_hosted/platforms/posix.h"
                                            ;

 case out|in:
  return mode | 
# 63 "fast_io/fast_io_hosted/platforms/posix.h" 3 4
               02
# 63 "fast_io/fast_io_hosted/platforms/posix.h"
                     ;

 case out|in|app:
 case in|app:
  return mode | 
# 67 "fast_io/fast_io_hosted/platforms/posix.h" 3 4
               02 
# 67 "fast_io/fast_io_hosted/platforms/posix.h"
                      | 
# 67 "fast_io/fast_io_hosted/platforms/posix.h" 3 4
                        0100 
# 67 "fast_io/fast_io_hosted/platforms/posix.h"
                                | 
# 67 "fast_io/fast_io_hosted/platforms/posix.h" 3 4
                                  02000
# 67 "fast_io/fast_io_hosted/platforms/posix.h"
                                          ;

 default:
  throw std::runtime_error("unknown posix file openmode");
 }
}
template<std::size_t om>
struct posix_file_openmode
{
 static int constexpr mode = calculate_posix_open_mode(om);
};
}

class posix_io_handle
{
 int fd;
protected:
 void close_impl() noexcept
 {
  if(fd!=-1)
   close(fd);
 }
 auto& protected_native_handle()
 {
  return fd;
 }
public:
 using char_type = char;
 using native_handle_type = int;
 native_handle_type native_handle()
 {
  return fd;
 }
 posix_io_handle() = default;
 posix_io_handle(int fdd):fd(fdd){}
 posix_io_handle(posix_io_handle const& dp):fd(dup(dp.fd))
 {
  if(fd<0)
   throw std::system_error(
# 105 "fast_io/fast_io_hosted/platforms/posix.h" 3 4
                          (*__errno_location ())
# 105 "fast_io/fast_io_hosted/platforms/posix.h"
                               ,std::generic_category());
 }
 posix_io_handle& operator=(posix_io_handle const& dp)
 {
  auto newfd(dup2(dp.fd,fd));
  if(newfd<0)
   throw std::system_error(
# 111 "fast_io/fast_io_hosted/platforms/posix.h" 3 4
                          (*__errno_location ())
# 111 "fast_io/fast_io_hosted/platforms/posix.h"
                               ,std::generic_category());
  fd=newfd;
  return *this;
 }
 posix_io_handle(posix_io_handle&& b) noexcept : posix_io_handle(b.fd)
 {
  b.fd = -1;
 }
 posix_io_handle& operator=(posix_io_handle&& b) noexcept
 {
  if(std::addressof(b)!=this)
  {
   close_impl();
   fd=b.fd;
   b.fd = -1;
  }
  return *this;
 }
 void swap(posix_io_handle& o) noexcept
 {
  using std::swap;
  swap(fd,o.fd);
 }
};

template<std::contiguous_iterator Iter>
inline Iter receive(posix_io_handle& h,Iter begin,Iter end)
{
 auto read_bytes(::read(h.native_handle(),std::to_address(begin),(end-begin)*sizeof(*begin)));
 if(read_bytes==-1)
  throw std::system_error(
# 141 "fast_io/fast_io_hosted/platforms/posix.h" 3 4
                         (*__errno_location ())
# 141 "fast_io/fast_io_hosted/platforms/posix.h"
                              ,std::generic_category());
 return begin+(read_bytes/sizeof(*begin));
}
template<std::contiguous_iterator Iter>
inline Iter send(posix_io_handle& h,Iter begin,Iter end)
{
 auto write_bytes(::write(h.native_handle(),std::to_address(begin),(end-begin)*sizeof(*begin)));
 if(write_bytes==-1)
  throw std::system_error(
# 149 "fast_io/fast_io_hosted/platforms/posix.h" 3 4
                         (*__errno_location ())
# 149 "fast_io/fast_io_hosted/platforms/posix.h"
                              ,std::generic_category());
 return begin+(write_bytes/sizeof(*begin));
}

template<typename T,std::integral R>
inline std::common_type_t<off64_t, std::size_t> seek(posix_io_handle& h,seek_type_t<T>,R i=0,seekdir s=seekdir::cur)
{
 auto ret(::lseek64(h.native_handle(),seek_precondition<off64_t,T,posix_io_handle::char_type>(i),static_cast<int>(s)));
 if(ret==-1)
  throw std::system_error(
# 158 "fast_io/fast_io_hosted/platforms/posix.h" 3 4
                         (*__errno_location ())
# 158 "fast_io/fast_io_hosted/platforms/posix.h"
                              ,std::generic_category());
 return ret;
}
template<std::integral R>
inline auto seek(posix_io_handle& h,R i=0,seekdir s=seekdir::cur)
{
 return seek(h,seek_type<posix_io_handle::char_type>,i,s);
}
inline void flush(posix_io_handle&)
{



}


inline auto zero_copy_in_handle(posix_io_handle& h)
{
 return h.native_handle();
}
inline auto zero_copy_out_handle(posix_io_handle& h)
{
 return h.native_handle();
}


inline void swap(posix_io_handle& a,posix_io_handle& b) noexcept
{
 a.swap(b);
}

class posix_file:public posix_io_handle
{
public:
 using char_type = posix_io_handle::char_type;
 using native_handle_type = posix_io_handle::native_handle_type;
 template<typename ...Args>
 requires requires(Args&& ...args)
 {
  {::open(std::forward<Args>(args)...)}->std::same_as<int>;
 }
 posix_file(native_interface_t,Args&& ...args):posix_io_handle(::open(std::forward<Args>(args)...))
 {
  if(native_handle()==-1)
   throw std::system_error(
# 202 "fast_io/fast_io_hosted/platforms/posix.h" 3 4
                          (*__errno_location ())
# 202 "fast_io/fast_io_hosted/platforms/posix.h"
                               ,std::generic_category());
 }
 template<std::size_t om,perms pm>
 posix_file(std::string_view file,open::interface_t<om>,perms_interface_t<pm>):posix_file(native_interface,file.data(),details::posix_file_openmode<om>::mode,static_cast<mode_t>(pm))
 {
  if constexpr (with_ate(open::mode(om)))
   seek(*this,0,seekdir::end);
 }
 template<std::size_t om>
 posix_file(std::string_view file,open::interface_t<om>):posix_file(native_interface,file.data(),details::posix_file_openmode<om>::mode,static_cast<mode_t>(420))
 {
  if constexpr (with_ate(open::mode(om)))
   seek(*this,0,seekdir::end);
 }
 template<std::size_t om>
 posix_file(std::string_view file,open::interface_t<om>,perms pm):posix_file(native_interface,file.data(),details::posix_file_openmode<om>::mode,static_cast<mode_t>(pm))
 {
  if constexpr (with_ate(open::mode(om)))
   seek(*this,0,seekdir::end);
 }

 posix_file(std::string_view file,open::mode const& m,perms pm=static_cast<perms>(420)):posix_file(native_interface,file.data(),details::calculate_posix_open_mode(m),static_cast<mode_t>(pm))
 {
  if(with_ate(m))
   seek(*this,0,seekdir::end);
 }
 posix_file(std::string_view file,std::string_view mode,perms pm=static_cast<perms>(420)):posix_file(file,fast_io::open::c_style(mode),pm){}
 ~posix_file()
 {
  posix_io_handle::close_impl();
 }
};

class posix_pipe_unique:public posix_io_handle
{
public:
 using posix_io_handle::char_type;
 using native_handle_type = int;
 void close()
 {
  posix_io_handle::close_impl();
  protected_native_handle() = -1;
 }
 ~posix_pipe_unique()
 {
  posix_io_handle::close_impl();
 }
};

class posix_pipe
{
public:
 using char_type = char;
 using native_handle_type = std::array<posix_pipe_unique,2>;
private:
 native_handle_type pipes;
public:
 posix_pipe()
 {



  if(::pipe(static_cast<int*>(static_cast<void*>(pipes.data())))==-1)

   throw std::system_error(
# 266 "fast_io/fast_io_hosted/platforms/posix.h" 3 4
                          (*__errno_location ())
# 266 "fast_io/fast_io_hosted/platforms/posix.h"
                               ,std::generic_category());
 }
 template<std::size_t om>
 posix_pipe(open::interface_t<om>):posix_pipe()
 {
  auto constexpr omb(om&~open::binary.value);
  static_assert(omb==open::in.value||omb==open::out.value||omb==(open::in.value|open::out.value),"pipe open mode must be in or out");
  if constexpr (!(om&~open::in.value)&&(om&~open::out.value))
   pipes.front().close();
  if constexpr ((om&~open::in.value)&&!(om&~open::out.value))
   pipes.back().close();
 }
 auto& native_handle()
 {
  return pipes;
 }
 auto& in()
 {
  return pipes.front();
 }
 auto& out()
 {
  return pipes.back();
 }
 void swap(posix_pipe& o) noexcept
 {
  using std::swap;
  swap(pipes,o.pipes);
 }
};
inline void swap(posix_pipe& a,posix_pipe& b) noexcept
{
 a.swap(b);
}

template<std::contiguous_iterator Iter>
inline Iter receive(posix_pipe& h,Iter begin,Iter end)
{
 return receive(h.in(),begin,end);
}
template<std::contiguous_iterator Iter>
inline Iter send(posix_pipe& h,Iter begin,Iter end)
{
 return send(h.out(),begin,end);
}

inline void flush(posix_pipe&)
{



}


inline auto zero_copy_in_handle(posix_pipe& h)
{
 return h.in().native_handle();
}
inline auto zero_copy_out_handle(posix_pipe& h)
{
 return h.out().native_handle();
}


using system_file = posix_file;
using system_io_handle = posix_io_handle;
using system_pipe_unique = posix_pipe_unique;
using system_pipe = posix_pipe;
inline int constexpr native_stdin_number = 0;
inline int constexpr native_stdout_number = 1;
inline int constexpr native_stderr_number = 2;



namespace details
{
template<zero_copy_output_stream output,zero_copy_input_stream input>
inline std::size_t zero_copy_transmit_once(output& outp,input& inp,std::size_t bytes)
{
 auto transmitted_bytes(::sendfile(zero_copy_out_handle(outp),zero_copy_in_handle(inp),nullptr,bytes));
 if(transmitted_bytes==-1)
  throw std::system_error(
# 347 "fast_io/fast_io_hosted/platforms/posix.h" 3 4
                         (*__errno_location ())
# 347 "fast_io/fast_io_hosted/platforms/posix.h"
                              ,std::generic_category());
 return transmitted_bytes;
}
}


template<zero_copy_output_stream output,zero_copy_input_stream input>
inline std::size_t zero_copy_transmit(output& outp,input& inp,std::size_t bytes)
{
 std::size_t constexpr maximum_transmit_bytes(2147479552);
 std::size_t transmitted(0);
 for(;bytes;)
 {
  std::size_t should_transfer(maximum_transmit_bytes);
  if(bytes<should_transfer)
   should_transfer=bytes;
  std::size_t transferred_this_round(details::zero_copy_transmit_once(outp,inp,should_transfer));
  transmitted+=transferred_this_round;
  if(transferred_this_round!=should_transfer)
   return transmitted;
  bytes-=transferred_this_round;
 }
 return transmitted;

}
template<zero_copy_output_stream output,zero_copy_input_stream input>
inline std::size_t zero_copy_transmit(output& outp,input& inp)
{
 std::size_t constexpr maximum_transmit_bytes(2147479552);
 for(std::size_t transmitted(0);;)
 {
  std::size_t transferred_this_round(details::zero_copy_transmit_once(outp,inp,maximum_transmit_bytes));
  transmitted+=transferred_this_round;
  if(transferred_this_round!=maximum_transmit_bytes)
   return transmitted;
 }
}


}
# 7 "fast_io/fast_io_hosted/platforms/native.h" 2


namespace fast_io
{
inline system_io_handle native_stdin()
{
 return native_stdin_number;
}
inline system_io_handle native_stdout()
{
 return native_stdout_number;
}
inline system_io_handle native_stderr()
{
 return native_stderr_number;
}
}
# 12 "fast_io/fast_io_hosted.h" 2
# 1 "fast_io/fast_io_hosted/iomutex.h" 1
       
# 1 "/usr/local/include/c++/10.0.0/mutex" 1 3
# 32 "/usr/local/include/c++/10.0.0/mutex" 3
       
# 33 "/usr/local/include/c++/10.0.0/mutex" 3






# 1 "/usr/local/include/c++/10.0.0/chrono" 1 3
# 33 "/usr/local/include/c++/10.0.0/chrono" 3
       
# 34 "/usr/local/include/c++/10.0.0/chrono" 3





# 1 "/usr/local/include/c++/10.0.0/ratio" 1 3
# 33 "/usr/local/include/c++/10.0.0/ratio" 3
       
# 34 "/usr/local/include/c++/10.0.0/ratio" 3
# 42 "/usr/local/include/c++/10.0.0/ratio" 3

# 42 "/usr/local/include/c++/10.0.0/ratio" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 56 "/usr/local/include/c++/10.0.0/ratio" 3
  template<intmax_t _Pn>
    struct __static_sign
    : integral_constant<intmax_t, (_Pn < 0) ? -1 : 1>
    { };

  template<intmax_t _Pn>
    struct __static_abs
    : integral_constant<intmax_t, _Pn * __static_sign<_Pn>::value>
    { };

  template<intmax_t _Pn, intmax_t _Qn>
    struct __static_gcd
    : __static_gcd<_Qn, (_Pn % _Qn)>
    { };

  template<intmax_t _Pn>
    struct __static_gcd<_Pn, 0>
    : integral_constant<intmax_t, __static_abs<_Pn>::value>
    { };

  template<intmax_t _Qn>
    struct __static_gcd<0, _Qn>
    : integral_constant<intmax_t, __static_abs<_Qn>::value>
    { };







  template<intmax_t _Pn, intmax_t _Qn>
    struct __safe_multiply
    {
    private:
      static const uintmax_t __c = uintmax_t(1) << (sizeof(intmax_t) * 4);

      static const uintmax_t __a0 = __static_abs<_Pn>::value % __c;
      static const uintmax_t __a1 = __static_abs<_Pn>::value / __c;
      static const uintmax_t __b0 = __static_abs<_Qn>::value % __c;
      static const uintmax_t __b1 = __static_abs<_Qn>::value / __c;

      static_assert(__a1 == 0 || __b1 == 0,
      "overflow in multiplication");
      static_assert(__a0 * __b1 + __b0 * __a1 < (__c >> 1),
      "overflow in multiplication");
      static_assert(__b0 * __a0 <= 0x7fffffffffffffffL,
      "overflow in multiplication");
      static_assert((__a0 * __b1 + __b0 * __a1) * __c
      <= 0x7fffffffffffffffL - __b0 * __a0,
      "overflow in multiplication");

    public:
      static const intmax_t value = _Pn * _Qn;
    };



  template<uintmax_t __hi1, uintmax_t __lo1, uintmax_t __hi2, uintmax_t __lo2>
    struct __big_less
    : integral_constant<bool, (__hi1 < __hi2
          || (__hi1 == __hi2 && __lo1 < __lo2))>
    { };

  template<uintmax_t __hi1, uintmax_t __lo1, uintmax_t __hi2, uintmax_t __lo2>
    struct __big_add
    {
      static constexpr uintmax_t __lo = __lo1 + __lo2;
      static constexpr uintmax_t __hi = (__hi1 + __hi2 +
      (__lo1 + __lo2 < __lo1));
    };


  template<uintmax_t __hi1, uintmax_t __lo1, uintmax_t __hi2, uintmax_t __lo2>
    struct __big_sub
    {
      static_assert(!__big_less<__hi1, __lo1, __hi2, __lo2>::value,
      "Internal library error");
      static constexpr uintmax_t __lo = __lo1 - __lo2;
      static constexpr uintmax_t __hi = (__hi1 - __hi2 -
      (__lo1 < __lo2));
    };


  template<uintmax_t __x, uintmax_t __y>
    struct __big_mul
    {
    private:
      static constexpr uintmax_t __c = uintmax_t(1) << (sizeof(intmax_t) * 4);
      static constexpr uintmax_t __x0 = __x % __c;
      static constexpr uintmax_t __x1 = __x / __c;
      static constexpr uintmax_t __y0 = __y % __c;
      static constexpr uintmax_t __y1 = __y / __c;
      static constexpr uintmax_t __x0y0 = __x0 * __y0;
      static constexpr uintmax_t __x0y1 = __x0 * __y1;
      static constexpr uintmax_t __x1y0 = __x1 * __y0;
      static constexpr uintmax_t __x1y1 = __x1 * __y1;
      static constexpr uintmax_t __mix = __x0y1 + __x1y0;
      static constexpr uintmax_t __mix_lo = __mix * __c;
      static constexpr uintmax_t __mix_hi
      = __mix / __c + ((__mix < __x0y1) ? __c : 0);
      typedef __big_add<__mix_hi, __mix_lo, __x1y1, __x0y0> _Res;
    public:
      static constexpr uintmax_t __hi = _Res::__hi;
      static constexpr uintmax_t __lo = _Res::__lo;
    };



  template<uintmax_t __n1, uintmax_t __n0, uintmax_t __d>
    struct __big_div_impl
    {
    private:
      static_assert(__d >= (uintmax_t(1) << (sizeof(intmax_t) * 8 - 1)),
      "Internal library error");
      static_assert(__n1 < __d, "Internal library error");
      static constexpr uintmax_t __c = uintmax_t(1) << (sizeof(intmax_t) * 4);
      static constexpr uintmax_t __d1 = __d / __c;
      static constexpr uintmax_t __d0 = __d % __c;

      static constexpr uintmax_t __q1x = __n1 / __d1;
      static constexpr uintmax_t __r1x = __n1 % __d1;
      static constexpr uintmax_t __m = __q1x * __d0;
      static constexpr uintmax_t __r1y = __r1x * __c + __n0 / __c;
      static constexpr uintmax_t __r1z = __r1y + __d;
      static constexpr uintmax_t __r1
      = ((__r1y < __m) ? ((__r1z >= __d) && (__r1z < __m))
  ? (__r1z + __d) : __r1z : __r1y) - __m;
      static constexpr uintmax_t __q1
      = __q1x - ((__r1y < __m)
   ? ((__r1z >= __d) && (__r1z < __m)) ? 2 : 1 : 0);
      static constexpr uintmax_t __q0x = __r1 / __d1;
      static constexpr uintmax_t __r0x = __r1 % __d1;
      static constexpr uintmax_t __n = __q0x * __d0;
      static constexpr uintmax_t __r0y = __r0x * __c + __n0 % __c;
      static constexpr uintmax_t __r0z = __r0y + __d;
      static constexpr uintmax_t __r0
      = ((__r0y < __n) ? ((__r0z >= __d) && (__r0z < __n))
  ? (__r0z + __d) : __r0z : __r0y) - __n;
      static constexpr uintmax_t __q0
      = __q0x - ((__r0y < __n) ? ((__r0z >= __d)
      && (__r0z < __n)) ? 2 : 1 : 0);

    public:
      static constexpr uintmax_t __quot = __q1 * __c + __q0;
      static constexpr uintmax_t __rem = __r0;

    private:
      typedef __big_mul<__quot, __d> _Prod;
      typedef __big_add<_Prod::__hi, _Prod::__lo, 0, __rem> _Sum;
      static_assert(_Sum::__hi == __n1 && _Sum::__lo == __n0,
      "Internal library error");
  };

  template<uintmax_t __n1, uintmax_t __n0, uintmax_t __d>
    struct __big_div
    {
    private:
      static_assert(__d != 0, "Internal library error");
      static_assert(sizeof (uintmax_t) == sizeof (unsigned long long),
      "This library calls __builtin_clzll on uintmax_t, which "
      "is unsafe on your platform. Please complain to "
      "http://gcc.gnu.org/bugzilla/");
      static constexpr int __shift = __builtin_clzll(__d);
      static constexpr int __coshift_ = sizeof(uintmax_t) * 8 - __shift;
      static constexpr int __coshift = (__shift != 0) ? __coshift_ : 0;
      static constexpr uintmax_t __c1 = uintmax_t(1) << __shift;
      static constexpr uintmax_t __c2 = uintmax_t(1) << __coshift;
      static constexpr uintmax_t __new_d = __d * __c1;
      static constexpr uintmax_t __new_n0 = __n0 * __c1;
      static constexpr uintmax_t __n1_shifted = (__n1 % __d) * __c1;
      static constexpr uintmax_t __n0_top = (__shift != 0) ? (__n0 / __c2) : 0;
      static constexpr uintmax_t __new_n1 = __n1_shifted + __n0_top;
      typedef __big_div_impl<__new_n1, __new_n0, __new_d> _Res;

    public:
      static constexpr uintmax_t __quot_hi = __n1 / __d;
      static constexpr uintmax_t __quot_lo = _Res::__quot;
      static constexpr uintmax_t __rem = _Res::__rem / __c1;

    private:
      typedef __big_mul<__quot_lo, __d> _P0;
      typedef __big_mul<__quot_hi, __d> _P1;
      typedef __big_add<_P0::__hi, _P0::__lo, _P1::__lo, __rem> _Sum;

      static_assert(_P1::__hi == 0, "Internal library error");
      static_assert(_Sum::__hi >= _P0::__hi, "Internal library error");

      static_assert(_Sum::__hi == __n1 && _Sum::__lo == __n0,
      "Internal library error");
      static_assert(__rem < __d, "Internal library error");
    };
# 265 "/usr/local/include/c++/10.0.0/ratio" 3
  template<intmax_t _Num, intmax_t _Den = 1>
    struct ratio
    {
      static_assert(_Den != 0, "denominator cannot be zero");
      static_assert(_Num >= -0x7fffffffffffffffL && _Den >= -0x7fffffffffffffffL,
      "out of range");


      static constexpr intmax_t num =
        _Num * __static_sign<_Den>::value / __static_gcd<_Num, _Den>::value;

      static constexpr intmax_t den =
        __static_abs<_Den>::value / __static_gcd<_Num, _Den>::value;

      typedef ratio<num, den> type;
    };

  template<intmax_t _Num, intmax_t _Den>
    constexpr intmax_t ratio<_Num, _Den>::num;

  template<intmax_t _Num, intmax_t _Den>
    constexpr intmax_t ratio<_Num, _Den>::den;



  template<typename _R1, typename _R2>
    struct __ratio_multiply
    {
    private:
      static const intmax_t __gcd1 =
        __static_gcd<_R1::num, _R2::den>::value;
      static const intmax_t __gcd2 =
        __static_gcd<_R2::num, _R1::den>::value;

    public:
      typedef ratio<
        __safe_multiply<(_R1::num / __gcd1),
                        (_R2::num / __gcd2)>::value,
        __safe_multiply<(_R1::den / __gcd2),
                        (_R2::den / __gcd1)>::value> type;

      static constexpr intmax_t num = type::num;
      static constexpr intmax_t den = type::den;
    };

  template<typename _R1, typename _R2>
    constexpr intmax_t __ratio_multiply<_R1, _R2>::num;

  template<typename _R1, typename _R2>
    constexpr intmax_t __ratio_multiply<_R1, _R2>::den;




  template<typename _R1, typename _R2>
    using ratio_multiply = typename __ratio_multiply<_R1, _R2>::type;



  template<typename _R1, typename _R2>
    struct __ratio_divide
    {
      static_assert(_R2::num != 0, "division by 0");

      typedef typename __ratio_multiply<
        _R1,
        ratio<_R2::den, _R2::num>>::type type;

      static constexpr intmax_t num = type::num;
      static constexpr intmax_t den = type::den;
    };

  template<typename _R1, typename _R2>
    constexpr intmax_t __ratio_divide<_R1, _R2>::num;

  template<typename _R1, typename _R2>
    constexpr intmax_t __ratio_divide<_R1, _R2>::den;




  template<typename _R1, typename _R2>
    using ratio_divide = typename __ratio_divide<_R1, _R2>::type;


  template<typename _R1, typename _R2>
    struct ratio_equal
    : integral_constant<bool, _R1::num == _R2::num && _R1::den == _R2::den>
    { };


  template<typename _R1, typename _R2>
    struct ratio_not_equal
    : integral_constant<bool, !ratio_equal<_R1, _R2>::value>
    { };




  template<typename _R1, typename _R2,
           typename _Left = __big_mul<_R1::num,_R2::den>,
           typename _Right = __big_mul<_R2::num,_R1::den> >
    struct __ratio_less_impl_1
    : integral_constant<bool, __big_less<_Left::__hi, _Left::__lo,
           _Right::__hi, _Right::__lo>::value>
    { };

  template<typename _R1, typename _R2,
    bool = (_R1::num == 0 || _R2::num == 0
     || (__static_sign<_R1::num>::value
         != __static_sign<_R2::num>::value)),
    bool = (__static_sign<_R1::num>::value == -1
     && __static_sign<_R2::num>::value == -1)>
    struct __ratio_less_impl
    : __ratio_less_impl_1<_R1, _R2>::type
    { };

  template<typename _R1, typename _R2>
    struct __ratio_less_impl<_R1, _R2, true, false>
    : integral_constant<bool, _R1::num < _R2::num>
    { };

  template<typename _R1, typename _R2>
    struct __ratio_less_impl<_R1, _R2, false, true>
    : __ratio_less_impl_1<ratio<-_R2::num, _R2::den>,
           ratio<-_R1::num, _R1::den> >::type
    { };




  template<typename _R1, typename _R2>
    struct ratio_less
    : __ratio_less_impl<_R1, _R2>::type
    { };


  template<typename _R1, typename _R2>
    struct ratio_less_equal
    : integral_constant<bool, !ratio_less<_R2, _R1>::value>
    { };


  template<typename _R1, typename _R2>
    struct ratio_greater
    : integral_constant<bool, ratio_less<_R2, _R1>::value>
    { };


  template<typename _R1, typename _R2>
    struct ratio_greater_equal
    : integral_constant<bool, !ratio_less<_R1, _R2>::value>
    { };


  template <typename _R1, typename _R2>
    inline constexpr bool ratio_equal_v = ratio_equal<_R1, _R2>::value;
  template <typename _R1, typename _R2>
    inline constexpr bool ratio_not_equal_v = ratio_not_equal<_R1, _R2>::value;
  template <typename _R1, typename _R2>
    inline constexpr bool ratio_less_v = ratio_less<_R1, _R2>::value;
  template <typename _R1, typename _R2>
    inline constexpr bool ratio_less_equal_v =
      ratio_less_equal<_R1, _R2>::value;
  template <typename _R1, typename _R2>
    inline constexpr bool ratio_greater_v = ratio_greater<_R1, _R2>::value;
  template <typename _R1, typename _R2>
    inline constexpr bool ratio_greater_equal_v
    = ratio_greater_equal<_R1, _R2>::value;




  template<typename _R1, typename _R2,
      bool = (_R1::num >= 0),
      bool = (_R2::num >= 0),
      bool = ratio_less<ratio<__static_abs<_R1::num>::value, _R1::den>,
        ratio<__static_abs<_R2::num>::value, _R2::den> >::value>
    struct __ratio_add_impl
    {
    private:
      typedef typename __ratio_add_impl<
        ratio<-_R1::num, _R1::den>,
        ratio<-_R2::num, _R2::den> >::type __t;
    public:
      typedef ratio<-__t::num, __t::den> type;
    };


  template<typename _R1, typename _R2, bool __b>
    struct __ratio_add_impl<_R1, _R2, true, true, __b>
    {
    private:
      static constexpr uintmax_t __g = __static_gcd<_R1::den, _R2::den>::value;
      static constexpr uintmax_t __d2 = _R2::den / __g;
      typedef __big_mul<_R1::den, __d2> __d;
      typedef __big_mul<_R1::num, _R2::den / __g> __x;
      typedef __big_mul<_R2::num, _R1::den / __g> __y;
      typedef __big_add<__x::__hi, __x::__lo, __y::__hi, __y::__lo> __n;
      static_assert(__n::__hi >= __x::__hi, "Internal library error");
      typedef __big_div<__n::__hi, __n::__lo, __g> __ng;
      static constexpr uintmax_t __g2 = __static_gcd<__ng::__rem, __g>::value;
      typedef __big_div<__n::__hi, __n::__lo, __g2> __n_final;
      static_assert(__n_final::__rem == 0, "Internal library error");
      static_assert(__n_final::__quot_hi == 0 &&
        __n_final::__quot_lo <= 0x7fffffffffffffffL, "overflow in addition");
      typedef __big_mul<_R1::den / __g2, __d2> __d_final;
      static_assert(__d_final::__hi == 0 &&
        __d_final::__lo <= 0x7fffffffffffffffL, "overflow in addition");
    public:
      typedef ratio<__n_final::__quot_lo, __d_final::__lo> type;
    };

  template<typename _R1, typename _R2>
    struct __ratio_add_impl<_R1, _R2, false, true, true>
    : __ratio_add_impl<_R2, _R1>
    { };


  template<typename _R1, typename _R2>
    struct __ratio_add_impl<_R1, _R2, true, false, false>
    {
    private:
      static constexpr uintmax_t __g = __static_gcd<_R1::den, _R2::den>::value;
      static constexpr uintmax_t __d2 = _R2::den / __g;
      typedef __big_mul<_R1::den, __d2> __d;
      typedef __big_mul<_R1::num, _R2::den / __g> __x;
      typedef __big_mul<-_R2::num, _R1::den / __g> __y;
      typedef __big_sub<__x::__hi, __x::__lo, __y::__hi, __y::__lo> __n;
      typedef __big_div<__n::__hi, __n::__lo, __g> __ng;
      static constexpr uintmax_t __g2 = __static_gcd<__ng::__rem, __g>::value;
      typedef __big_div<__n::__hi, __n::__lo, __g2> __n_final;
      static_assert(__n_final::__rem == 0, "Internal library error");
      static_assert(__n_final::__quot_hi == 0 &&
        __n_final::__quot_lo <= 0x7fffffffffffffffL, "overflow in addition");
      typedef __big_mul<_R1::den / __g2, __d2> __d_final;
      static_assert(__d_final::__hi == 0 &&
        __d_final::__lo <= 0x7fffffffffffffffL, "overflow in addition");
    public:
      typedef ratio<__n_final::__quot_lo, __d_final::__lo> type;
    };

  template<typename _R1, typename _R2>
    struct __ratio_add
    {
      typedef typename __ratio_add_impl<_R1, _R2>::type type;
      static constexpr intmax_t num = type::num;
      static constexpr intmax_t den = type::den;
    };

  template<typename _R1, typename _R2>
    constexpr intmax_t __ratio_add<_R1, _R2>::num;

  template<typename _R1, typename _R2>
    constexpr intmax_t __ratio_add<_R1, _R2>::den;




  template<typename _R1, typename _R2>
    using ratio_add = typename __ratio_add<_R1, _R2>::type;



  template<typename _R1, typename _R2>
    struct __ratio_subtract
    {
      typedef typename __ratio_add<
        _R1,
        ratio<-_R2::num, _R2::den>>::type type;

      static constexpr intmax_t num = type::num;
      static constexpr intmax_t den = type::den;
    };

  template<typename _R1, typename _R2>
    constexpr intmax_t __ratio_subtract<_R1, _R2>::num;

  template<typename _R1, typename _R2>
    constexpr intmax_t __ratio_subtract<_R1, _R2>::den;




  template<typename _R1, typename _R2>
    using ratio_subtract = typename __ratio_subtract<_R1, _R2>::type;


  typedef ratio<1, 1000000000000000000> atto;
  typedef ratio<1, 1000000000000000> femto;
  typedef ratio<1, 1000000000000> pico;
  typedef ratio<1, 1000000000> nano;
  typedef ratio<1, 1000000> micro;
  typedef ratio<1, 1000> milli;
  typedef ratio<1, 100> centi;
  typedef ratio<1, 10> deci;
  typedef ratio< 10, 1> deca;
  typedef ratio< 100, 1> hecto;
  typedef ratio< 1000, 1> kilo;
  typedef ratio< 1000000, 1> mega;
  typedef ratio< 1000000000, 1> giga;
  typedef ratio< 1000000000000, 1> tera;
  typedef ratio< 1000000000000000, 1> peta;
  typedef ratio< 1000000000000000000, 1> exa;



}
# 40 "/usr/local/include/c++/10.0.0/chrono" 2 3


# 1 "/usr/local/include/c++/10.0.0/ctime" 1 3
# 39 "/usr/local/include/c++/10.0.0/ctime" 3
       
# 40 "/usr/local/include/c++/10.0.0/ctime" 3
# 58 "/usr/local/include/c++/10.0.0/ctime" 3
namespace std
{
  using ::clock_t;
  using ::time_t;
  using ::tm;

  using ::clock;
  using ::difftime;
  using ::mktime;
  using ::time;
  using ::asctime;
  using ::ctime;
  using ::gmtime;
  using ::localtime;
  using ::strftime;
}



namespace std
{
  using ::timespec;
  using ::timespec_get;
}
# 43 "/usr/local/include/c++/10.0.0/chrono" 2 3
# 1 "/usr/local/include/c++/10.0.0/bits/parse_numbers.h" 1 3
# 33 "/usr/local/include/c++/10.0.0/bits/parse_numbers.h" 3
       
# 34 "/usr/local/include/c++/10.0.0/bits/parse_numbers.h" 3







namespace std __attribute__ ((__visibility__ ("default")))
{


namespace __parse_int
{
  template<unsigned _Base, char _Dig>
    struct _Digit;

  template<unsigned _Base>
    struct _Digit<_Base, '0'> : integral_constant<unsigned, 0>
    {
      using __valid = true_type;
    };

  template<unsigned _Base>
    struct _Digit<_Base, '1'> : integral_constant<unsigned, 1>
    {
      using __valid = true_type;
    };

  template<unsigned _Base, unsigned _Val>
    struct _Digit_impl : integral_constant<unsigned, _Val>
    {
      static_assert(_Base > _Val, "invalid digit");
      using __valid = true_type;
    };

  template<unsigned _Base>
    struct _Digit<_Base, '2'> : _Digit_impl<_Base, 2>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, '3'> : _Digit_impl<_Base, 3>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, '4'> : _Digit_impl<_Base, 4>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, '5'> : _Digit_impl<_Base, 5>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, '6'> : _Digit_impl<_Base, 6>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, '7'> : _Digit_impl<_Base, 7>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, '8'> : _Digit_impl<_Base, 8>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, '9'> : _Digit_impl<_Base, 9>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, 'a'> : _Digit_impl<_Base, 0xa>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, 'A'> : _Digit_impl<_Base, 0xa>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, 'b'> : _Digit_impl<_Base, 0xb>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, 'B'> : _Digit_impl<_Base, 0xb>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, 'c'> : _Digit_impl<_Base, 0xc>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, 'C'> : _Digit_impl<_Base, 0xc>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, 'd'> : _Digit_impl<_Base, 0xd>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, 'D'> : _Digit_impl<_Base, 0xd>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, 'e'> : _Digit_impl<_Base, 0xe>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, 'E'> : _Digit_impl<_Base, 0xe>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, 'f'> : _Digit_impl<_Base, 0xf>
    { };

  template<unsigned _Base>
    struct _Digit<_Base, 'F'> : _Digit_impl<_Base, 0xf>
    { };


  template<unsigned _Base>
    struct _Digit<_Base, '\''> : integral_constant<unsigned, 0>
    {
      using __valid = false_type;
    };



  template<unsigned long long _Val>
    using __ull_constant = integral_constant<unsigned long long, _Val>;

  template<unsigned _Base, char _Dig, char... _Digs>
    struct _Power_help
    {
      using __next = typename _Power_help<_Base, _Digs...>::type;
      using __valid_digit = typename _Digit<_Base, _Dig>::__valid;
      using type
 = __ull_constant<__next::value * (__valid_digit{} ? _Base : 1ULL)>;
    };

  template<unsigned _Base, char _Dig>
    struct _Power_help<_Base, _Dig>
    {
      using __valid_digit = typename _Digit<_Base, _Dig>::__valid;
      using type = __ull_constant<__valid_digit::value>;
    };

  template<unsigned _Base, char... _Digs>
    struct _Power : _Power_help<_Base, _Digs...>::type
    { };

  template<unsigned _Base>
    struct _Power<_Base> : __ull_constant<0>
    { };



  template<unsigned _Base, unsigned long long _Pow, char _Dig, char... _Digs>
    struct _Number_help
    {
      using __digit = _Digit<_Base, _Dig>;
      using __valid_digit = typename __digit::__valid;
      using __next = _Number_help<_Base,
      __valid_digit::value ? _Pow / _Base : _Pow,
      _Digs...>;
      using type = __ull_constant<_Pow * __digit::value + __next::type::value>;
      static_assert((type::value / _Pow) == __digit::value,
      "integer literal does not fit in unsigned long long");
    };


  template<unsigned _Base, unsigned long long _Pow, char _Dig, char..._Digs>
    struct _Number_help<_Base, _Pow, '\'', _Dig, _Digs...>
    : _Number_help<_Base, _Pow, _Dig, _Digs...>
    { };


  template<unsigned _Base, char _Dig>
    struct _Number_help<_Base, 1ULL, _Dig>
    {
      using type = __ull_constant<_Digit<_Base, _Dig>::value>;
    };

  template<unsigned _Base, char... _Digs>
    struct _Number
    : _Number_help<_Base, _Power<_Base, _Digs...>::value, _Digs...>::type
    { };

  template<unsigned _Base>
    struct _Number<_Base>
    : __ull_constant<0>
    { };



  template<char... _Digs>
    struct _Parse_int;

  template<char... _Digs>
    struct _Parse_int<'0', 'b', _Digs...>
    : _Number<2U, _Digs...>::type
    { };

  template<char... _Digs>
    struct _Parse_int<'0', 'B', _Digs...>
    : _Number<2U, _Digs...>::type
    { };

  template<char... _Digs>
    struct _Parse_int<'0', 'x', _Digs...>
    : _Number<16U, _Digs...>::type
    { };

  template<char... _Digs>
    struct _Parse_int<'0', 'X', _Digs...>
    : _Number<16U, _Digs...>::type
    { };

  template<char... _Digs>
    struct _Parse_int<'0', _Digs...>
    : _Number<8U, _Digs...>::type
    { };

  template<char... _Digs>
    struct _Parse_int
    : _Number<10U, _Digs...>::type
    { };

}


namespace __select_int
{
  template<unsigned long long _Val, typename... _Ints>
    struct _Select_int_base;

  template<unsigned long long _Val, typename _IntType, typename... _Ints>
    struct _Select_int_base<_Val, _IntType, _Ints...>
    : conditional_t<(_Val <= std::numeric_limits<_IntType>::max()),
      integral_constant<_IntType, _Val>,
      _Select_int_base<_Val, _Ints...>>
    { };

  template<unsigned long long _Val>
    struct _Select_int_base<_Val>
    { };

  template<char... _Digs>
    using _Select_int = typename _Select_int_base<
 __parse_int::_Parse_int<_Digs...>::value,
 unsigned char,
 unsigned short,
 unsigned int,
 unsigned long,
 unsigned long long
      >::type;

}


}
# 44 "/usr/local/include/c++/10.0.0/chrono" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 60 "/usr/local/include/c++/10.0.0/chrono" 3
  namespace chrono
  {
    template<typename _Rep, typename _Period = ratio<1>>
      struct duration;

    template<typename _Clock, typename _Dur = typename _Clock::duration>
      struct time_point;
  }





  template<typename _CT, typename _Period1, typename _Period2, typename = void>
    struct __duration_common_type
    { };

  template<typename _CT, typename _Period1, typename _Period2>
    struct __duration_common_type<_CT, _Period1, _Period2,
      __void_t<typename _CT::type>>
    {
    private:
      using __gcd_num = __static_gcd<_Period1::num, _Period2::num>;
      using __gcd_den = __static_gcd<_Period1::den, _Period2::den>;
      using __cr = typename _CT::type;
      using __r = ratio<__gcd_num::value,
   (_Period1::den / __gcd_den::value) * _Period2::den>;

    public:
      using type = chrono::duration<__cr, __r>;
    };

  template<typename _Period1, typename _Period2>
    struct __duration_common_type<__failure_type, _Period1, _Period2>
    { typedef __failure_type type; };





  template<typename _Rep1, typename _Period1, typename _Rep2, typename _Period2>
    struct common_type<chrono::duration<_Rep1, _Period1>,
         chrono::duration<_Rep2, _Period2>>
    : __duration_common_type<common_type<_Rep1, _Rep2>, _Period1, _Period2>
    { };





  template<typename _CT, typename _Clock, typename = void>
    struct __timepoint_common_type
    { };

  template<typename _CT, typename _Clock>
    struct __timepoint_common_type<_CT, _Clock, __void_t<typename _CT::type>>
    {
      using type = chrono::time_point<_Clock, typename _CT::type>;
    };





  template<typename _Clock, typename _Duration1, typename _Duration2>
    struct common_type<chrono::time_point<_Clock, _Duration1>,
         chrono::time_point<_Clock, _Duration2>>
    : __timepoint_common_type<common_type<_Duration1, _Duration2>, _Clock>
    { };



  namespace chrono
  {






    template<typename _ToDur, typename _CF, typename _CR,
      bool _NumIsOne = false, bool _DenIsOne = false>
      struct __duration_cast_impl
      {
 template<typename _Rep, typename _Period>
   static constexpr _ToDur
   __cast(const duration<_Rep, _Period>& __d)
   {
     typedef typename _ToDur::rep __to_rep;
     return _ToDur(static_cast<__to_rep>(static_cast<_CR>(__d.count())
       * static_cast<_CR>(_CF::num)
       / static_cast<_CR>(_CF::den)));
   }
      };

    template<typename _ToDur, typename _CF, typename _CR>
      struct __duration_cast_impl<_ToDur, _CF, _CR, true, true>
      {
 template<typename _Rep, typename _Period>
   static constexpr _ToDur
   __cast(const duration<_Rep, _Period>& __d)
   {
     typedef typename _ToDur::rep __to_rep;
     return _ToDur(static_cast<__to_rep>(__d.count()));
   }
      };

    template<typename _ToDur, typename _CF, typename _CR>
      struct __duration_cast_impl<_ToDur, _CF, _CR, true, false>
      {
 template<typename _Rep, typename _Period>
   static constexpr _ToDur
   __cast(const duration<_Rep, _Period>& __d)
   {
     typedef typename _ToDur::rep __to_rep;
     return _ToDur(static_cast<__to_rep>(
       static_cast<_CR>(__d.count()) / static_cast<_CR>(_CF::den)));
   }
      };

    template<typename _ToDur, typename _CF, typename _CR>
      struct __duration_cast_impl<_ToDur, _CF, _CR, false, true>
      {
 template<typename _Rep, typename _Period>
   static constexpr _ToDur
   __cast(const duration<_Rep, _Period>& __d)
   {
     typedef typename _ToDur::rep __to_rep;
     return _ToDur(static_cast<__to_rep>(
       static_cast<_CR>(__d.count()) * static_cast<_CR>(_CF::num)));
   }
      };

    template<typename _Tp>
      struct __is_duration
      : std::false_type
      { };

    template<typename _Rep, typename _Period>
      struct __is_duration<duration<_Rep, _Period>>
      : std::true_type
      { };

    template<typename _Tp>
      using __enable_if_is_duration
 = typename enable_if<__is_duration<_Tp>::value, _Tp>::type;

    template<typename _Tp>
      using __disable_if_is_duration
 = typename enable_if<!__is_duration<_Tp>::value, _Tp>::type;




    template<typename _ToDur, typename _Rep, typename _Period>
      constexpr __enable_if_is_duration<_ToDur>
      duration_cast(const duration<_Rep, _Period>& __d)
      {
 typedef typename _ToDur::period __to_period;
 typedef typename _ToDur::rep __to_rep;
 typedef ratio_divide<_Period, __to_period> __cf;
 typedef typename common_type<__to_rep, _Rep, intmax_t>::type
          __cr;
 typedef __duration_cast_impl<_ToDur, __cf, __cr,
          __cf::num == 1, __cf::den == 1> __dc;
 return __dc::__cast(__d);
      }


    template<typename _Rep>
      struct treat_as_floating_point
      : is_floating_point<_Rep>
      { };


    template <typename _Rep>
      inline constexpr bool treat_as_floating_point_v =
        treat_as_floating_point<_Rep>::value;





    template<typename _ToDur, typename _Rep, typename _Period>
      constexpr __enable_if_is_duration<_ToDur>
      floor(const duration<_Rep, _Period>& __d)
      {
 auto __to = chrono::duration_cast<_ToDur>(__d);
 if (__to > __d)
   return __to - _ToDur{1};
 return __to;
      }

    template<typename _ToDur, typename _Rep, typename _Period>
      constexpr __enable_if_is_duration<_ToDur>
      ceil(const duration<_Rep, _Period>& __d)
      {
 auto __to = chrono::duration_cast<_ToDur>(__d);
 if (__to < __d)
   return __to + _ToDur{1};
 return __to;
      }

    template <typename _ToDur, typename _Rep, typename _Period>
      constexpr enable_if_t<
 __and_<__is_duration<_ToDur>,
        __not_<treat_as_floating_point<typename _ToDur::rep>>>::value,
 _ToDur>
      round(const duration<_Rep, _Period>& __d)
      {
 _ToDur __t0 = chrono::floor<_ToDur>(__d);
 _ToDur __t1 = __t0 + _ToDur{1};
 auto __diff0 = __d - __t0;
 auto __diff1 = __t1 - __d;
 if (__diff0 == __diff1)
 {
     if (__t0.count() & 1)
  return __t1;
     return __t0;
 }
 else if (__diff0 < __diff1)
     return __t0;
 return __t1;
      }

    template<typename _Rep, typename _Period>
      constexpr
      enable_if_t<numeric_limits<_Rep>::is_signed, duration<_Rep, _Period>>
      abs(duration<_Rep, _Period> __d)
      {
 if (__d >= __d.zero())
   return __d;
 return -__d;
      }



    template<typename _Rep>
      struct duration_values
      {
 static constexpr _Rep
 zero() noexcept
 { return _Rep(0); }

 static constexpr _Rep
 max() noexcept
 { return numeric_limits<_Rep>::max(); }

 static constexpr _Rep
 min() noexcept
 { return numeric_limits<_Rep>::lowest(); }
      };



    template<typename _Tp>
      struct __is_ratio
      : std::false_type
      { };

    template<intmax_t _Num, intmax_t _Den>
      struct __is_ratio<ratio<_Num, _Den>>
      : std::true_type
      { };




    template<typename _Rep, typename _Period>
      struct duration
      {
      private:
 template<typename _Rep2>
   using __is_float = treat_as_floating_point<_Rep2>;


 template<typename _Period2>
   using __is_harmonic
     = __bool_constant<ratio_divide<_Period2, _Period>::den == 1>;

      public:

 typedef _Rep rep;
 typedef _Period period;

 static_assert(!__is_duration<_Rep>::value, "rep cannot be a duration");
 static_assert(__is_ratio<_Period>::value,
        "period must be a specialization of ratio");
 static_assert(_Period::num > 0, "period must be positive");


 constexpr duration() = default;

 duration(const duration&) = default;



 template<typename _Rep2, typename = _Require<
   is_convertible<const _Rep2&, rep>,
   __or_<__is_float<rep>, __not_<__is_float<_Rep2>>>>>
   constexpr explicit duration(const _Rep2& __rep)
   : __r(static_cast<rep>(__rep)) { }

 template<typename _Rep2, typename _Period2, typename = _Require<
   __or_<__is_float<rep>,
         __and_<__is_harmonic<_Period2>,
         __not_<__is_float<_Rep2>>>>>>
   constexpr duration(const duration<_Rep2, _Period2>& __d)
   : __r(duration_cast<duration>(__d).count()) { }

 ~duration() = default;
 duration& operator=(const duration&) = default;


 constexpr rep
 count() const
 { return __r; }


 constexpr duration
 operator+() const
 { return *this; }

 constexpr duration
 operator-() const
 { return duration(-__r); }

 constexpr duration&
 operator++()
 {
   ++__r;
   return *this;
 }

 constexpr duration
 operator++(int)
 { return duration(__r++); }

 constexpr duration&
 operator--()
 {
   --__r;
   return *this;
 }

 constexpr duration
 operator--(int)
 { return duration(__r--); }

 constexpr duration&
 operator+=(const duration& __d)
 {
   __r += __d.count();
   return *this;
 }

 constexpr duration&
 operator-=(const duration& __d)
 {
   __r -= __d.count();
   return *this;
 }

 constexpr duration&
 operator*=(const rep& __rhs)
 {
   __r *= __rhs;
   return *this;
 }

 constexpr duration&
 operator/=(const rep& __rhs)
 {
   __r /= __rhs;
   return *this;
 }


 template<typename _Rep2 = rep>
   constexpr
   typename enable_if<!treat_as_floating_point<_Rep2>::value,
        duration&>::type
   operator%=(const rep& __rhs)
   {
     __r %= __rhs;
     return *this;
   }

 template<typename _Rep2 = rep>
   constexpr
   typename enable_if<!treat_as_floating_point<_Rep2>::value,
        duration&>::type
   operator%=(const duration& __d)
   {
     __r %= __d.count();
     return *this;
   }


 static constexpr duration
 zero() noexcept
 { return duration(duration_values<rep>::zero()); }

 static constexpr duration
 min() noexcept
 { return duration(duration_values<rep>::min()); }

 static constexpr duration
 max() noexcept
 { return duration(duration_values<rep>::max()); }

      private:
 rep __r;
      };




    template<typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2>
      constexpr typename common_type<duration<_Rep1, _Period1>,
         duration<_Rep2, _Period2>>::type
      operator+(const duration<_Rep1, _Period1>& __lhs,
  const duration<_Rep2, _Period2>& __rhs)
      {
 typedef duration<_Rep1, _Period1> __dur1;
 typedef duration<_Rep2, _Period2> __dur2;
 typedef typename common_type<__dur1,__dur2>::type __cd;
 return __cd(__cd(__lhs).count() + __cd(__rhs).count());
      }


    template<typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2>
      constexpr typename common_type<duration<_Rep1, _Period1>,
         duration<_Rep2, _Period2>>::type
      operator-(const duration<_Rep1, _Period1>& __lhs,
  const duration<_Rep2, _Period2>& __rhs)
      {
 typedef duration<_Rep1, _Period1> __dur1;
 typedef duration<_Rep2, _Period2> __dur2;
 typedef typename common_type<__dur1,__dur2>::type __cd;
 return __cd(__cd(__lhs).count() - __cd(__rhs).count());
      }
# 513 "/usr/local/include/c++/10.0.0/chrono" 3
    template<typename _Rep1, typename _Rep2,
      typename _CRep = typename common_type<_Rep1, _Rep2>::type>
      using __common_rep_t = typename
 enable_if<is_convertible<const _Rep2&, _CRep>::value, _CRep>::type;






    template<typename _Rep1, typename _Period, typename _Rep2>
      constexpr duration<__common_rep_t<_Rep1, _Rep2>, _Period>
      operator*(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
      {
 typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period>
   __cd;
 return __cd(__cd(__d).count() * __s);
      }


    template<typename _Rep1, typename _Rep2, typename _Period>
      constexpr duration<__common_rep_t<_Rep2, _Rep1>, _Period>
      operator*(const _Rep1& __s, const duration<_Rep2, _Period>& __d)
      { return __d * __s; }

    template<typename _Rep1, typename _Period, typename _Rep2>
      constexpr
      duration<__common_rep_t<_Rep1, __disable_if_is_duration<_Rep2>>, _Period>
      operator/(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
      {
 typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period>
   __cd;
 return __cd(__cd(__d).count() / __s);
      }

    template<typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2>
      constexpr typename common_type<_Rep1, _Rep2>::type
      operator/(const duration<_Rep1, _Period1>& __lhs,
  const duration<_Rep2, _Period2>& __rhs)
      {
 typedef duration<_Rep1, _Period1> __dur1;
 typedef duration<_Rep2, _Period2> __dur2;
 typedef typename common_type<__dur1,__dur2>::type __cd;
 return __cd(__lhs).count() / __cd(__rhs).count();
      }


    template<typename _Rep1, typename _Period, typename _Rep2>
      constexpr
      duration<__common_rep_t<_Rep1, __disable_if_is_duration<_Rep2>>, _Period>
      operator%(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
      {
 typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period>
   __cd;
 return __cd(__cd(__d).count() % __s);
      }

    template<typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2>
      constexpr typename common_type<duration<_Rep1, _Period1>,
         duration<_Rep2, _Period2>>::type
      operator%(const duration<_Rep1, _Period1>& __lhs,
  const duration<_Rep2, _Period2>& __rhs)
      {
 typedef duration<_Rep1, _Period1> __dur1;
 typedef duration<_Rep2, _Period2> __dur2;
 typedef typename common_type<__dur1,__dur2>::type __cd;
 return __cd(__cd(__lhs).count() % __cd(__rhs).count());
      }



    template<typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2>
      constexpr bool
      operator==(const duration<_Rep1, _Period1>& __lhs,
   const duration<_Rep2, _Period2>& __rhs)
      {
 typedef duration<_Rep1, _Period1> __dur1;
 typedef duration<_Rep2, _Period2> __dur2;
 typedef typename common_type<__dur1,__dur2>::type __ct;
 return __ct(__lhs).count() == __ct(__rhs).count();
      }

    template<typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2>
      constexpr bool
      operator<(const duration<_Rep1, _Period1>& __lhs,
  const duration<_Rep2, _Period2>& __rhs)
      {
 typedef duration<_Rep1, _Period1> __dur1;
 typedef duration<_Rep2, _Period2> __dur2;
 typedef typename common_type<__dur1,__dur2>::type __ct;
 return __ct(__lhs).count() < __ct(__rhs).count();
      }

    template<typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2>
      constexpr bool
      operator!=(const duration<_Rep1, _Period1>& __lhs,
   const duration<_Rep2, _Period2>& __rhs)
      { return !(__lhs == __rhs); }

    template<typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2>
      constexpr bool
      operator<=(const duration<_Rep1, _Period1>& __lhs,
   const duration<_Rep2, _Period2>& __rhs)
      { return !(__rhs < __lhs); }

    template<typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2>
      constexpr bool
      operator>(const duration<_Rep1, _Period1>& __lhs,
  const duration<_Rep2, _Period2>& __rhs)
      { return __rhs < __lhs; }

    template<typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2>
      constexpr bool
      operator>=(const duration<_Rep1, _Period1>& __lhs,
   const duration<_Rep2, _Period2>& __rhs)
      { return !(__lhs < __rhs); }
# 651 "/usr/local/include/c++/10.0.0/chrono" 3
    typedef duration<int64_t, nano> nanoseconds;


    typedef duration<int64_t, micro> microseconds;


    typedef duration<int64_t, milli> milliseconds;


    typedef duration<int64_t> seconds;


    typedef duration<int64_t, ratio< 60>> minutes;


    typedef duration<int64_t, ratio<3600>> hours;




    template<typename _Clock, typename _Dur>
      struct time_point
      {
 typedef _Clock clock;
 typedef _Dur duration;
 typedef typename duration::rep rep;
 typedef typename duration::period period;

 constexpr time_point() : __d(duration::zero())
 { }

 constexpr explicit time_point(const duration& __dur)
 : __d(__dur)
 { }


 template<typename _Dur2,
   typename = _Require<is_convertible<_Dur2, _Dur>>>
   constexpr time_point(const time_point<clock, _Dur2>& __t)
   : __d(__t.time_since_epoch())
   { }


 constexpr duration
 time_since_epoch() const
 { return __d; }


 constexpr time_point&
 operator+=(const duration& __dur)
 {
   __d += __dur;
   return *this;
 }

 constexpr time_point&
 operator-=(const duration& __dur)
 {
   __d -= __dur;
   return *this;
 }


 static constexpr time_point
 min() noexcept
 { return time_point(duration::min()); }

 static constexpr time_point
 max() noexcept
 { return time_point(duration::max()); }

      private:
 duration __d;
      };


    template<typename _ToDur, typename _Clock, typename _Dur>
      constexpr typename enable_if<__is_duration<_ToDur>::value,
       time_point<_Clock, _ToDur>>::type
      time_point_cast(const time_point<_Clock, _Dur>& __t)
      {
 typedef time_point<_Clock, _ToDur> __time_point;
 return __time_point(duration_cast<_ToDur>(__t.time_since_epoch()));
      }


    template<typename _ToDur, typename _Clock, typename _Dur>
      constexpr
      enable_if_t<__is_duration<_ToDur>::value, time_point<_Clock, _ToDur>>
      floor(const time_point<_Clock, _Dur>& __tp)
      {
 return time_point<_Clock, _ToDur>{
     chrono::floor<_ToDur>(__tp.time_since_epoch())};
      }

    template<typename _ToDur, typename _Clock, typename _Dur>
      constexpr
      enable_if_t<__is_duration<_ToDur>::value, time_point<_Clock, _ToDur>>
      ceil(const time_point<_Clock, _Dur>& __tp)
      {
 return time_point<_Clock, _ToDur>{
     chrono::ceil<_ToDur>(__tp.time_since_epoch())};
      }

    template<typename _ToDur, typename _Clock, typename _Dur>
      constexpr enable_if_t<
 __and_<__is_duration<_ToDur>,
        __not_<treat_as_floating_point<typename _ToDur::rep>>>::value,
 time_point<_Clock, _ToDur>>
      round(const time_point<_Clock, _Dur>& __tp)
      {
 return time_point<_Clock, _ToDur>{
     chrono::round<_ToDur>(__tp.time_since_epoch())};
      }





    template<typename _Clock, typename _Dur1,
      typename _Rep2, typename _Period2>
      constexpr time_point<_Clock,
 typename common_type<_Dur1, duration<_Rep2, _Period2>>::type>
      operator+(const time_point<_Clock, _Dur1>& __lhs,
  const duration<_Rep2, _Period2>& __rhs)
      {
 typedef duration<_Rep2, _Period2> __dur2;
 typedef typename common_type<_Dur1,__dur2>::type __ct;
 typedef time_point<_Clock, __ct> __time_point;
 return __time_point(__lhs.time_since_epoch() + __rhs);
      }


    template<typename _Rep1, typename _Period1,
      typename _Clock, typename _Dur2>
      constexpr time_point<_Clock,
 typename common_type<duration<_Rep1, _Period1>, _Dur2>::type>
      operator+(const duration<_Rep1, _Period1>& __lhs,
  const time_point<_Clock, _Dur2>& __rhs)
      {
 typedef duration<_Rep1, _Period1> __dur1;
 typedef typename common_type<__dur1,_Dur2>::type __ct;
 typedef time_point<_Clock, __ct> __time_point;
 return __time_point(__rhs.time_since_epoch() + __lhs);
      }


    template<typename _Clock, typename _Dur1,
      typename _Rep2, typename _Period2>
      constexpr time_point<_Clock,
 typename common_type<_Dur1, duration<_Rep2, _Period2>>::type>
      operator-(const time_point<_Clock, _Dur1>& __lhs,
  const duration<_Rep2, _Period2>& __rhs)
      {
 typedef duration<_Rep2, _Period2> __dur2;
 typedef typename common_type<_Dur1,__dur2>::type __ct;
 typedef time_point<_Clock, __ct> __time_point;
 return __time_point(__lhs.time_since_epoch() -__rhs);
      }






    template<typename _Clock, typename _Dur1, typename _Dur2>
      constexpr typename common_type<_Dur1, _Dur2>::type
      operator-(const time_point<_Clock, _Dur1>& __lhs,
  const time_point<_Clock, _Dur2>& __rhs)
      { return __lhs.time_since_epoch() - __rhs.time_since_epoch(); }

    template<typename _Clock, typename _Dur1, typename _Dur2>
      constexpr bool
      operator==(const time_point<_Clock, _Dur1>& __lhs,
   const time_point<_Clock, _Dur2>& __rhs)
      { return __lhs.time_since_epoch() == __rhs.time_since_epoch(); }

    template<typename _Clock, typename _Dur1, typename _Dur2>
      constexpr bool
      operator!=(const time_point<_Clock, _Dur1>& __lhs,
   const time_point<_Clock, _Dur2>& __rhs)
      { return !(__lhs == __rhs); }

    template<typename _Clock, typename _Dur1, typename _Dur2>
      constexpr bool
      operator<(const time_point<_Clock, _Dur1>& __lhs,
  const time_point<_Clock, _Dur2>& __rhs)
      { return __lhs.time_since_epoch() < __rhs.time_since_epoch(); }

    template<typename _Clock, typename _Dur1, typename _Dur2>
      constexpr bool
      operator<=(const time_point<_Clock, _Dur1>& __lhs,
   const time_point<_Clock, _Dur2>& __rhs)
      { return !(__rhs < __lhs); }

    template<typename _Clock, typename _Dur1, typename _Dur2>
      constexpr bool
      operator>(const time_point<_Clock, _Dur1>& __lhs,
  const time_point<_Clock, _Dur2>& __rhs)
      { return __rhs < __lhs; }

    template<typename _Clock, typename _Dur1, typename _Dur2>
      constexpr bool
      operator>=(const time_point<_Clock, _Dur1>& __lhs,
   const time_point<_Clock, _Dur2>& __rhs)
      { return !(__lhs < __rhs); }
# 878 "/usr/local/include/c++/10.0.0/chrono" 3
    inline namespace _V2 {







    struct system_clock
    {
      typedef chrono::nanoseconds duration;
      typedef duration::rep rep;
      typedef duration::period period;
      typedef chrono::time_point<system_clock, duration> time_point;

      static_assert(system_clock::duration::min()
      < system_clock::duration::zero(),
      "a clock's minimum duration cannot be less than its epoch");

      static constexpr bool is_steady = false;

      static time_point
      now() noexcept;


      static std::time_t
      to_time_t(const time_point& __t) noexcept
      {
 return std::time_t(duration_cast<chrono::seconds>
      (__t.time_since_epoch()).count());
      }

      static time_point
      from_time_t(std::time_t __t) noexcept
      {
 typedef chrono::time_point<system_clock, seconds> __from;
 return time_point_cast<system_clock::duration>
        (__from(chrono::seconds(__t)));
      }
    };
# 926 "/usr/local/include/c++/10.0.0/chrono" 3
    struct steady_clock
    {
      typedef chrono::nanoseconds duration;
      typedef duration::rep rep;
      typedef duration::period period;
      typedef chrono::time_point<steady_clock, duration> time_point;

      static constexpr bool is_steady = true;

      static time_point
      now() noexcept;
    };
# 948 "/usr/local/include/c++/10.0.0/chrono" 3
    using high_resolution_clock = system_clock;

    }

  }





  inline namespace literals
  {
# 983 "/usr/local/include/c++/10.0.0/chrono" 3
  inline namespace chrono_literals
  {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wliteral-suffix"

    template<typename _Dur, char... _Digits>
      constexpr _Dur __check_overflow()
      {
 using _Val = __parse_int::_Parse_int<_Digits...>;
 constexpr typename _Dur::rep __repval = _Val::value;
 static_assert(__repval >= 0 && __repval == _Val::value,
        "literal value cannot be represented by duration type");
 return _Dur(__repval);
      }



    constexpr chrono::duration<long double, ratio<3600,1>>
    operator""h(long double __hours)
    { return chrono::duration<long double, ratio<3600,1>>{__hours}; }


    template <char... _Digits>
      constexpr chrono::hours
      operator""h()
      { return __check_overflow<chrono::hours, _Digits...>(); }


    constexpr chrono::duration<long double, ratio<60,1>>
    operator""min(long double __mins)
    { return chrono::duration<long double, ratio<60,1>>{__mins}; }


    template <char... _Digits>
      constexpr chrono::minutes
      operator""min()
      { return __check_overflow<chrono::minutes, _Digits...>(); }


    constexpr chrono::duration<long double>
    operator""s(long double __secs)
    { return chrono::duration<long double>{__secs}; }


    template <char... _Digits>
      constexpr chrono::seconds
      operator""s()
      { return __check_overflow<chrono::seconds, _Digits...>(); }


    constexpr chrono::duration<long double, milli>
    operator""ms(long double __msecs)
    { return chrono::duration<long double, milli>{__msecs}; }


    template <char... _Digits>
      constexpr chrono::milliseconds
      operator""ms()
      { return __check_overflow<chrono::milliseconds, _Digits...>(); }


    constexpr chrono::duration<long double, micro>
    operator""us(long double __usecs)
    { return chrono::duration<long double, micro>{__usecs}; }


    template <char... _Digits>
      constexpr chrono::microseconds
      operator""us()
      { return __check_overflow<chrono::microseconds, _Digits...>(); }


    constexpr chrono::duration<long double, nano>
    operator""ns(long double __nsecs)
    { return chrono::duration<long double, nano>{__nsecs}; }


    template <char... _Digits>
      constexpr chrono::nanoseconds
      operator""ns()
      { return __check_overflow<chrono::nanoseconds, _Digits...>(); }

#pragma GCC diagnostic pop
  }
  }

  namespace chrono
  {
    using namespace literals::chrono_literals;
  }




}
# 40 "/usr/local/include/c++/10.0.0/mutex" 2 3



# 1 "/usr/local/include/c++/10.0.0/bits/std_mutex.h" 1 3
# 33 "/usr/local/include/c++/10.0.0/bits/std_mutex.h" 3
       
# 34 "/usr/local/include/c++/10.0.0/bits/std_mutex.h" 3
# 43 "/usr/local/include/c++/10.0.0/bits/std_mutex.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 57 "/usr/local/include/c++/10.0.0/bits/std_mutex.h" 3
  class __mutex_base
  {
  protected:
    typedef __gthread_mutex_t __native_type;


    __native_type _M_mutex = { { 0, 0, 0, 0, 0, 0, 0, { 0, 0 } } };

    constexpr __mutex_base() noexcept = default;
# 78 "/usr/local/include/c++/10.0.0/bits/std_mutex.h" 3
    __mutex_base(const __mutex_base&) = delete;
    __mutex_base& operator=(const __mutex_base&) = delete;
  };


  class mutex : private __mutex_base
  {
  public:
    typedef __native_type* native_handle_type;


    constexpr

    mutex() noexcept = default;
    ~mutex() = default;

    mutex(const mutex&) = delete;
    mutex& operator=(const mutex&) = delete;

    void
    lock()
    {
      int __e = __gthread_mutex_lock(&_M_mutex);


      if (__e)
 __throw_system_error(__e);
    }

    bool
    try_lock() noexcept
    {

      return !__gthread_mutex_trylock(&_M_mutex);
    }

    void
    unlock()
    {

      __gthread_mutex_unlock(&_M_mutex);
    }

    native_handle_type
    native_handle() noexcept
    { return &_M_mutex; }
  };




  struct defer_lock_t { explicit defer_lock_t() = default; };


  struct try_to_lock_t { explicit try_to_lock_t() = default; };



  struct adopt_lock_t { explicit adopt_lock_t() = default; };


  inline constexpr defer_lock_t defer_lock { };


  inline constexpr try_to_lock_t try_to_lock { };


  inline constexpr adopt_lock_t adopt_lock { };






  template<typename _Mutex>
    class lock_guard
    {
    public:
      typedef _Mutex mutex_type;

      explicit lock_guard(mutex_type& __m) : _M_device(__m)
      { _M_device.lock(); }

      lock_guard(mutex_type& __m, adopt_lock_t) noexcept : _M_device(__m)
      { }

      ~lock_guard()
      { _M_device.unlock(); }

      lock_guard(const lock_guard&) = delete;
      lock_guard& operator=(const lock_guard&) = delete;

    private:
      mutex_type& _M_device;
    };



}
# 44 "/usr/local/include/c++/10.0.0/mutex" 2 3
# 1 "/usr/local/include/c++/10.0.0/bits/unique_lock.h" 1 3
# 33 "/usr/local/include/c++/10.0.0/bits/unique_lock.h" 3
       
# 34 "/usr/local/include/c++/10.0.0/bits/unique_lock.h" 3
# 42 "/usr/local/include/c++/10.0.0/bits/unique_lock.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 55 "/usr/local/include/c++/10.0.0/bits/unique_lock.h" 3
  template<typename _Mutex>
    class unique_lock
    {
    public:
      typedef _Mutex mutex_type;

      unique_lock() noexcept
      : _M_device(0), _M_owns(false)
      { }

      explicit unique_lock(mutex_type& __m)
      : _M_device(std::__addressof(__m)), _M_owns(false)
      {
 lock();
 _M_owns = true;
      }

      unique_lock(mutex_type& __m, defer_lock_t) noexcept
      : _M_device(std::__addressof(__m)), _M_owns(false)
      { }

      unique_lock(mutex_type& __m, try_to_lock_t)
      : _M_device(std::__addressof(__m)), _M_owns(_M_device->try_lock())
      { }

      unique_lock(mutex_type& __m, adopt_lock_t) noexcept
      : _M_device(std::__addressof(__m)), _M_owns(true)
      {

      }

      template<typename _Clock, typename _Duration>
 unique_lock(mutex_type& __m,
      const chrono::time_point<_Clock, _Duration>& __atime)
 : _M_device(std::__addressof(__m)),
   _M_owns(_M_device->try_lock_until(__atime))
 { }

      template<typename _Rep, typename _Period>
 unique_lock(mutex_type& __m,
      const chrono::duration<_Rep, _Period>& __rtime)
 : _M_device(std::__addressof(__m)),
   _M_owns(_M_device->try_lock_for(__rtime))
 { }

      ~unique_lock()
      {
 if (_M_owns)
   unlock();
      }

      unique_lock(const unique_lock&) = delete;
      unique_lock& operator=(const unique_lock&) = delete;

      unique_lock(unique_lock&& __u) noexcept
      : _M_device(__u._M_device), _M_owns(__u._M_owns)
      {
 __u._M_device = 0;
 __u._M_owns = false;
      }

      unique_lock& operator=(unique_lock&& __u) noexcept
      {
 if(_M_owns)
   unlock();

 unique_lock(std::move(__u)).swap(*this);

 __u._M_device = 0;
 __u._M_owns = false;

 return *this;
      }

      void
      lock()
      {
 if (!_M_device)
   __throw_system_error(int(errc::operation_not_permitted));
 else if (_M_owns)
   __throw_system_error(int(errc::resource_deadlock_would_occur));
 else
   {
     _M_device->lock();
     _M_owns = true;
   }
      }

      bool
      try_lock()
      {
 if (!_M_device)
   __throw_system_error(int(errc::operation_not_permitted));
 else if (_M_owns)
   __throw_system_error(int(errc::resource_deadlock_would_occur));
 else
   {
     _M_owns = _M_device->try_lock();
     return _M_owns;
   }
      }

      template<typename _Clock, typename _Duration>
 bool
 try_lock_until(const chrono::time_point<_Clock, _Duration>& __atime)
 {
   if (!_M_device)
     __throw_system_error(int(errc::operation_not_permitted));
   else if (_M_owns)
     __throw_system_error(int(errc::resource_deadlock_would_occur));
   else
     {
       _M_owns = _M_device->try_lock_until(__atime);
       return _M_owns;
     }
 }

      template<typename _Rep, typename _Period>
 bool
 try_lock_for(const chrono::duration<_Rep, _Period>& __rtime)
 {
   if (!_M_device)
     __throw_system_error(int(errc::operation_not_permitted));
   else if (_M_owns)
     __throw_system_error(int(errc::resource_deadlock_would_occur));
   else
     {
       _M_owns = _M_device->try_lock_for(__rtime);
       return _M_owns;
     }
  }

      void
      unlock()
      {
 if (!_M_owns)
   __throw_system_error(int(errc::operation_not_permitted));
 else if (_M_device)
   {
     _M_device->unlock();
     _M_owns = false;
   }
      }

      void
      swap(unique_lock& __u) noexcept
      {
 std::swap(_M_device, __u._M_device);
 std::swap(_M_owns, __u._M_owns);
      }

      mutex_type*
      release() noexcept
      {
 mutex_type* __ret = _M_device;
 _M_device = 0;
 _M_owns = false;
 return __ret;
      }

      bool
      owns_lock() const noexcept
      { return _M_owns; }

      explicit operator bool() const noexcept
      { return owns_lock(); }

      mutex_type*
      mutex() const noexcept
      { return _M_device; }

    private:
      mutex_type* _M_device;
      bool _M_owns;
    };



  template<typename _Mutex>
    inline void
    swap(unique_lock<_Mutex>& __x, unique_lock<_Mutex>& __y) noexcept
    { __x.swap(__y); }


}
# 45 "/usr/local/include/c++/10.0.0/mutex" 2 3
# 53 "/usr/local/include/c++/10.0.0/mutex" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 65 "/usr/local/include/c++/10.0.0/mutex" 3
  class __recursive_mutex_base
  {
  protected:
    typedef __gthread_recursive_mutex_t __native_type;

    __recursive_mutex_base(const __recursive_mutex_base&) = delete;
    __recursive_mutex_base& operator=(const __recursive_mutex_base&) = delete;


    __native_type _M_mutex = { { 0, 0, 0, 0, PTHREAD_MUTEX_RECURSIVE_NP, 0, 0, { 0, 0 } } };

    __recursive_mutex_base() = default;
# 89 "/usr/local/include/c++/10.0.0/mutex" 3
  };


  class recursive_mutex : private __recursive_mutex_base
  {
  public:
    typedef __native_type* native_handle_type;

    recursive_mutex() = default;
    ~recursive_mutex() = default;

    recursive_mutex(const recursive_mutex&) = delete;
    recursive_mutex& operator=(const recursive_mutex&) = delete;

    void
    lock()
    {
      int __e = __gthread_recursive_mutex_lock(&_M_mutex);


      if (__e)
 __throw_system_error(__e);
    }

    bool
    try_lock() noexcept
    {

      return !__gthread_recursive_mutex_trylock(&_M_mutex);
    }

    void
    unlock()
    {

      __gthread_recursive_mutex_unlock(&_M_mutex);
    }

    native_handle_type
    native_handle() noexcept
    { return &_M_mutex; }
  };


  template<typename _Derived>
    class __timed_mutex_impl
    {
    protected:
      template<typename _Rep, typename _Period>
 bool
 _M_try_lock_for(const chrono::duration<_Rep, _Period>& __rtime)
 {



   using __clock = chrono::system_clock;


   auto __rt = chrono::duration_cast<__clock::duration>(__rtime);
   if (ratio_greater<__clock::period, _Period>())
     ++__rt;
   return _M_try_lock_until(__clock::now() + __rt);
 }

      template<typename _Duration>
 bool
 _M_try_lock_until(const chrono::time_point<chrono::system_clock,
         _Duration>& __atime)
 {
   auto __s = chrono::time_point_cast<chrono::seconds>(__atime);
   auto __ns = chrono::duration_cast<chrono::nanoseconds>(__atime - __s);

   __gthread_time_t __ts = {
     static_cast<std::time_t>(__s.time_since_epoch().count()),
     static_cast<long>(__ns.count())
   };

   return static_cast<_Derived*>(this)->_M_timedlock(__ts);
 }
# 188 "/usr/local/include/c++/10.0.0/mutex" 3
      template<typename _Clock, typename _Duration>
 bool
 _M_try_lock_until(const chrono::time_point<_Clock, _Duration>& __atime)
 {



   auto __now = _Clock::now();
   do {
     auto __rtime = __atime - __now;
     if (_M_try_lock_for(__rtime))
       return true;
     __now = _Clock::now();
   } while (__atime > __now);
   return false;
 }
    };


  class timed_mutex
  : private __mutex_base, public __timed_mutex_impl<timed_mutex>
  {
  public:
    typedef __native_type* native_handle_type;

    timed_mutex() = default;
    ~timed_mutex() = default;

    timed_mutex(const timed_mutex&) = delete;
    timed_mutex& operator=(const timed_mutex&) = delete;

    void
    lock()
    {
      int __e = __gthread_mutex_lock(&_M_mutex);


      if (__e)
 __throw_system_error(__e);
    }

    bool
    try_lock() noexcept
    {

      return !__gthread_mutex_trylock(&_M_mutex);
    }

    template <class _Rep, class _Period>
      bool
      try_lock_for(const chrono::duration<_Rep, _Period>& __rtime)
      { return _M_try_lock_for(__rtime); }

    template <class _Clock, class _Duration>
      bool
      try_lock_until(const chrono::time_point<_Clock, _Duration>& __atime)
      { return _M_try_lock_until(__atime); }

    void
    unlock()
    {

      __gthread_mutex_unlock(&_M_mutex);
    }

    native_handle_type
    native_handle() noexcept
    { return &_M_mutex; }

    private:
      friend class __timed_mutex_impl<timed_mutex>;

      bool
      _M_timedlock(const __gthread_time_t& __ts)
      { return !__gthread_mutex_timedlock(&_M_mutex, &__ts); }






  };


  class recursive_timed_mutex
  : private __recursive_mutex_base,
    public __timed_mutex_impl<recursive_timed_mutex>
  {
  public:
    typedef __native_type* native_handle_type;

    recursive_timed_mutex() = default;
    ~recursive_timed_mutex() = default;

    recursive_timed_mutex(const recursive_timed_mutex&) = delete;
    recursive_timed_mutex& operator=(const recursive_timed_mutex&) = delete;

    void
    lock()
    {
      int __e = __gthread_recursive_mutex_lock(&_M_mutex);


      if (__e)
 __throw_system_error(__e);
    }

    bool
    try_lock() noexcept
    {

      return !__gthread_recursive_mutex_trylock(&_M_mutex);
    }

    template <class _Rep, class _Period>
      bool
      try_lock_for(const chrono::duration<_Rep, _Period>& __rtime)
      { return _M_try_lock_for(__rtime); }

    template <class _Clock, class _Duration>
      bool
      try_lock_until(const chrono::time_point<_Clock, _Duration>& __atime)
      { return _M_try_lock_until(__atime); }

    void
    unlock()
    {

      __gthread_recursive_mutex_unlock(&_M_mutex);
    }

    native_handle_type
    native_handle() noexcept
    { return &_M_mutex; }

    private:
      friend class __timed_mutex_impl<recursive_timed_mutex>;

      bool
      _M_timedlock(const __gthread_time_t& __ts)
      { return !__gthread_recursive_mutex_timedlock(&_M_mutex, &__ts); }






  };
# 510 "/usr/local/include/c++/10.0.0/mutex" 3
  template<typename _Lock>
    inline unique_lock<_Lock>
    __try_to_lock(_Lock& __l)
    { return unique_lock<_Lock>{__l, try_to_lock}; }

  template<int _Idx, bool _Continue = true>
    struct __try_lock_impl
    {
      template<typename... _Lock>
 static void
 __do_try_lock(tuple<_Lock&...>& __locks, int& __idx)
 {
          __idx = _Idx;
          auto __lock = std::__try_to_lock(std::get<_Idx>(__locks));
          if (__lock.owns_lock())
            {
       constexpr bool __cont = _Idx + 2 < sizeof...(_Lock);
       using __try_locker = __try_lock_impl<_Idx + 1, __cont>;
       __try_locker::__do_try_lock(__locks, __idx);
              if (__idx == -1)
                __lock.release();
            }
 }
    };

  template<int _Idx>
    struct __try_lock_impl<_Idx, false>
    {
      template<typename... _Lock>
 static void
 __do_try_lock(tuple<_Lock&...>& __locks, int& __idx)
 {
          __idx = _Idx;
          auto __lock = std::__try_to_lock(std::get<_Idx>(__locks));
          if (__lock.owns_lock())
            {
              __idx = -1;
              __lock.release();
            }
 }
    };
# 563 "/usr/local/include/c++/10.0.0/mutex" 3
  template<typename _Lock1, typename _Lock2, typename... _Lock3>
    int
    try_lock(_Lock1& __l1, _Lock2& __l2, _Lock3&... __l3)
    {
      int __idx;
      auto __locks = std::tie(__l1, __l2, __l3...);
      __try_lock_impl<0>::__do_try_lock(__locks, __idx);
      return __idx;
    }
# 584 "/usr/local/include/c++/10.0.0/mutex" 3
  template<typename _L1, typename _L2, typename... _L3>
    void
    lock(_L1& __l1, _L2& __l2, _L3&... __l3)
    {
      while (true)
        {
          using __try_locker = __try_lock_impl<0, sizeof...(_L3) != 0>;
          unique_lock<_L1> __first(__l1);
          int __idx;
          auto __locks = std::tie(__l2, __l3...);
          __try_locker::__do_try_lock(__locks, __idx);
          if (__idx == -1)
            {
              __first.release();
              return;
            }
        }
    }
# 610 "/usr/local/include/c++/10.0.0/mutex" 3
  template<typename... _MutexTypes>
    class scoped_lock
    {
    public:
      explicit scoped_lock(_MutexTypes&... __m) : _M_devices(std::tie(__m...))
      { std::lock(__m...); }

      explicit scoped_lock(adopt_lock_t, _MutexTypes&... __m) noexcept
      : _M_devices(std::tie(__m...))
      { }

      ~scoped_lock()
      { std::apply([](auto&... __m) { (__m.unlock(), ...); }, _M_devices); }

      scoped_lock(const scoped_lock&) = delete;
      scoped_lock& operator=(const scoped_lock&) = delete;

    private:
      tuple<_MutexTypes&...> _M_devices;
    };

  template<>
    class scoped_lock<>
    {
    public:
      explicit scoped_lock() = default;
      explicit scoped_lock(adopt_lock_t) noexcept { }
      ~scoped_lock() = default;

      scoped_lock(const scoped_lock&) = delete;
      scoped_lock& operator=(const scoped_lock&) = delete;
    };

  template<typename _Mutex>
    class scoped_lock<_Mutex>
    {
    public:
      using mutex_type = _Mutex;

      explicit scoped_lock(mutex_type& __m) : _M_device(__m)
      { _M_device.lock(); }

      explicit scoped_lock(adopt_lock_t, mutex_type& __m) noexcept
      : _M_device(__m)
      { }

      ~scoped_lock()
      { _M_device.unlock(); }

      scoped_lock(const scoped_lock&) = delete;
      scoped_lock& operator=(const scoped_lock&) = delete;

    private:
      mutex_type& _M_device;
    };




  struct once_flag
  {
  private:
    typedef __gthread_once_t __native_type;
    __native_type _M_once = 0;

  public:

    constexpr once_flag() noexcept = default;


    once_flag(const once_flag&) = delete;

    once_flag& operator=(const once_flag&) = delete;

    template<typename _Callable, typename... _Args>
      friend void
      call_once(once_flag& __once, _Callable&& __f, _Args&&... __args);
  };



  extern __thread void* __once_callable;
  extern __thread void (*__once_call)();
# 703 "/usr/local/include/c++/10.0.0/mutex" 3
  extern "C" void __once_proxy(void);



  template<typename _Callable, typename... _Args>
    void
    call_once(once_flag& __once, _Callable&& __f, _Args&&... __args)
    {


      auto __callable = [&] {
   std::__invoke(std::forward<_Callable>(__f),
   std::forward<_Args>(__args)...);
      };

      __once_callable = std::__addressof(__callable);
      __once_call = []{ (*(decltype(__callable)*)__once_callable)(); };






      int __e = __gthread_once(&__once._M_once, &__once_proxy);
# 739 "/usr/local/include/c++/10.0.0/mutex" 3
      if (__e)
 __throw_system_error(__e);
    }




}
# 3 "fast_io/fast_io_hosted/iomutex.h" 2


# 4 "fast_io/fast_io_hosted/iomutex.h"
namespace fast_io
{

template<stream T>
class basic_iomutex
{
 std::unique_ptr<std::mutex> mtx;
 T handler;
public:
 using native_handle_type = T;
 using lock_guard_type = std::lock_guard<std::mutex>;
 using char_type = typename native_handle_type::char_type;
 template<typename ...Args>
 requires std::constructible_from<T,Args...>
 basic_iomutex(Args&& ...args):mtx(std::make_unique<std::mutex>()),handler(std::forward<Args>(args)...){}
 native_handle_type& native_handle()
 {
  return handler;
 }
 std::mutex& mutex()
 {
  return *mtx;
 }
 void swap(basic_iomutex& o) noexcept
 {
  using std::swap;
  swap(mtx,o.mtx);
  swap(handler,o.handler);
 }
};

template<stream T>
inline auto& mutex(basic_iomutex<T>& t)
{
 return t.mutex();
}

template<stream T>
inline auto& unlocked_handle(basic_iomutex<T>& t)
{
 return t.native_handle();
}

template<output_stream T,std::contiguous_iterator Iter>
inline auto send(basic_iomutex<T>& t,Iter b,Iter e)
{
 std::lock_guard lg(t.mutex());
 return send(t.native_handle(),b,e);
}

template<output_stream T>
inline void flush(basic_iomutex<T>& t)
{
 std::lock_guard lg(t.mutex());
 flush(t.native_handle());
}
template<input_stream T,std::contiguous_iterator Iter>
inline Iter receive(basic_iomutex<T>& t,Iter begin,Iter end)
{
 std::lock_guard lg(t.mutex());
 return receive(t.native_handle(),begin,end);
}


template<random_access_stream T,typename... Args>
inline auto seek(basic_iomutex<T>& t,Args&& ...args)
{
 std::lock_guard lg(t.mutex());
 return seek(t.native_handle(),std::forward<Args>(args)...);
}

template<character_output_stream output>
inline void fill_nc(basic_iomutex<output>& out,std::size_t count,typename output::char_type const& ch)
{
 std::lock_guard lg{out.mutex()};
 fill_nc(out.native_handle(),count,ch);
}

template<stream T>
inline void swap(basic_iomutex<T>& a,basic_iomutex<T>& b) noexcept
{
 a.swap(b);
}

}
# 13 "fast_io/fast_io_hosted.h" 2
# 1 "fast_io/fast_io_hosted/chrono.h" 1
       


namespace fast_io
{


template<output_stream output,typename Rep,typename Period>
void print_define(output& out, std::chrono::duration<Rep,Period> const& duration)
{
 print(out,std::chrono::duration_cast<std::chrono::duration<double>>(duration).count());
}

template<output_stream output,typename Clock,typename Duration>
void print_define(output& out, std::chrono::time_point<Clock,Duration> const& tmp)
{
 print(out,tmp.time_since_epoch());
}


}
# 14 "fast_io/fast_io_hosted.h" 2
# 4 "fast_io/fast_io.h" 2





namespace fast_io
{
inline namespace
{

using in_type = fast_io::basic_iomutex<fast_io::basic_ibuf<system_io_handle>>;

in_type in(native_stdin_number);
inline system_io_handle out(native_stdout_number);
inline system_io_handle err(native_stderr_number);


inline auto out_buf()
{
 return basic_obuf<system_io_handle>(native_stdout_number);
}

inline auto log()
{
 return basic_obuf<system_io_handle>(native_stderr_number);
}

}
}
# 3 "autocomplete.cpp" 2
# 1 "fast_io/fast_io_async.h" 1
       

# 1 "fast_io/fast_io_async/model.h" 1
       

namespace fast_io
{

enum class async
{
 unknown = 0,
 iocp = 1,
 epoll = 2,
 kqueue = 3,
 posix = 4,
 native =



 epoll





};

}




# 1 "fast_io/fast_io_async/epoll.h" 1
       

# 1 "/usr/include/x86_64-linux-gnu/sys/epoll.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/epoll.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/epoll.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/epoll.h" 3 4

# 23 "/usr/include/x86_64-linux-gnu/bits/epoll.h" 3 4
enum
  {
    EPOLL_CLOEXEC = 02000000

  };
# 28 "/usr/include/x86_64-linux-gnu/sys/epoll.h" 2 3 4






enum EPOLL_EVENTS
  {
    EPOLLIN = 0x001,

    EPOLLPRI = 0x002,

    EPOLLOUT = 0x004,

    EPOLLRDNORM = 0x040,

    EPOLLRDBAND = 0x080,

    EPOLLWRNORM = 0x100,

    EPOLLWRBAND = 0x200,

    EPOLLMSG = 0x400,

    EPOLLERR = 0x008,

    EPOLLHUP = 0x010,

    EPOLLRDHUP = 0x2000,

    EPOLLEXCLUSIVE = 1u << 28,

    EPOLLWAKEUP = 1u << 29,

    EPOLLONESHOT = 1u << 30,

    EPOLLET = 1u << 31

  };
# 75 "/usr/include/x86_64-linux-gnu/sys/epoll.h" 3 4
typedef union epoll_data
{
  void *ptr;
  int fd;
  uint32_t u32;
  uint64_t u64;
} epoll_data_t;

struct epoll_event
{
  uint32_t events;
  epoll_data_t data;
} __attribute__ ((__packed__));


extern "C" {





extern int epoll_create (int __size) throw ();



extern int epoll_create1 (int __flags) throw ();
# 109 "/usr/include/x86_64-linux-gnu/sys/epoll.h" 3 4
extern int epoll_ctl (int __epfd, int __op, int __fd,
        struct epoll_event *__event) throw ();
# 123 "/usr/include/x86_64-linux-gnu/sys/epoll.h" 3 4
extern int epoll_wait (int __epfd, struct epoll_event *__events,
         int __maxevents, int __timeout);







extern int epoll_pwait (int __epfd, struct epoll_event *__events,
   int __maxevents, int __timeout,
   const __sigset_t *__ss);

}
# 4 "fast_io/fast_io_async/epoll.h" 2


# 5 "fast_io/fast_io_async/epoll.h"
namespace fast_io
{

namespace epoll
{

struct close_on_exec_function_invoked_t
{
explicit constexpr close_on_exec_function_invoked_t()=default;
};

inline constexpr close_on_exec_function_invoked_t close_on_exec_function_invoked{};


class handle_pool
{
 int fd;
 void close_impl() noexcept
 {
  if(fd!=-1)
   close(fd);
 }
public:
 using native_handle_type = int;
 explicit handle_pool(std::integral auto counts):fd(::epoll_create(static_cast<int>(counts)))
 {
  if(fd==-1)
   throw std::system_error(
# 32 "fast_io/fast_io_async/epoll.h" 3 4
                          (*__errno_location ())
# 32 "fast_io/fast_io_async/epoll.h"
                               ,std::generic_category());
 }
 explicit handle_pool(std::integral auto counts,close_on_exec_function_invoked_t):
  fd(::epoll_create1(static_cast<int>(counts)|
# 35 "fast_io/fast_io_async/epoll.h" 3 4
                                             EPOLL_CLOEXEC
# 35 "fast_io/fast_io_async/epoll.h"
                                                          ))
 {
  if(fd==-1)
   throw std::system_error(
# 38 "fast_io/fast_io_async/epoll.h" 3 4
                          (*__errno_location ())
# 38 "fast_io/fast_io_async/epoll.h"
                               ,std::generic_category());
 }
 handle_pool(handle_pool const& dp):fd(dup(dp.fd))
 {
  if(fd<0)
   throw std::system_error(
# 43 "fast_io/fast_io_async/epoll.h" 3 4
                          (*__errno_location ())
# 43 "fast_io/fast_io_async/epoll.h"
                               ,std::generic_category());
 }
 handle_pool& operator=(handle_pool const& dp)
 {
  auto newfd(dup2(dp.fd,fd));
  if(newfd<0)
   throw std::system_error(
# 49 "fast_io/fast_io_async/epoll.h" 3 4
                          (*__errno_location ())
# 49 "fast_io/fast_io_async/epoll.h"
                               ,std::generic_category());
  fd=newfd;
  return *this;
 }
 handle_pool(handle_pool&& b) noexcept : handle_pool(b.fd)
 {
  b.fd = -1;
 }
 handle_pool& operator=(handle_pool&& b) noexcept
 {
  if(std::addressof(b)!=this)
  {
   close_impl();
   fd=b.fd;
   b.fd = -1;
  }
  return *this;
 }
 auto native_handle() const
 {
  return fd;
 }
 ~handle_pool()
 {
  if(fd!=-1)
   close(fd);
 }
};


enum class event:std::uint32_t
{
none=0,in=1,pri=2,out=4,err=8,hup=0x10,nval=0x20,rdnorm=0x40,
rdband=0x80,wrnorm=0x100,wrband=0x200,message=0x400,
rdhup=0x2000,exclusive=1u<<28,oneshot=1u<<30,edge_trigger=1u<<31
};

constexpr event operator&(event x, event y) noexcept
{
using utype = typename std::underlying_type<event>::type;
return static_cast<event>(static_cast<utype>(x) & static_cast<utype>(y));
}

constexpr event operator|(event x, event y) noexcept
{
using utype = typename std::underlying_type<event>::type;
return static_cast<event>(static_cast<utype>(x) | static_cast<utype>(y));
}

constexpr event operator^(event x, event y) noexcept
{
using utype = typename std::underlying_type<event>::type;
return static_cast<event>(static_cast<utype>(x) ^ static_cast<utype>(y));
}

constexpr event operator~(event x) noexcept
{
using utype = typename std::underlying_type<event>::type;
return static_cast<event>(~static_cast<utype>(x));
}

inline event& operator&=(event& x, event y) noexcept{return x=x&y;}

inline event& operator|=(event& x, event y) noexcept{return x=x|y;}

inline event& operator^=(event& x, event y) noexcept{return x=x^y;}

struct events:epoll_event{};

inline constexpr event get(events const& e)
{
 return static_cast<event>((static_cast<epoll_event const&>(e)).events);
}

inline constexpr auto fd(events const& e)
{
 return (static_cast<epoll_event const&>(e)).data.fd;
}

template<typename T>
concept epoll_stream = requires(T& t)
{
 {ultimate_native_handle(out)}->std::same_as<int>;
};

template<epoll_stream sm>
inline constexpr bool operator==(sm& s,events const& d)
{
 return ultimate_native_handle(s)==fd(d);
}

template<epoll_stream sm>
inline constexpr bool operator!=(sm& s,events const& d)
{
 return ultimate_native_handle(s)!=fd(d);
}

template<epoll_stream sm>
inline constexpr bool operator==(events const& d,sm& s)
{
 return ultimate_native_handle(s)==fd(d);
}

template<epoll_stream sm>
inline constexpr bool operator!=(events const& d,sm& s)
{
 return ultimate_native_handle(s)!=fd(d);
}

template<epoll_stream output>
inline output& add_control(handle_pool& pool,output& out,event e)
{
 auto const out_ultimate(ultimate_native_handle(out));
 epoll_event evt{static_cast<std::uint32_t>(e),{.fd=out_ultimate}};
 if(::epoll_ctl(pool.native_handle(),1,out_ultimate,std::addressof(evt))==-1)
  throw std::system_error(
# 164 "fast_io/fast_io_async/epoll.h" 3 4
                         (*__errno_location ())
# 164 "fast_io/fast_io_async/epoll.h"
                              ,std::generic_category());
 return out;
}

template<epoll_stream output>
inline output& delete_control(handle_pool& pool,output& out)
{
 auto const out_ultimate(ultimate_native_handle(out));
 epoll_event evt{1,{.fd=out_ultimate}};
 if(::epoll_ctl(pool.native_handle(),2,out_ultimate,std::addressof(evt))==-1)
  throw std::system_error(
# 174 "fast_io/fast_io_async/epoll.h" 3 4
                         (*__errno_location ())
# 174 "fast_io/fast_io_async/epoll.h"
                              ,std::generic_category());
 return out;
}
template<epoll_stream output>
inline output& modify_control(handle_pool& pool,output& out,event e)
{
 auto const out_ultimate(ultimate_native_handle(out));
 epoll_event evt{static_cast<std::uint32_t>(e),{.fd=out_ultimate}};
 if(::epoll_ctl(pool.native_handle(),3,out_ultimate,std::addressof(evt))==-1)
  throw std::system_error(
# 183 "fast_io/fast_io_async/epoll.h" 3 4
                         (*__errno_location ())
# 183 "fast_io/fast_io_async/epoll.h"
                              ,std::generic_category());
 return out;
}

template<typename Rep,typename Period>
inline std::span<events> wait(handle_pool& pool,std::span<events> evs,std::chrono::duration<Rep,Period> const& timeout)
{
 int ret(::epoll_wait(pool.native_handle(),evs.data(),static_cast<int>(evs.size()),
  static_cast<int>(std::chrono::duration_cast<std::chrono::milliseconds>(timeout).count())==1));
 if(ret==-1)
  throw std::system_error(
# 193 "fast_io/fast_io_async/epoll.h" 3 4
                         (*__errno_location ())
# 193 "fast_io/fast_io_async/epoll.h"
                              ,std::generic_category());
 return evs.first(static_cast<std::size_t>(ret));
}

inline std::span<events> wait(handle_pool& pool,std::span<events> evs)
{
 int ret(::epoll_wait(pool.native_handle(),evs.data(),static_cast<int>(evs.size()),-1));
 if(ret==-1)
  throw std::system_error(
# 201 "fast_io/fast_io_async/epoll.h" 3 4
                         (*__errno_location ())
# 201 "fast_io/fast_io_async/epoll.h"
                              ,std::generic_category());
 return evs.first(static_cast<std::size_t>(ret));
}
# 221 "fast_io/fast_io_async/epoll.h"
}

}
# 31 "fast_io/fast_io_async/model.h" 2
# 4 "fast_io/fast_io_async.h" 2
# 4 "autocomplete.cpp" 2
# 1 "fast_io/fast_io_device.h" 1
       





namespace fast_io
{
using pipe = io_wrapper<system_pipe>;

using isystem_file = input_file_wrapper<system_file>;
using osystem_file = output_file_wrapper<system_file>;
using iosystem_file = io_file_wrapper<system_file>;

using sync = basic_sync<basic_file_wrapper<system_file,fast_io::open::app|fast_io::open::binary>,basic_ostring<std::string>>;
using fsync = basic_fsync<basic_file_wrapper<system_file,fast_io::open::app|fast_io::open::binary>,basic_ostring<std::string>>;

using sync_mutex = basic_iomutex<sync>;
using fsync_mutex = basic_iomutex<fsync>;

using ibuf = basic_ibuf<isystem_file>;
using obuf = basic_obuf<osystem_file>;
using iobuf = basic_iobuf<iosystem_file>;

using ibuf_mutex = basic_iomutex<ibuf>;
using obuf_mutex = basic_iomutex<obuf>;
using iobuf_mutex = basic_iomutex<iobuf>;
using istring_view_mutex = basic_iomutex<istring_view>;
using ostring_mutex = basic_iomutex<ostring>;


using dynamic_buf = basic_iobuf<dynamic_stream>;

}
# 5 "autocomplete.cpp" 2
# 1 "fast_io/fast_io_network.h" 1
       



# 1 "fast_io/fast_io_network/network.h" 1
       




# 1 "/usr/include/x86_64-linux-gnu/sys/socket.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4

# 24 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
extern "C" {



# 1 "/usr/local/lib/gcc/x86_64-pc-linux-gnu/10.0.0/include/stddef.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/sys/socket.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/socket.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/socket.h" 3 4
# 1 "/usr/local/lib/gcc/x86_64-pc-linux-gnu/10.0.0/include/stddef.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/socket.h" 2 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/socket.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/socket_type.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/socket_type.h" 3 4
enum __socket_type
{
  SOCK_STREAM = 1,


  SOCK_DGRAM = 2,


  SOCK_RAW = 3,

  SOCK_RDM = 4,

  SOCK_SEQPACKET = 5,


  SOCK_DCCP = 6,

  SOCK_PACKET = 10,







  SOCK_CLOEXEC = 02000000,


  SOCK_NONBLOCK = 00004000


};
# 39 "/usr/include/x86_64-linux-gnu/bits/socket.h" 2 3 4
# 172 "/usr/include/x86_64-linux-gnu/bits/socket.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h" 3 4
typedef unsigned short int sa_family_t;
# 173 "/usr/include/x86_64-linux-gnu/bits/socket.h" 2 3 4


struct sockaddr
  {
    sa_family_t sa_family;
    char sa_data[14];
  };
# 188 "/usr/include/x86_64-linux-gnu/bits/socket.h" 3 4
struct sockaddr_storage
  {
    sa_family_t ss_family;
    char __ss_padding[(128 - (sizeof (unsigned short int)) - sizeof (unsigned long int))];
    unsigned long int __ss_align;
  };



enum
  {
    MSG_OOB = 0x01,

    MSG_PEEK = 0x02,

    MSG_DONTROUTE = 0x04,



    MSG_TRYHARD = MSG_DONTROUTE,


    MSG_CTRUNC = 0x08,

    MSG_PROXY = 0x10,

    MSG_TRUNC = 0x20,

    MSG_DONTWAIT = 0x40,

    MSG_EOR = 0x80,

    MSG_WAITALL = 0x100,

    MSG_FIN = 0x200,

    MSG_SYN = 0x400,

    MSG_CONFIRM = 0x800,

    MSG_RST = 0x1000,

    MSG_ERRQUEUE = 0x2000,

    MSG_NOSIGNAL = 0x4000,

    MSG_MORE = 0x8000,

    MSG_WAITFORONE = 0x10000,

    MSG_BATCH = 0x40000,

    MSG_ZEROCOPY = 0x4000000,

    MSG_FASTOPEN = 0x20000000,


    MSG_CMSG_CLOEXEC = 0x40000000



  };




struct msghdr
  {
    void *msg_name;
    socklen_t msg_namelen;

    struct iovec *msg_iov;
    size_t msg_iovlen;

    void *msg_control;
    size_t msg_controllen;




    int msg_flags;
  };


struct cmsghdr
  {
    size_t cmsg_len;




    int cmsg_level;
    int cmsg_type;

    __extension__ unsigned char __cmsg_data [];

  };
# 302 "/usr/include/x86_64-linux-gnu/bits/socket.h" 3 4
extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
          struct cmsghdr *__cmsg) throw ();




extern __inline __attribute__ ((__gnu_inline__)) struct cmsghdr *
__attribute__ ((__leaf__)) __cmsg_nxthdr (struct msghdr *__mhdr, struct cmsghdr *__cmsg) throw ()
{
  if ((size_t) __cmsg->cmsg_len < sizeof (struct cmsghdr))

    return (struct cmsghdr *) 0;

  __cmsg = (struct cmsghdr *) ((unsigned char *) __cmsg
          + (((__cmsg->cmsg_len) + sizeof (size_t) - 1) & (size_t) ~(sizeof (size_t) - 1)));
  if ((unsigned char *) (__cmsg + 1) > ((unsigned char *) __mhdr->msg_control
     + __mhdr->msg_controllen)
      || ((unsigned char *) __cmsg + (((__cmsg->cmsg_len) + sizeof (size_t) - 1) & (size_t) ~(sizeof (size_t) - 1))
   > ((unsigned char *) __mhdr->msg_control + __mhdr->msg_controllen)))

    return (struct cmsghdr *) 0;
  return __cmsg;
}




enum
  {
    SCM_RIGHTS = 0x01


    , SCM_CREDENTIALS = 0x02


  };



struct ucred
{
  pid_t pid;
  uid_t uid;
  gid_t gid;
};
# 390 "/usr/include/x86_64-linux-gnu/bits/socket.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/socket.h" 1 3 4
# 1 "/usr/include/asm-generic/socket.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/asm/sockios.h" 1 3 4
# 1 "/usr/include/asm-generic/sockios.h" 1 3 4
# 2 "/usr/include/x86_64-linux-gnu/asm/sockios.h" 2 3 4
# 6 "/usr/include/asm-generic/socket.h" 2 3 4
# 2 "/usr/include/x86_64-linux-gnu/asm/socket.h" 2 3 4
# 391 "/usr/include/x86_64-linux-gnu/bits/socket.h" 2 3 4
# 444 "/usr/include/x86_64-linux-gnu/bits/socket.h" 3 4
struct linger
  {
    int l_onoff;
    int l_linger;
  };
# 34 "/usr/include/x86_64-linux-gnu/sys/socket.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_osockaddr.h" 1 3 4





struct osockaddr
{
  unsigned short int sa_family;
  unsigned char sa_data[14];
};
# 37 "/usr/include/x86_64-linux-gnu/sys/socket.h" 2 3 4




enum
{
  SHUT_RD = 0,

  SHUT_WR,

  SHUT_RDWR

};
# 90 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
struct mmsghdr
  {
    struct msghdr msg_hdr;
    unsigned int msg_len;

  };






extern int socket (int __domain, int __type, int __protocol) throw ();





extern int socketpair (int __domain, int __type, int __protocol,
         int __fds[2]) throw ();


extern int bind (int __fd, const struct sockaddr * __addr, socklen_t __len)
     throw ();


extern int getsockname (int __fd, struct sockaddr *__restrict __addr,
   socklen_t *__restrict __len) throw ();
# 126 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
extern int connect (int __fd, const struct sockaddr * __addr, socklen_t __len);



extern int getpeername (int __fd, struct sockaddr *__restrict __addr,
   socklen_t *__restrict __len) throw ();






extern ssize_t send (int __fd, const void *__buf, size_t __n, int __flags);






extern ssize_t recv (int __fd, void *__buf, size_t __n, int __flags);






extern ssize_t sendto (int __fd, const void *__buf, size_t __n,
         int __flags, const struct sockaddr * __addr,
         socklen_t __addr_len);
# 163 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
extern ssize_t recvfrom (int __fd, void *__restrict __buf, size_t __n,
    int __flags, struct sockaddr *__restrict __addr,
    socklen_t *__restrict __addr_len);







extern ssize_t sendmsg (int __fd, const struct msghdr *__message,
   int __flags);







extern int sendmmsg (int __fd, struct mmsghdr *__vmessages,
       unsigned int __vlen, int __flags);







extern ssize_t recvmsg (int __fd, struct msghdr *__message, int __flags);







extern int recvmmsg (int __fd, struct mmsghdr *__vmessages,
       unsigned int __vlen, int __flags,
       struct timespec *__tmo);






extern int getsockopt (int __fd, int __level, int __optname,
         void *__restrict __optval,
         socklen_t *__restrict __optlen) throw ();




extern int setsockopt (int __fd, int __level, int __optname,
         const void *__optval, socklen_t __optlen) throw ();





extern int listen (int __fd, int __n) throw ();
# 232 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
extern int accept (int __fd, struct sockaddr *__restrict __addr,
     socklen_t *__restrict __addr_len);






extern int accept4 (int __fd, struct sockaddr *__restrict __addr,
      socklen_t *__restrict __addr_len, int __flags);
# 250 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
extern int shutdown (int __fd, int __how) throw ();




extern int sockatmark (int __fd) throw ();







extern int isfdtype (int __fd, int __fdtype) throw ();
# 272 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
}
# 7 "fast_io/fast_io_network/network.h" 2

# 1 "/usr/include/arpa/inet.h" 1 3 4
# 22 "/usr/include/arpa/inet.h" 3 4
# 1 "/usr/include/netinet/in.h" 1 3 4
# 27 "/usr/include/netinet/in.h" 3 4
extern "C" {


typedef uint32_t in_addr_t;
struct in_addr
  {
    in_addr_t s_addr;
  };


# 1 "/usr/include/x86_64-linux-gnu/bits/in.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/in.h" 3 4
struct ip_opts
  {
    struct in_addr ip_dst;
    char ip_opts[40];
  };


struct ip_mreqn
  {
    struct in_addr imr_multiaddr;
    struct in_addr imr_address;
    int imr_ifindex;
  };


struct in_pktinfo
  {
    int ipi_ifindex;
    struct in_addr ipi_spec_dst;
    struct in_addr ipi_addr;
  };
# 38 "/usr/include/netinet/in.h" 2 3 4


enum
  {
    IPPROTO_IP = 0,

    IPPROTO_ICMP = 1,

    IPPROTO_IGMP = 2,

    IPPROTO_IPIP = 4,

    IPPROTO_TCP = 6,

    IPPROTO_EGP = 8,

    IPPROTO_PUP = 12,

    IPPROTO_UDP = 17,

    IPPROTO_IDP = 22,

    IPPROTO_TP = 29,

    IPPROTO_DCCP = 33,

    IPPROTO_IPV6 = 41,

    IPPROTO_RSVP = 46,

    IPPROTO_GRE = 47,

    IPPROTO_ESP = 50,

    IPPROTO_AH = 51,

    IPPROTO_MTP = 92,

    IPPROTO_BEETPH = 94,

    IPPROTO_ENCAP = 98,

    IPPROTO_PIM = 103,

    IPPROTO_COMP = 108,

    IPPROTO_SCTP = 132,

    IPPROTO_UDPLITE = 136,

    IPPROTO_MPLS = 137,

    IPPROTO_RAW = 255,

    IPPROTO_MAX
  };





enum
  {
    IPPROTO_HOPOPTS = 0,

    IPPROTO_ROUTING = 43,

    IPPROTO_FRAGMENT = 44,

    IPPROTO_ICMPV6 = 58,

    IPPROTO_NONE = 59,

    IPPROTO_DSTOPTS = 60,

    IPPROTO_MH = 135

  };



typedef uint16_t in_port_t;


enum
  {
    IPPORT_ECHO = 7,
    IPPORT_DISCARD = 9,
    IPPORT_SYSTAT = 11,
    IPPORT_DAYTIME = 13,
    IPPORT_NETSTAT = 15,
    IPPORT_FTP = 21,
    IPPORT_TELNET = 23,
    IPPORT_SMTP = 25,
    IPPORT_TIMESERVER = 37,
    IPPORT_NAMESERVER = 42,
    IPPORT_WHOIS = 43,
    IPPORT_MTP = 57,

    IPPORT_TFTP = 69,
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,


    IPPORT_EXECSERVER = 512,
    IPPORT_LOGINSERVER = 513,
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,


    IPPORT_BIFFUDP = 512,
    IPPORT_WHOSERVER = 513,
    IPPORT_ROUTESERVER = 520,


    IPPORT_RESERVED = 1024,


    IPPORT_USERRESERVED = 5000
  };
# 211 "/usr/include/netinet/in.h" 3 4
struct in6_addr
  {
    union
      {
 uint8_t __u6_addr8[16];
 uint16_t __u6_addr16[8];
 uint32_t __u6_addr32[4];
      } __in6_u;





  };


extern const struct in6_addr in6addr_any;
extern const struct in6_addr in6addr_loopback;
# 237 "/usr/include/netinet/in.h" 3 4
struct sockaddr_in
  {
    sa_family_t sin_family;
    in_port_t sin_port;
    struct in_addr sin_addr;


    unsigned char sin_zero[sizeof (struct sockaddr) -
      (sizeof (unsigned short int)) -
      sizeof (in_port_t) -
      sizeof (struct in_addr)];
  };



struct sockaddr_in6
  {
    sa_family_t sin6_family;
    in_port_t sin6_port;
    uint32_t sin6_flowinfo;
    struct in6_addr sin6_addr;
    uint32_t sin6_scope_id;
  };




struct ip_mreq
  {

    struct in_addr imr_multiaddr;


    struct in_addr imr_interface;
  };

struct ip_mreq_source
  {

    struct in_addr imr_multiaddr;


    struct in_addr imr_interface;


    struct in_addr imr_sourceaddr;
  };




struct ipv6_mreq
  {

    struct in6_addr ipv6mr_multiaddr;


    unsigned int ipv6mr_interface;
  };




struct group_req
  {

    uint32_t gr_interface;


    struct sockaddr_storage gr_group;
  };

struct group_source_req
  {

    uint32_t gsr_interface;


    struct sockaddr_storage gsr_group;


    struct sockaddr_storage gsr_source;
  };



struct ip_msfilter
  {

    struct in_addr imsf_multiaddr;


    struct in_addr imsf_interface;


    uint32_t imsf_fmode;


    uint32_t imsf_numsrc;

    struct in_addr imsf_slist[1];
  };





struct group_filter
  {

    uint32_t gf_interface;


    struct sockaddr_storage gf_group;


    uint32_t gf_fmode;


    uint32_t gf_numsrc;

    struct sockaddr_storage gf_slist[1];
};
# 374 "/usr/include/netinet/in.h" 3 4
extern uint32_t ntohl (uint32_t __netlong) throw () __attribute__ ((__const__));
extern uint16_t ntohs (uint16_t __netshort)
     throw () __attribute__ ((__const__));
extern uint32_t htonl (uint32_t __hostlong)
     throw () __attribute__ ((__const__));
extern uint16_t htons (uint16_t __hostshort)
     throw () __attribute__ ((__const__));




# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 386 "/usr/include/netinet/in.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 387 "/usr/include/netinet/in.h" 2 3 4
# 502 "/usr/include/netinet/in.h" 3 4
extern int bindresvport (int __sockfd, struct sockaddr_in *__sock_in) throw ();


extern int bindresvport6 (int __sockfd, struct sockaddr_in6 *__sock_in)
     throw ();
# 532 "/usr/include/netinet/in.h" 3 4
struct cmsghdr;



struct in6_pktinfo
  {
    struct in6_addr ipi6_addr;
    unsigned int ipi6_ifindex;
  };


struct ip6_mtuinfo
  {
    struct sockaddr_in6 ip6m_addr;
    uint32_t ip6m_mtu;
  };



extern int inet6_option_space (int __nbytes)
     throw () __attribute__ ((__deprecated__));
extern int inet6_option_init (void *__bp, struct cmsghdr **__cmsgp,
         int __type) throw () __attribute__ ((__deprecated__));
extern int inet6_option_append (struct cmsghdr *__cmsg,
    const uint8_t *__typep, int __multx,
    int __plusy) throw () __attribute__ ((__deprecated__));
extern uint8_t *inet6_option_alloc (struct cmsghdr *__cmsg, int __datalen,
        int __multx, int __plusy)
     throw () __attribute__ ((__deprecated__));
extern int inet6_option_next (const struct cmsghdr *__cmsg,
         uint8_t **__tptrp)
     throw () __attribute__ ((__deprecated__));
extern int inet6_option_find (const struct cmsghdr *__cmsg,
         uint8_t **__tptrp, int __type)
     throw () __attribute__ ((__deprecated__));



extern int inet6_opt_init (void *__extbuf, socklen_t __extlen) throw ();
extern int inet6_opt_append (void *__extbuf, socklen_t __extlen, int __offset,
        uint8_t __type, socklen_t __len, uint8_t __align,
        void **__databufp) throw ();
extern int inet6_opt_finish (void *__extbuf, socklen_t __extlen, int __offset)
     throw ();
extern int inet6_opt_set_val (void *__databuf, int __offset, void *__val,
         socklen_t __vallen) throw ();
extern int inet6_opt_next (void *__extbuf, socklen_t __extlen, int __offset,
      uint8_t *__typep, socklen_t *__lenp,
      void **__databufp) throw ();
extern int inet6_opt_find (void *__extbuf, socklen_t __extlen, int __offset,
      uint8_t __type, socklen_t *__lenp,
      void **__databufp) throw ();
extern int inet6_opt_get_val (void *__databuf, int __offset, void *__val,
         socklen_t __vallen) throw ();



extern socklen_t inet6_rth_space (int __type, int __segments) throw ();
extern void *inet6_rth_init (void *__bp, socklen_t __bp_len, int __type,
        int __segments) throw ();
extern int inet6_rth_add (void *__bp, const struct in6_addr *__addr) throw ();
extern int inet6_rth_reverse (const void *__in, void *__out) throw ();
extern int inet6_rth_segments (const void *__bp) throw ();
extern struct in6_addr *inet6_rth_getaddr (const void *__bp, int __index)
     throw ();





extern int getipv4sourcefilter (int __s, struct in_addr __interface_addr,
    struct in_addr __group, uint32_t *__fmode,
    uint32_t *__numsrc, struct in_addr *__slist)
     throw ();


extern int setipv4sourcefilter (int __s, struct in_addr __interface_addr,
    struct in_addr __group, uint32_t __fmode,
    uint32_t __numsrc,
    const struct in_addr *__slist)
     throw ();



extern int getsourcefilter (int __s, uint32_t __interface_addr,
       const struct sockaddr *__group,
       socklen_t __grouplen, uint32_t *__fmode,
       uint32_t *__numsrc,
       struct sockaddr_storage *__slist) throw ();


extern int setsourcefilter (int __s, uint32_t __interface_addr,
       const struct sockaddr *__group,
       socklen_t __grouplen, uint32_t __fmode,
       uint32_t __numsrc,
       const struct sockaddr_storage *__slist) throw ();


}
# 23 "/usr/include/arpa/inet.h" 2 3 4







extern "C" {



extern in_addr_t inet_addr (const char *__cp) throw ();


extern in_addr_t inet_lnaof (struct in_addr __in) throw ();



extern struct in_addr inet_makeaddr (in_addr_t __net, in_addr_t __host)
     throw ();


extern in_addr_t inet_netof (struct in_addr __in) throw ();



extern in_addr_t inet_network (const char *__cp) throw ();



extern char *inet_ntoa (struct in_addr __in) throw ();




extern int inet_pton (int __af, const char *__restrict __cp,
        void *__restrict __buf) throw ();




extern const char *inet_ntop (int __af, const void *__restrict __cp,
         char *__restrict __buf, socklen_t __len)
     throw ();






extern int inet_aton (const char *__cp, struct in_addr *__inp) throw ();



extern char *inet_neta (in_addr_t __net, char *__buf, size_t __len) throw ();




extern char *inet_net_ntop (int __af, const void *__cp, int __bits,
       char *__buf, size_t __len) throw ();




extern int inet_net_pton (int __af, const char *__cp,
     void *__buf, size_t __len) throw ();




extern unsigned int inet_nsap_addr (const char *__cp,
        unsigned char *__buf, int __len) throw ();



extern char *inet_nsap_ntoa (int __len, const unsigned char *__cp,
        char *__buf) throw ();


}
# 9 "fast_io/fast_io_network/network.h" 2


# 1 "/usr/include/netdb.h" 1 3 4
# 32 "/usr/include/netdb.h" 3 4
# 1 "/usr/include/rpc/netdb.h" 1 3 4
# 42 "/usr/include/rpc/netdb.h" 3 4
# 1 "/usr/local/lib/gcc/x86_64-pc-linux-gnu/10.0.0/include/stddef.h" 1 3 4
# 43 "/usr/include/rpc/netdb.h" 2 3 4

extern "C" {

struct rpcent
{
  char *r_name;
  char **r_aliases;
  int r_number;
};

extern void setrpcent (int __stayopen) throw ();
extern void endrpcent (void) throw ();
extern struct rpcent *getrpcbyname (const char *__name) throw ();
extern struct rpcent *getrpcbynumber (int __number) throw ();
extern struct rpcent *getrpcent (void) throw ();


extern int getrpcbyname_r (const char *__name, struct rpcent *__result_buf,
      char *__buffer, size_t __buflen,
      struct rpcent **__result) throw ();

extern int getrpcbynumber_r (int __number, struct rpcent *__result_buf,
        char *__buffer, size_t __buflen,
        struct rpcent **__result) throw ();

extern int getrpcent_r (struct rpcent *__result_buf, char *__buffer,
   size_t __buflen, struct rpcent **__result) throw ();


}
# 33 "/usr/include/netdb.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h" 3 4
union sigval
{
  int sival_int;
  void *sival_ptr;
};

typedef union sigval __sigval_t;
# 7 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h" 2 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h" 3 4
typedef struct sigevent
  {
    __sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
 int _pad[((64 / sizeof (int)) - 4)];



 __pid_t _tid;

 struct
   {
     void (*_function) (__sigval_t);
     pthread_attr_t *_attribute;
   } _sigev_thread;
      } _sigev_un;
  } sigevent_t;
# 37 "/usr/include/netdb.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/netdb.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/netdb.h" 3 4
struct netent
{
  char *n_name;
  char **n_aliases;
  int n_addrtype;
  uint32_t n_net;
};
# 41 "/usr/include/netdb.h" 2 3 4
# 51 "/usr/include/netdb.h" 3 4
extern "C" {







extern int *__h_errno_location (void) throw () __attribute__ ((__const__));
# 90 "/usr/include/netdb.h" 3 4
extern void herror (const char *__str) throw ();


extern const char *hstrerror (int __err_num) throw ();




struct hostent
{
  char *h_name;
  char **h_aliases;
  int h_addrtype;
  int h_length;
  char **h_addr_list;



};






extern void sethostent (int __stay_open);





extern void endhostent (void);






extern struct hostent *gethostent (void);






extern struct hostent *gethostbyaddr (const void *__addr, __socklen_t __len,
          int __type);





extern struct hostent *gethostbyname (const char *__name);
# 153 "/usr/include/netdb.h" 3 4
extern struct hostent *gethostbyname2 (const char *__name, int __af);
# 165 "/usr/include/netdb.h" 3 4
extern int gethostent_r (struct hostent *__restrict __result_buf,
    char *__restrict __buf, size_t __buflen,
    struct hostent **__restrict __result,
    int *__restrict __h_errnop);

extern int gethostbyaddr_r (const void *__restrict __addr, __socklen_t __len,
       int __type,
       struct hostent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct hostent **__restrict __result,
       int *__restrict __h_errnop);

extern int gethostbyname_r (const char *__restrict __name,
       struct hostent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct hostent **__restrict __result,
       int *__restrict __h_errnop);

extern int gethostbyname2_r (const char *__restrict __name, int __af,
        struct hostent *__restrict __result_buf,
        char *__restrict __buf, size_t __buflen,
        struct hostent **__restrict __result,
        int *__restrict __h_errnop);
# 196 "/usr/include/netdb.h" 3 4
extern void setnetent (int __stay_open);





extern void endnetent (void);






extern struct netent *getnetent (void);






extern struct netent *getnetbyaddr (uint32_t __net, int __type);





extern struct netent *getnetbyname (const char *__name);
# 235 "/usr/include/netdb.h" 3 4
extern int getnetent_r (struct netent *__restrict __result_buf,
   char *__restrict __buf, size_t __buflen,
   struct netent **__restrict __result,
   int *__restrict __h_errnop);

extern int getnetbyaddr_r (uint32_t __net, int __type,
      struct netent *__restrict __result_buf,
      char *__restrict __buf, size_t __buflen,
      struct netent **__restrict __result,
      int *__restrict __h_errnop);

extern int getnetbyname_r (const char *__restrict __name,
      struct netent *__restrict __result_buf,
      char *__restrict __buf, size_t __buflen,
      struct netent **__restrict __result,
      int *__restrict __h_errnop);




struct servent
{
  char *s_name;
  char **s_aliases;
  int s_port;
  char *s_proto;
};






extern void setservent (int __stay_open);





extern void endservent (void);






extern struct servent *getservent (void);






extern struct servent *getservbyname (const char *__name, const char *__proto);






extern struct servent *getservbyport (int __port, const char *__proto);
# 306 "/usr/include/netdb.h" 3 4
extern int getservent_r (struct servent *__restrict __result_buf,
    char *__restrict __buf, size_t __buflen,
    struct servent **__restrict __result);

extern int getservbyname_r (const char *__restrict __name,
       const char *__restrict __proto,
       struct servent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct servent **__restrict __result);

extern int getservbyport_r (int __port, const char *__restrict __proto,
       struct servent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct servent **__restrict __result);




struct protoent
{
  char *p_name;
  char **p_aliases;
  int p_proto;
};






extern void setprotoent (int __stay_open);





extern void endprotoent (void);






extern struct protoent *getprotoent (void);





extern struct protoent *getprotobyname (const char *__name);





extern struct protoent *getprotobynumber (int __proto);
# 372 "/usr/include/netdb.h" 3 4
extern int getprotoent_r (struct protoent *__restrict __result_buf,
     char *__restrict __buf, size_t __buflen,
     struct protoent **__restrict __result);

extern int getprotobyname_r (const char *__restrict __name,
        struct protoent *__restrict __result_buf,
        char *__restrict __buf, size_t __buflen,
        struct protoent **__restrict __result);

extern int getprotobynumber_r (int __proto,
          struct protoent *__restrict __result_buf,
          char *__restrict __buf, size_t __buflen,
          struct protoent **__restrict __result);
# 393 "/usr/include/netdb.h" 3 4
extern int setnetgrent (const char *__netgroup);







extern void endnetgrent (void);
# 410 "/usr/include/netdb.h" 3 4
extern int getnetgrent (char **__restrict __hostp,
   char **__restrict __userp,
   char **__restrict __domainp);
# 421 "/usr/include/netdb.h" 3 4
extern int innetgr (const char *__netgroup, const char *__host,
      const char *__user, const char *__domain);







extern int getnetgrent_r (char **__restrict __hostp,
     char **__restrict __userp,
     char **__restrict __domainp,
     char *__restrict __buffer, size_t __buflen);
# 449 "/usr/include/netdb.h" 3 4
extern int rcmd (char **__restrict __ahost, unsigned short int __rport,
   const char *__restrict __locuser,
   const char *__restrict __remuser,
   const char *__restrict __cmd, int *__restrict __fd2p);
# 461 "/usr/include/netdb.h" 3 4
extern int rcmd_af (char **__restrict __ahost, unsigned short int __rport,
      const char *__restrict __locuser,
      const char *__restrict __remuser,
      const char *__restrict __cmd, int *__restrict __fd2p,
      sa_family_t __af);
# 477 "/usr/include/netdb.h" 3 4
extern int rexec (char **__restrict __ahost, int __rport,
    const char *__restrict __name,
    const char *__restrict __pass,
    const char *__restrict __cmd, int *__restrict __fd2p);
# 489 "/usr/include/netdb.h" 3 4
extern int rexec_af (char **__restrict __ahost, int __rport,
       const char *__restrict __name,
       const char *__restrict __pass,
       const char *__restrict __cmd, int *__restrict __fd2p,
       sa_family_t __af);
# 503 "/usr/include/netdb.h" 3 4
extern int ruserok (const char *__rhost, int __suser,
      const char *__remuser, const char *__locuser);
# 513 "/usr/include/netdb.h" 3 4
extern int ruserok_af (const char *__rhost, int __suser,
         const char *__remuser, const char *__locuser,
         sa_family_t __af);
# 526 "/usr/include/netdb.h" 3 4
extern int iruserok (uint32_t __raddr, int __suser,
       const char *__remuser, const char *__locuser);
# 537 "/usr/include/netdb.h" 3 4
extern int iruserok_af (const void *__raddr, int __suser,
   const char *__remuser, const char *__locuser,
   sa_family_t __af);
# 549 "/usr/include/netdb.h" 3 4
extern int rresvport (int *__alport);
# 558 "/usr/include/netdb.h" 3 4
extern int rresvport_af (int *__alport, sa_family_t __af);






struct addrinfo
{
  int ai_flags;
  int ai_family;
  int ai_socktype;
  int ai_protocol;
  socklen_t ai_addrlen;
  struct sockaddr *ai_addr;
  char *ai_canonname;
  struct addrinfo *ai_next;
};



struct gaicb
{
  const char *ar_name;
  const char *ar_service;
  const struct addrinfo *ar_request;
  struct addrinfo *ar_result;

  int __return;
  int __glibc_reserved[5];
};
# 660 "/usr/include/netdb.h" 3 4
extern int getaddrinfo (const char *__restrict __name,
   const char *__restrict __service,
   const struct addrinfo *__restrict __req,
   struct addrinfo **__restrict __pai);


extern void freeaddrinfo (struct addrinfo *__ai) throw ();


extern const char *gai_strerror (int __ecode) throw ();





extern int getnameinfo (const struct sockaddr *__restrict __sa,
   socklen_t __salen, char *__restrict __host,
   socklen_t __hostlen, char *__restrict __serv,
   socklen_t __servlen, int __flags);
# 690 "/usr/include/netdb.h" 3 4
extern int getaddrinfo_a (int __mode, struct gaicb *__list[],
     int __ent, struct sigevent *__restrict __sig);
# 701 "/usr/include/netdb.h" 3 4
extern int gai_suspend (const struct gaicb *const __list[], int __ent,
   const struct timespec *__timeout);


extern int gai_error (struct gaicb *__req) throw ();


extern int gai_cancel (struct gaicb *__gaicbp) throw ();


}
# 12 "fast_io/fast_io_network/network.h" 2



# 14 "fast_io/fast_io_network/network.h"
namespace fast_io
{
namespace sock
{
enum class family
{
unspec = 
# 20 "fast_io/fast_io_network/network.h" 3 4
        0
# 20 "fast_io/fast_io_network/network.h"
                 ,
local = 1,
ipx = 
# 22 "fast_io/fast_io_network/network.h" 3 4
     4
# 22 "fast_io/fast_io_network/network.h"
           ,
apple_talk = 
# 23 "fast_io/fast_io_network/network.h" 3 4
            5
# 23 "fast_io/fast_io_network/network.h"
                        ,
ipv4 = 
# 24 "fast_io/fast_io_network/network.h" 3 4
      2
# 24 "fast_io/fast_io_network/network.h"
             ,
ipv6 = 
# 25 "fast_io/fast_io_network/network.h" 3 4
      10





# 30 "fast_io/fast_io_network/network.h"
};

enum class type
{
stream = 
# 34 "fast_io/fast_io_network/network.h" 3 4
        SOCK_STREAM
# 34 "fast_io/fast_io_network/network.h"
                   ,
datagrams =
# 35 "fast_io/fast_io_network/network.h" 3 4
          SOCK_DGRAM
# 35 "fast_io/fast_io_network/network.h"
                    ,
sequence_packet = 
# 36 "fast_io/fast_io_network/network.h" 3 4
                 SOCK_SEQPACKET
# 36 "fast_io/fast_io_network/network.h"
                               ,
raw = 
# 37 "fast_io/fast_io_network/network.h" 3 4
     SOCK_RAW
# 37 "fast_io/fast_io_network/network.h"
             ,
reliable_datagram_layer=
# 38 "fast_io/fast_io_network/network.h" 3 4
                       SOCK_RDM
# 38 "fast_io/fast_io_network/network.h"
                               ,
};

enum class protocal
{
none = 0,
ipv4 = 
# 44 "fast_io/fast_io_network/network.h" 3 4
      IPPROTO_IP
# 44 "fast_io/fast_io_network/network.h"
                ,
ipv6 = 
# 45 "fast_io/fast_io_network/network.h" 3 4
      IPPROTO_IPV6
# 45 "fast_io/fast_io_network/network.h"
                  ,
tcp = 
# 46 "fast_io/fast_io_network/network.h" 3 4
     IPPROTO_TCP
# 46 "fast_io/fast_io_network/network.h"
                ,
udp = 
# 47 "fast_io/fast_io_network/network.h" 3 4
     IPPROTO_UDP
# 47 "fast_io/fast_io_network/network.h"
                ,
};

}

}




# 1 "fast_io/fast_io_network/posix_socket.h" 1
       

namespace fast_io
{
class gai_exception:public std::exception
{
 int ec;
public:
 explicit gai_exception(int errorc):ec(errorc){}
 auto get() const
 {
  return ec;
 }
 char const* what() const noexcept
 {
  return gai_strerror(ec);
 }
};
}

namespace fast_io::sock::details
{
namespace
{
template<typename Func,typename ...Args>
inline auto call_posix(Func&& func,Args&& ...args)
{
 auto ret(func(std::forward<Args>(args)...));
 if(ret==-1)
  throw std::system_error(
# 30 "fast_io/fast_io_network/posix_socket.h" 3 4
                         (*__errno_location ())
# 30 "fast_io/fast_io_network/posix_socket.h"
                              ,std::generic_category());
 return ret;
}

template<typename ...Args>
inline auto socket(Args&& ...args)
{
 return call_posix(::socket,std::forward<Args>(args)...);
}

template<typename T>
inline auto accept(int sck,T& sock_address,socklen_t& storage_size)
{
 return call_posix(::accept,sck,reinterpret_cast<sockaddr*>(std::addressof(sock_address)),std::addressof(storage_size));
}

template<typename T,std::unsigned_integral sock_type_size>
inline auto connect(int sck,T& sock_address,sock_type_size size)
{
 return call_posix(::connect,sck,reinterpret_cast<sockaddr*>(std::addressof(sock_address)),size);
}

template<typename ...Args>
inline auto send(Args&& ...args)
{
 return call_posix(::send,std::forward<Args>(args)...);
}
template<typename ...Args>
inline auto recv(Args&& ...args)
{
 return call_posix(::recv,std::forward<Args>(args)...);
}

template<typename ...Args>
inline auto closesocket(Args&& ...args)
{
 return call_posix(::close,std::forward<Args>(args)...);
}

template<typename T,std::unsigned_integral sock_type_size>
inline auto bind(int sck,T& sock_address,sock_type_size size)
{
 return call_posix(::bind,sck,reinterpret_cast<sockaddr*>(std::addressof(sock_address)),size);
}

template<typename ...Args>
inline auto bind(Args&& ...args)
{
 return call_posix(::bind,std::forward<Args>(args)...);
}

template<typename ...Args>
inline auto listen(Args&& ...args)
{
 return call_posix(::listen,std::forward<Args>(args)...);
}

template<typename ...Args>
inline void getaddrinfo(Args&& ...args)
{
 int ec(::getaddrinfo(std::forward<Args>(args)...));
 if(ec)
  throw gai_exception(ec);
}

template<typename ...Args>
inline void freeaddrinfo(Args&& ...args)
{
 ::freeaddrinfo(std::forward<Args>(args)...);
}


using address_family = sa_family_t;
using socket_type = int;
inline constexpr auto invalid_socket(-1);
}
}
# 58 "fast_io/fast_io_network/network.h" 2

# 1 "fast_io/fast_io_network/address.h" 1
       
# 1 "/usr/local/include/c++/10.0.0/variant" 1 3
# 32 "/usr/local/include/c++/10.0.0/variant" 3
       
# 33 "/usr/local/include/c++/10.0.0/variant" 3
# 49 "/usr/local/include/c++/10.0.0/variant" 3

# 49 "/usr/local/include/c++/10.0.0/variant" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


namespace __detail
{
namespace __variant
{
  template<size_t _Np, typename... _Types>
    struct _Nth_type;

  template<size_t _Np, typename _First, typename... _Rest>
    struct _Nth_type<_Np, _First, _Rest...>
    : _Nth_type<_Np-1, _Rest...> { };

  template<typename _First, typename... _Rest>
    struct _Nth_type<0, _First, _Rest...>
    { using type = _First; };

}
}



  template<typename... _Types> class tuple;
  template<typename... _Types> class variant;
  template <typename> struct hash;

  template<typename _Variant>
    struct variant_size;

  template<typename _Variant>
    struct variant_size<const _Variant> : variant_size<_Variant> {};

  template<typename _Variant>
    struct variant_size<volatile _Variant> : variant_size<_Variant> {};

  template<typename _Variant>
    struct variant_size<const volatile _Variant> : variant_size<_Variant> {};

  template<typename... _Types>
    struct variant_size<variant<_Types...>>
    : std::integral_constant<size_t, sizeof...(_Types)> {};

  template<typename _Variant>
    inline constexpr size_t variant_size_v = variant_size<_Variant>::value;

  template<size_t _Np, typename _Variant>
    struct variant_alternative;

  template<size_t _Np, typename _First, typename... _Rest>
    struct variant_alternative<_Np, variant<_First, _Rest...>>
    : variant_alternative<_Np-1, variant<_Rest...>> {};

  template<typename _First, typename... _Rest>
    struct variant_alternative<0, variant<_First, _Rest...>>
    { using type = _First; };

  template<size_t _Np, typename _Variant>
    using variant_alternative_t =
      typename variant_alternative<_Np, _Variant>::type;

  template<size_t _Np, typename _Variant>
    struct variant_alternative<_Np, const _Variant>
    { using type = add_const_t<variant_alternative_t<_Np, _Variant>>; };

  template<size_t _Np, typename _Variant>
    struct variant_alternative<_Np, volatile _Variant>
    { using type = add_volatile_t<variant_alternative_t<_Np, _Variant>>; };

  template<size_t _Np, typename _Variant>
    struct variant_alternative<_Np, const volatile _Variant>
    { using type = add_cv_t<variant_alternative_t<_Np, _Variant>>; };

  inline constexpr size_t variant_npos = -1;

  template<size_t _Np, typename... _Types>
    constexpr variant_alternative_t<_Np, variant<_Types...>>&
    get(variant<_Types...>&);

  template<size_t _Np, typename... _Types>
    constexpr variant_alternative_t<_Np, variant<_Types...>>&&
    get(variant<_Types...>&&);

  template<size_t _Np, typename... _Types>
    constexpr variant_alternative_t<_Np, variant<_Types...>> const&
    get(const variant<_Types...>&);

  template<size_t _Np, typename... _Types>
    constexpr variant_alternative_t<_Np, variant<_Types...>> const&&
    get(const variant<_Types...>&&);

  template<typename _Result_type, typename _Visitor, typename... _Variants>
    constexpr decltype(auto)
    __do_visit(_Visitor&& __visitor, _Variants&&... __variants);

  template <typename... _Types, typename _Tp>
    decltype(auto)
    __variant_cast(_Tp&& __rhs)
    {
      if constexpr (is_lvalue_reference_v<_Tp>)
 {
   if constexpr (is_const_v<remove_reference_t<_Tp>>)
     return static_cast<const variant<_Types...>&>(__rhs);
   else
     return static_cast<variant<_Types...>&>(__rhs);
 }
      else
        return static_cast<variant<_Types...>&&>(__rhs);
    }

namespace __detail
{
namespace __variant
{


  template<typename _Tp, typename... _Types>
    struct __index_of : std::integral_constant<size_t, 0> {};

  template<typename _Tp, typename... _Types>
    inline constexpr size_t __index_of_v = __index_of<_Tp, _Types...>::value;

  template<typename _Tp, typename _First, typename... _Rest>
    struct __index_of<_Tp, _First, _Rest...> :
      std::integral_constant<size_t, is_same_v<_Tp, _First>
 ? 0 : __index_of_v<_Tp, _Rest...> + 1> {};


  struct __variant_cookie {};

  struct __variant_idx_cookie { using type = __variant_idx_cookie; };

  template<typename> struct __deduce_visit_result { };


  template<typename _Visitor, typename... _Variants>
    constexpr void
    __raw_visit(_Visitor&& __visitor, _Variants&&... __variants)
    {
      std::__do_visit<__variant_cookie>(std::forward<_Visitor>(__visitor),
            std::forward<_Variants>(__variants)...);
    }


  template<typename _Visitor, typename... _Variants>
    constexpr void
    __raw_idx_visit(_Visitor&& __visitor, _Variants&&... __variants)
    {
      std::__do_visit<__variant_idx_cookie>(std::forward<_Visitor>(__visitor),
   std::forward<_Variants>(__variants)...);
    }
# 210 "/usr/local/include/c++/10.0.0/variant" 3
  template<typename _Type, bool = std::is_literal_type_v<_Type>>
    struct _Uninitialized;

  template<typename _Type>
    struct _Uninitialized<_Type, true>
    {
      template<typename... _Args>
 constexpr
 _Uninitialized(in_place_index_t<0>, _Args&&... __args)
 : _M_storage(std::forward<_Args>(__args)...)
 { }

      constexpr const _Type& _M_get() const & noexcept
      { return _M_storage; }

      constexpr _Type& _M_get() & noexcept
      { return _M_storage; }

      constexpr const _Type&& _M_get() const && noexcept
      { return std::move(_M_storage); }

      constexpr _Type&& _M_get() && noexcept
      { return std::move(_M_storage); }

      _Type _M_storage;
    };

  template<typename _Type>
    struct _Uninitialized<_Type, false>
    {
      template<typename... _Args>
 constexpr
 _Uninitialized(in_place_index_t<0>, _Args&&... __args)
 {
   ::new ((void*)std::addressof(_M_storage))
     _Type(std::forward<_Args>(__args)...);
 }

      const _Type& _M_get() const & noexcept
      { return *_M_storage._M_ptr(); }

      _Type& _M_get() & noexcept
      { return *_M_storage._M_ptr(); }

      const _Type&& _M_get() const && noexcept
      { return std::move(*_M_storage._M_ptr()); }

      _Type&& _M_get() && noexcept
      { return std::move(*_M_storage._M_ptr()); }

      __gnu_cxx::__aligned_membuf<_Type> _M_storage;
    };

  template<typename _Union>
    constexpr decltype(auto)
    __get(in_place_index_t<0>, _Union&& __u) noexcept
    { return std::forward<_Union>(__u)._M_first._M_get(); }

  template<size_t _Np, typename _Union>
    constexpr decltype(auto)
    __get(in_place_index_t<_Np>, _Union&& __u) noexcept
    {
      return __variant::__get(in_place_index<_Np-1>,
         std::forward<_Union>(__u)._M_rest);
    }


  template<size_t _Np, typename _Variant>
    constexpr decltype(auto)
    __get(_Variant&& __v) noexcept
    {
      return __variant::__get(std::in_place_index<_Np>,
         std::forward<_Variant>(__v)._M_u);
    }

  template<typename... _Types>
    struct _Traits
    {
      static constexpr bool _S_default_ctor =
   is_default_constructible_v<typename _Nth_type<0, _Types...>::type>;
      static constexpr bool _S_copy_ctor =
   (is_copy_constructible_v<_Types> && ...);
      static constexpr bool _S_move_ctor =
   (is_move_constructible_v<_Types> && ...);
      static constexpr bool _S_copy_assign =
   _S_copy_ctor
   && (is_copy_assignable_v<_Types> && ...);
      static constexpr bool _S_move_assign =
   _S_move_ctor
   && (is_move_assignable_v<_Types> && ...);

      static constexpr bool _S_trivial_dtor =
   (is_trivially_destructible_v<_Types> && ...);
      static constexpr bool _S_trivial_copy_ctor =
   (is_trivially_copy_constructible_v<_Types> && ...);
      static constexpr bool _S_trivial_move_ctor =
   (is_trivially_move_constructible_v<_Types> && ...);
      static constexpr bool _S_trivial_copy_assign =
   _S_trivial_dtor && _S_trivial_copy_ctor
   && (is_trivially_copy_assignable_v<_Types> && ...);
      static constexpr bool _S_trivial_move_assign =
   _S_trivial_dtor && _S_trivial_move_ctor
   && (is_trivially_move_assignable_v<_Types> && ...);



      static constexpr bool _S_nothrow_default_ctor =
   is_nothrow_default_constructible_v<
       typename _Nth_type<0, _Types...>::type>;
      static constexpr bool _S_nothrow_copy_ctor = false;
      static constexpr bool _S_nothrow_move_ctor =
   (is_nothrow_move_constructible_v<_Types> && ...);
      static constexpr bool _S_nothrow_copy_assign = false;
      static constexpr bool _S_nothrow_move_assign =
   _S_nothrow_move_ctor
   && (is_nothrow_move_assignable_v<_Types> && ...);
    };


  template<typename... _Types>
    union _Variadic_union { };

  template<typename _First, typename... _Rest>
    union _Variadic_union<_First, _Rest...>
    {
      constexpr _Variadic_union() : _M_rest() { }

      template<typename... _Args>
 constexpr _Variadic_union(in_place_index_t<0>, _Args&&... __args)
 : _M_first(in_place_index<0>, std::forward<_Args>(__args)...)
 { }

      template<size_t _Np, typename... _Args>
 constexpr _Variadic_union(in_place_index_t<_Np>, _Args&&... __args)
 : _M_rest(in_place_index<_Np-1>, std::forward<_Args>(__args)...)
 { }

      _Uninitialized<_First> _M_first;
      _Variadic_union<_Rest...> _M_rest;
    };






  template<typename _Tp>
    struct _Never_valueless_alt
    : __and_<bool_constant<sizeof(_Tp) <= 256>, is_trivially_copyable<_Tp>>
    { };
# 371 "/usr/local/include/c++/10.0.0/variant" 3
  template <typename... _Types>
    constexpr bool __never_valueless()
    {
      return _Traits<_Types...>::_S_move_assign
 && (_Never_valueless_alt<_Types>::value && ...);
    }


  template<bool __trivially_destructible, typename... _Types>
    struct _Variant_storage;

  template <typename... _Types>
    using __select_index =
      typename __select_int::_Select_int_base<sizeof...(_Types),
           unsigned char,
           unsigned short>::type::value_type;

  template<typename... _Types>
    struct _Variant_storage<false, _Types...>
    {
      constexpr _Variant_storage() : _M_index(variant_npos) { }

      template<size_t _Np, typename... _Args>
 constexpr _Variant_storage(in_place_index_t<_Np>, _Args&&... __args)
 : _M_u(in_place_index<_Np>, std::forward<_Args>(__args)...),
 _M_index(_Np)
 { }

      void _M_reset()
      {
 if (!_M_valid()) [[unlikely]]
   return;

 std::__do_visit<void>([](auto&& __this_mem) mutable
   {
     std::_Destroy(std::__addressof(__this_mem));
   }, __variant_cast<_Types...>(*this));

 _M_index = variant_npos;
      }

      ~_Variant_storage()
      { _M_reset(); }

      void*
      _M_storage() const noexcept
      {
 return const_cast<void*>(static_cast<const void*>(
     std::addressof(_M_u)));
      }

      constexpr bool
      _M_valid() const noexcept
      {
 if constexpr (__variant::__never_valueless<_Types...>())
   return true;
 return this->_M_index != __index_type(variant_npos);
      }

      _Variadic_union<_Types...> _M_u;
      using __index_type = __select_index<_Types...>;
      __index_type _M_index;
    };

  template<typename... _Types>
    struct _Variant_storage<true, _Types...>
    {
      constexpr _Variant_storage() : _M_index(variant_npos) { }

      template<size_t _Np, typename... _Args>
 constexpr _Variant_storage(in_place_index_t<_Np>, _Args&&... __args)
 : _M_u(in_place_index<_Np>, std::forward<_Args>(__args)...),
 _M_index(_Np)
 { }

      void _M_reset() noexcept
      { _M_index = variant_npos; }

      void*
      _M_storage() const noexcept
      {
 return const_cast<void*>(static_cast<const void*>(
     std::addressof(_M_u)));
      }

      constexpr bool
      _M_valid() const noexcept
      {
 if constexpr (__variant::__never_valueless<_Types...>())
   return true;
 return this->_M_index != __index_type(variant_npos);
      }

      _Variadic_union<_Types...> _M_u;
      using __index_type = __select_index<_Types...>;
      __index_type _M_index;
    };

  template<typename... _Types>
    using _Variant_storage_alias =
 _Variant_storage<_Traits<_Types...>::_S_trivial_dtor, _Types...>;

  template<typename _Tp, typename _Up>
    void __variant_construct_single(_Tp&& __lhs, _Up&& __rhs_mem)
    {
      void* __storage = std::addressof(__lhs._M_u);
      using _Type = remove_reference_t<decltype(__rhs_mem)>;
      if constexpr (!is_same_v<_Type, __variant_cookie>)
        ::new (__storage)
   _Type(std::forward<decltype(__rhs_mem)>(__rhs_mem));
    }

  template<typename... _Types, typename _Tp, typename _Up>
    void __variant_construct(_Tp&& __lhs, _Up&& __rhs)
    {
      __lhs._M_index = __rhs._M_index;
      __variant::__raw_visit([&__lhs](auto&& __rhs_mem) mutable
        {
   __variant_construct_single(std::forward<_Tp>(__lhs),
       std::forward<decltype(__rhs_mem)>(__rhs_mem));
 }, __variant_cast<_Types...>(std::forward<_Up>(__rhs)));
    }




  template<bool, typename... _Types>
    struct _Copy_ctor_base : _Variant_storage_alias<_Types...>
    {
      using _Base = _Variant_storage_alias<_Types...>;
      using _Base::_Base;

      _Copy_ctor_base(const _Copy_ctor_base& __rhs)
   noexcept(_Traits<_Types...>::_S_nothrow_copy_ctor)
      {
 __variant_construct<_Types...>(*this, __rhs);
      }

      _Copy_ctor_base(_Copy_ctor_base&&) = default;
      _Copy_ctor_base& operator=(const _Copy_ctor_base&) = default;
      _Copy_ctor_base& operator=(_Copy_ctor_base&&) = default;
    };

  template<typename... _Types>
    struct _Copy_ctor_base<true, _Types...> : _Variant_storage_alias<_Types...>
    {
      using _Base = _Variant_storage_alias<_Types...>;
      using _Base::_Base;
    };

  template<typename... _Types>
    using _Copy_ctor_alias =
 _Copy_ctor_base<_Traits<_Types...>::_S_trivial_copy_ctor, _Types...>;

  template<bool, typename... _Types>
    struct _Move_ctor_base : _Copy_ctor_alias<_Types...>
    {
      using _Base = _Copy_ctor_alias<_Types...>;
      using _Base::_Base;

      _Move_ctor_base(_Move_ctor_base&& __rhs)
   noexcept(_Traits<_Types...>::_S_nothrow_move_ctor)
      {
 __variant_construct<_Types...>(*this, std::move(__rhs));
      }

      template<typename _Up>
        void _M_destructive_move(unsigned short __rhs_index, _Up&& __rhs)
        {
   this->_M_reset();
   __variant_construct_single(*this, std::forward<_Up>(__rhs));
   this->_M_index = __rhs_index;
 }

      template<typename _Up>
        void _M_destructive_copy(unsigned short __rhs_index, const _Up& __rhs)
        {
   this->_M_reset();
   __variant_construct_single(*this, __rhs);
   this->_M_index = __rhs_index;
 }

      _Move_ctor_base(const _Move_ctor_base&) = default;
      _Move_ctor_base& operator=(const _Move_ctor_base&) = default;
      _Move_ctor_base& operator=(_Move_ctor_base&&) = default;
    };

  template<typename... _Types>
    struct _Move_ctor_base<true, _Types...> : _Copy_ctor_alias<_Types...>
    {
      using _Base = _Copy_ctor_alias<_Types...>;
      using _Base::_Base;

      template<typename _Up>
        void _M_destructive_move(unsigned short __rhs_index, _Up&& __rhs)
        {
   this->_M_reset();
   __variant_construct_single(*this, std::forward<_Up>(__rhs));
   this->_M_index = __rhs_index;
 }

      template<typename _Up>
        void _M_destructive_copy(unsigned short __rhs_index, const _Up& __rhs)
        {
   this->_M_reset();
   __variant_construct_single(*this, __rhs);
   this->_M_index = __rhs_index;
 }
    };

  template<typename... _Types>
    using _Move_ctor_alias =
 _Move_ctor_base<_Traits<_Types...>::_S_trivial_move_ctor, _Types...>;

  template<bool, typename... _Types>
    struct _Copy_assign_base : _Move_ctor_alias<_Types...>
    {
      using _Base = _Move_ctor_alias<_Types...>;
      using _Base::_Base;

      _Copy_assign_base&
      operator=(const _Copy_assign_base& __rhs)
   noexcept(_Traits<_Types...>::_S_nothrow_copy_assign)
      {
 __variant::__raw_idx_visit(
   [this](auto&& __rhs_mem, auto __rhs_index) mutable
   {
     if constexpr (__rhs_index != variant_npos)
       {
  if (this->_M_index == __rhs_index)
    __variant::__get<__rhs_index>(*this) = __rhs_mem;
  else
    {
      using __rhs_type = __remove_cvref_t<decltype(__rhs_mem)>;
      if constexpr (is_nothrow_copy_constructible_v<__rhs_type>
   || !is_nothrow_move_constructible_v<__rhs_type>)







        this->_M_destructive_copy(__rhs_index, __rhs_mem);
      else
        __variant_cast<_Types...>(*this)
   = variant<_Types...>(__rhs_mem);
    }
       }
     else
       this->_M_reset();
   }, __variant_cast<_Types...>(__rhs));
 return *this;
      }

      _Copy_assign_base(const _Copy_assign_base&) = default;
      _Copy_assign_base(_Copy_assign_base&&) = default;
      _Copy_assign_base& operator=(_Copy_assign_base&&) = default;
    };

  template<typename... _Types>
    struct _Copy_assign_base<true, _Types...> : _Move_ctor_alias<_Types...>
    {
      using _Base = _Move_ctor_alias<_Types...>;
      using _Base::_Base;
    };

  template<typename... _Types>
    using _Copy_assign_alias =
      _Copy_assign_base<_Traits<_Types...>::_S_trivial_copy_assign, _Types...>;

  template<bool, typename... _Types>
    struct _Move_assign_base : _Copy_assign_alias<_Types...>
    {
      using _Base = _Copy_assign_alias<_Types...>;
      using _Base::_Base;

      _Move_assign_base&
      operator=(_Move_assign_base&& __rhs)
   noexcept(_Traits<_Types...>::_S_nothrow_move_assign)
      {
 __variant::__raw_idx_visit(
   [this](auto&& __rhs_mem, auto __rhs_index) mutable
   {
     if constexpr (__rhs_index != variant_npos)
       {
  if (this->_M_index == __rhs_index)
    __variant::__get<__rhs_index>(*this) = std::move(__rhs_mem);
  else
    __variant_cast<_Types...>(*this)
      .template emplace<__rhs_index>(std::move(__rhs_mem));
       }
     else
       this->_M_reset();
   }, __variant_cast<_Types...>(__rhs));
 return *this;
      }

      _Move_assign_base(const _Move_assign_base&) = default;
      _Move_assign_base(_Move_assign_base&&) = default;
      _Move_assign_base& operator=(const _Move_assign_base&) = default;
    };

  template<typename... _Types>
    struct _Move_assign_base<true, _Types...> : _Copy_assign_alias<_Types...>
    {
      using _Base = _Copy_assign_alias<_Types...>;
      using _Base::_Base;
    };

  template<typename... _Types>
    using _Move_assign_alias =
      _Move_assign_base<_Traits<_Types...>::_S_trivial_move_assign, _Types...>;

  template<typename... _Types>
    struct _Variant_base : _Move_assign_alias<_Types...>
    {
      using _Base = _Move_assign_alias<_Types...>;

      constexpr
      _Variant_base()
   noexcept(_Traits<_Types...>::_S_nothrow_default_ctor)
      : _Variant_base(in_place_index<0>) { }

      template<size_t _Np, typename... _Args>
 constexpr explicit
 _Variant_base(in_place_index_t<_Np> __i, _Args&&... __args)
 : _Base(__i, std::forward<_Args>(__args)...)
 { }

      _Variant_base(const _Variant_base&) = default;
      _Variant_base(_Variant_base&&) = default;
      _Variant_base& operator=(const _Variant_base&) = default;
      _Variant_base& operator=(_Variant_base&&) = default;
    };


  template<typename _Tp, typename _Tuple>
    struct __tuple_count;

  template<typename _Tp, typename _Tuple>
    inline constexpr size_t __tuple_count_v =
      __tuple_count<_Tp, _Tuple>::value;

  template<typename _Tp, typename... _Types>
    struct __tuple_count<_Tp, tuple<_Types...>>
    : integral_constant<size_t, 0> { };

  template<typename _Tp, typename _First, typename... _Rest>
    struct __tuple_count<_Tp, tuple<_First, _Rest...>>
    : integral_constant<
 size_t,
 __tuple_count_v<_Tp, tuple<_Rest...>> + is_same_v<_Tp, _First>> { };


  template<typename _Tp, typename... _Types>
    inline constexpr bool __exactly_once =
      __tuple_count_v<_Tp, tuple<_Types...>> == 1;


  template<typename _Ti> struct _Arr { _Ti _M_x[1]; };


  template<size_t _Ind, typename _Tp, typename _Ti,
    bool _Ti_is_cv_bool = is_same_v<remove_cv_t<_Ti>, bool>,
    typename = void>
    struct _Build_FUN
    {


      void _S_fun();
    };


  template<size_t _Ind, typename _Tp, typename _Ti>
    struct _Build_FUN<_Ind, _Tp, _Ti, false,
        void_t<decltype(_Arr<_Ti>{{std::declval<_Tp>()}})>>
    {

      static integral_constant<size_t, _Ind> _S_fun(_Ti);
    };


  template<size_t _Ind, typename _Tp, typename _Ti>
    struct _Build_FUN<_Ind, _Tp, _Ti, true,
        enable_if_t<is_same_v<__remove_cvref_t<_Tp>, bool>>>
    {

      static integral_constant<size_t, _Ind> _S_fun(_Ti);
    };

  template<typename _Tp, typename _Variant,
    typename = make_index_sequence<variant_size_v<_Variant>>>
    struct _Build_FUNs;

  template<typename _Tp, typename... _Ti, size_t... _Ind>
    struct _Build_FUNs<_Tp, variant<_Ti...>, index_sequence<_Ind...>>
    : _Build_FUN<_Ind, _Tp, _Ti>...
    {
      using _Build_FUN<_Ind, _Tp, _Ti>::_S_fun...;
    };



  template<typename _Tp, typename _Variant>
    using _FUN_type
      = decltype(_Build_FUNs<_Tp, _Variant>::_S_fun(std::declval<_Tp>()));


  template<typename _Tp, typename _Variant, typename = void>
    struct __accepted_index
    : integral_constant<size_t, variant_npos>
    { };

  template<typename _Tp, typename _Variant>
    struct __accepted_index<_Tp, _Variant, void_t<_FUN_type<_Tp, _Variant>>>
    : _FUN_type<_Tp, _Variant>
    { };


  template<typename _Variant>
    void* __get_storage(_Variant&& __v) noexcept
    { return __v._M_storage(); }

  template <typename _Maybe_variant_cookie, typename _Variant>
    struct _Extra_visit_slot_needed
    {
      template <typename> struct _Variant_never_valueless;

      template <typename... _Types>
 struct _Variant_never_valueless<variant<_Types...>>
 : bool_constant<__variant::__never_valueless<_Types...>()> {};

      static constexpr bool value =
 (is_same_v<_Maybe_variant_cookie, __variant_cookie>
  || is_same_v<_Maybe_variant_cookie, __variant_idx_cookie>)
 && !_Variant_never_valueless<__remove_cvref_t<_Variant>>::value;
    };


  template<typename _Tp, size_t... _Dimensions>
    struct _Multi_array;


  template<typename _Tp>
    struct _Multi_array<_Tp>
    {
      template<typename>
 struct __untag_result
 : false_type
 { using element_type = _Tp; };

      template <typename... _Args>
 struct __untag_result<const void(*)(_Args...)>
 : false_type
 { using element_type = void(*)(_Args...); };

      template <typename... _Args>
 struct __untag_result<__variant_cookie(*)(_Args...)>
 : false_type
 { using element_type = void(*)(_Args...); };

      template <typename... _Args>
 struct __untag_result<__variant_idx_cookie(*)(_Args...)>
 : false_type
 { using element_type = void(*)(_Args...); };

      template <typename _Res, typename... _Args>
 struct __untag_result<__deduce_visit_result<_Res>(*)(_Args...)>
 : true_type
 { using element_type = _Res(*)(_Args...); };

      using __result_is_deduced = __untag_result<_Tp>;

      constexpr const typename __untag_result<_Tp>::element_type&
      _M_access() const
      { return _M_data; }

      typename __untag_result<_Tp>::element_type _M_data;
    };


  template<typename _Ret,
    typename _Visitor,
    typename... _Variants,
    size_t __first, size_t... __rest>
    struct _Multi_array<_Ret(*)(_Visitor, _Variants...), __first, __rest...>
    {
      static constexpr size_t __index =
 sizeof...(_Variants) - sizeof...(__rest) - 1;

      using _Variant = typename _Nth_type<__index, _Variants...>::type;

      static constexpr int __do_cookie =
 _Extra_visit_slot_needed<_Ret, _Variant>::value ? 1 : 0;

      using _Tp = _Ret(*)(_Visitor, _Variants...);

      template<typename... _Args>
 constexpr decltype(auto)
 _M_access(size_t __first_index, _Args... __rest_indices) const
        {
   return _M_arr[__first_index + __do_cookie]
     ._M_access(__rest_indices...);
 }

      _Multi_array<_Tp, __rest...> _M_arr[__first + __do_cookie];
    };
# 907 "/usr/local/include/c++/10.0.0/variant" 3
  template<typename _Array_type, typename _Index_seq>
    struct __gen_vtable_impl;
# 917 "/usr/local/include/c++/10.0.0/variant" 3
  template<typename _Result_type, typename _Visitor, size_t... __dimensions,
    typename... _Variants, size_t... __indices>
    struct __gen_vtable_impl<
 _Multi_array<_Result_type (*)(_Visitor, _Variants...), __dimensions...>,
 std::index_sequence<__indices...>>
    {
      using _Next =
   remove_reference_t<typename _Nth_type<sizeof...(__indices),
        _Variants...>::type>;
      using _Array_type =
   _Multi_array<_Result_type (*)(_Visitor, _Variants...),
         __dimensions...>;

      static constexpr _Array_type
      _S_apply()
      {
 _Array_type __vtable{};
 _S_apply_all_alts(
   __vtable, make_index_sequence<variant_size_v<_Next>>());
 return __vtable;
      }

      template<size_t... __var_indices>
 static constexpr void
 _S_apply_all_alts(_Array_type& __vtable,
     std::index_sequence<__var_indices...>)
 {
   if constexpr (_Extra_visit_slot_needed<_Result_type, _Next>::value)
     (_S_apply_single_alt<true, __var_indices>(
       __vtable._M_arr[__var_indices + 1],
       &(__vtable._M_arr[0])), ...);
   else
     (_S_apply_single_alt<false, __var_indices>(
       __vtable._M_arr[__var_indices]), ...);
 }

      template<bool __do_cookie, size_t __index, typename _Tp>
 static constexpr void
 _S_apply_single_alt(_Tp& __element, _Tp* __cookie_element = nullptr)
 {
   if constexpr (__do_cookie)
     {
       __element = __gen_vtable_impl<
  _Tp,
  std::index_sequence<__indices..., __index>>::_S_apply();
       *__cookie_element = __gen_vtable_impl<
  _Tp,
  std::index_sequence<__indices..., variant_npos>>::_S_apply();
     }
   else
     {
       __element = __gen_vtable_impl<
  remove_reference_t<decltype(__element)>,
  std::index_sequence<__indices..., __index>>::_S_apply();
     }
 }
    };




  template<typename _Result_type, typename _Visitor, typename... _Variants,
    size_t... __indices>
    struct __gen_vtable_impl<
      _Multi_array<_Result_type (*)(_Visitor, _Variants...)>,
     std::index_sequence<__indices...>>
    {
      using _Array_type =
   _Multi_array<_Result_type (*)(_Visitor, _Variants...)>;

      template<size_t __index, typename _Variant>
 static constexpr decltype(auto)
 __element_by_index_or_cookie(_Variant&& __var) noexcept
        {
   if constexpr (__index != variant_npos)
     return __variant::__get<__index>(std::forward<_Variant>(__var));
   else
     return __variant_cookie{};
 }

      static constexpr decltype(auto)
      __visit_invoke(_Visitor&& __visitor, _Variants... __vars)
      {
 if constexpr (is_same_v<_Result_type, __variant_idx_cookie>)


   std::__invoke(std::forward<_Visitor>(__visitor),
       __element_by_index_or_cookie<__indices>(
  std::forward<_Variants>(__vars))...,
       integral_constant<size_t, __indices>()...);
 else if constexpr (is_same_v<_Result_type, __variant_cookie>)

   std::__invoke(std::forward<_Visitor>(__visitor),
       __element_by_index_or_cookie<__indices>(
  std::forward<_Variants>(__vars))...);
 else if constexpr (_Array_type::__result_is_deduced::value)

   return std::__invoke(std::forward<_Visitor>(__visitor),
       __element_by_index_or_cookie<__indices>(
  std::forward<_Variants>(__vars))...);
 else
   return std::__invoke_r<_Result_type>(
       std::forward<_Visitor>(__visitor),
       __variant::__get<__indices>(std::forward<_Variants>(__vars))...);
      }

      static constexpr auto
      _S_apply()
      { return _Array_type{&__visit_invoke}; }
    };

  template<typename _Result_type, typename _Visitor, typename... _Variants>
    struct __gen_vtable
    {
      using _Array_type =
   _Multi_array<_Result_type (*)(_Visitor, _Variants...),
         variant_size_v<remove_reference_t<_Variants>>...>;

      static constexpr _Array_type _S_vtable
 = __gen_vtable_impl<_Array_type, std::index_sequence<>>::_S_apply();
    };

  template<size_t _Np, typename _Tp>
    struct _Base_dedup : public _Tp { };

  template<typename _Variant, typename __indices>
    struct _Variant_hash_base;

  template<typename... _Types, size_t... __indices>
    struct _Variant_hash_base<variant<_Types...>,
         std::index_sequence<__indices...>>
    : _Base_dedup<__indices, __poison_hash<remove_const_t<_Types>>>... { };

}
}

  template<size_t _Np, typename _Variant, typename... _Args>
    void __variant_construct_by_index(_Variant& __v, _Args&&... __args)
    {
      __v._M_index = _Np;
      auto&& __storage = __detail::__variant::__get<_Np>(__v);
      ::new ((void*)std::addressof(__storage))
        remove_reference_t<decltype(__storage)>
   (std::forward<_Args>(__args)...);
    }

  template<typename _Tp, typename... _Types>
    constexpr bool
    holds_alternative(const variant<_Types...>& __v) noexcept
    {
      static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
      "T must occur exactly once in alternatives");
      return __v.index() == __detail::__variant::__index_of_v<_Tp, _Types...>;
    }

  template<typename _Tp, typename... _Types>
    constexpr _Tp& get(variant<_Types...>& __v)
    {
      static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
      "T must occur exactly once in alternatives");
      static_assert(!is_void_v<_Tp>, "_Tp must not be void");
      return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(__v);
    }

  template<typename _Tp, typename... _Types>
    constexpr _Tp&& get(variant<_Types...>&& __v)
    {
      static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
      "T must occur exactly once in alternatives");
      static_assert(!is_void_v<_Tp>, "_Tp must not be void");
      return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(
 std::move(__v));
    }

  template<typename _Tp, typename... _Types>
    constexpr const _Tp& get(const variant<_Types...>& __v)
    {
      static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
      "T must occur exactly once in alternatives");
      static_assert(!is_void_v<_Tp>, "_Tp must not be void");
      return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(__v);
    }

  template<typename _Tp, typename... _Types>
    constexpr const _Tp&& get(const variant<_Types...>&& __v)
    {
      static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
      "T must occur exactly once in alternatives");
      static_assert(!is_void_v<_Tp>, "_Tp must not be void");
      return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(
 std::move(__v));
    }

  template<size_t _Np, typename... _Types>
    constexpr add_pointer_t<variant_alternative_t<_Np, variant<_Types...>>>
    get_if(variant<_Types...>* __ptr) noexcept
    {
      using _Alternative_type = variant_alternative_t<_Np, variant<_Types...>>;
      static_assert(_Np < sizeof...(_Types),
      "The index must be in [0, number of alternatives)");
      static_assert(!is_void_v<_Alternative_type>, "_Tp must not be void");
      if (__ptr && __ptr->index() == _Np)
 return std::addressof(__detail::__variant::__get<_Np>(*__ptr));
      return nullptr;
    }

  template<size_t _Np, typename... _Types>
    constexpr
    add_pointer_t<const variant_alternative_t<_Np, variant<_Types...>>>
    get_if(const variant<_Types...>* __ptr) noexcept
    {
      using _Alternative_type = variant_alternative_t<_Np, variant<_Types...>>;
      static_assert(_Np < sizeof...(_Types),
      "The index must be in [0, number of alternatives)");
      static_assert(!is_void_v<_Alternative_type>, "_Tp must not be void");
      if (__ptr && __ptr->index() == _Np)
 return std::addressof(__detail::__variant::__get<_Np>(*__ptr));
      return nullptr;
    }

  template<typename _Tp, typename... _Types>
    constexpr add_pointer_t<_Tp>
    get_if(variant<_Types...>* __ptr) noexcept
    {
      static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
      "T must occur exactly once in alternatives");
      static_assert(!is_void_v<_Tp>, "_Tp must not be void");
      return std::get_if<__detail::__variant::__index_of_v<_Tp, _Types...>>(
   __ptr);
    }

  template<typename _Tp, typename... _Types>
    constexpr add_pointer_t<const _Tp>
    get_if(const variant<_Types...>* __ptr) noexcept
    {
      static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
      "T must occur exactly once in alternatives");
      static_assert(!is_void_v<_Tp>, "_Tp must not be void");
      return std::get_if<__detail::__variant::__index_of_v<_Tp, _Types...>>(
   __ptr);
    }

  struct monostate { };
# 1189 "/usr/local/include/c++/10.0.0/variant" 3
  template<typename... _Types> constexpr bool operator <(const variant<_Types...>& __lhs, const variant<_Types...>& __rhs) { bool __ret = true; __detail::__variant::__raw_idx_visit( [&__ret, &__lhs] (auto&& __rhs_mem, auto __rhs_index) mutable { if constexpr (__rhs_index != variant_npos) { if (__lhs.index() == __rhs_index) { auto& __this_mem = std::get<__rhs_index>(__lhs); __ret = __this_mem < __rhs_mem; } else __ret = (__lhs.index() + 1) < (__rhs_index + 1); } else __ret = (__lhs.index() + 1) < (__rhs_index + 1); }, __rhs); return __ret; } constexpr bool operator <(monostate, monostate) noexcept { return 0 < 0; }
  template<typename... _Types> constexpr bool operator <=(const variant<_Types...>& __lhs, const variant<_Types...>& __rhs) { bool __ret = true; __detail::__variant::__raw_idx_visit( [&__ret, &__lhs] (auto&& __rhs_mem, auto __rhs_index) mutable { if constexpr (__rhs_index != variant_npos) { if (__lhs.index() == __rhs_index) { auto& __this_mem = std::get<__rhs_index>(__lhs); __ret = __this_mem <= __rhs_mem; } else __ret = (__lhs.index() + 1) <= (__rhs_index + 1); } else __ret = (__lhs.index() + 1) <= (__rhs_index + 1); }, __rhs); return __ret; } constexpr bool operator <=(monostate, monostate) noexcept { return 0 <= 0; }
  template<typename... _Types> constexpr bool operator ==(const variant<_Types...>& __lhs, const variant<_Types...>& __rhs) { bool __ret = true; __detail::__variant::__raw_idx_visit( [&__ret, &__lhs] (auto&& __rhs_mem, auto __rhs_index) mutable { if constexpr (__rhs_index != variant_npos) { if (__lhs.index() == __rhs_index) { auto& __this_mem = std::get<__rhs_index>(__lhs); __ret = __this_mem == __rhs_mem; } else __ret = (__lhs.index() + 1) == (__rhs_index + 1); } else __ret = (__lhs.index() + 1) == (__rhs_index + 1); }, __rhs); return __ret; } constexpr bool operator ==(monostate, monostate) noexcept { return 0 == 0; }
  template<typename... _Types> constexpr bool operator !=(const variant<_Types...>& __lhs, const variant<_Types...>& __rhs) { bool __ret = true; __detail::__variant::__raw_idx_visit( [&__ret, &__lhs] (auto&& __rhs_mem, auto __rhs_index) mutable { if constexpr (__rhs_index != variant_npos) { if (__lhs.index() == __rhs_index) { auto& __this_mem = std::get<__rhs_index>(__lhs); __ret = __this_mem != __rhs_mem; } else __ret = (__lhs.index() + 1) != (__rhs_index + 1); } else __ret = (__lhs.index() + 1) != (__rhs_index + 1); }, __rhs); return __ret; } constexpr bool operator !=(monostate, monostate) noexcept { return 0 != 0; }
  template<typename... _Types> constexpr bool operator >=(const variant<_Types...>& __lhs, const variant<_Types...>& __rhs) { bool __ret = true; __detail::__variant::__raw_idx_visit( [&__ret, &__lhs] (auto&& __rhs_mem, auto __rhs_index) mutable { if constexpr (__rhs_index != variant_npos) { if (__lhs.index() == __rhs_index) { auto& __this_mem = std::get<__rhs_index>(__lhs); __ret = __this_mem >= __rhs_mem; } else __ret = (__lhs.index() + 1) >= (__rhs_index + 1); } else __ret = (__lhs.index() + 1) >= (__rhs_index + 1); }, __rhs); return __ret; } constexpr bool operator >=(monostate, monostate) noexcept { return 0 >= 0; }
  template<typename... _Types> constexpr bool operator >(const variant<_Types...>& __lhs, const variant<_Types...>& __rhs) { bool __ret = true; __detail::__variant::__raw_idx_visit( [&__ret, &__lhs] (auto&& __rhs_mem, auto __rhs_index) mutable { if constexpr (__rhs_index != variant_npos) { if (__lhs.index() == __rhs_index) { auto& __this_mem = std::get<__rhs_index>(__lhs); __ret = __this_mem > __rhs_mem; } else __ret = (__lhs.index() + 1) > (__rhs_index + 1); } else __ret = (__lhs.index() + 1) > (__rhs_index + 1); }, __rhs); return __ret; } constexpr bool operator >(monostate, monostate) noexcept { return 0 > 0; }



  template<typename _Visitor, typename... _Variants>
    constexpr decltype(auto) visit(_Visitor&&, _Variants&&...);

  template<typename... _Types>
    inline enable_if_t<(is_move_constructible_v<_Types> && ...)
   && (is_swappable_v<_Types> && ...)>
    swap(variant<_Types...>& __lhs, variant<_Types...>& __rhs)
    noexcept(noexcept(__lhs.swap(__rhs)))
    { __lhs.swap(__rhs); }

  template<typename... _Types>
    enable_if_t<!((is_move_constructible_v<_Types> && ...)
     && (is_swappable_v<_Types> && ...))>
    swap(variant<_Types...>&, variant<_Types...>&) = delete;

  class bad_variant_access : public exception
  {
  public:
    bad_variant_access() noexcept { }

    const char* what() const noexcept override
    { return _M_reason; }

  private:
    bad_variant_access(const char* __reason) noexcept : _M_reason(__reason) { }


    const char* _M_reason = "bad variant access";

    friend void __throw_bad_variant_access(const char* __what);
  };


  inline void
  __throw_bad_variant_access(const char* __what)
  { (throw (bad_variant_access(__what))); }

  inline void
  __throw_bad_variant_access(bool __valueless)
  {
    if (__valueless) [[__unlikely__]]
      __throw_bad_variant_access("std::get: variant is valueless");
    else
      __throw_bad_variant_access("std::get: wrong index for variant");
  }

  template<typename... _Types>
    class variant
    : private __detail::__variant::_Variant_base<_Types...>,
      private _Enable_default_constructor<
 __detail::__variant::_Traits<_Types...>::_S_default_ctor,
   variant<_Types...>>,
      private _Enable_copy_move<
 __detail::__variant::_Traits<_Types...>::_S_copy_ctor,
 __detail::__variant::_Traits<_Types...>::_S_copy_assign,
 __detail::__variant::_Traits<_Types...>::_S_move_ctor,
 __detail::__variant::_Traits<_Types...>::_S_move_assign,
 variant<_Types...>>
    {
    private:
      template <typename... _UTypes, typename _Tp>
 friend decltype(auto) __variant_cast(_Tp&&);
      template<size_t _Np, typename _Variant, typename... _Args>
 friend void __variant_construct_by_index(_Variant& __v,
       _Args&&... __args);

      static_assert(sizeof...(_Types) > 0,
      "variant must have at least one alternative");
      static_assert(!(std::is_reference_v<_Types> || ...),
      "variant must have no reference alternative");
      static_assert(!(std::is_void_v<_Types> || ...),
      "variant must have no void alternative");

      using _Base = __detail::__variant::_Variant_base<_Types...>;
      using _Default_ctor_enabler =
 _Enable_default_constructor<
   __detail::__variant::_Traits<_Types...>::_S_default_ctor,
     variant<_Types...>>;

      template<typename _Tp>
 static constexpr bool __not_self
   = !is_same_v<__remove_cvref_t<_Tp>, variant>;

      template<typename _Tp>
 static constexpr bool
 __exactly_once = __detail::__variant::__exactly_once<_Tp, _Types...>;

      template<typename _Tp>
 static constexpr size_t __accepted_index
   = __detail::__variant::__accepted_index<_Tp, variant>::value;

      template<size_t _Np, typename = enable_if_t<(_Np < sizeof...(_Types))>>
 using __to_type = variant_alternative_t<_Np, variant>;

      template<typename _Tp, typename = enable_if_t<__not_self<_Tp>>>
 using __accepted_type = __to_type<__accepted_index<_Tp>>;

      template<typename _Tp>
 static constexpr size_t __index_of =
   __detail::__variant::__index_of_v<_Tp, _Types...>;

      using _Traits = __detail::__variant::_Traits<_Types...>;

      template<typename _Tp>
 struct __is_in_place_tag : false_type { };
      template<typename _Tp>
 struct __is_in_place_tag<in_place_type_t<_Tp>> : true_type { };
      template<size_t _Np>
 struct __is_in_place_tag<in_place_index_t<_Np>> : true_type { };

      template<typename _Tp>
 static constexpr bool __not_in_place_tag
   = !__is_in_place_tag<__remove_cvref_t<_Tp>>::value;

    public:
      variant() = default;
      variant(const variant& __rhs) = default;
      variant(variant&&) = default;
      variant& operator=(const variant&) = default;
      variant& operator=(variant&&) = default;
      ~variant() = default;

      template<typename _Tp,
        typename = enable_if_t<sizeof...(_Types) != 0>,
        typename = enable_if_t<__not_in_place_tag<_Tp>>,
        typename _Tj = __accepted_type<_Tp&&>,
        typename = enable_if_t<__exactly_once<_Tj>
          && is_constructible_v<_Tj, _Tp>>>
 constexpr
 variant(_Tp&& __t)
 noexcept(is_nothrow_constructible_v<_Tj, _Tp>)
 : variant(in_place_index<__accepted_index<_Tp>>,
    std::forward<_Tp>(__t))
 { }

      template<typename _Tp, typename... _Args,
        typename = enable_if_t<__exactly_once<_Tp>
          && is_constructible_v<_Tp, _Args...>>>
 constexpr explicit
 variant(in_place_type_t<_Tp>, _Args&&... __args)
 : variant(in_place_index<__index_of<_Tp>>,
    std::forward<_Args>(__args)...)
 { }

      template<typename _Tp, typename _Up, typename... _Args,
        typename = enable_if_t<__exactly_once<_Tp>
          && is_constructible_v<_Tp,
        initializer_list<_Up>&, _Args...>>>
 constexpr explicit
 variant(in_place_type_t<_Tp>, initializer_list<_Up> __il,
  _Args&&... __args)
 : variant(in_place_index<__index_of<_Tp>>, __il,
    std::forward<_Args>(__args)...)
 { }

      template<size_t _Np, typename... _Args,
        typename _Tp = __to_type<_Np>,
        typename = enable_if_t<is_constructible_v<_Tp, _Args...>>>
 constexpr explicit
 variant(in_place_index_t<_Np>, _Args&&... __args)
 : _Base(in_place_index<_Np>, std::forward<_Args>(__args)...),
 _Default_ctor_enabler(_Enable_default_constructor_tag{})
 { }

      template<size_t _Np, typename _Up, typename... _Args,
        typename _Tp = __to_type<_Np>,
        typename = enable_if_t<is_constructible_v<_Tp,
        initializer_list<_Up>&,
        _Args...>>>
 constexpr explicit
 variant(in_place_index_t<_Np>, initializer_list<_Up> __il,
  _Args&&... __args)
 : _Base(in_place_index<_Np>, __il, std::forward<_Args>(__args)...),
 _Default_ctor_enabler(_Enable_default_constructor_tag{})
 { }

      template<typename _Tp>
 enable_if_t<__exactly_once<__accepted_type<_Tp&&>>
      && is_constructible_v<__accepted_type<_Tp&&>, _Tp>
      && is_assignable_v<__accepted_type<_Tp&&>&, _Tp>,
      variant&>
 operator=(_Tp&& __rhs)
 noexcept(is_nothrow_assignable_v<__accepted_type<_Tp&&>&, _Tp>
   && is_nothrow_constructible_v<__accepted_type<_Tp&&>, _Tp>)
 {
   constexpr auto __index = __accepted_index<_Tp>;
   if (index() == __index)
     std::get<__index>(*this) = std::forward<_Tp>(__rhs);
   else
     {
       using _Tj = __accepted_type<_Tp&&>;
       if constexpr (is_nothrow_constructible_v<_Tj, _Tp>
       || !is_nothrow_move_constructible_v<_Tj>)
  this->emplace<__index>(std::forward<_Tp>(__rhs));
       else
  operator=(variant(std::forward<_Tp>(__rhs)));
     }
   return *this;
 }

      template<typename _Tp, typename... _Args>
 enable_if_t<is_constructible_v<_Tp, _Args...> && __exactly_once<_Tp>,
      _Tp&>
 emplace(_Args&&... __args)
 {
   constexpr size_t __index = __index_of<_Tp>;
   return this->emplace<__index>(std::forward<_Args>(__args)...);
 }

      template<typename _Tp, typename _Up, typename... _Args>
 enable_if_t<is_constructible_v<_Tp, initializer_list<_Up>&, _Args...>
      && __exactly_once<_Tp>,
      _Tp&>
 emplace(initializer_list<_Up> __il, _Args&&... __args)
 {
   constexpr size_t __index = __index_of<_Tp>;
   return this->emplace<__index>(__il, std::forward<_Args>(__args)...);
 }

      template<size_t _Np, typename... _Args>
 enable_if_t<is_constructible_v<variant_alternative_t<_Np, variant>,
           _Args...>,
      variant_alternative_t<_Np, variant>&>
 emplace(_Args&&... __args)
 {
   static_assert(_Np < sizeof...(_Types),
   "The index must be in [0, number of alternatives)");
   using type = variant_alternative_t<_Np, variant>;


   if constexpr (is_nothrow_constructible_v<type, _Args...>)
     {
       this->_M_reset();
       __variant_construct_by_index<_Np>(*this,
    std::forward<_Args>(__args)...);
     }
   else if constexpr (is_scalar_v<type>)
     {

       const type __tmp(std::forward<_Args>(__args)...);

       this->_M_reset();
       __variant_construct_by_index<_Np>(*this, __tmp);
     }
   else if constexpr (__detail::__variant::_Never_valueless_alt<type>()
       && _Traits::_S_move_assign)
     {

       variant __tmp(in_place_index<_Np>,
       std::forward<_Args>(__args)...);

       *this = std::move(__tmp);
     }
   else
     {


       this->_M_reset();
       try
  {
    __variant_construct_by_index<_Np>(*this,
      std::forward<_Args>(__args)...);
  }
       catch(...)
  {
    this->_M_index = variant_npos;
    throw;
  }
     }
   return std::get<_Np>(*this);
 }

      template<size_t _Np, typename _Up, typename... _Args>
 enable_if_t<is_constructible_v<variant_alternative_t<_Np, variant>,
           initializer_list<_Up>&, _Args...>,
      variant_alternative_t<_Np, variant>&>
 emplace(initializer_list<_Up> __il, _Args&&... __args)
 {
   static_assert(_Np < sizeof...(_Types),
   "The index must be in [0, number of alternatives)");
   using type = variant_alternative_t<_Np, variant>;


   if constexpr (is_nothrow_constructible_v<type,
         initializer_list<_Up>&,
         _Args...>)
     {
       this->_M_reset();
       __variant_construct_by_index<_Np>(*this, __il,
    std::forward<_Args>(__args)...);
     }
   else if constexpr (__detail::__variant::_Never_valueless_alt<type>()
       && _Traits::_S_move_assign)
     {

       variant __tmp(in_place_index<_Np>, __il,
       std::forward<_Args>(__args)...);

       *this = std::move(__tmp);
     }
   else
     {


       this->_M_reset();
       try
  {
    __variant_construct_by_index<_Np>(*this, __il,
      std::forward<_Args>(__args)...);
  }
       catch(...)
  {
    this->_M_index = variant_npos;
    throw;
  }
     }
   return std::get<_Np>(*this);
 }

      constexpr bool valueless_by_exception() const noexcept
      { return !this->_M_valid(); }

      constexpr size_t index() const noexcept
      {
 using __index_type = typename _Base::__index_type;
 if constexpr (__detail::__variant::__never_valueless<_Types...>())
   return this->_M_index;
 else if constexpr (sizeof...(_Types) <= __index_type(-1) / 2)
   return make_signed_t<__index_type>(this->_M_index);
 else
   return size_t(__index_type(this->_M_index + 1)) - 1;
      }

      void
      swap(variant& __rhs)
      noexcept((__is_nothrow_swappable<_Types>::value && ...)
        && is_nothrow_move_constructible_v<variant>)
      {
 __detail::__variant::__raw_idx_visit(
   [this, &__rhs](auto&& __rhs_mem, auto __rhs_index) mutable
   {
     if constexpr (__rhs_index != variant_npos)
       {
  if (this->index() == __rhs_index)
    {
      auto& __this_mem =
        std::get<__rhs_index>(*this);
      using std::swap;
      swap(__this_mem, __rhs_mem);
    }
  else
    {
      if (!this->valueless_by_exception()) [[__likely__]]
        {
   auto __tmp(std::move(__rhs_mem));
   __rhs = std::move(*this);
   this->_M_destructive_move(__rhs_index,
        std::move(__tmp));
        }
      else
        {
   this->_M_destructive_move(__rhs_index,
        std::move(__rhs_mem));
   __rhs._M_reset();
        }
    }
       }
     else
       {
  if (!this->valueless_by_exception()) [[__likely__]]
    {
      __rhs = std::move(*this);
      this->_M_reset();
    }
       }
   }, __rhs);
      }

    private:







      template<size_t _Np, typename _Vp>
 friend constexpr decltype(auto)
 __detail::__variant::__get(_Vp&& __v) noexcept;

      template<typename _Vp>
 friend void*
 __detail::__variant::__get_storage(_Vp&& __v) noexcept;







      template<typename... _Tp> friend constexpr bool operator <(const variant<_Tp...>& __lhs, const variant<_Tp...>& __rhs);
      template<typename... _Tp> friend constexpr bool operator <=(const variant<_Tp...>& __lhs, const variant<_Tp...>& __rhs);
      template<typename... _Tp> friend constexpr bool operator ==(const variant<_Tp...>& __lhs, const variant<_Tp...>& __rhs);
      template<typename... _Tp> friend constexpr bool operator !=(const variant<_Tp...>& __lhs, const variant<_Tp...>& __rhs);
      template<typename... _Tp> friend constexpr bool operator >=(const variant<_Tp...>& __lhs, const variant<_Tp...>& __rhs);
      template<typename... _Tp> friend constexpr bool operator >(const variant<_Tp...>& __lhs, const variant<_Tp...>& __rhs);


    };

  template<size_t _Np, typename... _Types>
    constexpr variant_alternative_t<_Np, variant<_Types...>>&
    get(variant<_Types...>& __v)
    {
      static_assert(_Np < sizeof...(_Types),
      "The index must be in [0, number of alternatives)");
      if (__v.index() != _Np)
 __throw_bad_variant_access(__v.valueless_by_exception());
      return __detail::__variant::__get<_Np>(__v);
    }

  template<size_t _Np, typename... _Types>
    constexpr variant_alternative_t<_Np, variant<_Types...>>&&
    get(variant<_Types...>&& __v)
    {
      static_assert(_Np < sizeof...(_Types),
      "The index must be in [0, number of alternatives)");
      if (__v.index() != _Np)
 __throw_bad_variant_access(__v.valueless_by_exception());
      return __detail::__variant::__get<_Np>(std::move(__v));
    }

  template<size_t _Np, typename... _Types>
    constexpr const variant_alternative_t<_Np, variant<_Types...>>&
    get(const variant<_Types...>& __v)
    {
      static_assert(_Np < sizeof...(_Types),
      "The index must be in [0, number of alternatives)");
      if (__v.index() != _Np)
 __throw_bad_variant_access(__v.valueless_by_exception());
      return __detail::__variant::__get<_Np>(__v);
    }

  template<size_t _Np, typename... _Types>
    constexpr const variant_alternative_t<_Np, variant<_Types...>>&&
    get(const variant<_Types...>&& __v)
    {
      static_assert(_Np < sizeof...(_Types),
      "The index must be in [0, number of alternatives)");
      if (__v.index() != _Np)
 __throw_bad_variant_access(__v.valueless_by_exception());
      return __detail::__variant::__get<_Np>(std::move(__v));
    }

  template<typename _Result_type, typename _Visitor, typename... _Variants>
    constexpr decltype(auto)
    __do_visit(_Visitor&& __visitor, _Variants&&... __variants)
    {
      constexpr auto& __vtable = __detail::__variant::__gen_vtable<
 _Result_type, _Visitor&&, _Variants&&...>::_S_vtable;

      auto __func_ptr = __vtable._M_access(__variants.index()...);
      return (*__func_ptr)(std::forward<_Visitor>(__visitor),
      std::forward<_Variants>(__variants)...);
    }

  template<typename _Visitor, typename... _Variants>
    constexpr decltype(auto)
    visit(_Visitor&& __visitor, _Variants&&... __variants)
    {
      if ((__variants.valueless_by_exception() || ...))
 __throw_bad_variant_access("std::visit: variant is valueless");

      using _Result_type = std::invoke_result_t<_Visitor,
 decltype(std::get<0>(std::declval<_Variants>()))...>;

      using _Tag = __detail::__variant::__deduce_visit_result<_Result_type>;

      return std::__do_visit<_Tag>(std::forward<_Visitor>(__visitor),
       std::forward<_Variants>(__variants)...);
    }


  template<typename _Res, typename _Visitor, typename... _Variants>
    constexpr _Res
    visit(_Visitor&& __visitor, _Variants&&... __variants)
    {
      if ((__variants.valueless_by_exception() || ...))
 __throw_bad_variant_access("std::visit<R>: variant is valueless");

      return std::__do_visit<_Res>(std::forward<_Visitor>(__visitor),
       std::forward<_Variants>(__variants)...);
    }


  template<bool, typename... _Types>
    struct __variant_hash_call_base_impl
    {
      size_t
      operator()(const variant<_Types...>& __t) const
      noexcept((is_nothrow_invocable_v<hash<decay_t<_Types>>, _Types> && ...))
      {
 size_t __ret;
 __detail::__variant::__raw_visit(
   [&__t, &__ret](auto&& __t_mem) mutable
   {
     using _Type = __remove_cvref_t<decltype(__t_mem)>;
     if constexpr (!is_same_v<_Type,
                __detail::__variant::__variant_cookie>)
       __ret = std::hash<size_t>{}(__t.index())
        + std::hash<_Type>{}(__t_mem);
     else
       __ret = std::hash<size_t>{}(__t.index());
   }, __t);
 return __ret;
      }
    };

  template<typename... _Types>
    struct __variant_hash_call_base_impl<false, _Types...> {};

  template<typename... _Types>
    using __variant_hash_call_base =
    __variant_hash_call_base_impl<(__poison_hash<remove_const_t<_Types>>::
       __enable_hash_call &&...), _Types...>;

  template<typename... _Types>
    struct hash<variant<_Types...>>
    : private __detail::__variant::_Variant_hash_base<
 variant<_Types...>, std::index_sequence_for<_Types...>>,
      public __variant_hash_call_base<_Types...>
    {
      using result_type [[__deprecated__]] = size_t;
      using argument_type [[__deprecated__]] = variant<_Types...>;
    };

  template<>
    struct hash<monostate>
    {
      using result_type [[__deprecated__]] = size_t;
      using argument_type [[__deprecated__]] = monostate;

      size_t
      operator()(const monostate&) const noexcept
      {
 constexpr size_t __magic_monostate_hash = -7777;
 return __magic_monostate_hash;
      }
    };

  template<typename... _Types>
    struct __is_fast_hash<hash<variant<_Types...>>>
    : bool_constant<(__is_fast_hash<_Types>::value && ...)>
    { };


}
# 3 "fast_io/fast_io_network/address.h" 2


# 4 "fast_io/fast_io_network/address.h"
namespace fast_io
{

struct ipv4
{
 std::array<std::byte, 4> storage{};
};


template<character_input_stream input>
inline constexpr void scan_define(input& in,ipv4& v4)
{
 for(auto& e: v4.storage)
  scan(in,e);
}

inline constexpr std::size_t native_socket_address_size(ipv4 const&)
{
 return sizeof(sockaddr_in);
}

inline constexpr auto family(ipv4 const&)
{
 return sock::family::ipv4;
}


struct socket_address_storage
{
 sockaddr sock;
 std::array<std::byte,sizeof(sockaddr_storage)<sizeof(sockaddr)?0x0:sizeof(sockaddr_storage)-sizeof(sockaddr)> storage;
};



template<std::integral U>
inline constexpr auto to_socket_address_storage(ipv4 const& add,U port)
{
 sockaddr_in v4st{};
 v4st.sin_family=static_cast<sock::details::address_family>(fast_io::sock::family::ipv4);
 v4st.sin_port=details::big_endian(static_cast<std::uint16_t>(port));
 std::memcpy(std::addressof(v4st.sin_addr),add.storage.data(),sizeof(add.storage));
 socket_address_storage stor{};
 std::memcpy(std::addressof(stor),std::addressof(v4st),sizeof(sockaddr_in));
 return stor;
}

template<character_output_stream output>
inline constexpr void print_define(output& os, ipv4 const &v)
{
 print(os, v.storage.front());
 put(os, 0x2E);
 print(os, v.storage[1]);
 put(os, 0x2E);
 print(os, v.storage[2]);
 put(os, 0x2E);
 print(os, v.storage.back());
}

struct ipv6
{
 std::array<std::byte, 16> storage{};
};
inline constexpr std::size_t native_socket_address_size(ipv6 const&)
{
 return sizeof(sockaddr_in6);
}

inline constexpr auto family(ipv6 const&)
{
 return sock::family::ipv6;
}

template<character_input_stream input>
inline constexpr void scan_define(input& in,ipv6& v6)
{
 constexpr auto npos(static_cast<std::size_t>(-1));
 std::basic_string<typename input::char_type> str;
 scan(in,str);
 if(str.size()<2)
  throw std::runtime_error("ipv6 address too short");
 else if(39<str.size())
  throw std::runtime_error("ipv6 address too long");
 std::size_t colons(0),position(npos);
 if(str.front()!=0x3a)
  ++colons;
 if(str.back()!=0x3a)
  ++colons;
 for(std::size_t i(0);i!=str.size();++i)
  if(str[i]==0x3a)
  {
   ++colons;
   if(i+1!=str.size()&&str[i+1]==0x3a)
   {
    position=i;
    ++i;
   }
  }
 if(7<colons)
  throw std::runtime_error("too many : for ipv6 address");
 if(position!=npos)
 {
  std::string tempstr(1,0x20);
  for(std::size_t i(9-colons);i--;)
   tempstr.append("0 ",2);
  str.insert(position,tempstr);
 }
 fast_io::basic_istring_view<std::basic_string_view<typename input::char_type>> istrbuf(str);
 std::uint16_t temp{};
 for(auto i(v6.storage.begin()),e(v6.storage.end());i!=e;++i)
 {
  fast_io::scan(istrbuf,fast_io::hex(temp));
  *i=static_cast<std::byte>(temp>>8);
  *++i=static_cast<std::byte>(temp&255);
 }
}

template<std::integral U>
inline constexpr auto to_socket_address_storage(ipv6 const& add,U port)
{
 sockaddr_in6 v6st{};
 v6st.sin6_family=static_cast<sock::details::address_family>(fast_io::sock::family::ipv6);
 v6st.sin6_port=details::big_endian(static_cast<std::uint16_t>(port));
 std::memcpy(std::addressof(v6st.sin6_addr),add.storage.data(),sizeof(add.storage));
 socket_address_storage stor{};
 std::memcpy(std::addressof(stor),std::addressof(v6st),sizeof(sockaddr_in6));
 return stor;
}

template<character_output_stream output,std::size_t base,bool uppercase,typename T>
requires std::same_as<ipv6,std::remove_cvref_t<T>>
inline constexpr void print_define(output& os,manip::base_t<base,uppercase,T> e)
{
 std::array<std::uint16_t,8> storage{};
 for(std::size_t i(0);i!=storage.size();++i)
  storage[i]=(std::to_integer<std::uint16_t>(e.reference.storage[i<<1])<<8)|std::to_integer<std::uint16_t>(e.reference.storage[(i<<1)+1]);
 constexpr auto npos(static_cast<std::size_t>(-1));
 std::size_t last_zero_range(npos);
 std::size_t maximum_zero_size(0),maximum_zero_start(npos);
 for(std::size_t i(0),sz(storage.size());i!=sz;++i)
 {
  auto& e(storage[i]);
  if(e)
   last_zero_range=npos;
  else
  {
   if(maximum_zero_start==npos)
   {
    maximum_zero_size=1;
    maximum_zero_start=last_zero_range=i;
   }
   else if(last_zero_range==npos)
    last_zero_range=i;
   else
   {
    if(maximum_zero_size<i+1-last_zero_range)
    {
     maximum_zero_size=i+1-last_zero_range;
     maximum_zero_start=last_zero_range;
    }
   }
  }
 }
 if(maximum_zero_size)
 {
  if(maximum_zero_start)
   print(os,fast_io::base<base,uppercase>(storage.front()));
  for(std::size_t i(1);i<maximum_zero_start;++i)
   print(os,fast_io::char_view(0x3a),fast_io::base<base,uppercase>(storage[i]));
  print(os,"::");
  std::size_t const maximum_zero_end(maximum_zero_start+maximum_zero_size);
  if(maximum_zero_end==storage.size())
   return;
  print(os,fast_io::base<base,uppercase>(storage[maximum_zero_end]));
  for(std::size_t i(maximum_zero_end+1);i<storage.size();++i)
   print(os,fast_io::char_view(0x3a),fast_io::base<base,uppercase>(storage[i]));
 }
 else
 {
  print(os, fast_io::hex(storage.front()));
  for (auto i(storage.cbegin() + 1); i != storage.cend(); ++i)
   print(os,fast_io::char_view(0x3a),fast_io::base<base,uppercase>(*i));
 }
}

template<character_output_stream output,typename T>
requires std::same_as<ipv6,std::remove_cvref_t<T>>
inline constexpr void print_define(output& out,T const& v)
{
 print(out,fast_io::hex(v));
}

class address
{
public:
 using variant_type = std::variant<ipv4, ipv6>;
private:
 variant_type var;
public:
 template<typename... Args>
 requires std::constructible_from<variant_type, Args...>
 explicit constexpr address(Args &&... args) :var(std::forward<Args>(args)...){}

 constexpr auto& variant() { return var; }
 constexpr auto& variant() const { return var; }
};

template<std::integral U>
inline constexpr auto to_socket_address_storage(address const& v,U port)
{
 return std::visit([port](auto const &arg) {
  return to_socket_address_storage(arg,port);
 }, v.variant());
}

inline constexpr std::size_t native_socket_address_size(address const& v)
{
 return std::visit([](auto const &arg) {
  return native_socket_address_size(arg);
 }, v.variant());
}


inline constexpr auto family(address const& v)
{
 return std::visit([](auto const &arg) {
  return family(arg);
 }, v.variant());
}

template<character_output_stream output>
inline constexpr void print_define(output &os, address const &v)
{
 std::visit([&os](auto const &arg) {
  print_define(os,arg);
 }, v.variant());
}

}
# 60 "fast_io/fast_io_network/network.h" 2
# 1 "fast_io/fast_io_network/socket.h" 1
       

namespace fast_io
{

class socket
{
 sock::details::socket_type handle=sock::details::invalid_socket;
 void close_impl()
 try
 {
  if(handle!=sock::details::invalid_socket)
   sock::details::closesocket(handle);
 }
 catch(...)
 {}
protected:
 auto& protected_native_handle() {return handle;}
public:
 socket()=default;
 socket(sock::details::socket_type v):handle(v){}
 template<typename ...Args>
 socket(native_interface_t,Args&& ...args):handle(sock::details::socket(std::forward<Args>(args)...)){}
 socket(sock::family family,sock::type const &type,sock::protocal const &protocal = sock::protocal::none):
  handle(sock::details::socket(static_cast<sock::details::address_family>(family),static_cast<int>(type),static_cast<int>(protocal))){}
 auto native_handle() {return handle;}
 socket(socket const&) = delete;
 socket& operator=(socket const&) = delete;
 socket(socket && soc) noexcept:handle(soc.handle)
 {
  soc.handle = sock::details::invalid_socket;
 }
 socket& operator=(socket && soc) noexcept
 {
  if(soc.handle!=handle)
  {
   close_impl();
   handle = soc.handle;
   soc.handle = sock::details::invalid_socket;
  }
  return *this;
 }
 ~socket()
 {
  close_impl();
 }
};

template<std::contiguous_iterator Iter>
inline Iter receive(socket& soc,Iter begin,Iter end)
{
 return begin+((sock::details::recv(soc.native_handle(),std::to_address(begin),static_cast<int>((end-begin)*sizeof(*begin)),0))/sizeof(*begin));
}
template<std::contiguous_iterator Iter>
inline Iter send(socket& soc,Iter begin,Iter end)
{
 return begin+(sock::details::send(soc.native_handle(),std::to_address(begin),static_cast<int>((end-begin)*sizeof(*begin)),0)/sizeof(*begin));
}

inline constexpr void flush(socket&)
{
}


inline auto zero_copy_out_handle(socket& soc)
{
 return soc.native_handle();
}


struct address_info
{
 socket_address_storage storage={};
 socklen_t storage_size=sizeof(socket_address_storage);
};

class client:public socket
{
 address_info cinfo;
public:
 using char_type = char;
 template<typename T,std::integral U,typename ...Args>
 client(T const& add,U u,Args&& ...args):socket(family(add),std::forward<Args>(args)...),cinfo{to_socket_address_storage(add,u),sizeof(socket_address_storage)}
 {
  sock::details::connect(native_handle(),cinfo.storage,native_socket_address_size(add));
 }
 constexpr auto& info()
 {
  return cinfo;
 }
 constexpr auto& info() const
 {
  return cinfo;
 }
};

class server
{
 socket soc;
public:
 template<typename addrType,std::integral U,typename ...Args>
 requires (!std::integral<addrType>)
 server(addrType const& add,U u,Args&& ...args):soc(family(add),std::forward<Args>(args)...)
 {
  auto stg(to_socket_address_storage(add,u));
  sock::details::bind(soc.native_handle(),stg,native_socket_address_size(add));
  sock::details::listen(soc.native_handle(),10);
 }
 template<std::integral U,typename ...Args>
 server(U u,Args&& ...args):server(ipv4{},u,std::forward<Args>(args)...)
 {
 }
 constexpr auto& native_handle()
 {
  return soc;
 }
};



inline void unblock(socket& sv)
{
 if(::fcntl(sv.native_handle(), 
# 123 "fast_io/fast_io_network/socket.h" 3 4
                               4
# 123 "fast_io/fast_io_network/socket.h"
                                      , 
# 123 "fast_io/fast_io_network/socket.h" 3 4
                                        04000
# 123 "fast_io/fast_io_network/socket.h"
                                                  )==-1)
  throw std::system_error(
# 124 "fast_io/fast_io_network/socket.h" 3 4
                         (*__errno_location ())
# 124 "fast_io/fast_io_network/socket.h"
                              ,std::generic_category());
}

inline void unblock(server& sv)
{
 unblock(sv.native_handle());
}


class async_server
{
 socket soc;
public:
 template<typename addrType,std::integral U,typename ...Args>
 requires (!std::integral<addrType>)
 async_server(addrType const& add,U u,Args&& ...args):soc(family(add),std::forward<Args>(args)...)
 {
  auto stg(to_socket_address_storage(add,u));


  unblock(soc);

  sock::details::bind(soc.native_handle(),stg,native_socket_address_size(add));
  sock::details::listen(soc.native_handle(),10);
 }
 template<std::integral U,typename ...Args>
 async_server(U u,Args&& ...args):async_server(ipv4{},u,std::forward<Args>(args)...)
 {
 }
 constexpr auto& native_handle()
 {
  return soc;
 }
};

struct non_block_t
{
explicit constexpr non_block_t()=default;
};

inline constexpr non_block_t non_block{};

class acceptor:public socket
{
 address_info cinfo;
public:
 using native_handle_type = sock::details::socket_type;
 using char_type = char;
 acceptor(server& listener_socket)
 {
  protected_native_handle()=sock::details::accept(listener_socket.native_handle().native_handle(),cinfo.storage,cinfo.storage_size);
 }
 acceptor(async_server& listener_socket)
 {



  protected_native_handle()=sock::details::accept(listener_socket.native_handle().native_handle(),cinfo.storage,cinfo.storage_size);
  unblock(*this);

 }
 constexpr auto& get()
 {
  return cinfo;
 }
 constexpr auto& get() const
 {
  return cinfo;
 }
};

}
# 61 "fast_io/fast_io_network/network.h" 2
# 1 "fast_io/fast_io_network/dns.h" 1
       



namespace fast_io
{
namespace details
{
 struct dns_iterator
 {
  addrinfo *ptr;
 };
 struct dns_sentinal
 {
 };
 inline constexpr bool operator==(dns_iterator const& a, dns_iterator const& b)
 {
  return a.ptr == b.ptr;
 }
 inline constexpr bool operator!=(dns_iterator const& a, dns_iterator const& b)
 {
  return !(a==b);
 }
 inline constexpr bool operator==(dns_sentinal, dns_iterator const& b)
 {
  return b.ptr == nullptr;
 }
 inline constexpr bool operator==(dns_iterator const& b, dns_sentinal)
 {
  return b.ptr == nullptr;
 }
 inline constexpr bool operator!=(dns_sentinal, dns_iterator const& b)
 {
  return b.ptr != nullptr;
 }
 inline constexpr bool operator!=(dns_iterator const& b, dns_sentinal)
 {
  return b.ptr != nullptr;
 }
 inline address operator*(dns_iterator const &a)
 {
  if (a.ptr->ai_family == 
# 42 "fast_io/fast_io_network/dns.h" 3 4
                         2
# 42 "fast_io/fast_io_network/dns.h"
                                )
  {
   sockaddr_in addr;
   memcpy(std::addressof(addr), a.ptr->ai_addr, sizeof(addr));
   ipv4 ret;
   memcpy(ret.storage.data(), std::addressof(addr.sin_addr), sizeof(ret.storage));
   return address(ret);
  }
  else if (a.ptr->ai_family == 
# 50 "fast_io/fast_io_network/dns.h" 3 4
                              10
# 50 "fast_io/fast_io_network/dns.h"
                                      )
  {
   sockaddr_in6 addr;
   memcpy(std::addressof(addr), a.ptr->ai_addr, sizeof(addr));
   ipv6 ret;
   memcpy(ret.storage.data(), std::addressof(addr.sin6_addr), sizeof(ret.storage));
   return address(ret);
  }
  throw std::runtime_error("unknown family");
 }
 inline constexpr dns_iterator& operator++(dns_iterator& a)
 {
  a.ptr = a.ptr->ai_next;
  return a;
 }
 inline constexpr dns_iterator operator++(dns_iterator& a, int)
 {
  auto temp(a);
  ++a;
  return temp;
 }
}

template<fast_io::sock::family fam>
class basic_dns
{
 addrinfo *result;
public:
 basic_dns(std::string_view host)
 {
  addrinfo hints{};
  hints.ai_family = static_cast<fast_io::sock::details::address_family>(fam);
  fast_io::sock::details::getaddrinfo(host.data(), nullptr, std::addressof(hints), std::addressof(result));
 }
 constexpr auto& get_result()
 {
  return result;
 }
 constexpr auto& get_result() const
 {
  return result;
 }
 basic_dns(basic_dns const&) = delete;
 basic_dns& operator=(basic_dns const&) = delete;
 basic_dns(basic_dns&& d) noexcept:result(d.result)
 {
  d.result=nullptr;
 }
 basic_dns& operator=(basic_dns&& d) noexcept
 {
  if(std::addressof(d)!=this)
  {
   if(result)
    fast_io::sock::details::freeaddrinfo(result);
   result=d.result;
   d.result=nullptr;
  }
  return *this;
 }
 ~basic_dns()
 {
  if(result)
   fast_io::sock::details::freeaddrinfo(result);
 }
};

using ipv4_dns = basic_dns<fast_io::sock::family::ipv4>;
using ipv6_dns = basic_dns<fast_io::sock::family::ipv6>;
using dns = basic_dns<fast_io::sock::family::unspec>;

template<fast_io::sock::family fam>
inline constexpr auto cbegin(basic_dns<fam> const& d)
{
 return details::dns_iterator{d.get_result()};
}

template<fast_io::sock::family fam>
inline constexpr auto begin(basic_dns<fam> const& d)
{
 return cbegin(d);
}

template<fast_io::sock::family fam>
inline constexpr auto begin(basic_dns<fam> & d)
{
 return details::dns_iterator{d.get_result()};
}

template<fast_io::sock::family fam>
inline constexpr details::dns_sentinal end(basic_dns<fam> const& d)
{
 return {};
}

template<fast_io::sock::family fam>
inline constexpr details::dns_sentinal cend(basic_dns<fam> const& d)
{
 return {};
}

template<fast_io::sock::family fam=fast_io::sock::family::unspec>
inline constexpr auto dns_once(std::string_view host)
{
 return *cbegin(basic_dns<fam>(host));
}


}
# 62 "fast_io/fast_io_network/network.h" 2
# 1 "fast_io/fast_io_network/http.h" 1
       


namespace fast_io
{



template<character_input_stream input>
inline void get_http_header_split(input& in,std::basic_string<typename input::char_type> &str)
{
 str.clear();
 for(decltype(get<true>(in)) ch;!(ch=get<true>(in)).second&&!details::isspace(ch.first)&ch.first!=0xD&ch.first!=0x3a;str.push_back(ch.first));
}

template<fast_io::character_input_stream input>
inline constexpr auto scan_http_header(input& in)
{
 std::unordered_map<std::string,std::string> results;
 for(std::string str,a,b;;)
 {
  getline(in,str);
  if(str.size()<2)
   return results;
  fast_io::istring_view isv(str);
  get_http_header_split(isv,a);
  if(a.back()==0x3a)
   a.pop_back();
  getcarriage(isv,b);
  results.emplace(std::move(a),std::move(b));
 }
}
template<fast_io::character_input_stream input>
inline constexpr void skip_http_header(input& in)
{
 while(1<skip_line(in));
}


}
# 63 "fast_io/fast_io_network/network.h" 2
# 6 "fast_io/fast_io_network.h" 2

namespace fast_io
{
using acceptor_buf = self_tie<basic_iobuf<acceptor>>;
using client_buf = self_tie<basic_iobuf<client>>;
}
# 6 "autocomplete.cpp" 2

# 1 "tree.h" 1





# 1 "/usr/local/include/c++/10.0.0/queue" 1 3
# 58 "/usr/local/include/c++/10.0.0/queue" 3
       
# 59 "/usr/local/include/c++/10.0.0/queue" 3

# 1 "/usr/local/include/c++/10.0.0/deque" 1 3
# 58 "/usr/local/include/c++/10.0.0/deque" 3
       
# 59 "/usr/local/include/c++/10.0.0/deque" 3
# 67 "/usr/local/include/c++/10.0.0/deque" 3
# 1 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 1 3
# 69 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3

# 69 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


# 92 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
  constexpr inline size_t
  __deque_buf_size(size_t __size)
  { return (__size < 512
     ? size_t(512 / __size) : size_t(1)); }
# 109 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
  template<typename _Tp, typename _Ref, typename _Ptr>
    struct _Deque_iterator
    {






    private:
      template<typename _CvTp>
 using __iter = _Deque_iterator<_Tp, _CvTp&, __ptr_rebind<_Ptr, _CvTp>>;
    public:
      typedef __iter<_Tp> iterator;
      typedef __iter<const _Tp> const_iterator;
      typedef __ptr_rebind<_Ptr, _Tp> _Elt_pointer;
      typedef __ptr_rebind<_Ptr, _Elt_pointer> _Map_pointer;


      static size_t _S_buffer_size() noexcept
      { return __deque_buf_size(sizeof(_Tp)); }

      typedef std::random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Ptr pointer;
      typedef _Ref reference;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Deque_iterator _Self;

      _Elt_pointer _M_cur;
      _Elt_pointer _M_first;
      _Elt_pointer _M_last;
      _Map_pointer _M_node;

      _Deque_iterator(_Elt_pointer __x, _Map_pointer __y) noexcept
      : _M_cur(__x), _M_first(*__y),
 _M_last(*__y + _S_buffer_size()), _M_node(__y) { }

      _Deque_iterator() noexcept
      : _M_cur(), _M_first(), _M_last(), _M_node() { }
# 158 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      template<typename _Iter,
        typename = _Require<is_same<_Self, const_iterator>,
       is_same<_Iter, iterator>>>
       _Deque_iterator(const _Iter& __x) noexcept
       : _M_cur(__x._M_cur), _M_first(__x._M_first),
  _M_last(__x._M_last), _M_node(__x._M_node) { }

      _Deque_iterator(const _Deque_iterator& __x) noexcept
       : _M_cur(__x._M_cur), _M_first(__x._M_first),
  _M_last(__x._M_last), _M_node(__x._M_node) { }

      _Deque_iterator& operator=(const _Deque_iterator&) = default;


      iterator
      _M_const_cast() const noexcept
      { return iterator(_M_cur, _M_node); }

      reference
      operator*() const noexcept
      { return *_M_cur; }

      pointer
      operator->() const noexcept
      { return _M_cur; }

      _Self&
      operator++() noexcept
      {
 ++_M_cur;
 if (_M_cur == _M_last)
   {
     _M_set_node(_M_node + 1);
     _M_cur = _M_first;
   }
 return *this;
      }

      _Self
      operator++(int) noexcept
      {
 _Self __tmp = *this;
 ++*this;
 return __tmp;
      }

      _Self&
      operator--() noexcept
      {
 if (_M_cur == _M_first)
   {
     _M_set_node(_M_node - 1);
     _M_cur = _M_last;
   }
 --_M_cur;
 return *this;
      }

      _Self
      operator--(int) noexcept
      {
 _Self __tmp = *this;
 --*this;
 return __tmp;
      }

      _Self&
      operator+=(difference_type __n) noexcept
      {
 const difference_type __offset = __n + (_M_cur - _M_first);
 if (__offset >= 0 && __offset < difference_type(_S_buffer_size()))
   _M_cur += __n;
 else
   {
     const difference_type __node_offset =
       __offset > 0 ? __offset / difference_type(_S_buffer_size())
      : -difference_type((-__offset - 1)
           / _S_buffer_size()) - 1;
     _M_set_node(_M_node + __node_offset);
     _M_cur = _M_first + (__offset - __node_offset
     * difference_type(_S_buffer_size()));
   }
 return *this;
      }

      _Self&
      operator-=(difference_type __n) noexcept
      { return *this += -__n; }

      reference
      operator[](difference_type __n) const noexcept
      { return *(*this + __n); }






      void
      _M_set_node(_Map_pointer __new_node) noexcept
      {
 _M_node = __new_node;
 _M_first = *__new_node;
 _M_last = _M_first + difference_type(_S_buffer_size());
      }

      friend bool
      operator==(const _Self& __x, const _Self& __y) noexcept
      { return __x._M_cur == __y._M_cur; }




      template<typename _RefR, typename _PtrR>
 friend bool
 operator==(const _Self& __x,
     const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
 { return __x._M_cur == __y._M_cur; }

      friend bool
      operator!=(const _Self& __x, const _Self& __y) noexcept
      { return !(__x == __y); }

      template<typename _RefR, typename _PtrR>
 friend bool
 operator!=(const _Self& __x,
     const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
 { return !(__x == __y); }

      friend bool
      operator<(const _Self& __x, const _Self& __y) noexcept
      {
 return (__x._M_node == __y._M_node)
   ? (__x._M_cur < __y._M_cur) : (__x._M_node < __y._M_node);
      }

      template<typename _RefR, typename _PtrR>
 friend bool
 operator<(const _Self& __x,
    const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
 {
   return (__x._M_node == __y._M_node)
     ? (__x._M_cur < __y._M_cur) : (__x._M_node < __y._M_node);
 }

      friend bool
      operator>(const _Self& __x, const _Self& __y) noexcept
      { return __y < __x; }

      template<typename _RefR, typename _PtrR>
 friend bool
 operator>(const _Self& __x,
    const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
 { return __y < __x; }

      friend bool
      operator<=(const _Self& __x, const _Self& __y) noexcept
      { return !(__y < __x); }

      template<typename _RefR, typename _PtrR>
 friend bool
 operator<=(const _Self& __x,
     const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
 { return !(__y < __x); }

      friend bool
      operator>=(const _Self& __x, const _Self& __y) noexcept
      { return !(__x < __y); }

      template<typename _RefR, typename _PtrR>
 friend bool
 operator>=(const _Self& __x,
     const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
 { return !(__x < __y); }

      friend difference_type
      operator-(const _Self& __x, const _Self& __y) noexcept
      {
 return difference_type(_S_buffer_size())
   * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
   + (__y._M_last - __y._M_cur);
      }





      template<typename _RefR, typename _PtrR>
 friend difference_type
 operator-(const _Self& __x,
    const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
 {
   return difference_type(_S_buffer_size())
     * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
     + (__y._M_last - __y._M_cur);
 }

      friend _Self
      operator+(const _Self& __x, difference_type __n) noexcept
      {
 _Self __tmp = __x;
 __tmp += __n;
 return __tmp;
      }

      friend _Self
      operator-(const _Self& __x, difference_type __n) noexcept
      {
 _Self __tmp = __x;
 __tmp -= __n;
 return __tmp;
      }

      friend _Self
      operator+(difference_type __n, const _Self& __x) noexcept
      { return __x + __n; }
    };
# 386 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    class _Deque_base
    {
    protected:
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_Tp>::other _Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;





      typedef typename _Alloc_traits::pointer _Ptr;
      typedef typename _Alloc_traits::const_pointer _Ptr_const;


      typedef typename _Alloc_traits::template rebind<_Ptr>::other
 _Map_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Map_alloc_type> _Map_alloc_traits;

      typedef _Alloc allocator_type;

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Tp_allocator()); }

      typedef _Deque_iterator<_Tp, _Tp&, _Ptr> iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, _Ptr_const> const_iterator;

      _Deque_base()
      : _M_impl()
      { _M_initialize_map(0); }

      _Deque_base(size_t __num_elements)
      : _M_impl()
      { _M_initialize_map(__num_elements); }

      _Deque_base(const allocator_type& __a, size_t __num_elements)
      : _M_impl(__a)
      { _M_initialize_map(__num_elements); }

      _Deque_base(const allocator_type& __a)
      : _M_impl(__a)
      { }


      _Deque_base(_Deque_base&& __x)
      : _M_impl(std::move(__x._M_get_Tp_allocator()))
      {
 _M_initialize_map(0);
 if (__x._M_impl._M_map)
   this->_M_impl._M_swap_data(__x._M_impl);
      }

      _Deque_base(_Deque_base&& __x, const allocator_type& __a)
      : _M_impl(std::move(__x._M_impl), _Tp_alloc_type(__a))
      { __x._M_initialize_map(0); }

      _Deque_base(_Deque_base&& __x, const allocator_type& __a, size_t __n)
      : _M_impl(__a)
      {
 if (__x.get_allocator() == __a)
   {
     if (__x._M_impl._M_map)
       {
  _M_initialize_map(0);
  this->_M_impl._M_swap_data(__x._M_impl);
       }
   }
 else
   {
     _M_initialize_map(__n);
   }
      }


      ~_Deque_base() noexcept;

      typedef typename iterator::_Map_pointer _Map_pointer;

      struct _Deque_impl_data
      {
 _Map_pointer _M_map;
 size_t _M_map_size;
 iterator _M_start;
 iterator _M_finish;

 _Deque_impl_data() noexcept
 : _M_map(), _M_map_size(), _M_start(), _M_finish()
 { }


 _Deque_impl_data(const _Deque_impl_data&) = default;
 _Deque_impl_data&
 operator=(const _Deque_impl_data&) = default;

 _Deque_impl_data(_Deque_impl_data&& __x) noexcept
 : _Deque_impl_data(__x)
 { __x = _Deque_impl_data(); }


 void
 _M_swap_data(_Deque_impl_data& __x) noexcept
 {


   std::swap(*this, __x);
 }
      };




      struct _Deque_impl
      : public _Tp_alloc_type, public _Deque_impl_data
      {
 _Deque_impl() noexcept(is_nothrow_default_constructible<_Tp_alloc_type>::value)

 : _Tp_alloc_type()
 { }

 _Deque_impl(const _Tp_alloc_type& __a) noexcept
 : _Tp_alloc_type(__a)
 { }


 _Deque_impl(_Deque_impl&&) = default;

 _Deque_impl(_Tp_alloc_type&& __a) noexcept
 : _Tp_alloc_type(std::move(__a))
 { }

 _Deque_impl(_Deque_impl&& __d, _Tp_alloc_type&& __a)
 : _Tp_alloc_type(std::move(__a)), _Deque_impl_data(std::move(__d))
 { }

      };

      _Tp_alloc_type&
      _M_get_Tp_allocator() noexcept
      { return this->_M_impl; }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const noexcept
      { return this->_M_impl; }

      _Map_alloc_type
      _M_get_map_allocator() const noexcept
      { return _Map_alloc_type(_M_get_Tp_allocator()); }

      _Ptr
      _M_allocate_node()
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;
 return _Traits::allocate(_M_impl, __deque_buf_size(sizeof(_Tp)));
      }

      void
      _M_deallocate_node(_Ptr __p) noexcept
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;
 _Traits::deallocate(_M_impl, __p, __deque_buf_size(sizeof(_Tp)));
      }

      _Map_pointer
      _M_allocate_map(size_t __n)
      {
 _Map_alloc_type __map_alloc = _M_get_map_allocator();
 return _Map_alloc_traits::allocate(__map_alloc, __n);
      }

      void
      _M_deallocate_map(_Map_pointer __p, size_t __n) noexcept
      {
 _Map_alloc_type __map_alloc = _M_get_map_allocator();
 _Map_alloc_traits::deallocate(__map_alloc, __p, __n);
      }

      void _M_initialize_map(size_t);
      void _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish);
      void _M_destroy_nodes(_Map_pointer __nstart,
       _Map_pointer __nfinish) noexcept;
      enum { _S_initial_map_size = 8 };

      _Deque_impl _M_impl;
    };

  template<typename _Tp, typename _Alloc>
    _Deque_base<_Tp, _Alloc>::
    ~_Deque_base() noexcept
    {
      if (this->_M_impl._M_map)
 {
   _M_destroy_nodes(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
 }
    }
# 593 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_initialize_map(size_t __num_elements)
    {
      const size_t __num_nodes = (__num_elements / __deque_buf_size(sizeof(_Tp))
      + 1);

      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
        size_t(__num_nodes + 2));
      this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);






      _Map_pointer __nstart = (this->_M_impl._M_map
          + (this->_M_impl._M_map_size - __num_nodes) / 2);
      _Map_pointer __nfinish = __nstart + __num_nodes;

      try
 { _M_create_nodes(__nstart, __nfinish); }
      catch(...)
 {
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
   this->_M_impl._M_map = _Map_pointer();
   this->_M_impl._M_map_size = 0;
   throw;
 }

      this->_M_impl._M_start._M_set_node(__nstart);
      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
      this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
     + __num_elements
     % __deque_buf_size(sizeof(_Tp)));
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish)
    {
      _Map_pointer __cur;
      try
 {
   for (__cur = __nstart; __cur < __nfinish; ++__cur)
     *__cur = this->_M_allocate_node();
 }
      catch(...)
 {
   _M_destroy_nodes(__nstart, __cur);
   throw;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_destroy_nodes(_Map_pointer __nstart,
       _Map_pointer __nfinish) noexcept
    {
      for (_Map_pointer __n = __nstart; __n < __nfinish; ++__n)
 _M_deallocate_node(*__n);
    }
# 744 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class deque : protected _Deque_base<_Tp, _Alloc>
    {
# 757 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      static_assert(is_same<typename remove_cv<_Tp>::type, _Tp>::value,
   "std::deque must have a non-const, non-volatile value_type");

      static_assert(is_same<typename _Alloc::value_type, _Tp>::value,
   "std::deque must have the same value_type as its allocator");



      typedef _Deque_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef typename _Base::_Alloc_traits _Alloc_traits;
      typedef typename _Base::_Map_pointer _Map_pointer;

    public:
      typedef _Tp value_type;
      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Base::iterator iterator;
      typedef typename _Base::const_iterator const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    private:
      static size_t _S_buffer_size() noexcept
      { return __deque_buf_size(sizeof(_Tp)); }


      using _Base::_M_initialize_map;
      using _Base::_M_create_nodes;
      using _Base::_M_destroy_nodes;
      using _Base::_M_allocate_node;
      using _Base::_M_deallocate_node;
      using _Base::_M_allocate_map;
      using _Base::_M_deallocate_map;
      using _Base::_M_get_Tp_allocator;





      using _Base::_M_impl;

    public:







      deque() = default;
# 821 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      explicit
      deque(const allocator_type& __a)
      : _Base(__a, 0) { }
# 834 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      explicit
      deque(size_type __n, const allocator_type& __a = allocator_type())
      : _Base(__a, _S_check_init_len(__n, __a))
      { _M_default_initialize(); }
# 847 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      deque(size_type __n, const value_type& __value,
     const allocator_type& __a = allocator_type())
      : _Base(__a, _S_check_init_len(__n, __a))
      { _M_fill_initialize(__value); }
# 874 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      deque(const deque& __x)
      : _Base(_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()),
       __x.size())
      { std::__uninitialized_copy_a(__x.begin(), __x.end(),
        this->_M_impl._M_start,
        _M_get_Tp_allocator()); }
# 890 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      deque(deque&&) = default;


      deque(const deque& __x, const allocator_type& __a)
      : _Base(__a, __x.size())
      { std::__uninitialized_copy_a(__x.begin(), __x.end(),
        this->_M_impl._M_start,
        _M_get_Tp_allocator()); }


      deque(deque&& __x, const allocator_type& __a)
      : deque(std::move(__x), __a, typename _Alloc_traits::is_always_equal{})
      { }

    private:
      deque(deque&& __x, const allocator_type& __a, true_type)
      : _Base(std::move(__x), __a)
      { }

      deque(deque&& __x, const allocator_type& __a, false_type)
      : _Base(std::move(__x), __a, __x.size())
      {
 if (__x.get_allocator() != __a && !__x.empty())
   {
     std::__uninitialized_move_a(__x.begin(), __x.end(),
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
     __x.clear();
   }
      }

    public:
# 933 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      deque(initializer_list<value_type> __l,
     const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_range_initialize(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }
# 958 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 deque(_InputIterator __first, _InputIterator __last,
       const allocator_type& __a = allocator_type())
 : _Base(__a)
 {
   _M_range_initialize(__first, __last,
         std::__iterator_category(__first));
 }
# 984 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      ~deque()
      { _M_destroy_data(begin(), end(), _M_get_Tp_allocator()); }
# 996 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      deque&
      operator=(const deque& __x);
# 1008 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      deque&
      operator=(deque&& __x) noexcept(_Alloc_traits::_S_always_equal())
      {
 using __always_equal = typename _Alloc_traits::is_always_equal;
 _M_move_assign1(std::move(__x), __always_equal{});
 return *this;
      }
# 1027 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      deque&
      operator=(initializer_list<value_type> __l)
      {
 _M_assign_aux(__l.begin(), __l.end(),
        random_access_iterator_tag());
 return *this;
      }
# 1046 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 1063 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 void
 assign(_InputIterator __first, _InputIterator __last)
 { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }
# 1090 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      void
      assign(initializer_list<value_type> __l)
      { _M_assign_aux(__l.begin(), __l.end(), random_access_iterator_tag()); }



      allocator_type
      get_allocator() const noexcept
      { return _Base::get_allocator(); }






      iterator
      begin() noexcept
      { return this->_M_impl._M_start; }





      const_iterator
      begin() const noexcept
      { return this->_M_impl._M_start; }






      iterator
      end() noexcept
      { return this->_M_impl._M_finish; }






      const_iterator
      end() const noexcept
      { return this->_M_impl._M_finish; }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(this->_M_impl._M_start); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(this->_M_impl._M_start); }






      const_iterator
      cbegin() const noexcept
      { return this->_M_impl._M_start; }






      const_iterator
      cend() const noexcept
      { return this->_M_impl._M_finish; }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->_M_impl._M_start); }




      size_type
      size() const noexcept
      { return this->_M_impl._M_finish - this->_M_impl._M_start; }


      size_type
      max_size() const noexcept
      { return _S_max_size(_M_get_Tp_allocator()); }
# 1229 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      void
      resize(size_type __new_size)
      {
 const size_type __len = size();
 if (__new_size > __len)
   _M_default_append(__new_size - __len);
 else if (__new_size < __len)
   _M_erase_at_end(this->_M_impl._M_start
     + difference_type(__new_size));
      }
# 1251 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      void
      resize(size_type __new_size, const value_type& __x)
# 1268 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      {
 const size_type __len = size();
 if (__new_size > __len)
   _M_fill_insert(this->_M_impl._M_finish, __new_size - __len, __x);
 else if (__new_size < __len)
   _M_erase_at_end(this->_M_impl._M_start
     + difference_type(__new_size));
      }



      void
      shrink_to_fit() noexcept
      { _M_shrink_to_fit(); }






      [[__nodiscard__]] bool
      empty() const noexcept
      { return this->_M_impl._M_finish == this->_M_impl._M_start; }
# 1304 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      reference
      operator[](size_type __n) noexcept
      {
 ;
 return this->_M_impl._M_start[difference_type(__n)];
      }
# 1322 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      const_reference
      operator[](size_type __n) const noexcept
      {
 ;
 return this->_M_impl._M_start[difference_type(__n)];
      }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("deque::_M_range_check: __n " "(which is %zu)>= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
      }

    public:
# 1353 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 1371 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front() noexcept
      {
 ;
 return *begin();
      }





      const_reference
      front() const noexcept
      {
 ;
 return *begin();
      }





      reference
      back() noexcept
      {
 ;
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }





      const_reference
      back() const noexcept
      {
 ;
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
# 1436 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      void
      push_front(const value_type& __x)
      {
 if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
   {
     _Alloc_traits::construct(this->_M_impl,
         this->_M_impl._M_start._M_cur - 1,
         __x);
     --this->_M_impl._M_start._M_cur;
   }
 else
   _M_push_front_aux(__x);
      }


      void
      push_front(value_type&& __x)
      { emplace_front(std::move(__x)); }

      template<typename... _Args>

 reference



 emplace_front(_Args&&... __args);
# 1473 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_last - 1)
   {
     _Alloc_traits::construct(this->_M_impl,
         this->_M_impl._M_finish._M_cur, __x);
     ++this->_M_impl._M_finish._M_cur;
   }
 else
   _M_push_back_aux(__x);
      }


      void
      push_back(value_type&& __x)
      { emplace_back(std::move(__x)); }

      template<typename... _Args>

 reference



 emplace_back(_Args&&... __args);
# 1509 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      void
      pop_front() noexcept
      {
 ;
 if (this->_M_impl._M_start._M_cur
     != this->_M_impl._M_start._M_last - 1)
   {
     _Alloc_traits::destroy(_M_get_Tp_allocator(),
       this->_M_impl._M_start._M_cur);
     ++this->_M_impl._M_start._M_cur;
   }
 else
   _M_pop_front_aux();
      }
# 1532 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      void
      pop_back() noexcept
      {
 ;
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_first)
   {
     --this->_M_impl._M_finish._M_cur;
     _Alloc_traits::destroy(_M_get_Tp_allocator(),
       this->_M_impl._M_finish._M_cur);
   }
 else
   _M_pop_back_aux();
      }
# 1557 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      template<typename... _Args>
 iterator
 emplace(const_iterator __position, _Args&&... __args);
# 1570 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x);
# 1596 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      iterator
      insert(const_iterator __position, value_type&& __x)
      { return emplace(__position, std::move(__x)); }
# 1610 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      iterator
      insert(const_iterator __p, initializer_list<value_type> __l)
      {
 auto __offset = __p - cbegin();
 _M_range_insert_aux(__p._M_const_cast(), __l.begin(), __l.end(),
       std::random_access_iterator_tag());
 return begin() + __offset;
      }
# 1629 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      iterator
      insert(const_iterator __position, size_type __n, const value_type& __x)
      {
 difference_type __offset = __position - cbegin();
 _M_fill_insert(__position._M_const_cast(), __n, __x);
 return begin() + __offset;
      }
# 1663 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
 insert(const_iterator __position, _InputIterator __first,
        _InputIterator __last)
 {
   difference_type __offset = __position - cbegin();
   _M_range_insert_aux(__position._M_const_cast(), __first, __last,
         std::__iterator_category(__first));
   return begin() + __offset;
 }
# 1709 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      iterator

      erase(const_iterator __position)



      { return _M_erase(__position._M_const_cast()); }
# 1733 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      iterator

      erase(const_iterator __first, const_iterator __last)



      { return _M_erase(__first._M_const_cast(), __last._M_const_cast()); }
# 1752 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      void
      swap(deque& __x) noexcept
      {


                                                          ;

 _M_impl._M_swap_data(__x._M_impl);
 _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
      __x._M_get_Tp_allocator());
      }







      void
      clear() noexcept
      { _M_erase_at_end(begin()); }

    protected:
# 1802 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      static size_t
      _S_check_init_len(size_t __n, const allocator_type& __a)
      {
 if (__n > _S_max_size(__a))
   __throw_length_error(
       ("cannot create std::deque larger than max_size()"));
 return __n;
      }

      static size_type
      _S_max_size(const _Tp_alloc_type& __a) noexcept
      {
 const size_t __diffmax = __gnu_cxx::__numeric_traits<ptrdiff_t>::__max;
 const size_t __allocmax = _Alloc_traits::max_size(__a);
 return (std::min)(__diffmax, __allocmax);
      }
# 1831 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      template<typename _InputIterator>
 void
 _M_range_initialize(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag);


      template<typename _ForwardIterator>
 void
 _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag);
# 1853 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      void
      _M_fill_initialize(const value_type& __value);



      void
      _M_default_initialize();
# 1884 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      template<typename _InputIterator>
 void
 _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
 void
 _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag)
 {
   const size_type __len = std::distance(__first, __last);
   if (__len > size())
     {
       _ForwardIterator __mid = __first;
       std::advance(__mid, size());
       std::copy(__first, __mid, begin());
       _M_range_insert_aux(end(), __mid, __last,
      std::__iterator_category(__first));
     }
   else
     _M_erase_at_end(std::copy(__first, __last, begin()));
 }



      void
      _M_fill_assign(size_type __n, const value_type& __val)
      {
 if (__n > size())
   {
     std::fill(begin(), end(), __val);
     _M_fill_insert(end(), __n - size(), __val);
   }
 else
   {
     _M_erase_at_end(begin() + difference_type(__n));
     std::fill(begin(), end(), __val);
   }
      }
# 1932 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      template<typename... _Args>
 void _M_push_back_aux(_Args&&... __args);

      template<typename... _Args>
 void _M_push_front_aux(_Args&&... __args);


      void _M_pop_back_aux();

      void _M_pop_front_aux();
# 1971 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      template<typename _InputIterator>
 void
 _M_range_insert_aux(iterator __pos, _InputIterator __first,
       _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
 void
 _M_range_insert_aux(iterator __pos, _ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag);




      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);






      template<typename... _Args>
 iterator
 _M_insert_aux(iterator __pos, _Args&&... __args);



      void
      _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);


      template<typename _ForwardIterator>
 void
 _M_insert_aux(iterator __pos,
        _ForwardIterator __first, _ForwardIterator __last,
        size_type __n);




      void
      _M_destroy_data_aux(iterator __first, iterator __last);



      template<typename _Alloc1>
 void
 _M_destroy_data(iterator __first, iterator __last, const _Alloc1&)
 { _M_destroy_data_aux(__first, __last); }

      void
      _M_destroy_data(iterator __first, iterator __last,
        const std::allocator<_Tp>&)
      {
 if (!__has_trivial_destructor(value_type))
   _M_destroy_data_aux(__first, __last);
      }


      void
      _M_erase_at_begin(iterator __pos)
      {
 _M_destroy_data(begin(), __pos, _M_get_Tp_allocator());
 _M_destroy_nodes(this->_M_impl._M_start._M_node, __pos._M_node);
 this->_M_impl._M_start = __pos;
      }



      void
      _M_erase_at_end(iterator __pos)
      {
 _M_destroy_data(__pos, end(), _M_get_Tp_allocator());
 _M_destroy_nodes(__pos._M_node + 1,
    this->_M_impl._M_finish._M_node + 1);
 this->_M_impl._M_finish = __pos;
      }

      iterator
      _M_erase(iterator __pos);

      iterator
      _M_erase(iterator __first, iterator __last);



      void
      _M_default_append(size_type __n);

      bool
      _M_shrink_to_fit();




      iterator
      _M_reserve_elements_at_front(size_type __n)
      {
 const size_type __vacancies = this->_M_impl._M_start._M_cur
          - this->_M_impl._M_start._M_first;
 if (__n > __vacancies)
   _M_new_elements_at_front(__n - __vacancies);
 return this->_M_impl._M_start - difference_type(__n);
      }

      iterator
      _M_reserve_elements_at_back(size_type __n)
      {
 const size_type __vacancies = (this->_M_impl._M_finish._M_last
           - this->_M_impl._M_finish._M_cur) - 1;
 if (__n > __vacancies)
   _M_new_elements_at_back(__n - __vacancies);
 return this->_M_impl._M_finish + difference_type(__n);
      }

      void
      _M_new_elements_at_front(size_type __new_elements);

      void
      _M_new_elements_at_back(size_type __new_elements);
# 2103 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
      void
      _M_reserve_map_at_back(size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add + 1 > this->_M_impl._M_map_size
     - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, false);
      }

      void
      _M_reserve_map_at_front(size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add > size_type(this->_M_impl._M_start._M_node
           - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, true);
      }

      void
      _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);





      void
      _M_move_assign1(deque&& __x, true_type) noexcept
      {
 this->_M_impl._M_swap_data(__x._M_impl);
 __x.clear();
 std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
      }




      void
      _M_move_assign1(deque&& __x, false_type)
      {
 constexpr bool __move_storage =
   _Alloc_traits::_S_propagate_on_move_assign();
 _M_move_assign2(std::move(__x), __bool_constant<__move_storage>());
      }



      template<typename... _Args>
      void
      _M_replace_map(_Args&&... __args)
      {

 deque __newobj(std::forward<_Args>(__args)...);

 clear();
 _M_deallocate_node(*begin()._M_node);
 _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
 this->_M_impl._M_map = nullptr;
 this->_M_impl._M_map_size = 0;

 this->_M_impl._M_swap_data(__newobj._M_impl);
      }


      void
      _M_move_assign2(deque&& __x, true_type)
      {

 auto __alloc = __x._M_get_Tp_allocator();


 _M_replace_map(std::move(__x));

 _M_get_Tp_allocator() = std::move(__alloc);
      }



      void
      _M_move_assign2(deque&& __x, false_type)
      {
 if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
   {


     _M_replace_map(std::move(__x), __x.get_allocator());
   }
 else
   {


     _M_assign_aux(std::make_move_iterator(__x.begin()),
     std::make_move_iterator(__x.end()),
     std::random_access_iterator_tag());
     __x.clear();
   }
      }

    };


  template<typename _InputIterator, typename _ValT
      = typename iterator_traits<_InputIterator>::value_type,
    typename _Allocator = allocator<_ValT>,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireAllocator<_Allocator>>
    deque(_InputIterator, _InputIterator, _Allocator = _Allocator())
      -> deque<_ValT, _Allocator>;
# 2220 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const deque<_Tp, _Alloc>& __x, const deque<_Tp, _Alloc>& __y)
    { return __x.size() == __y.size()
      && std::equal(__x.begin(), __x.end(), __y.begin()); }
# 2237 "/usr/local/include/c++/10.0.0/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const deque<_Tp, _Alloc>& __x, const deque<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const deque<_Tp, _Alloc>& __x, const deque<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const deque<_Tp, _Alloc>& __x, const deque<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const deque<_Tp, _Alloc>& __x, const deque<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const deque<_Tp, _Alloc>& __x, const deque<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }








  template<class _Tp>
    struct __is_bitwise_relocatable<std::deque<_Tp>>
    : true_type { };



}
# 68 "/usr/local/include/c++/10.0.0/deque" 2 3

# 1 "/usr/local/include/c++/10.0.0/bits/deque.tcc" 1 3
# 61 "/usr/local/include/c++/10.0.0/bits/deque.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{




  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_default_initialize()
    {
      _Map_pointer __cur;
      try
 {
   for (__cur = this->_M_impl._M_start._M_node;
        __cur < this->_M_impl._M_finish._M_node;
        ++__cur)
     std::__uninitialized_default_a(*__cur, *__cur + _S_buffer_size(),
        _M_get_Tp_allocator());
   std::__uninitialized_default_a(this->_M_impl._M_finish._M_first,
      this->_M_impl._M_finish._M_cur,
      _M_get_Tp_allocator());
 }
      catch(...)
 {
   std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),
   _M_get_Tp_allocator());
   throw;
 }
    }


  template <typename _Tp, typename _Alloc>
    deque<_Tp, _Alloc>&
    deque<_Tp, _Alloc>::
    operator=(const deque& __x)
    {
      if (&__x != this)
 {

   if (_Alloc_traits::_S_propagate_on_copy_assign())
     {
       if (!_Alloc_traits::_S_always_equal()
    && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
  {


    _M_replace_map(__x, __x.get_allocator());
    std::__alloc_on_copy(_M_get_Tp_allocator(),
           __x._M_get_Tp_allocator());
    return *this;
  }
       std::__alloc_on_copy(_M_get_Tp_allocator(),
       __x._M_get_Tp_allocator());
     }

   const size_type __len = size();
   if (__len >= __x.size())
     _M_erase_at_end(std::copy(__x.begin(), __x.end(),
          this->_M_impl._M_start));
   else
     {
       const_iterator __mid = __x.begin() + difference_type(__len);
       std::copy(__x.begin(), __mid, this->_M_impl._M_start);
       _M_range_insert_aux(this->_M_impl._M_finish, __mid, __x.end(),
      std::random_access_iterator_tag());
     }
 }
      return *this;
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>

      typename deque<_Tp, _Alloc>::reference



      deque<_Tp, _Alloc>::
      emplace_front(_Args&&... __args)
      {
 if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
   {
     _Alloc_traits::construct(this->_M_impl,
         this->_M_impl._M_start._M_cur - 1,
         std::forward<_Args>(__args)...);
     --this->_M_impl._M_start._M_cur;
   }
 else
   _M_push_front_aux(std::forward<_Args>(__args)...);

 return front();

      }

  template<typename _Tp, typename _Alloc>
    template<typename... _Args>

      typename deque<_Tp, _Alloc>::reference



      deque<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_last - 1)
   {
     _Alloc_traits::construct(this->_M_impl,
         this->_M_impl._M_finish._M_cur,
         std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish._M_cur;
   }
 else
   _M_push_back_aux(std::forward<_Args>(__args)...);

 return back();

      }



  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      typename deque<_Tp, _Alloc>::iterator
      deque<_Tp, _Alloc>::
      emplace(const_iterator __position, _Args&&... __args)
      {
 if (__position._M_cur == this->_M_impl._M_start._M_cur)
   {
     emplace_front(std::forward<_Args>(__args)...);
     return this->_M_impl._M_start;
   }
 else if (__position._M_cur == this->_M_impl._M_finish._M_cur)
   {
     emplace_back(std::forward<_Args>(__args)...);
     iterator __tmp = this->_M_impl._M_finish;
     --__tmp;
     return __tmp;
   }
 else
   return _M_insert_aux(__position._M_const_cast(),
          std::forward<_Args>(__args)...);
      }


  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::

    insert(const_iterator __position, const value_type& __x)



    {
      if (__position._M_cur == this->_M_impl._M_start._M_cur)
 {
   push_front(__x);
   return this->_M_impl._M_start;
 }
      else if (__position._M_cur == this->_M_impl._M_finish._M_cur)
 {
   push_back(__x);
   iterator __tmp = this->_M_impl._M_finish;
   --__tmp;
   return __tmp;
 }
      else
 return _M_insert_aux(__position._M_const_cast(), __x);
   }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    _M_erase(iterator __position)
    {
      iterator __next = __position;
      ++__next;
      const difference_type __index = __position - begin();
      if (static_cast<size_type>(__index) < (size() >> 1))
 {
   if (__position != begin())
     std::move_backward(begin(), __position, __next);
   pop_front();
 }
      else
 {
   if (__next != end())
     std::move(__next, end(), __position);
   pop_back();
 }
      return begin() + __index;
    }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first == __last)
 return __first;
      else if (__first == begin() && __last == end())
 {
   clear();
   return end();
 }
      else
 {
   const difference_type __n = __last - __first;
   const difference_type __elems_before = __first - begin();
   if (static_cast<size_type>(__elems_before) <= (size() - __n) / 2)
     {
       if (__first != begin())
  std::move_backward(begin(), __first, __last);
       _M_erase_at_begin(begin() + __n);
     }
   else
     {
       if (__last != end())
  std::move(__last, end(), __first);
       _M_erase_at_end(end() - __n);
     }
   return begin() + __elems_before;
 }
    }

  template <typename _Tp, class _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 iterator __cur = begin();
 for (; __first != __last && __cur != end(); ++__cur, (void)++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   _M_range_insert_aux(end(), __first, __last,
         std::__iterator_category(__first));
      }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)
    {
      if (__pos._M_cur == this->_M_impl._M_start._M_cur)
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   try
     {
       std::__uninitialized_fill_a(__new_start, this->_M_impl._M_start,
       __x, _M_get_Tp_allocator());
       this->_M_impl._M_start = __new_start;
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   try
     {
       std::__uninitialized_fill_a(this->_M_impl._M_finish,
       __new_finish, __x,
       _M_get_Tp_allocator());
       this->_M_impl._M_finish = __new_finish;
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
      else
 _M_insert_aux(__pos, __n, __x);
    }


  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_default_append(size_type __n)
    {
      if (__n)
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   try
     {
       std::__uninitialized_default_a(this->_M_impl._M_finish,
          __new_finish,
          _M_get_Tp_allocator());
       this->_M_impl._M_finish = __new_finish;
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
    }

  template <typename _Tp, typename _Alloc>
    bool
    deque<_Tp, _Alloc>::
    _M_shrink_to_fit()
    {
      const difference_type __front_capacity
 = (this->_M_impl._M_start._M_cur - this->_M_impl._M_start._M_first);
      if (__front_capacity == 0)
 return false;

      const difference_type __back_capacity
 = (this->_M_impl._M_finish._M_last - this->_M_impl._M_finish._M_cur);
      if (__front_capacity + __back_capacity < _S_buffer_size())
 return false;

      return std::__shrink_to_fit_aux<deque>::_S_do_it(*this);
    }


  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_initialize(const value_type& __value)
    {
      _Map_pointer __cur;
      try
 {
   for (__cur = this->_M_impl._M_start._M_node;
        __cur < this->_M_impl._M_finish._M_node;
        ++__cur)
     std::__uninitialized_fill_a(*__cur, *__cur + _S_buffer_size(),
     __value, _M_get_Tp_allocator());
   std::__uninitialized_fill_a(this->_M_impl._M_finish._M_first,
          this->_M_impl._M_finish._M_cur,
          __value, _M_get_Tp_allocator());
 }
      catch(...)
 {
   std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),
   _M_get_Tp_allocator());
   throw;
 }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_InputIterator __first, _InputIterator __last,
     std::input_iterator_tag)
      {
 this->_M_initialize_map(0);
 try
   {
     for (; __first != __last; ++__first)

       emplace_back(*__first);



   }
 catch(...)
   {
     clear();
     throw;
   }
      }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
     std::forward_iterator_tag)
      {
 const size_type __n = std::distance(__first, __last);
 this->_M_initialize_map(_S_check_init_len(__n, _M_get_Tp_allocator()));

 _Map_pointer __cur_node;
 try
   {
     for (__cur_node = this->_M_impl._M_start._M_node;
   __cur_node < this->_M_impl._M_finish._M_node;
   ++__cur_node)
       {
  _ForwardIterator __mid = __first;
  std::advance(__mid, _S_buffer_size());
  std::__uninitialized_copy_a(__first, __mid, *__cur_node,
         _M_get_Tp_allocator());
  __first = __mid;
       }
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_finish._M_first,
     _M_get_Tp_allocator());
   }
 catch(...)
   {
     std::_Destroy(this->_M_impl._M_start,
     iterator(*__cur_node, __cur_node),
     _M_get_Tp_allocator());
     throw;
   }
      }


  template<typename _Tp, typename _Alloc>

    template<typename... _Args>
      void
      deque<_Tp, _Alloc>::
      _M_push_back_aux(_Args&&... __args)





      {
 if (size() == max_size())
   __throw_length_error(
       ("cannot create std::deque larger than max_size()"));

 _M_reserve_map_at_back();
 *(this->_M_impl._M_finish._M_node + 1) = this->_M_allocate_node();
 try
   {

     _Alloc_traits::construct(this->_M_impl,
         this->_M_impl._M_finish._M_cur,
         std::forward<_Args>(__args)...);



     this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node
      + 1);
     this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_first;
   }
 catch(...)
   {
     _M_deallocate_node(*(this->_M_impl._M_finish._M_node + 1));
     throw;
   }
      }


  template<typename _Tp, typename _Alloc>

    template<typename... _Args>
      void
      deque<_Tp, _Alloc>::
      _M_push_front_aux(_Args&&... __args)





      {
 if (size() == max_size())
   __throw_length_error(
       ("cannot create std::deque larger than max_size()"));

 _M_reserve_map_at_front();
 *(this->_M_impl._M_start._M_node - 1) = this->_M_allocate_node();
 try
   {
     this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node
            - 1);
     this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_last - 1;

     _Alloc_traits::construct(this->_M_impl,
         this->_M_impl._M_start._M_cur,
         std::forward<_Args>(__args)...);



   }
 catch(...)
   {
     ++this->_M_impl._M_start;
     _M_deallocate_node(*(this->_M_impl._M_start._M_node - 1));
     throw;
   }
      }


  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_back_aux()
    {
      _M_deallocate_node(this->_M_impl._M_finish._M_first);
      this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node - 1);
      this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_last - 1;
      _Alloc_traits::destroy(_M_get_Tp_allocator(),
        this->_M_impl._M_finish._M_cur);
    }






  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_front_aux()
    {
      _Alloc_traits::destroy(_M_get_Tp_allocator(),
        this->_M_impl._M_start._M_cur);
      _M_deallocate_node(this->_M_impl._M_start._M_first);
      this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node + 1);
      this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_first;
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
     _InputIterator __first, _InputIterator __last,
     std::input_iterator_tag)
      { std::copy(__first, __last, std::inserter(*this, __pos)); }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
     _ForwardIterator __first, _ForwardIterator __last,
     std::forward_iterator_tag)
      {
 const size_type __n = std::distance(__first, __last);
 if (__pos._M_cur == this->_M_impl._M_start._M_cur)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last, __new_start,
         _M_get_Tp_allocator());
  this->_M_impl._M_start = __new_start;
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
 else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
   {
     iterator __new_finish = _M_reserve_elements_at_back(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last,
         this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  this->_M_impl._M_finish = __new_finish;
       }
     catch(...)
       {
  _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
     __new_finish._M_node + 1);
  throw;
       }
   }
 else
   _M_insert_aux(__pos, __first, __last, __n);
      }

  template<typename _Tp, typename _Alloc>

    template<typename... _Args>
      typename deque<_Tp, _Alloc>::iterator
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos, _Args&&... __args)
      {
 value_type __x_copy(std::forward<_Args>(__args)...);







 difference_type __index = __pos - this->_M_impl._M_start;
 if (static_cast<size_type>(__index) < size() / 2)
   {
     push_front(std::move(front()));
     iterator __front1 = this->_M_impl._M_start;
     ++__front1;
     iterator __front2 = __front1;
     ++__front2;
     __pos = this->_M_impl._M_start + __index;
     iterator __pos1 = __pos;
     ++__pos1;
     std::move(__front2, __pos1, __front1);
   }
 else
   {
     push_back(std::move(back()));
     iterator __back1 = this->_M_impl._M_finish;
     --__back1;
     iterator __back2 = __back1;
     --__back2;
     __pos = this->_M_impl._M_start + __index;
     std::move_backward(__pos, __back2, __back1);
   }
 *__pos = std::move(__x_copy);
 return __pos;
      }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_insert_aux(iterator __pos, size_type __n, const value_type& __x)
    {
      const difference_type __elems_before = __pos - this->_M_impl._M_start;
      const size_type __length = this->size();
      value_type __x_copy = __x;
      if (__elems_before < difference_type(__length / 2))
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   iterator __old_start = this->_M_impl._M_start;
   __pos = this->_M_impl._M_start + __elems_before;
   try
     {
       if (__elems_before >= difference_type(__n))
  {
    iterator __start_n = (this->_M_impl._M_start
     + difference_type(__n));
    std::__uninitialized_move_a(this->_M_impl._M_start,
           __start_n, __new_start,
           _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::move(__start_n, __pos, __old_start);
    std::fill(__pos - difference_type(__n), __pos, __x_copy);
  }
       else
  {
    std::__uninitialized_move_fill(this->_M_impl._M_start,
       __pos, __new_start,
       this->_M_impl._M_start,
       __x_copy,
       _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::fill(__old_start, __pos, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   iterator __old_finish = this->_M_impl._M_finish;
   const difference_type __elems_after =
     difference_type(__length) - __elems_before;
   __pos = this->_M_impl._M_finish - __elems_after;
   try
     {
       if (__elems_after > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_move_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::move_backward(__pos, __finish_n, __old_finish);
    std::fill(__pos, __pos + difference_type(__n), __x_copy);
  }
       else
  {
    std::__uninitialized_fill_move(this->_M_impl._M_finish,
       __pos + difference_type(__n),
       __x_copy, __pos,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::fill(__pos, __old_finish, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos,
      _ForwardIterator __first, _ForwardIterator __last,
      size_type __n)
      {
 const difference_type __elemsbefore = __pos - this->_M_impl._M_start;
 const size_type __length = size();
 if (static_cast<size_type>(__elemsbefore) < __length / 2)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     iterator __old_start = this->_M_impl._M_start;
     __pos = this->_M_impl._M_start + __elemsbefore;
     try
       {
  if (__elemsbefore >= difference_type(__n))
    {
      iterator __start_n = (this->_M_impl._M_start
       + difference_type(__n));
      std::__uninitialized_move_a(this->_M_impl._M_start,
      __start_n, __new_start,
      _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::move(__start_n, __pos, __old_start);
      std::copy(__first, __last, __pos - difference_type(__n));
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, difference_type(__n) - __elemsbefore);
      std::__uninitialized_move_copy(this->_M_impl._M_start,
         __pos, __first, __mid,
         __new_start,
         _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::copy(__mid, __last, __old_start);
    }
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
 else
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   iterator __old_finish = this->_M_impl._M_finish;
   const difference_type __elemsafter =
     difference_type(__length) - __elemsbefore;
   __pos = this->_M_impl._M_finish - __elemsafter;
   try
     {
       if (__elemsafter > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_move_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::move_backward(__pos, __finish_n, __old_finish);
    std::copy(__first, __last, __pos);
  }
       else
  {
    _ForwardIterator __mid = __first;
    std::advance(__mid, __elemsafter);
    std::__uninitialized_copy_move(__mid, __last, __pos,
       this->_M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy(__first, __mid, __pos);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
      }

   template<typename _Tp, typename _Alloc>
     void
     deque<_Tp, _Alloc>::
     _M_destroy_data_aux(iterator __first, iterator __last)
     {
       for (_Map_pointer __node = __first._M_node + 1;
     __node < __last._M_node; ++__node)
  std::_Destroy(*__node, *__node + _S_buffer_size(),
         _M_get_Tp_allocator());

       if (__first._M_node != __last._M_node)
  {
    std::_Destroy(__first._M_cur, __first._M_last,
    _M_get_Tp_allocator());
    std::_Destroy(__last._M_first, __last._M_cur,
    _M_get_Tp_allocator());
  }
       else
  std::_Destroy(__first._M_cur, __last._M_cur,
         _M_get_Tp_allocator());
     }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_front(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
 __throw_length_error(("deque::_M_new_elements_at_front"));

      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
         / _S_buffer_size());
      _M_reserve_map_at_front(__new_nodes);
      size_type __i;
      try
 {
   for (__i = 1; __i <= __new_nodes; ++__i)
     *(this->_M_impl._M_start._M_node - __i) = this->_M_allocate_node();
 }
      catch(...)
 {
   for (size_type __j = 1; __j < __i; ++__j)
     _M_deallocate_node(*(this->_M_impl._M_start._M_node - __j));
   throw;
 }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_back(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
 __throw_length_error(("deque::_M_new_elements_at_back"));

      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
         / _S_buffer_size());
      _M_reserve_map_at_back(__new_nodes);
      size_type __i;
      try
 {
   for (__i = 1; __i <= __new_nodes; ++__i)
     *(this->_M_impl._M_finish._M_node + __i) = this->_M_allocate_node();
 }
      catch(...)
 {
   for (size_type __j = 1; __j < __i; ++__j)
     _M_deallocate_node(*(this->_M_impl._M_finish._M_node + __j));
   throw;
 }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)
    {
      const size_type __old_num_nodes
 = this->_M_impl._M_finish._M_node - this->_M_impl._M_start._M_node + 1;
      const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;

      _Map_pointer __new_nstart;
      if (this->_M_impl._M_map_size > 2 * __new_num_nodes)
 {
   __new_nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size
      - __new_num_nodes) / 2
    + (__add_at_front ? __nodes_to_add : 0);
   if (__new_nstart < this->_M_impl._M_start._M_node)
     std::copy(this->_M_impl._M_start._M_node,
        this->_M_impl._M_finish._M_node + 1,
        __new_nstart);
   else
     std::copy_backward(this->_M_impl._M_start._M_node,
          this->_M_impl._M_finish._M_node + 1,
          __new_nstart + __old_num_nodes);
 }
      else
 {
   size_type __new_map_size = this->_M_impl._M_map_size
         + std::max(this->_M_impl._M_map_size,
      __nodes_to_add) + 2;

   _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);
   __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
    + (__add_at_front ? __nodes_to_add : 0);
   std::copy(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1,
      __new_nstart);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);

   this->_M_impl._M_map = __new_map;
   this->_M_impl._M_map_size = __new_map_size;
 }

      this->_M_impl._M_start._M_set_node(__new_nstart);
      this->_M_impl._M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
    }





  template<typename _Tp, typename _VTp>
    void
    __fill_a1(const std::_Deque_iterator<_Tp, _Tp&, _Tp*>& __first,
       const std::_Deque_iterator<_Tp, _Tp&, _Tp*>& __last,
       const _VTp& __value)
    {
      typedef std::_Deque_iterator<_Tp, _Tp&, _Tp*> _Iter;
      if (__first._M_node != __last._M_node)
 {
   std::__fill_a1(__first._M_cur, __first._M_last, __value);

   for (typename _Iter::_Map_pointer __node = __first._M_node + 1;
        __node < __last._M_node; ++__node)
     std::__fill_a1(*__node, *__node + _Iter::_S_buffer_size(), __value);

   std::__fill_a1(__last._M_first, __last._M_cur, __value);
 }
      else
 std::__fill_a1(__first._M_cur, __last._M_cur, __value);
    }

  template<bool _IsMove,
    typename _Tp, typename _Ref, typename _Ptr, typename _OI>
    _OI
    __copy_move_dit(std::_Deque_iterator<_Tp, _Ref, _Ptr> __first,
      std::_Deque_iterator<_Tp, _Ref, _Ptr> __last,
      _OI __result)
    {
      typedef std::_Deque_iterator<_Tp, _Ref, _Ptr> _Iter;
      if (__first._M_node != __last._M_node)
 {
   __result
     = std::__copy_move_a1<_IsMove>(__first._M_cur, __first._M_last,
        __result);

   for (typename _Iter::_Map_pointer __node = __first._M_node + 1;
        __node != __last._M_node; ++__node)
     __result
       = std::__copy_move_a1<_IsMove>(*__node,
          *__node + _Iter::_S_buffer_size(),
          __result);

   return std::__copy_move_a1<_IsMove>(__last._M_first, __last._M_cur,
           __result);
 }

      return std::__copy_move_a1<_IsMove>(__first._M_cur, __last._M_cur,
       __result);
    }

  template<bool _IsMove,
    typename _Tp, typename _Ref, typename _Ptr, typename _OI>
    _OI
    __copy_move_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr> __first,
     std::_Deque_iterator<_Tp, _Ref, _Ptr> __last,
     _OI __result)
    { return __copy_move_dit<_IsMove>(__first, __last, __result); }

  template<bool _IsMove,
    typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
    std::_Deque_iterator<_OTp, _OTp&, _OTp*>
    __copy_move_a1(std::_Deque_iterator<_ITp, _IRef, _IPtr> __first,
     std::_Deque_iterator<_ITp, _IRef, _IPtr> __last,
     std::_Deque_iterator<_OTp, _OTp&, _OTp*> __result)
    { return __copy_move_dit<_IsMove>(__first, __last, __result); }

  template<bool _IsMove, typename _II, typename _Tp>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value,
      std::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
    __copy_move_a1(_II __first, _II __last,
     std::_Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef std::_Deque_iterator<_Tp, _Tp&, _Tp*> _Iter;
      typedef typename _Iter::difference_type difference_type;

      difference_type __len = __last - __first;
      while (__len > 0)
 {
   const difference_type __clen
     = std::min(__len, __result._M_last - __result._M_cur);
   std::__copy_move_a1<_IsMove>(__first, __first + __clen,
           __result._M_cur);

   __first += __clen;
   __result += __clen;
   __len -= __clen;
 }

      return __result;
    }

  template<bool _IsMove,
    typename _Tp, typename _Ref, typename _Ptr, typename _OI>
    _OI
    __copy_move_backward_dit(
  std::_Deque_iterator<_Tp, _Ref, _Ptr> __first,
  std::_Deque_iterator<_Tp, _Ref, _Ptr> __last,
  _OI __result)
    {
      typedef std::_Deque_iterator<_Tp, _Ref, _Ptr> _Iter;
      if (__first._M_node != __last._M_node)
 {
   __result = std::__copy_move_backward_a1<_IsMove>(
  __last._M_first, __last._M_cur, __result);

   for (typename _Iter::_Map_pointer __node = __last._M_node - 1;
        __node != __first._M_node; --__node)
     __result = std::__copy_move_backward_a1<_IsMove>(
  *__node, *__node + _Iter::_S_buffer_size(), __result);

   return std::__copy_move_backward_a1<_IsMove>(
   __first._M_cur, __first._M_last, __result);
 }

      return std::__copy_move_backward_a1<_IsMove>(
  __first._M_cur, __last._M_cur, __result);
    }

  template<bool _IsMove,
    typename _Tp, typename _Ref, typename _Ptr, typename _OI>
    _OI
    __copy_move_backward_a1(
  std::_Deque_iterator<_Tp, _Ref, _Ptr> __first,
  std::_Deque_iterator<_Tp, _Ref, _Ptr> __last,
  _OI __result)
    { return __copy_move_backward_dit<_IsMove>(__first, __last, __result); }

  template<bool _IsMove,
    typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
    std::_Deque_iterator<_OTp, _OTp&, _OTp*>
    __copy_move_backward_a1(
  std::_Deque_iterator<_ITp, _IRef, _IPtr> __first,
  std::_Deque_iterator<_ITp, _IRef, _IPtr> __last,
  std::_Deque_iterator<_OTp, _OTp&, _OTp*> __result)
    { return __copy_move_backward_dit<_IsMove>(__first, __last, __result); }

  template<bool _IsMove, typename _II, typename _Tp>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value,
      std::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
    __copy_move_backward_a1(_II __first, _II __last,
  std::_Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef std::_Deque_iterator<_Tp, _Tp&, _Tp*> _Iter;
      typedef typename _Iter::difference_type difference_type;

      difference_type __len = __last - __first;
      while (__len > 0)
 {
   difference_type __rlen = __result._M_cur - __result._M_first;
   _Tp* __rend = __result._M_cur;
   if (!__rlen)
     {
       __rlen = _Iter::_S_buffer_size();
       __rend = *(__result._M_node - 1) + __rlen;
     }

   const difference_type __clen = std::min(__len, __rlen);
   std::__copy_move_backward_a1<_IsMove>(__last - __clen, __last, __rend);

   __last -= __clen;
   __result -= __clen;
   __len -= __clen;
 }

      return __result;
    }

  template<typename _Tp, typename _Ref, typename _Ptr, typename _II>
    bool
    __equal_dit(
 const std::_Deque_iterator<_Tp, _Ref, _Ptr>& __first1,
 const std::_Deque_iterator<_Tp, _Ref, _Ptr>& __last1,
 _II __first2)
    {
      typedef std::_Deque_iterator<_Tp, _Ref, _Ptr> _Iter;
      if (__first1._M_node != __last1._M_node)
 {
   if (!std::__equal_aux1(__first1._M_cur, __first1._M_last, __first2))
     return false;

   __first2 += __first1._M_last - __first1._M_cur;
   for (typename _Iter::_Map_pointer __node = __first1._M_node + 1;
        __node != __last1._M_node;
        __first2 += _Iter::_S_buffer_size(), ++__node)
     if (!std::__equal_aux1(*__node, *__node + _Iter::_S_buffer_size(),
      __first2))
       return false;

   return std::__equal_aux1(__last1._M_first, __last1._M_cur, __first2);
 }

      return std::__equal_aux1(__first1._M_cur, __last1._M_cur, __first2);
    }

  template<typename _Tp, typename _Ref, typename _Ptr, typename _II>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value, bool>::__type
    __equal_aux1(std::_Deque_iterator<_Tp, _Ref, _Ptr> __first1,
   std::_Deque_iterator<_Tp, _Ref, _Ptr> __last1,
   _II __first2)
    { return std::__equal_dit(__first1, __last1, __first2); }

  template<typename _Tp1, typename _Ref1, typename _Ptr1,
    typename _Tp2, typename _Ref2, typename _Ptr2>
    bool
    __equal_aux1(std::_Deque_iterator<_Tp1, _Ref1, _Ptr1> __first1,
   std::_Deque_iterator<_Tp1, _Ref1, _Ptr1> __last1,
   std::_Deque_iterator<_Tp2, _Ref2, _Ptr2> __first2)
    { return std::__equal_dit(__first1, __last1, __first2); }

  template<typename _II, typename _Tp, typename _Ref, typename _Ptr>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value, bool>::__type
    __equal_aux1(_II __first1, _II __last1,
  std::_Deque_iterator<_Tp, _Ref, _Ptr> __first2)
    {
      typedef std::_Deque_iterator<_Tp, _Ref, _Ptr> _Iter;
      typedef typename _Iter::difference_type difference_type;

      difference_type __len = __last1 - __first1;
      while (__len > 0)
 {
   const difference_type __clen
     = std::min(__len, __first2._M_last - __first2._M_cur);
   if (!std::__equal_aux1(__first1, __first1 + __clen, __first2._M_cur))
     return false;

   __first1 += __clen;
   __len -= __clen;
   __first2 += __clen;
 }

      return true;
    }


}
# 70 "/usr/local/include/c++/10.0.0/deque" 2 3






namespace std __attribute__ ((__visibility__ ("default")))
{

  namespace pmr
  {
    template<typename _Tp> class polymorphic_allocator;
    template<typename _Tp>
      using deque = std::deque<_Tp, polymorphic_allocator<_Tp>>;
  }

}



namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Tp, typename _Alloc, typename _Predicate>
    inline typename deque<_Tp, _Alloc>::size_type
    erase_if(deque<_Tp, _Alloc>& __cont, _Predicate __pred)
    {
      const auto __osz = __cont.size();
      __cont.erase(std::remove_if(__cont.begin(), __cont.end(), __pred),
     __cont.end());
      return __osz - __cont.size();
    }

  template<typename _Tp, typename _Alloc, typename _Up>
    inline typename deque<_Tp, _Alloc>::size_type
    erase(deque<_Tp, _Alloc>& __cont, const _Up& __value)
    {
      const auto __osz = __cont.size();
      __cont.erase(std::remove(__cont.begin(), __cont.end(), __value),
     __cont.end());
      return __osz - __cont.size();
    }

}
# 61 "/usr/local/include/c++/10.0.0/queue" 2 3



# 1 "/usr/local/include/c++/10.0.0/bits/stl_queue.h" 1 3
# 65 "/usr/local/include/c++/10.0.0/bits/stl_queue.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 95 "/usr/local/include/c++/10.0.0/bits/stl_queue.h" 3
  template<typename _Tp, typename _Sequence = deque<_Tp> >
    class queue
    {
# 109 "/usr/local/include/c++/10.0.0/bits/stl_queue.h" 3
      template<typename _Tp1, typename _Seq1>
 friend bool
 operator==(const queue<_Tp1, _Seq1>&, const queue<_Tp1, _Seq1>&);

      template<typename _Tp1, typename _Seq1>
 friend bool
 operator<(const queue<_Tp1, _Seq1>&, const queue<_Tp1, _Seq1>&);


      template<typename _Alloc>
 using _Uses = typename
   enable_if<uses_allocator<_Sequence, _Alloc>::value>::type;





      static_assert(is_same<_Tp, typename _Sequence::value_type>::value,
   "value_type must be the same as the underlying container");



    public:
      typedef typename _Sequence::value_type value_type;
      typedef typename _Sequence::reference reference;
      typedef typename _Sequence::const_reference const_reference;
      typedef typename _Sequence::size_type size_type;
      typedef _Sequence container_type;

    protected:
# 147 "/usr/local/include/c++/10.0.0/bits/stl_queue.h" 3
      _Sequence c;

    public:
# 158 "/usr/local/include/c++/10.0.0/bits/stl_queue.h" 3
      template<typename _Seq = _Sequence, typename _Requires = typename
        enable_if<is_default_constructible<_Seq>::value>::type>
 queue()
 : c() { }

      explicit
      queue(const _Sequence& __c)
      : c(__c) { }

      explicit
      queue(_Sequence&& __c)
      : c(std::move(__c)) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 explicit
 queue(const _Alloc& __a)
 : c(__a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 queue(const _Sequence& __c, const _Alloc& __a)
 : c(__c, __a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 queue(_Sequence&& __c, const _Alloc& __a)
 : c(std::move(__c), __a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 queue(const queue& __q, const _Alloc& __a)
 : c(__q.c, __a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 queue(queue&& __q, const _Alloc& __a)
 : c(std::move(__q.c), __a) { }





      [[__nodiscard__]] bool
      empty() const
      { return c.empty(); }


      size_type
      size() const
      { return c.size(); }





      reference
      front()
      {
 ;
 return c.front();
      }





      const_reference
      front() const
      {
 ;
 return c.front();
      }





      reference
      back()
      {
 ;
 return c.back();
      }





      const_reference
      back() const
      {
 ;
 return c.back();
      }
# 258 "/usr/local/include/c++/10.0.0/bits/stl_queue.h" 3
      void
      push(const value_type& __x)
      { c.push_back(__x); }


      void
      push(value_type&& __x)
      { c.push_back(std::move(__x)); }


      template<typename... _Args>
 decltype(auto)
 emplace(_Args&&... __args)
 { return c.emplace_back(std::forward<_Args>(__args)...); }
# 291 "/usr/local/include/c++/10.0.0/bits/stl_queue.h" 3
      void
      pop()
      {
 ;
 c.pop_front();
      }


      void
      swap(queue& __q)

      noexcept(__is_nothrow_swappable<_Sequence>::value)



      {
 using std::swap;
 swap(c, __q.c);
      }

    };


  template<typename _Container,
    typename = _RequireNotAllocator<_Container>>
    queue(_Container) -> queue<typename _Container::value_type, _Container>;

  template<typename _Container, typename _Allocator,
    typename = _RequireNotAllocator<_Container>,
    typename = _RequireAllocator<_Allocator>>
    queue(_Container, _Allocator)
    -> queue<typename _Container::value_type, _Container>;
# 336 "/usr/local/include/c++/10.0.0/bits/stl_queue.h" 3
  template<typename _Tp, typename _Seq>
    inline bool
    operator==(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return __x.c == __y.c; }
# 354 "/usr/local/include/c++/10.0.0/bits/stl_queue.h" 3
  template<typename _Tp, typename _Seq>
    inline bool
    operator<(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return __x.c < __y.c; }


  template<typename _Tp, typename _Seq>
    inline bool
    operator!=(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Seq>
    inline bool
    operator>(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Seq>
    inline bool
    operator<=(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Seq>
    inline bool
    operator>=(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Seq>
    inline


    typename enable_if<__is_swappable<_Seq>::value>::type



    swap(queue<_Tp, _Seq>& __x, queue<_Tp, _Seq>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }

  template<typename _Tp, typename _Seq, typename _Alloc>
    struct uses_allocator<queue<_Tp, _Seq>, _Alloc>
    : public uses_allocator<_Seq, _Alloc>::type { };
# 441 "/usr/local/include/c++/10.0.0/bits/stl_queue.h" 3
  template<typename _Tp, typename _Sequence = vector<_Tp>,
    typename _Compare = less<typename _Sequence::value_type> >
    class priority_queue
    {
# 459 "/usr/local/include/c++/10.0.0/bits/stl_queue.h" 3
      template<typename _Alloc>
 using _Uses = typename
   enable_if<uses_allocator<_Sequence, _Alloc>::value>::type;





      static_assert(is_same<_Tp, typename _Sequence::value_type>::value,
   "value_type must be the same as the underlying container");



    public:
      typedef typename _Sequence::value_type value_type;
      typedef typename _Sequence::reference reference;
      typedef typename _Sequence::const_reference const_reference;
      typedef typename _Sequence::size_type size_type;
      typedef _Sequence container_type;


      typedef _Compare value_compare;

    protected:

      _Sequence c;
      _Compare comp;

    public:
# 498 "/usr/local/include/c++/10.0.0/bits/stl_queue.h" 3
      template<typename _Seq = _Sequence, typename _Requires = typename
        enable_if<__and_<is_default_constructible<_Compare>,
    is_default_constructible<_Seq>>::value>::type>
 priority_queue()
 : c(), comp() { }

      explicit
      priority_queue(const _Compare& __x, const _Sequence& __s)
      : c(__s), comp(__x)
      { std::make_heap(c.begin(), c.end(), comp); }

      explicit
      priority_queue(const _Compare& __x, _Sequence&& __s = _Sequence())
      : c(std::move(__s)), comp(__x)
      { std::make_heap(c.begin(), c.end(), comp); }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 explicit
 priority_queue(const _Alloc& __a)
 : c(__a), comp() { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 priority_queue(const _Compare& __x, const _Alloc& __a)
 : c(__a), comp(__x) { }



      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 priority_queue(const _Compare& __x, const _Sequence& __c,
         const _Alloc& __a)
 : c(__c, __a), comp(__x)
 { std::make_heap(c.begin(), c.end(), comp); }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 priority_queue(const _Compare& __x, _Sequence&& __c, const _Alloc& __a)
 : c(std::move(__c), __a), comp(__x)
 { std::make_heap(c.begin(), c.end(), comp); }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 priority_queue(const priority_queue& __q, const _Alloc& __a)
 : c(__q.c, __a), comp(__q.comp) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 priority_queue(priority_queue&& __q, const _Alloc& __a)
 : c(std::move(__q.c), __a), comp(std::move(__q.comp)) { }
# 572 "/usr/local/include/c++/10.0.0/bits/stl_queue.h" 3
      template<typename _InputIterator>
 priority_queue(_InputIterator __first, _InputIterator __last,
         const _Compare& __x,
         const _Sequence& __s)
 : c(__s), comp(__x)
 {
   ;
   c.insert(c.end(), __first, __last);
   std::make_heap(c.begin(), c.end(), comp);
 }

      template<typename _InputIterator>
 priority_queue(_InputIterator __first, _InputIterator __last,
         const _Compare& __x = _Compare(),
         _Sequence&& __s = _Sequence())
 : c(std::move(__s)), comp(__x)
 {
   ;
   c.insert(c.end(), __first, __last);
   std::make_heap(c.begin(), c.end(), comp);
 }





      [[__nodiscard__]] bool
      empty() const
      { return c.empty(); }


      size_type
      size() const
      { return c.size(); }





      const_reference
      top() const
      {
 ;
 return c.front();
      }
# 626 "/usr/local/include/c++/10.0.0/bits/stl_queue.h" 3
      void
      push(const value_type& __x)
      {
 c.push_back(__x);
 std::push_heap(c.begin(), c.end(), comp);
      }


      void
      push(value_type&& __x)
      {
 c.push_back(std::move(__x));
 std::push_heap(c.begin(), c.end(), comp);
      }

      template<typename... _Args>
 void
 emplace(_Args&&... __args)
 {
   c.emplace_back(std::forward<_Args>(__args)...);
   std::push_heap(c.begin(), c.end(), comp);
 }
# 661 "/usr/local/include/c++/10.0.0/bits/stl_queue.h" 3
      void
      pop()
      {
 ;
 std::pop_heap(c.begin(), c.end(), comp);
 c.pop_back();
      }


      void
      swap(priority_queue& __pq)
      noexcept(__and_<

   __is_nothrow_swappable<_Sequence>,



   __is_nothrow_swappable<_Compare>
        >::value)
      {
 using std::swap;
 swap(c, __pq.c);
 swap(comp, __pq.comp);
      }

    };


  template<typename _Compare, typename _Container,
    typename = _RequireNotAllocator<_Compare>,
    typename = _RequireNotAllocator<_Container>>
    priority_queue(_Compare, _Container)
    -> priority_queue<typename _Container::value_type, _Container, _Compare>;

  template<typename _InputIterator, typename _ValT
    = typename iterator_traits<_InputIterator>::value_type,
    typename _Compare = less<_ValT>,
    typename _Container = vector<_ValT>,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireNotAllocator<_Compare>,
    typename = _RequireNotAllocator<_Container>>
    priority_queue(_InputIterator, _InputIterator, _Compare = _Compare(),
     _Container = _Container())
    -> priority_queue<_ValT, _Container, _Compare>;

  template<typename _Compare, typename _Container, typename _Allocator,
    typename = _RequireNotAllocator<_Compare>,
    typename = _RequireNotAllocator<_Container>,
    typename = _RequireAllocator<_Allocator>>
    priority_queue(_Compare, _Container, _Allocator)
    -> priority_queue<typename _Container::value_type, _Container, _Compare>;





  template<typename _Tp, typename _Sequence, typename _Compare>
    inline


    typename enable_if<__and_<__is_swappable<_Sequence>,
         __is_swappable<_Compare>>::value>::type



    swap(priority_queue<_Tp, _Sequence, _Compare>& __x,
  priority_queue<_Tp, _Sequence, _Compare>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }

  template<typename _Tp, typename _Sequence, typename _Compare,
    typename _Alloc>
    struct uses_allocator<priority_queue<_Tp, _Sequence, _Compare>, _Alloc>
    : public uses_allocator<_Sequence, _Alloc>::type { };



}
# 65 "/usr/local/include/c++/10.0.0/queue" 2 3
# 7 "tree.h" 2
# 1 "/usr/local/include/c++/10.0.0/set" 1 3
# 58 "/usr/local/include/c++/10.0.0/set" 3
       
# 59 "/usr/local/include/c++/10.0.0/set" 3

# 1 "/usr/local/include/c++/10.0.0/bits/stl_tree.h" 1 3
# 61 "/usr/local/include/c++/10.0.0/bits/stl_tree.h" 3
       
# 62 "/usr/local/include/c++/10.0.0/bits/stl_tree.h" 3
# 75 "/usr/local/include/c++/10.0.0/bits/stl_tree.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 99 "/usr/local/include/c++/10.0.0/bits/stl_tree.h" 3
  enum _Rb_tree_color { _S_red = false, _S_black = true };

  struct _Rb_tree_node_base
  {
    typedef _Rb_tree_node_base* _Base_ptr;
    typedef const _Rb_tree_node_base* _Const_Base_ptr;

    _Rb_tree_color _M_color;
    _Base_ptr _M_parent;
    _Base_ptr _M_left;
    _Base_ptr _M_right;

    static _Base_ptr
    _S_minimum(_Base_ptr __x) noexcept
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Const_Base_ptr
    _S_minimum(_Const_Base_ptr __x) noexcept
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }

    static _Base_ptr
    _S_maximum(_Base_ptr __x) noexcept
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }

    static _Const_Base_ptr
    _S_maximum(_Const_Base_ptr __x) noexcept
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }
  };


  template<typename _Key_compare>
    struct _Rb_tree_key_compare
    {
      _Key_compare _M_key_compare;

      _Rb_tree_key_compare()
      noexcept(is_nothrow_default_constructible<_Key_compare>::value)

      : _M_key_compare()
      { }

      _Rb_tree_key_compare(const _Key_compare& __comp)
      : _M_key_compare(__comp)
      { }



      _Rb_tree_key_compare(const _Rb_tree_key_compare&) = default;

      _Rb_tree_key_compare(_Rb_tree_key_compare&& __x)
 noexcept(is_nothrow_copy_constructible<_Key_compare>::value)
      : _M_key_compare(__x._M_key_compare)
      { }

    };


  struct _Rb_tree_header
  {
    _Rb_tree_node_base _M_header;
    size_t _M_node_count;

    _Rb_tree_header() noexcept
    {
      _M_header._M_color = _S_red;
      _M_reset();
    }


    _Rb_tree_header(_Rb_tree_header&& __x) noexcept
    {
      if (__x._M_header._M_parent != nullptr)
 _M_move_data(__x);
      else
 {
   _M_header._M_color = _S_red;
   _M_reset();
 }
    }


    void
    _M_move_data(_Rb_tree_header& __from)
    {
      _M_header._M_color = __from._M_header._M_color;
      _M_header._M_parent = __from._M_header._M_parent;
      _M_header._M_left = __from._M_header._M_left;
      _M_header._M_right = __from._M_header._M_right;
      _M_header._M_parent->_M_parent = &_M_header;
      _M_node_count = __from._M_node_count;

      __from._M_reset();
    }

    void
    _M_reset()
    {
      _M_header._M_parent = 0;
      _M_header._M_left = &_M_header;
      _M_header._M_right = &_M_header;
      _M_node_count = 0;
    }
  };

  template<typename _Val>
    struct _Rb_tree_node : public _Rb_tree_node_base
    {
      typedef _Rb_tree_node<_Val>* _Link_type;
# 231 "/usr/local/include/c++/10.0.0/bits/stl_tree.h" 3
      __gnu_cxx::__aligned_membuf<_Val> _M_storage;

      _Val*
      _M_valptr()
      { return _M_storage._M_ptr(); }

      const _Val*
      _M_valptr() const
      { return _M_storage._M_ptr(); }

    };

  __attribute__ ((__pure__)) _Rb_tree_node_base*
  _Rb_tree_increment(_Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) const _Rb_tree_node_base*
  _Rb_tree_increment(const _Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) _Rb_tree_node_base*
  _Rb_tree_decrement(_Rb_tree_node_base* __x) throw ();

  __attribute__ ((__pure__)) const _Rb_tree_node_base*
  _Rb_tree_decrement(const _Rb_tree_node_base* __x) throw ();

  template<typename _Tp>
    struct _Rb_tree_iterator
    {
      typedef _Tp value_type;
      typedef _Tp& reference;
      typedef _Tp* pointer;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
      typedef _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_iterator() noexcept
      : _M_node() { }

      explicit
      _Rb_tree_iterator(_Base_ptr __x) noexcept
      : _M_node(__x) { }

      reference
      operator*() const noexcept
      { return *static_cast<_Link_type>(_M_node)->_M_valptr(); }

      pointer
      operator->() const noexcept
      { return static_cast<_Link_type> (_M_node)->_M_valptr(); }

      _Self&
      operator++() noexcept
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--() noexcept
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      friend bool
      operator==(const _Self& __x, const _Self& __y) noexcept
      { return __x._M_node == __y._M_node; }

      friend bool
      operator!=(const _Self& __x, const _Self& __y) noexcept
      { return __x._M_node != __y._M_node; }

      _Base_ptr _M_node;
  };

  template<typename _Tp>
    struct _Rb_tree_const_iterator
    {
      typedef _Tp value_type;
      typedef const _Tp& reference;
      typedef const _Tp* pointer;

      typedef _Rb_tree_iterator<_Tp> iterator;

      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;

      typedef _Rb_tree_const_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
      typedef const _Rb_tree_node<_Tp>* _Link_type;

      _Rb_tree_const_iterator() noexcept
      : _M_node() { }

      explicit
      _Rb_tree_const_iterator(_Base_ptr __x) noexcept
      : _M_node(__x) { }

      _Rb_tree_const_iterator(const iterator& __it) noexcept
      : _M_node(__it._M_node) { }

      iterator
      _M_const_cast() const noexcept
      { return iterator(const_cast<typename iterator::_Base_ptr>(_M_node)); }

      reference
      operator*() const noexcept
      { return *static_cast<_Link_type>(_M_node)->_M_valptr(); }

      pointer
      operator->() const noexcept
      { return static_cast<_Link_type>(_M_node)->_M_valptr(); }

      _Self&
      operator++() noexcept
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }

      _Self
      operator++(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }

      _Self&
      operator--() noexcept
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }

      _Self
      operator--(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }

      friend bool
      operator==(const _Self& __x, const _Self& __y) noexcept
      { return __x._M_node == __y._M_node; }

      friend bool
      operator!=(const _Self& __x, const _Self& __y) noexcept
      { return __x._M_node != __y._M_node; }

      _Base_ptr _M_node;
    };

  void
  _Rb_tree_insert_and_rebalance(const bool __insert_left,
    _Rb_tree_node_base* __x,
    _Rb_tree_node_base* __p,
    _Rb_tree_node_base& __header) throw ();

  _Rb_tree_node_base*
  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,
          _Rb_tree_node_base& __header) throw ();


  template<typename _Cmp, typename _SfinaeType, typename = __void_t<>>
    struct __has_is_transparent
    { };

  template<typename _Cmp, typename _SfinaeType>
    struct __has_is_transparent<_Cmp, _SfinaeType,
    __void_t<typename _Cmp::is_transparent>>
    { typedef void type; };

  template<typename _Cmp, typename _SfinaeType>
    using __has_is_transparent_t
      = typename __has_is_transparent<_Cmp, _SfinaeType>::type;



  template<typename _Tree1, typename _Cmp2>
    struct _Rb_tree_merge_helper { };


  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc = allocator<_Val> >
    class _Rb_tree
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_Rb_tree_node<_Val> >::other _Node_allocator;

      typedef __gnu_cxx::__alloc_traits<_Node_allocator> _Alloc_traits;

    protected:
      typedef _Rb_tree_node_base* _Base_ptr;
      typedef const _Rb_tree_node_base* _Const_Base_ptr;
      typedef _Rb_tree_node<_Val>* _Link_type;
      typedef const _Rb_tree_node<_Val>* _Const_Link_type;

    private:


      struct _Reuse_or_alloc_node
      {
 _Reuse_or_alloc_node(_Rb_tree& __t)
 : _M_root(__t._M_root()), _M_nodes(__t._M_rightmost()), _M_t(__t)
 {
   if (_M_root)
     {
       _M_root->_M_parent = 0;

       if (_M_nodes->_M_left)
  _M_nodes = _M_nodes->_M_left;
     }
   else
     _M_nodes = 0;
 }


 _Reuse_or_alloc_node(const _Reuse_or_alloc_node&) = delete;


 ~_Reuse_or_alloc_node()
 { _M_t._M_erase(static_cast<_Link_type>(_M_root)); }

 template<typename _Arg>
   _Link_type



   operator()(_Arg&& __arg)

   {
     _Link_type __node = static_cast<_Link_type>(_M_extract());
     if (__node)
       {
  _M_t._M_destroy_node(__node);
  _M_t._M_construct_node(__node, std::forward<_Arg>(__arg));
  return __node;
       }

     return _M_t._M_create_node(std::forward<_Arg>(__arg));
   }

      private:
 _Base_ptr
 _M_extract()
 {
   if (!_M_nodes)
     return _M_nodes;

   _Base_ptr __node = _M_nodes;
   _M_nodes = _M_nodes->_M_parent;
   if (_M_nodes)
     {
       if (_M_nodes->_M_right == __node)
  {
    _M_nodes->_M_right = 0;

    if (_M_nodes->_M_left)
      {
        _M_nodes = _M_nodes->_M_left;

        while (_M_nodes->_M_right)
   _M_nodes = _M_nodes->_M_right;

        if (_M_nodes->_M_left)
   _M_nodes = _M_nodes->_M_left;
      }
  }
       else
  _M_nodes->_M_left = 0;
     }
   else
     _M_root = 0;

   return __node;
 }

 _Base_ptr _M_root;
 _Base_ptr _M_nodes;
 _Rb_tree& _M_t;
      };



      struct _Alloc_node
      {
 _Alloc_node(_Rb_tree& __t)
 : _M_t(__t) { }

 template<typename _Arg>
   _Link_type



   operator()(_Arg&& __arg) const

   { return _M_t._M_create_node(std::forward<_Arg>(__arg)); }

      private:
 _Rb_tree& _M_t;
      };

    public:
      typedef _Key key_type;
      typedef _Val value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

      _Node_allocator&
      _M_get_Node_allocator() noexcept
      { return this->_M_impl; }

      const _Node_allocator&
      _M_get_Node_allocator() const noexcept
      { return this->_M_impl; }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Node_allocator()); }

    protected:
      _Link_type
      _M_get_node()
      { return _Alloc_traits::allocate(_M_get_Node_allocator(), 1); }

      void
      _M_put_node(_Link_type __p) noexcept
      { _Alloc_traits::deallocate(_M_get_Node_allocator(), __p, 1); }
# 607 "/usr/local/include/c++/10.0.0/bits/stl_tree.h" 3
      template<typename... _Args>
 void
 _M_construct_node(_Link_type __node, _Args&&... __args)
 {
   try
     {
       ::new(__node) _Rb_tree_node<_Val>;
       _Alloc_traits::construct(_M_get_Node_allocator(),
           __node->_M_valptr(),
           std::forward<_Args>(__args)...);
     }
   catch(...)
     {
       __node->~_Rb_tree_node<_Val>();
       _M_put_node(__node);
       throw;
     }
 }

      template<typename... _Args>
 _Link_type
 _M_create_node(_Args&&... __args)
 {
   _Link_type __tmp = _M_get_node();
   _M_construct_node(__tmp, std::forward<_Args>(__args)...);
   return __tmp;
 }


      void
      _M_destroy_node(_Link_type __p) noexcept
      {



 _Alloc_traits::destroy(_M_get_Node_allocator(), __p->_M_valptr());
 __p->~_Rb_tree_node<_Val>();

      }

      void
      _M_drop_node(_Link_type __p) noexcept
      {
 _M_destroy_node(__p);
 _M_put_node(__p);
      }

      template<typename _NodeGen>
 _Link_type
 _M_clone_node(_Const_Link_type __x, _NodeGen& __node_gen)
 {
   _Link_type __tmp = __node_gen(*__x->_M_valptr());
   __tmp->_M_color = __x->_M_color;
   __tmp->_M_left = 0;
   __tmp->_M_right = 0;
   return __tmp;
 }

    protected:




      template<typename _Key_compare,
        bool = __is_pod(_Key_compare)>

 struct _Rb_tree_impl
 : public _Node_allocator
 , public _Rb_tree_key_compare<_Key_compare>
 , public _Rb_tree_header
 {
   typedef _Rb_tree_key_compare<_Key_compare> _Base_key_compare;

   _Rb_tree_impl()
     noexcept(is_nothrow_default_constructible<_Node_allocator>::value && is_nothrow_default_constructible<_Base_key_compare>::value)


   : _Node_allocator()
   { }

   _Rb_tree_impl(const _Rb_tree_impl& __x)
   : _Node_allocator(_Alloc_traits::_S_select_on_copy(__x))
   , _Base_key_compare(__x._M_key_compare)
   { }






   _Rb_tree_impl(_Rb_tree_impl&&) = default;

   explicit
   _Rb_tree_impl(_Node_allocator&& __a)
   : _Node_allocator(std::move(__a))
   { }

   _Rb_tree_impl(_Rb_tree_impl&& __x, _Node_allocator&& __a)
   : _Node_allocator(std::move(__a)),
     _Base_key_compare(std::move(__x)),
     _Rb_tree_header(std::move(__x))
   { }

   _Rb_tree_impl(const _Key_compare& __comp, _Node_allocator&& __a)
   : _Node_allocator(std::move(__a)), _Base_key_compare(__comp)
   { }

 };

      _Rb_tree_impl<_Compare> _M_impl;

    protected:
      _Base_ptr&
      _M_root() noexcept
      { return this->_M_impl._M_header._M_parent; }

      _Const_Base_ptr
      _M_root() const noexcept
      { return this->_M_impl._M_header._M_parent; }

      _Base_ptr&
      _M_leftmost() noexcept
      { return this->_M_impl._M_header._M_left; }

      _Const_Base_ptr
      _M_leftmost() const noexcept
      { return this->_M_impl._M_header._M_left; }

      _Base_ptr&
      _M_rightmost() noexcept
      { return this->_M_impl._M_header._M_right; }

      _Const_Base_ptr
      _M_rightmost() const noexcept
      { return this->_M_impl._M_header._M_right; }

      _Link_type
      _M_begin() noexcept
      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }

      _Const_Link_type
      _M_begin() const noexcept
      {
 return static_cast<_Const_Link_type>
   (this->_M_impl._M_header._M_parent);
      }

      _Base_ptr
      _M_end() noexcept
      { return &this->_M_impl._M_header; }

      _Const_Base_ptr
      _M_end() const noexcept
      { return &this->_M_impl._M_header; }

      static const _Key&
      _S_key(_Const_Link_type __x)
      {



 static_assert(__is_invocable<_Compare&, const _Key&, const _Key&>{},
        "comparison object must be invocable "
        "with two arguments of key type");



 if constexpr (__is_invocable<_Compare&, const _Key&, const _Key&>{})
   static_assert(
       is_invocable_v<const _Compare&, const _Key&, const _Key&>,
       "comparison object must be invocable as const");



 return _KeyOfValue()(*__x->_M_valptr());
      }

      static _Link_type
      _S_left(_Base_ptr __x) noexcept
      { return static_cast<_Link_type>(__x->_M_left); }

      static _Const_Link_type
      _S_left(_Const_Base_ptr __x) noexcept
      { return static_cast<_Const_Link_type>(__x->_M_left); }

      static _Link_type
      _S_right(_Base_ptr __x) noexcept
      { return static_cast<_Link_type>(__x->_M_right); }

      static _Const_Link_type
      _S_right(_Const_Base_ptr __x) noexcept
      { return static_cast<_Const_Link_type>(__x->_M_right); }

      static const _Key&
      _S_key(_Const_Base_ptr __x)
      { return _S_key(static_cast<_Const_Link_type>(__x)); }

      static _Base_ptr
      _S_minimum(_Base_ptr __x) noexcept
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Const_Base_ptr
      _S_minimum(_Const_Base_ptr __x) noexcept
      { return _Rb_tree_node_base::_S_minimum(__x); }

      static _Base_ptr
      _S_maximum(_Base_ptr __x) noexcept
      { return _Rb_tree_node_base::_S_maximum(__x); }

      static _Const_Base_ptr
      _S_maximum(_Const_Base_ptr __x) noexcept
      { return _Rb_tree_node_base::_S_maximum(__x); }

    public:
      typedef _Rb_tree_iterator<value_type> iterator;
      typedef _Rb_tree_const_iterator<value_type> const_iterator;

      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;


      using node_type = _Node_handle<_Key, _Val, _Node_allocator>;
      using insert_return_type = _Node_insert_return<
 conditional_t<is_same_v<_Key, _Val>, const_iterator, iterator>,
 node_type>;


      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_unique_pos(const key_type& __k);

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_equal_pos(const key_type& __k);

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_hint_unique_pos(const_iterator __pos,
        const key_type& __k);

      pair<_Base_ptr, _Base_ptr>
      _M_get_insert_hint_equal_pos(const_iterator __pos,
       const key_type& __k);

    private:

      template<typename _Arg, typename _NodeGen>
 iterator
 _M_insert_(_Base_ptr __x, _Base_ptr __y, _Arg&& __v, _NodeGen&);

      iterator
      _M_insert_node(_Base_ptr __x, _Base_ptr __y, _Link_type __z);

      template<typename _Arg>
 iterator
 _M_insert_lower(_Base_ptr __y, _Arg&& __v);

      template<typename _Arg>
 iterator
 _M_insert_equal_lower(_Arg&& __x);

      iterator
      _M_insert_lower_node(_Base_ptr __p, _Link_type __z);

      iterator
      _M_insert_equal_lower_node(_Link_type __z);
# 885 "/usr/local/include/c++/10.0.0/bits/stl_tree.h" 3
      template<typename _NodeGen>
 _Link_type
 _M_copy(_Const_Link_type __x, _Base_ptr __p, _NodeGen&);

      template<typename _NodeGen>
 _Link_type
 _M_copy(const _Rb_tree& __x, _NodeGen& __gen)
 {
   _Link_type __root = _M_copy(__x._M_begin(), _M_end(), __gen);
   _M_leftmost() = _S_minimum(__root);
   _M_rightmost() = _S_maximum(__root);
   _M_impl._M_node_count = __x._M_impl._M_node_count;
   return __root;
 }

      _Link_type
      _M_copy(const _Rb_tree& __x)
      {
 _Alloc_node __an(*this);
 return _M_copy(__x, __an);
      }

      void
      _M_erase(_Link_type __x);

      iterator
      _M_lower_bound(_Link_type __x, _Base_ptr __y,
       const _Key& __k);

      const_iterator
      _M_lower_bound(_Const_Link_type __x, _Const_Base_ptr __y,
       const _Key& __k) const;

      iterator
      _M_upper_bound(_Link_type __x, _Base_ptr __y,
       const _Key& __k);

      const_iterator
      _M_upper_bound(_Const_Link_type __x, _Const_Base_ptr __y,
       const _Key& __k) const;

    public:




      _Rb_tree() = default;


      _Rb_tree(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_impl(__comp, _Node_allocator(__a)) { }

      _Rb_tree(const _Rb_tree& __x)
      : _M_impl(__x._M_impl)
      {
 if (__x._M_root() != 0)
   _M_root() = _M_copy(__x);
      }


      _Rb_tree(const allocator_type& __a)
      : _M_impl(_Node_allocator(__a))
      { }

      _Rb_tree(const _Rb_tree& __x, const allocator_type& __a)
      : _M_impl(__x._M_impl._M_key_compare, _Node_allocator(__a))
      {
 if (__x._M_root() != nullptr)
   _M_root() = _M_copy(__x);
      }

      _Rb_tree(_Rb_tree&&) = default;

      _Rb_tree(_Rb_tree&& __x, const allocator_type& __a)
      : _Rb_tree(std::move(__x), _Node_allocator(__a))
      { }

    private:
      _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a, true_type)
      noexcept(is_nothrow_default_constructible<_Compare>::value)
      : _M_impl(std::move(__x._M_impl), std::move(__a))
      { }

      _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a, false_type)
      : _M_impl(__x._M_impl._M_key_compare, std::move(__a))
      {
 if (__x._M_root() != nullptr)
   _M_move_data(__x, false_type{});
      }

    public:
      _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a)
      noexcept( noexcept(
 _Rb_tree(std::declval<_Rb_tree&&>(), std::declval<_Node_allocator&&>(),
   std::declval<typename _Alloc_traits::is_always_equal>())) )
      : _Rb_tree(std::move(__x), std::move(__a),
   typename _Alloc_traits::is_always_equal{})
      { }


      ~_Rb_tree() noexcept
      { _M_erase(_M_begin()); }

      _Rb_tree&
      operator=(const _Rb_tree& __x);


      _Compare
      key_comp() const
      { return _M_impl._M_key_compare; }

      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_header._M_left); }

      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_header._M_left); }

      iterator
      end() noexcept
      { return iterator(&this->_M_impl._M_header); }

      const_iterator
      end() const noexcept
      { return const_iterator(&this->_M_impl._M_header); }

      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }

      [[__nodiscard__]] bool
      empty() const noexcept
      { return _M_impl._M_node_count == 0; }

      size_type
      size() const noexcept
      { return _M_impl._M_node_count; }

      size_type
      max_size() const noexcept
      { return _Alloc_traits::max_size(_M_get_Node_allocator()); }

      void
      swap(_Rb_tree& __t)
      noexcept(__is_nothrow_swappable<_Compare>::value);



      template<typename _Arg>
 pair<iterator, bool>
 _M_insert_unique(_Arg&& __x);

      template<typename _Arg>
 iterator
 _M_insert_equal(_Arg&& __x);

      template<typename _Arg, typename _NodeGen>
 iterator
 _M_insert_unique_(const_iterator __pos, _Arg&& __x, _NodeGen&);

      template<typename _Arg>
 iterator
 _M_insert_unique_(const_iterator __pos, _Arg&& __x)
 {
   _Alloc_node __an(*this);
   return _M_insert_unique_(__pos, std::forward<_Arg>(__x), __an);
 }

      template<typename _Arg, typename _NodeGen>
 iterator
 _M_insert_equal_(const_iterator __pos, _Arg&& __x, _NodeGen&);

      template<typename _Arg>
 iterator
 _M_insert_equal_(const_iterator __pos, _Arg&& __x)
 {
   _Alloc_node __an(*this);
   return _M_insert_equal_(__pos, std::forward<_Arg>(__x), __an);
 }

      template<typename... _Args>
 pair<iterator, bool>
 _M_emplace_unique(_Args&&... __args);

      template<typename... _Args>
 iterator
 _M_emplace_equal(_Args&&... __args);

      template<typename... _Args>
 iterator
 _M_emplace_hint_unique(const_iterator __pos, _Args&&... __args);

      template<typename... _Args>
 iterator
 _M_emplace_hint_equal(const_iterator __pos, _Args&&... __args);

      template<typename _Iter>
 using __same_value_type
   = is_same<value_type, typename iterator_traits<_Iter>::value_type>;

      template<typename _InputIterator>
 __enable_if_t<__same_value_type<_InputIterator>::value>
 _M_insert_range_unique(_InputIterator __first, _InputIterator __last)
 {
   _Alloc_node __an(*this);
   for (; __first != __last; ++__first)
     _M_insert_unique_(end(), *__first, __an);
 }

      template<typename _InputIterator>
 __enable_if_t<!__same_value_type<_InputIterator>::value>
 _M_insert_range_unique(_InputIterator __first, _InputIterator __last)
 {
   for (; __first != __last; ++__first)
     _M_emplace_unique(*__first);
 }

      template<typename _InputIterator>
 __enable_if_t<__same_value_type<_InputIterator>::value>
 _M_insert_range_equal(_InputIterator __first, _InputIterator __last)
 {
   _Alloc_node __an(*this);
   for (; __first != __last; ++__first)
     _M_insert_equal_(end(), *__first, __an);
 }

      template<typename _InputIterator>
 __enable_if_t<!__same_value_type<_InputIterator>::value>
 _M_insert_range_equal(_InputIterator __first, _InputIterator __last)
 {
   _Alloc_node __an(*this);
   for (; __first != __last; ++__first)
     _M_emplace_equal(*__first);
 }
# 1182 "/usr/local/include/c++/10.0.0/bits/stl_tree.h" 3
    private:
      void
      _M_erase_aux(const_iterator __position);

      void
      _M_erase_aux(const_iterator __first, const_iterator __last);

    public:



      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(const_iterator __position)
      {
 ;
 const_iterator __result = __position;
 ++__result;
 _M_erase_aux(__position);
 return __result._M_const_cast();
      }


      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(iterator __position)
      {
 ;
 iterator __result = __position;
 ++__result;
 _M_erase_aux(__position);
 return __result;
      }
# 1231 "/usr/local/include/c++/10.0.0/bits/stl_tree.h" 3
      size_type
      erase(const key_type& __x);




      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(const_iterator __first, const_iterator __last)
      {
 _M_erase_aux(__first, __last);
 return __last._M_const_cast();
      }
# 1254 "/usr/local/include/c++/10.0.0/bits/stl_tree.h" 3
      void
      clear() noexcept
      {
 _M_erase(_M_begin());
 _M_impl._M_reset();
      }


      iterator
      find(const key_type& __k);

      const_iterator
      find(const key_type& __k) const;

      size_type
      count(const key_type& __k) const;

      iterator
      lower_bound(const key_type& __k)
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      lower_bound(const key_type& __k) const
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }

      iterator
      upper_bound(const key_type& __k)
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      const_iterator
      upper_bound(const key_type& __k) const
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }

      pair<iterator, iterator>
      equal_range(const key_type& __k);

      pair<const_iterator, const_iterator>
      equal_range(const key_type& __k) const;


      template<typename _Kt,
        typename _Req = __has_is_transparent_t<_Compare, _Kt>>
 iterator
 _M_find_tr(const _Kt& __k)
 {
   const _Rb_tree* __const_this = this;
   return __const_this->_M_find_tr(__k)._M_const_cast();
 }

      template<typename _Kt,
        typename _Req = __has_is_transparent_t<_Compare, _Kt>>
 const_iterator
 _M_find_tr(const _Kt& __k) const
 {
   auto __j = _M_lower_bound_tr(__k);
   if (__j != end() && _M_impl._M_key_compare(__k, _S_key(__j._M_node)))
     __j = end();
   return __j;
 }

      template<typename _Kt,
        typename _Req = __has_is_transparent_t<_Compare, _Kt>>
 size_type
 _M_count_tr(const _Kt& __k) const
 {
   auto __p = _M_equal_range_tr(__k);
   return std::distance(__p.first, __p.second);
 }

      template<typename _Kt,
        typename _Req = __has_is_transparent_t<_Compare, _Kt>>
 iterator
 _M_lower_bound_tr(const _Kt& __k)
 {
   const _Rb_tree* __const_this = this;
   return __const_this->_M_lower_bound_tr(__k)._M_const_cast();
 }

      template<typename _Kt,
        typename _Req = __has_is_transparent_t<_Compare, _Kt>>
 const_iterator
 _M_lower_bound_tr(const _Kt& __k) const
 {
   auto __x = _M_begin();
   auto __y = _M_end();
   while (__x != 0)
     if (!_M_impl._M_key_compare(_S_key(__x), __k))
       {
  __y = __x;
  __x = _S_left(__x);
       }
     else
       __x = _S_right(__x);
   return const_iterator(__y);
 }

      template<typename _Kt,
        typename _Req = __has_is_transparent_t<_Compare, _Kt>>
 iterator
 _M_upper_bound_tr(const _Kt& __k)
 {
   const _Rb_tree* __const_this = this;
   return __const_this->_M_upper_bound_tr(__k)._M_const_cast();
 }

      template<typename _Kt,
        typename _Req = __has_is_transparent_t<_Compare, _Kt>>
 const_iterator
 _M_upper_bound_tr(const _Kt& __k) const
 {
   auto __x = _M_begin();
   auto __y = _M_end();
   while (__x != 0)
     if (_M_impl._M_key_compare(__k, _S_key(__x)))
       {
  __y = __x;
  __x = _S_left(__x);
       }
     else
       __x = _S_right(__x);
   return const_iterator(__y);
 }

      template<typename _Kt,
        typename _Req = __has_is_transparent_t<_Compare, _Kt>>
 pair<iterator, iterator>
 _M_equal_range_tr(const _Kt& __k)
 {
   const _Rb_tree* __const_this = this;
   auto __ret = __const_this->_M_equal_range_tr(__k);
   return { __ret.first._M_const_cast(), __ret.second._M_const_cast() };
 }

      template<typename _Kt,
        typename _Req = __has_is_transparent_t<_Compare, _Kt>>
 pair<const_iterator, const_iterator>
 _M_equal_range_tr(const _Kt& __k) const
 {
   auto __low = _M_lower_bound_tr(__k);
   auto __high = __low;
   auto& __cmp = _M_impl._M_key_compare;
   while (__high != end() && !__cmp(__k, _S_key(__high._M_node)))
     ++__high;
   return { __low, __high };
 }



      bool
      __rb_verify() const;


      _Rb_tree&
      operator=(_Rb_tree&&)
      noexcept(_Alloc_traits::_S_nothrow_move()
        && is_nothrow_move_assignable<_Compare>::value);

      template<typename _Iterator>
 void
 _M_assign_unique(_Iterator, _Iterator);

      template<typename _Iterator>
 void
 _M_assign_equal(_Iterator, _Iterator);

    private:

      void
      _M_move_data(_Rb_tree& __x, true_type)
      { _M_impl._M_move_data(__x._M_impl); }



      void
      _M_move_data(_Rb_tree&, false_type);


      void
      _M_move_assign(_Rb_tree&, true_type);



      void
      _M_move_assign(_Rb_tree&, false_type);



    public:

      insert_return_type
      _M_reinsert_node_unique(node_type&& __nh)
      {
 insert_return_type __ret;
 if (__nh.empty())
   __ret.position = end();
 else
   {
     ;

     auto __res = _M_get_insert_unique_pos(__nh._M_key());
     if (__res.second)
       {
  __ret.position
    = _M_insert_node(__res.first, __res.second, __nh._M_ptr);
  __nh._M_ptr = nullptr;
  __ret.inserted = true;
       }
     else
       {
  __ret.node = std::move(__nh);
  __ret.position = iterator(__res.first);
  __ret.inserted = false;
       }
   }
 return __ret;
      }


      iterator
      _M_reinsert_node_equal(node_type&& __nh)
      {
 iterator __ret;
 if (__nh.empty())
   __ret = end();
 else
   {
     ;
     auto __res = _M_get_insert_equal_pos(__nh._M_key());
     if (__res.second)
       __ret = _M_insert_node(__res.first, __res.second, __nh._M_ptr);
     else
       __ret = _M_insert_equal_lower_node(__nh._M_ptr);
     __nh._M_ptr = nullptr;
   }
 return __ret;
      }


      iterator
      _M_reinsert_node_hint_unique(const_iterator __hint, node_type&& __nh)
      {
 iterator __ret;
 if (__nh.empty())
   __ret = end();
 else
   {
     ;
     auto __res = _M_get_insert_hint_unique_pos(__hint, __nh._M_key());
     if (__res.second)
       {
  __ret = _M_insert_node(__res.first, __res.second, __nh._M_ptr);
  __nh._M_ptr = nullptr;
       }
     else
       __ret = iterator(__res.first);
   }
 return __ret;
      }


      iterator
      _M_reinsert_node_hint_equal(const_iterator __hint, node_type&& __nh)
      {
 iterator __ret;
 if (__nh.empty())
   __ret = end();
 else
   {
     ;
     auto __res = _M_get_insert_hint_equal_pos(__hint, __nh._M_key());
     if (__res.second)
       __ret = _M_insert_node(__res.first, __res.second, __nh._M_ptr);
     else
       __ret = _M_insert_equal_lower_node(__nh._M_ptr);
     __nh._M_ptr = nullptr;
   }
 return __ret;
      }


      node_type
      extract(const_iterator __pos)
      {
 auto __ptr = _Rb_tree_rebalance_for_erase(
     __pos._M_const_cast()._M_node, _M_impl._M_header);
 --_M_impl._M_node_count;
 return { static_cast<_Link_type>(__ptr), _M_get_Node_allocator() };
      }


      node_type
      extract(const key_type& __k)
      {
 node_type __nh;
 auto __pos = find(__k);
 if (__pos != end())
   __nh = extract(const_iterator(__pos));
 return __nh;
      }

      template<typename _Compare2>
 using _Compatible_tree
   = _Rb_tree<_Key, _Val, _KeyOfValue, _Compare2, _Alloc>;

      template<typename, typename>
 friend class _Rb_tree_merge_helper;


      template<typename _Compare2>
 void
 _M_merge_unique(_Compatible_tree<_Compare2>& __src) noexcept
 {
   using _Merge_helper = _Rb_tree_merge_helper<_Rb_tree, _Compare2>;
   for (auto __i = __src.begin(), __end = __src.end(); __i != __end;)
     {
       auto __pos = __i++;
       auto __res = _M_get_insert_unique_pos(_KeyOfValue()(*__pos));
       if (__res.second)
  {
    auto& __src_impl = _Merge_helper::_S_get_impl(__src);
    auto __ptr = _Rb_tree_rebalance_for_erase(
        __pos._M_node, __src_impl._M_header);
    --__src_impl._M_node_count;
    _M_insert_node(__res.first, __res.second,
     static_cast<_Link_type>(__ptr));
  }
     }
 }


      template<typename _Compare2>
 void
 _M_merge_equal(_Compatible_tree<_Compare2>& __src) noexcept
 {
   using _Merge_helper = _Rb_tree_merge_helper<_Rb_tree, _Compare2>;
   for (auto __i = __src.begin(), __end = __src.end(); __i != __end;)
     {
       auto __pos = __i++;
       auto __res = _M_get_insert_equal_pos(_KeyOfValue()(*__pos));
       if (__res.second)
  {
    auto& __src_impl = _Merge_helper::_S_get_impl(__src);
    auto __ptr = _Rb_tree_rebalance_for_erase(
        __pos._M_node, __src_impl._M_header);
    --__src_impl._M_node_count;
    _M_insert_node(__res.first, __res.second,
     static_cast<_Link_type>(__ptr));
  }
     }
 }


      friend bool
      operator==(const _Rb_tree& __x, const _Rb_tree& __y)
      {
 return __x.size() == __y.size()
   && std::equal(__x.begin(), __x.end(), __y.begin());
      }

      friend bool
      operator<(const _Rb_tree& __x, const _Rb_tree& __y)
      {
 return std::lexicographical_compare(__x.begin(), __x.end(),
         __y.begin(), __y.end());
      }

      friend bool __attribute__ ((__deprecated__))
      operator!=(const _Rb_tree& __x, const _Rb_tree& __y)
      { return !(__x == __y); }

      friend bool __attribute__ ((__deprecated__))
      operator>(const _Rb_tree& __x, const _Rb_tree& __y)
      { return __y < __x; }

      friend bool __attribute__ ((__deprecated__))
      operator<=(const _Rb_tree& __x, const _Rb_tree& __y)
      { return !(__y < __x); }

      friend bool __attribute__ ((__deprecated__))
      operator>=(const _Rb_tree& __x, const _Rb_tree& __y)
      { return !(__x < __y); }
    };

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    inline void
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { __x.swap(__y); }


  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_move_data(_Rb_tree& __x, false_type)
    {
      if (_M_get_Node_allocator() == __x._M_get_Node_allocator())
 _M_move_data(__x, true_type());
      else
 {
   _Alloc_node __an(*this);
   auto __lbd =
     [&__an](const value_type& __cval)
     {
       auto& __val = const_cast<value_type&>(__cval);
       return __an(std::move_if_noexcept(__val));
     };
   _M_root() = _M_copy(__x, __lbd);
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    inline void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_move_assign(_Rb_tree& __x, true_type)
    {
      clear();
      if (__x._M_root() != nullptr)
 _M_move_data(__x, true_type());
      std::__alloc_on_move(_M_get_Node_allocator(),
      __x._M_get_Node_allocator());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_move_assign(_Rb_tree& __x, false_type)
    {
      if (_M_get_Node_allocator() == __x._M_get_Node_allocator())
 return _M_move_assign(__x, true_type{});



      _Reuse_or_alloc_node __roan(*this);
      _M_impl._M_reset();
      if (__x._M_root() != nullptr)
 {
   auto __lbd =
     [&__roan](const value_type& __cval)
     {
       auto& __val = const_cast<value_type&>(__cval);
       return __roan(std::move_if_noexcept(__val));
     };
   _M_root() = _M_copy(__x, __lbd);
   __x.clear();
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    inline _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    operator=(_Rb_tree&& __x)
    noexcept(_Alloc_traits::_S_nothrow_move()
      && is_nothrow_move_assignable<_Compare>::value)
    {
      _M_impl._M_key_compare = std::move(__x._M_impl._M_key_compare);
      _M_move_assign(__x, __bool_constant<_Alloc_traits::_S_nothrow_move()>());
      return *this;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    template<typename _Iterator>
      void
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_assign_unique(_Iterator __first, _Iterator __last)
      {
 _Reuse_or_alloc_node __roan(*this);
 _M_impl._M_reset();
 for (; __first != __last; ++__first)
   _M_insert_unique_(end(), *__first, __roan);
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    template<typename _Iterator>
      void
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_assign_equal(_Iterator __first, _Iterator __last)
      {
 _Reuse_or_alloc_node __roan(*this);
 _M_impl._M_reset();
 for (; __first != __last; ++__first)
   _M_insert_equal_(end(), *__first, __roan);
      }


  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    operator=(const _Rb_tree& __x)
    {
      if (this != &__x)
 {


   if (_Alloc_traits::_S_propagate_on_copy_assign())
     {
       auto& __this_alloc = this->_M_get_Node_allocator();
       auto& __that_alloc = __x._M_get_Node_allocator();
       if (!_Alloc_traits::_S_always_equal()
    && __this_alloc != __that_alloc)
  {


    clear();
    std::__alloc_on_copy(__this_alloc, __that_alloc);
  }
     }


   _Reuse_or_alloc_node __roan(*this);
   _M_impl._M_reset();
   _M_impl._M_key_compare = __x._M_impl._M_key_compare;
   if (__x._M_root() != 0)
     _M_root() = _M_copy(__x, __roan);
 }

      return *this;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>

    template<typename _Arg, typename _NodeGen>



      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_insert_(_Base_ptr __x, _Base_ptr __p,

   _Arg&& __v,



   _NodeGen& __node_gen)
      {
 bool __insert_left = (__x != 0 || __p == _M_end()
         || _M_impl._M_key_compare(_KeyOfValue()(__v),
       _S_key(__p)));

 _Link_type __z = __node_gen(std::forward<_Arg>(__v));

 _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
          this->_M_impl._M_header);
 ++_M_impl._M_node_count;
 return iterator(__z);
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>

    template<typename _Arg>

    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_lower(_Base_ptr __p, _Arg&& __v)



    {
      bool __insert_left = (__p == _M_end()
       || !_M_impl._M_key_compare(_S_key(__p),
             _KeyOfValue()(__v)));

      _Link_type __z = _M_create_node(std::forward<_Arg>(__v));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>

    template<typename _Arg>

    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_equal_lower(_Arg&& __v)



    {
      _Link_type __x = _M_begin();
      _Base_ptr __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ?
  _S_left(__x) : _S_right(__x);
 }
      return _M_insert_lower(__y, std::forward<_Arg>(__v));
    }

  template<typename _Key, typename _Val, typename _KoV,
    typename _Compare, typename _Alloc>
    template<typename _NodeGen>
      typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
      _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
      _M_copy(_Const_Link_type __x, _Base_ptr __p, _NodeGen& __node_gen)
      {

 _Link_type __top = _M_clone_node(__x, __node_gen);
 __top->_M_parent = __p;

 try
   {
     if (__x->_M_right)
       __top->_M_right = _M_copy(_S_right(__x), __top, __node_gen);
     __p = __top;
     __x = _S_left(__x);

     while (__x != 0)
       {
  _Link_type __y = _M_clone_node(__x, __node_gen);
  __p->_M_left = __y;
  __y->_M_parent = __p;
  if (__x->_M_right)
    __y->_M_right = _M_copy(_S_right(__x), __y, __node_gen);
  __p = __y;
  __x = _S_left(__x);
       }
   }
 catch(...)
   {
     _M_erase(__top);
     throw;
   }
 return __top;
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase(_Link_type __x)
    {

      while (__x != 0)
 {
   _M_erase(_S_right(__x));
   _Link_type __y = _S_left(__x);
   _M_drop_node(__x);
   __x = __y;
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Base_ptr __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Const_Link_type __x, _Const_Base_ptr __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Link_type __x, _Base_ptr __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Const_Link_type __x, _Const_Base_ptr __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Base_ptr __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Link_type __xu(__x);
       _Base_ptr __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<iterator,
     iterator>(_M_lower_bound(__x, __y, __k),
        _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<iterator, iterator>(iterator(__y),
          iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Base_ptr __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Const_Link_type __xu(__x);
       _Const_Base_ptr __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<const_iterator,
     const_iterator>(_M_lower_bound(__x, __y, __k),
       _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<const_iterator, const_iterator>(const_iterator(__y),
        const_iterator(__y));
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    swap(_Rb_tree& __t)
    noexcept(__is_nothrow_swappable<_Compare>::value)
    {
      if (_M_root() == 0)
 {
   if (__t._M_root() != 0)
     _M_impl._M_move_data(__t._M_impl);
 }
      else if (__t._M_root() == 0)
 __t._M_impl._M_move_data(_M_impl);
      else
 {
   std::swap(_M_root(),__t._M_root());
   std::swap(_M_leftmost(),__t._M_leftmost());
   std::swap(_M_rightmost(),__t._M_rightmost());

   _M_root()->_M_parent = _M_end();
   __t._M_root()->_M_parent = __t._M_end();
   std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
 }

      std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);

      _Alloc_traits::_S_on_swap(_M_get_Node_allocator(),
    __t._M_get_Node_allocator());
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_unique_pos(const key_type& __k)
    {
      typedef pair<_Base_ptr, _Base_ptr> _Res;
      _Link_type __x = _M_begin();
      _Base_ptr __y = _M_end();
      bool __comp = true;
      while (__x != 0)
 {
   __y = __x;
   __comp = _M_impl._M_key_compare(__k, _S_key(__x));
   __x = __comp ? _S_left(__x) : _S_right(__x);
 }
      iterator __j = iterator(__y);
      if (__comp)
 {
   if (__j == begin())
     return _Res(__x, __y);
   else
     --__j;
 }
      if (_M_impl._M_key_compare(_S_key(__j._M_node), __k))
 return _Res(__x, __y);
      return _Res(__j._M_node, 0);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_equal_pos(const key_type& __k)
    {
      typedef pair<_Base_ptr, _Base_ptr> _Res;
      _Link_type __x = _M_begin();
      _Base_ptr __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = _M_impl._M_key_compare(__k, _S_key(__x)) ?
  _S_left(__x) : _S_right(__x);
 }
      return _Res(__x, __y);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>

    template<typename _Arg>

    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator, bool>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_unique(_Arg&& __v)



    {
      typedef pair<iterator, bool> _Res;
      pair<_Base_ptr, _Base_ptr> __res
 = _M_get_insert_unique_pos(_KeyOfValue()(__v));

      if (__res.second)
 {
   _Alloc_node __an(*this);
   return _Res(_M_insert_(__res.first, __res.second,
     std::forward<_Arg>(__v), __an),
        true);
 }

      return _Res(iterator(__res.first), false);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>

    template<typename _Arg>

    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::

    _M_insert_equal(_Arg&& __v)



    {
      pair<_Base_ptr, _Base_ptr> __res
 = _M_get_insert_equal_pos(_KeyOfValue()(__v));
      _Alloc_node __an(*this);
      return _M_insert_(__res.first, __res.second,
   std::forward<_Arg>(__v), __an);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_hint_unique_pos(const_iterator __position,
      const key_type& __k)
    {
      iterator __pos = __position._M_const_cast();
      typedef pair<_Base_ptr, _Base_ptr> _Res;


      if (__pos._M_node == _M_end())
 {
   if (size() > 0
       && _M_impl._M_key_compare(_S_key(_M_rightmost()), __k))
     return _Res(0, _M_rightmost());
   else
     return _M_get_insert_unique_pos(__k);
 }
      else if (_M_impl._M_key_compare(__k, _S_key(__pos._M_node)))
 {

   iterator __before = __pos;
   if (__pos._M_node == _M_leftmost())
     return _Res(_M_leftmost(), _M_leftmost());
   else if (_M_impl._M_key_compare(_S_key((--__before)._M_node), __k))
     {
       if (_S_right(__before._M_node) == 0)
  return _Res(0, __before._M_node);
       else
  return _Res(__pos._M_node, __pos._M_node);
     }
   else
     return _M_get_insert_unique_pos(__k);
 }
      else if (_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
 {

   iterator __after = __pos;
   if (__pos._M_node == _M_rightmost())
     return _Res(0, _M_rightmost());
   else if (_M_impl._M_key_compare(__k, _S_key((++__after)._M_node)))
     {
       if (_S_right(__pos._M_node) == 0)
  return _Res(0, __pos._M_node);
       else
  return _Res(__after._M_node, __after._M_node);
     }
   else
     return _M_get_insert_unique_pos(__k);
 }
      else

 return _Res(__pos._M_node, 0);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>

    template<typename _Arg, typename _NodeGen>



      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_insert_unique_(const_iterator __position,

   _Arg&& __v,



   _NodeGen& __node_gen)
    {
      pair<_Base_ptr, _Base_ptr> __res
 = _M_get_insert_hint_unique_pos(__position, _KeyOfValue()(__v));

      if (__res.second)
 return _M_insert_(__res.first, __res.second,
     std::forward<_Arg>(__v),
     __node_gen);
      return iterator(__res.first);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::_Base_ptr>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_get_insert_hint_equal_pos(const_iterator __position, const key_type& __k)
    {
      iterator __pos = __position._M_const_cast();
      typedef pair<_Base_ptr, _Base_ptr> _Res;


      if (__pos._M_node == _M_end())
 {
   if (size() > 0
       && !_M_impl._M_key_compare(__k, _S_key(_M_rightmost())))
     return _Res(0, _M_rightmost());
   else
     return _M_get_insert_equal_pos(__k);
 }
      else if (!_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
 {

   iterator __before = __pos;
   if (__pos._M_node == _M_leftmost())
     return _Res(_M_leftmost(), _M_leftmost());
   else if (!_M_impl._M_key_compare(__k, _S_key((--__before)._M_node)))
     {
       if (_S_right(__before._M_node) == 0)
  return _Res(0, __before._M_node);
       else
  return _Res(__pos._M_node, __pos._M_node);
     }
   else
     return _M_get_insert_equal_pos(__k);
 }
      else
 {

   iterator __after = __pos;
   if (__pos._M_node == _M_rightmost())
     return _Res(0, _M_rightmost());
   else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node), __k))
     {
       if (_S_right(__pos._M_node) == 0)
  return _Res(0, __pos._M_node);
       else
  return _Res(__after._M_node, __after._M_node);
     }
   else
     return _Res(0, 0);
 }
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>

    template<typename _Arg, typename _NodeGen>



      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_insert_equal_(const_iterator __position,

         _Arg&& __v,



         _NodeGen& __node_gen)
      {
 pair<_Base_ptr, _Base_ptr> __res
   = _M_get_insert_hint_equal_pos(__position, _KeyOfValue()(__v));

 if (__res.second)
   return _M_insert_(__res.first, __res.second,
       std::forward<_Arg>(__v),
       __node_gen);

 return _M_insert_equal_lower(std::forward<_Arg>(__v));
      }


  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_node(_Base_ptr __x, _Base_ptr __p, _Link_type __z)
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || _M_impl._M_key_compare(_S_key(__z),
            _S_key(__p)));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_lower_node(_Base_ptr __p, _Link_type __z)
    {
      bool __insert_left = (__p == _M_end()
       || !_M_impl._M_key_compare(_S_key(__p),
             _S_key(__z)));

      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal_lower_node(_Link_type __z)
    {
      _Link_type __x = _M_begin();
      _Base_ptr __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = !_M_impl._M_key_compare(_S_key(__x), _S_key(__z)) ?
  _S_left(__x) : _S_right(__x);
 }
      return _M_insert_lower_node(__y, __z);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    template<typename... _Args>
      pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator, bool>
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_unique(_Args&&... __args)
      {
 _Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

 try
   {
     typedef pair<iterator, bool> _Res;
     auto __res = _M_get_insert_unique_pos(_S_key(__z));
     if (__res.second)
       return _Res(_M_insert_node(__res.first, __res.second, __z), true);

     _M_drop_node(__z);
     return _Res(iterator(__res.first), false);
   }
 catch(...)
   {
     _M_drop_node(__z);
     throw;
   }
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    template<typename... _Args>
      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_equal(_Args&&... __args)
      {
 _Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

 try
   {
     auto __res = _M_get_insert_equal_pos(_S_key(__z));
     return _M_insert_node(__res.first, __res.second, __z);
   }
 catch(...)
   {
     _M_drop_node(__z);
     throw;
   }
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    template<typename... _Args>
      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_hint_unique(const_iterator __pos, _Args&&... __args)
      {
 _Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

 try
   {
     auto __res = _M_get_insert_hint_unique_pos(__pos, _S_key(__z));

     if (__res.second)
       return _M_insert_node(__res.first, __res.second, __z);

     _M_drop_node(__z);
     return iterator(__res.first);
   }
 catch(...)
   {
     _M_drop_node(__z);
     throw;
   }
      }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    template<typename... _Args>
      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
      _M_emplace_hint_equal(const_iterator __pos, _Args&&... __args)
      {
 _Link_type __z = _M_create_node(std::forward<_Args>(__args)...);

 try
   {
     auto __res = _M_get_insert_hint_equal_pos(__pos, _S_key(__z));

     if (__res.second)
       return _M_insert_node(__res.first, __res.second, __z);

     return _M_insert_equal_lower_node(__z);
   }
 catch(...)
   {
     _M_drop_node(__z);
     throw;
   }
      }



  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase_aux(const_iterator __position)
    {
      _Link_type __y =
 static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
    (const_cast<_Base_ptr>(__position._M_node),
     this->_M_impl._M_header));
      _M_drop_node(__y);
      --_M_impl._M_node_count;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase_aux(const_iterator __first, const_iterator __last)
    {
      if (__first == begin() && __last == end())
 clear();
      else
 while (__first != __last)
   _M_erase_aux(__first++);
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key& __x)
    {
      pair<iterator, iterator> __p = equal_range(__x);
      const size_type __old_size = size();
      _M_erase_aux(__p.first, __p.second);
      return __old_size - size();
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k)
    {
      iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k) const
    {
      const_iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    count(const _Key& __k) const
    {
      pair<const_iterator, const_iterator> __p = equal_range(__k);
      const size_type __n = std::distance(__p.first, __p.second);
      return __n;
    }

  __attribute__ ((__pure__)) unsigned int
  _Rb_tree_black_count(const _Rb_tree_node_base* __node,
         const _Rb_tree_node_base* __root) throw ();

  template<typename _Key, typename _Val, typename _KeyOfValue,
    typename _Compare, typename _Alloc>
    bool
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
    {
      if (_M_impl._M_node_count == 0 || begin() == end())
 return _M_impl._M_node_count == 0 && begin() == end()
        && this->_M_impl._M_header._M_left == _M_end()
        && this->_M_impl._M_header._M_right == _M_end();

      unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());
      for (const_iterator __it = begin(); __it != end(); ++__it)
 {
   _Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);
   _Const_Link_type __L = _S_left(__x);
   _Const_Link_type __R = _S_right(__x);

   if (__x->_M_color == _S_red)
     if ((__L && __L->_M_color == _S_red)
  || (__R && __R->_M_color == _S_red))
       return false;

   if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
     return false;
   if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
     return false;

   if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)
     return false;
 }

      if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
 return false;
      if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
 return false;
      return true;
    }



  template<typename _Key, typename _Val, typename _Sel, typename _Cmp1,
    typename _Alloc, typename _Cmp2>
    struct _Rb_tree_merge_helper<_Rb_tree<_Key, _Val, _Sel, _Cmp1, _Alloc>,
     _Cmp2>
    {
    private:
      friend class _Rb_tree<_Key, _Val, _Sel, _Cmp1, _Alloc>;

      static auto&
      _S_get_impl(_Rb_tree<_Key, _Val, _Sel, _Cmp2, _Alloc>& __tree)
      { return __tree._M_impl; }
    };



}
# 61 "/usr/local/include/c++/10.0.0/set" 2 3
# 1 "/usr/local/include/c++/10.0.0/bits/stl_set.h" 1 3
# 64 "/usr/local/include/c++/10.0.0/bits/stl_set.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Key, typename _Compare, typename _Alloc>
    class multiset;
# 92 "/usr/local/include/c++/10.0.0/bits/stl_set.h" 3
  template<typename _Key, typename _Compare = std::less<_Key>,
    typename _Alloc = std::allocator<_Key> >
    class set
    {
# 108 "/usr/local/include/c++/10.0.0/bits/stl_set.h" 3
      static_assert(is_same<typename remove_cv<_Key>::type, _Key>::value,
   "std::set must have a non-const, non-volatile value_type");

      static_assert(is_same<typename _Alloc::value_type, _Key>::value,
   "std::set must have the same value_type as its allocator");



    public:



      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;


    private:
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_Key>::other _Key_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
         key_compare, _Key_alloc_type> _Rep_type;
      _Rep_type _M_t;

      typedef __gnu_cxx::__alloc_traits<_Key_alloc_type> _Alloc_traits;

    public:


      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;



      typedef typename _Rep_type::const_iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;



      using node_type = typename _Rep_type::node_type;
      using insert_return_type = typename _Rep_type::insert_return_type;
# 167 "/usr/local/include/c++/10.0.0/bits/stl_set.h" 3
      set() = default;







      explicit
      set(const _Compare& __comp,
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Key_alloc_type(__a)) { }
# 190 "/usr/local/include/c++/10.0.0/bits/stl_set.h" 3
      template<typename _InputIterator>
 set(_InputIterator __first, _InputIterator __last)
 : _M_t()
 { _M_t._M_insert_range_unique(__first, __last); }
# 207 "/usr/local/include/c++/10.0.0/bits/stl_set.h" 3
      template<typename _InputIterator>
 set(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp,
     const allocator_type& __a = allocator_type())
 : _M_t(__comp, _Key_alloc_type(__a))
 { _M_t._M_insert_range_unique(__first, __last); }
# 223 "/usr/local/include/c++/10.0.0/bits/stl_set.h" 3
      set(const set&) = default;







      set(set&&) = default;
# 243 "/usr/local/include/c++/10.0.0/bits/stl_set.h" 3
      set(initializer_list<value_type> __l,
   const _Compare& __comp = _Compare(),
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Key_alloc_type(__a))
      { _M_t._M_insert_range_unique(__l.begin(), __l.end()); }


      explicit
      set(const allocator_type& __a)
      : _M_t(_Key_alloc_type(__a)) { }


      set(const set& __x, const allocator_type& __a)
      : _M_t(__x._M_t, _Key_alloc_type(__a)) { }


      set(set&& __x, const allocator_type& __a)
      noexcept(is_nothrow_copy_constructible<_Compare>::value
        && _Alloc_traits::_S_always_equal())
      : _M_t(std::move(__x._M_t), _Key_alloc_type(__a)) { }


      set(initializer_list<value_type> __l, const allocator_type& __a)
      : _M_t(_Key_alloc_type(__a))
      { _M_t._M_insert_range_unique(__l.begin(), __l.end()); }


      template<typename _InputIterator>
 set(_InputIterator __first, _InputIterator __last,
     const allocator_type& __a)
 : _M_t(_Key_alloc_type(__a))
 { _M_t._M_insert_range_unique(__first, __last); }






      ~set() = default;
# 297 "/usr/local/include/c++/10.0.0/bits/stl_set.h" 3
      set&
      operator=(const set&) = default;


      set&
      operator=(set&&) = default;
# 315 "/usr/local/include/c++/10.0.0/bits/stl_set.h" 3
      set&
      operator=(initializer_list<value_type> __l)
      {
 _M_t._M_assign_unique(__l.begin(), __l.end());
 return *this;
      }





      key_compare
      key_comp() const
      { return _M_t.key_comp(); }

      value_compare
      value_comp() const
      { return _M_t.key_comp(); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_t.get_allocator()); }






      iterator
      begin() const noexcept
      { return _M_t.begin(); }






      iterator
      end() const noexcept
      { return _M_t.end(); }






      reverse_iterator
      rbegin() const noexcept
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() const noexcept
      { return _M_t.rend(); }







      iterator
      cbegin() const noexcept
      { return _M_t.begin(); }






      iterator
      cend() const noexcept
      { return _M_t.end(); }






      reverse_iterator
      crbegin() const noexcept
      { return _M_t.rbegin(); }






      reverse_iterator
      crend() const noexcept
      { return _M_t.rend(); }



      [[__nodiscard__]] bool
      empty() const noexcept
      { return _M_t.empty(); }


      size_type
      size() const noexcept
      { return _M_t.size(); }


      size_type
      max_size() const noexcept
      { return _M_t.max_size(); }
# 440 "/usr/local/include/c++/10.0.0/bits/stl_set.h" 3
      void
      swap(set& __x)
      noexcept(__is_nothrow_swappable<_Compare>::value)
      { _M_t.swap(__x._M_t); }
# 460 "/usr/local/include/c++/10.0.0/bits/stl_set.h" 3
      template<typename... _Args>
 std::pair<iterator, bool>
 emplace(_Args&&... __args)
 { return _M_t._M_emplace_unique(std::forward<_Args>(__args)...); }
# 486 "/usr/local/include/c++/10.0.0/bits/stl_set.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 {
   return _M_t._M_emplace_hint_unique(__pos,
          std::forward<_Args>(__args)...);
 }
# 508 "/usr/local/include/c++/10.0.0/bits/stl_set.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      {
 std::pair<typename _Rep_type::iterator, bool> __p =
   _M_t._M_insert_unique(__x);
 return std::pair<iterator, bool>(__p.first, __p.second);
      }


      std::pair<iterator, bool>
      insert(value_type&& __x)
      {
 std::pair<typename _Rep_type::iterator, bool> __p =
   _M_t._M_insert_unique(std::move(__x));
 return std::pair<iterator, bool>(__p.first, __p.second);
      }
# 545 "/usr/local/include/c++/10.0.0/bits/stl_set.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x)
      { return _M_t._M_insert_unique_(__position, __x); }


      iterator
      insert(const_iterator __position, value_type&& __x)
      { return _M_t._M_insert_unique_(__position, std::move(__x)); }
# 564 "/usr/local/include/c++/10.0.0/bits/stl_set.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_t._M_insert_range_unique(__first, __last); }
# 577 "/usr/local/include/c++/10.0.0/bits/stl_set.h" 3
      void
      insert(initializer_list<value_type> __l)
      { this->insert(__l.begin(), __l.end()); }




      node_type
      extract(const_iterator __pos)
      {
 ;
 return _M_t.extract(__pos);
      }


      node_type
      extract(const key_type& __x)
      { return _M_t.extract(__x); }


      insert_return_type
      insert(node_type&& __nh)
      { return _M_t._M_reinsert_node_unique(std::move(__nh)); }


      iterator
      insert(const_iterator __hint, node_type&& __nh)
      { return _M_t._M_reinsert_node_hint_unique(__hint, std::move(__nh)); }

      template<typename, typename>
 friend class std::_Rb_tree_merge_helper;

      template<typename _Compare1>
 void
 merge(set<_Key, _Compare1, _Alloc>& __source)
 {
   using _Merge_helper = _Rb_tree_merge_helper<set, _Compare1>;
   _M_t._M_merge_unique(_Merge_helper::_S_get_tree(__source));
 }

      template<typename _Compare1>
 void
 merge(set<_Key, _Compare1, _Alloc>&& __source)
 { merge(__source); }

      template<typename _Compare1>
 void
 merge(multiset<_Key, _Compare1, _Alloc>& __source)
 {
   using _Merge_helper = _Rb_tree_merge_helper<set, _Compare1>;
   _M_t._M_merge_unique(_Merge_helper::_S_get_tree(__source));
 }

      template<typename _Compare1>
 void
 merge(multiset<_Key, _Compare1, _Alloc>&& __source)
 { merge(__source); }
# 652 "/usr/local/include/c++/10.0.0/bits/stl_set.h" 3
      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(const_iterator __position)
      { return _M_t.erase(__position); }
# 683 "/usr/local/include/c++/10.0.0/bits/stl_set.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 704 "/usr/local/include/c++/10.0.0/bits/stl_set.h" 3
      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_t.erase(__first, __last); }
# 732 "/usr/local/include/c++/10.0.0/bits/stl_set.h" 3
      void
      clear() noexcept
      { _M_t.clear(); }
# 747 "/usr/local/include/c++/10.0.0/bits/stl_set.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }


      template<typename _Kt>
 auto
 count(const _Kt& __x) const
 -> decltype(_M_t._M_count_tr(__x))
 { return _M_t._M_count_tr(__x); }
# 767 "/usr/local/include/c++/10.0.0/bits/stl_set.h" 3
      bool
      contains(const key_type& __x) const
      { return _M_t.find(__x) != _M_t.end(); }

      template<typename _Kt>
 auto
 contains(const _Kt& __x) const
 -> decltype(_M_t._M_find_tr(__x), void(), true)
 { return _M_t._M_find_tr(__x) != _M_t.end(); }
# 793 "/usr/local/include/c++/10.0.0/bits/stl_set.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }


      template<typename _Kt>
 auto
 find(const _Kt& __x)
 -> decltype(iterator{_M_t._M_find_tr(__x)})
 { return iterator{_M_t._M_find_tr(__x)}; }

      template<typename _Kt>
 auto
 find(const _Kt& __x) const
 -> decltype(const_iterator{_M_t._M_find_tr(__x)})
 { return const_iterator{_M_t._M_find_tr(__x)}; }
# 828 "/usr/local/include/c++/10.0.0/bits/stl_set.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }


      template<typename _Kt>
 auto
 lower_bound(const _Kt& __x)
 -> decltype(iterator(_M_t._M_lower_bound_tr(__x)))
 { return iterator(_M_t._M_lower_bound_tr(__x)); }

      template<typename _Kt>
 auto
 lower_bound(const _Kt& __x) const
 -> decltype(const_iterator(_M_t._M_lower_bound_tr(__x)))
 { return const_iterator(_M_t._M_lower_bound_tr(__x)); }
# 858 "/usr/local/include/c++/10.0.0/bits/stl_set.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }


      template<typename _Kt>
 auto
 upper_bound(const _Kt& __x)
 -> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
 { return iterator(_M_t._M_upper_bound_tr(__x)); }

      template<typename _Kt>
 auto
 upper_bound(const _Kt& __x) const
 -> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
 { return const_iterator(_M_t._M_upper_bound_tr(__x)); }
# 897 "/usr/local/include/c++/10.0.0/bits/stl_set.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }


      template<typename _Kt>
 auto
 equal_range(const _Kt& __x)
 -> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
 { return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }

      template<typename _Kt>
 auto
 equal_range(const _Kt& __x) const
 -> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
 { return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }



      template<typename _K1, typename _C1, typename _A1>
 friend bool
 operator==(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);

      template<typename _K1, typename _C1, typename _A1>
 friend bool
 operator<(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);
    };



  template<typename _InputIterator,
    typename _Compare =
      less<typename iterator_traits<_InputIterator>::value_type>,
    typename _Allocator =
      allocator<typename iterator_traits<_InputIterator>::value_type>,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireNotAllocator<_Compare>,
    typename = _RequireAllocator<_Allocator>>
    set(_InputIterator, _InputIterator,
 _Compare = _Compare(), _Allocator = _Allocator())
    -> set<typename iterator_traits<_InputIterator>::value_type,
   _Compare, _Allocator>;

  template<typename _Key, typename _Compare = less<_Key>,
    typename _Allocator = allocator<_Key>,
    typename = _RequireNotAllocator<_Compare>,
    typename = _RequireAllocator<_Allocator>>
    set(initializer_list<_Key>,
 _Compare = _Compare(), _Allocator = _Allocator())
    -> set<_Key, _Compare, _Allocator>;

  template<typename _InputIterator, typename _Allocator,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireAllocator<_Allocator>>
    set(_InputIterator, _InputIterator, _Allocator)
    -> set<typename iterator_traits<_InputIterator>::value_type,
    less<typename iterator_traits<_InputIterator>::value_type>,
    _Allocator>;

  template<typename _Key, typename _Allocator,
    typename = _RequireAllocator<_Allocator>>
    set(initializer_list<_Key>, _Allocator)
    -> set<_Key, less<_Key>, _Allocator>;
# 977 "/usr/local/include/c++/10.0.0/bits/stl_set.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator==(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 994 "/usr/local/include/c++/10.0.0/bits/stl_set.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<(const set<_Key, _Compare, _Alloc>& __x,
       const set<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>(const set<_Key, _Compare, _Alloc>& __x,
       const set<_Key, _Compare, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline void
    swap(set<_Key, _Compare, _Alloc>& __x, set<_Key, _Compare, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }





  template<typename _Val, typename _Cmp1, typename _Alloc, typename _Cmp2>
    struct
    _Rb_tree_merge_helper<std::set<_Val, _Cmp1, _Alloc>, _Cmp2>
    {
    private:
      friend class std::set<_Val, _Cmp1, _Alloc>;

      static auto&
      _S_get_tree(std::set<_Val, _Cmp2, _Alloc>& __set)
      { return __set._M_t; }

      static auto&
      _S_get_tree(std::multiset<_Val, _Cmp2, _Alloc>& __set)
      { return __set._M_t; }
    };

namespace ranges::__detail
{
  template<typename _Tp> extern inline const bool __enable_view_impl;
  template<typename _Key, typename _Compare, typename _Alloc>
    inline constexpr bool
      __enable_view_impl<std::set<_Key, _Compare, _Alloc>> = false;
}




}
# 62 "/usr/local/include/c++/10.0.0/set" 2 3
# 1 "/usr/local/include/c++/10.0.0/bits/stl_multiset.h" 1 3
# 64 "/usr/local/include/c++/10.0.0/bits/stl_multiset.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Key, typename _Compare, typename _Alloc>
    class set;
# 94 "/usr/local/include/c++/10.0.0/bits/stl_multiset.h" 3
  template <typename _Key, typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<_Key> >
    class multiset
    {
# 110 "/usr/local/include/c++/10.0.0/bits/stl_multiset.h" 3
      static_assert(is_same<typename remove_cv<_Key>::type, _Key>::value,
   "std::multiset must have a non-const, non-volatile value_type");

      static_assert(is_same<typename _Alloc::value_type, _Key>::value,
   "std::multiset must have the same value_type as its allocator");



    public:

      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;

    private:

      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_Key>::other _Key_alloc_type;

      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
         key_compare, _Key_alloc_type> _Rep_type;

      _Rep_type _M_t;

      typedef __gnu_cxx::__alloc_traits<_Key_alloc_type> _Alloc_traits;

    public:
      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;



      typedef typename _Rep_type::const_iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;


      using node_type = typename _Rep_type::node_type;
# 164 "/usr/local/include/c++/10.0.0/bits/stl_multiset.h" 3
      multiset() = default;







      explicit
      multiset(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Key_alloc_type(__a)) { }
# 186 "/usr/local/include/c++/10.0.0/bits/stl_multiset.h" 3
      template<typename _InputIterator>
 multiset(_InputIterator __first, _InputIterator __last)
 : _M_t()
 { _M_t._M_insert_range_equal(__first, __last); }
# 202 "/usr/local/include/c++/10.0.0/bits/stl_multiset.h" 3
      template<typename _InputIterator>
 multiset(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
 : _M_t(__comp, _Key_alloc_type(__a))
 { _M_t._M_insert_range_equal(__first, __last); }
# 218 "/usr/local/include/c++/10.0.0/bits/stl_multiset.h" 3
      multiset(const multiset&) = default;
# 227 "/usr/local/include/c++/10.0.0/bits/stl_multiset.h" 3
      multiset(multiset&&) = default;
# 239 "/usr/local/include/c++/10.0.0/bits/stl_multiset.h" 3
      multiset(initializer_list<value_type> __l,
        const _Compare& __comp = _Compare(),
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, _Key_alloc_type(__a))
      { _M_t._M_insert_range_equal(__l.begin(), __l.end()); }


      explicit
      multiset(const allocator_type& __a)
      : _M_t(_Key_alloc_type(__a)) { }


      multiset(const multiset& __m, const allocator_type& __a)
      : _M_t(__m._M_t, _Key_alloc_type(__a)) { }


      multiset(multiset&& __m, const allocator_type& __a)
      noexcept(is_nothrow_copy_constructible<_Compare>::value
        && _Alloc_traits::_S_always_equal())
      : _M_t(std::move(__m._M_t), _Key_alloc_type(__a)) { }


      multiset(initializer_list<value_type> __l, const allocator_type& __a)
      : _M_t(_Key_alloc_type(__a))
      { _M_t._M_insert_range_equal(__l.begin(), __l.end()); }


      template<typename _InputIterator>
 multiset(_InputIterator __first, _InputIterator __last,
   const allocator_type& __a)
 : _M_t(_Key_alloc_type(__a))
 { _M_t._M_insert_range_equal(__first, __last); }






      ~multiset() = default;
# 293 "/usr/local/include/c++/10.0.0/bits/stl_multiset.h" 3
      multiset&
      operator=(const multiset&) = default;


      multiset&
      operator=(multiset&&) = default;
# 311 "/usr/local/include/c++/10.0.0/bits/stl_multiset.h" 3
      multiset&
      operator=(initializer_list<value_type> __l)
      {
 _M_t._M_assign_equal(__l.begin(), __l.end());
 return *this;
      }





      key_compare
      key_comp() const
      { return _M_t.key_comp(); }

      value_compare
      value_comp() const
      { return _M_t.key_comp(); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_t.get_allocator()); }






      iterator
      begin() const noexcept
      { return _M_t.begin(); }






      iterator
      end() const noexcept
      { return _M_t.end(); }






      reverse_iterator
      rbegin() const noexcept
      { return _M_t.rbegin(); }






      reverse_iterator
      rend() const noexcept
      { return _M_t.rend(); }







      iterator
      cbegin() const noexcept
      { return _M_t.begin(); }






      iterator
      cend() const noexcept
      { return _M_t.end(); }






      reverse_iterator
      crbegin() const noexcept
      { return _M_t.rbegin(); }






      reverse_iterator
      crend() const noexcept
      { return _M_t.rend(); }



      [[__nodiscard__]] bool
      empty() const noexcept
      { return _M_t.empty(); }


      size_type
      size() const noexcept
      { return _M_t.size(); }


      size_type
      max_size() const noexcept
      { return _M_t.max_size(); }
# 436 "/usr/local/include/c++/10.0.0/bits/stl_multiset.h" 3
      void
      swap(multiset& __x)
      noexcept(__is_nothrow_swappable<_Compare>::value)
      { _M_t.swap(__x._M_t); }
# 455 "/usr/local/include/c++/10.0.0/bits/stl_multiset.h" 3
      template<typename... _Args>
 iterator
 emplace(_Args&&... __args)
 { return _M_t._M_emplace_equal(std::forward<_Args>(__args)...); }
# 481 "/usr/local/include/c++/10.0.0/bits/stl_multiset.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 {
   return _M_t._M_emplace_hint_equal(__pos,
         std::forward<_Args>(__args)...);
 }
# 501 "/usr/local/include/c++/10.0.0/bits/stl_multiset.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }


      iterator
      insert(value_type&& __x)
      { return _M_t._M_insert_equal(std::move(__x)); }
# 531 "/usr/local/include/c++/10.0.0/bits/stl_multiset.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x)
      { return _M_t._M_insert_equal_(__position, __x); }


      iterator
      insert(const_iterator __position, value_type&& __x)
      { return _M_t._M_insert_equal_(__position, std::move(__x)); }
# 549 "/usr/local/include/c++/10.0.0/bits/stl_multiset.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_t._M_insert_range_equal(__first, __last); }
# 562 "/usr/local/include/c++/10.0.0/bits/stl_multiset.h" 3
      void
      insert(initializer_list<value_type> __l)
      { this->insert(__l.begin(), __l.end()); }




      node_type
      extract(const_iterator __pos)
      {
 ;
 return _M_t.extract(__pos);
      }


      node_type
      extract(const key_type& __x)
      { return _M_t.extract(__x); }


      iterator
      insert(node_type&& __nh)
      { return _M_t._M_reinsert_node_equal(std::move(__nh)); }


      iterator
      insert(const_iterator __hint, node_type&& __nh)
      { return _M_t._M_reinsert_node_hint_equal(__hint, std::move(__nh)); }

      template<typename, typename>
 friend class std::_Rb_tree_merge_helper;

      template<typename _Compare1>
 void
 merge(multiset<_Key, _Compare1, _Alloc>& __source)
 {
   using _Merge_helper = _Rb_tree_merge_helper<multiset, _Compare1>;
   _M_t._M_merge_equal(_Merge_helper::_S_get_tree(__source));
 }

      template<typename _Compare1>
 void
 merge(multiset<_Key, _Compare1, _Alloc>&& __source)
 { merge(__source); }

      template<typename _Compare1>
 void
 merge(set<_Key, _Compare1, _Alloc>& __source)
 {
   using _Merge_helper = _Rb_tree_merge_helper<multiset, _Compare1>;
   _M_t._M_merge_equal(_Merge_helper::_S_get_tree(__source));
 }

      template<typename _Compare1>
 void
 merge(set<_Key, _Compare1, _Alloc>&& __source)
 { merge(__source); }
# 637 "/usr/local/include/c++/10.0.0/bits/stl_multiset.h" 3
      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(const_iterator __position)
      { return _M_t.erase(__position); }
# 668 "/usr/local/include/c++/10.0.0/bits/stl_multiset.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
# 689 "/usr/local/include/c++/10.0.0/bits/stl_multiset.h" 3
      __attribute ((__abi_tag__ ("cxx11")))
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_t.erase(__first, __last); }
# 717 "/usr/local/include/c++/10.0.0/bits/stl_multiset.h" 3
      void
      clear() noexcept
      { _M_t.clear(); }
# 729 "/usr/local/include/c++/10.0.0/bits/stl_multiset.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }


      template<typename _Kt>
 auto
 count(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))
 { return _M_t._M_count_tr(__x); }
# 748 "/usr/local/include/c++/10.0.0/bits/stl_multiset.h" 3
      bool
      contains(const key_type& __x) const
      { return _M_t.find(__x) != _M_t.end(); }

      template<typename _Kt>
 auto
 contains(const _Kt& __x) const
 -> decltype(_M_t._M_find_tr(__x), void(), true)
 { return _M_t._M_find_tr(__x) != _M_t.end(); }
# 774 "/usr/local/include/c++/10.0.0/bits/stl_multiset.h" 3
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }


      template<typename _Kt>
 auto
 find(const _Kt& __x)
 -> decltype(iterator{_M_t._M_find_tr(__x)})
 { return iterator{_M_t._M_find_tr(__x)}; }

      template<typename _Kt>
 auto
 find(const _Kt& __x) const
 -> decltype(const_iterator{_M_t._M_find_tr(__x)})
 { return const_iterator{_M_t._M_find_tr(__x)}; }
# 809 "/usr/local/include/c++/10.0.0/bits/stl_multiset.h" 3
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }

      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }


      template<typename _Kt>
 auto
 lower_bound(const _Kt& __x)
 -> decltype(iterator(_M_t._M_lower_bound_tr(__x)))
 { return iterator(_M_t._M_lower_bound_tr(__x)); }

      template<typename _Kt>
 auto
 lower_bound(const _Kt& __x) const
 -> decltype(iterator(_M_t._M_lower_bound_tr(__x)))
 { return iterator(_M_t._M_lower_bound_tr(__x)); }
# 839 "/usr/local/include/c++/10.0.0/bits/stl_multiset.h" 3
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }

      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }


      template<typename _Kt>
 auto
 upper_bound(const _Kt& __x)
 -> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
 { return iterator(_M_t._M_upper_bound_tr(__x)); }

      template<typename _Kt>
 auto
 upper_bound(const _Kt& __x) const
 -> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
 { return iterator(_M_t._M_upper_bound_tr(__x)); }
# 878 "/usr/local/include/c++/10.0.0/bits/stl_multiset.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }


      template<typename _Kt>
 auto
 equal_range(const _Kt& __x)
 -> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
 { return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }

      template<typename _Kt>
 auto
 equal_range(const _Kt& __x) const
 -> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
 { return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }



      template<typename _K1, typename _C1, typename _A1>
 friend bool
 operator==(const multiset<_K1, _C1, _A1>&,
     const multiset<_K1, _C1, _A1>&);

      template<typename _K1, typename _C1, typename _A1>
 friend bool
 operator< (const multiset<_K1, _C1, _A1>&,
     const multiset<_K1, _C1, _A1>&);
    };



  template<typename _InputIterator,
    typename _Compare =
      less<typename iterator_traits<_InputIterator>::value_type>,
    typename _Allocator =
      allocator<typename iterator_traits<_InputIterator>::value_type>,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireNotAllocator<_Compare>,
    typename = _RequireAllocator<_Allocator>>
    multiset(_InputIterator, _InputIterator,
      _Compare = _Compare(), _Allocator = _Allocator())
    -> multiset<typename iterator_traits<_InputIterator>::value_type,
  _Compare, _Allocator>;

  template<typename _Key,
    typename _Compare = less<_Key>,
    typename _Allocator = allocator<_Key>,
    typename = _RequireNotAllocator<_Compare>,
    typename = _RequireAllocator<_Allocator>>
    multiset(initializer_list<_Key>,
      _Compare = _Compare(), _Allocator = _Allocator())
    -> multiset<_Key, _Compare, _Allocator>;

  template<typename _InputIterator, typename _Allocator,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireAllocator<_Allocator>>
    multiset(_InputIterator, _InputIterator, _Allocator)
    -> multiset<typename iterator_traits<_InputIterator>::value_type,
         less<typename iterator_traits<_InputIterator>::value_type>,
         _Allocator>;

  template<typename _Key, typename _Allocator,
    typename = _RequireAllocator<_Allocator>>
    multiset(initializer_list<_Key>, _Allocator)
    -> multiset<_Key, less<_Key>, _Allocator>;
# 962 "/usr/local/include/c++/10.0.0/bits/stl_multiset.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
# 979 "/usr/local/include/c++/10.0.0/bits/stl_multiset.h" 3
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multiset<_Key, _Compare, _Alloc>& __x,
       const multiset<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multiset<_Key,_Compare,_Alloc>& __x,
       const multiset<_Key,_Compare,_Alloc>& __y)
    { return __y < __x; }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Key, typename _Compare, typename _Alloc>
    inline void
    swap(multiset<_Key, _Compare, _Alloc>& __x,
  multiset<_Key, _Compare, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }





  template<typename _Val, typename _Cmp1, typename _Alloc, typename _Cmp2>
    struct
    _Rb_tree_merge_helper<std::multiset<_Val, _Cmp1, _Alloc>,
     _Cmp2>
    {
    private:
      friend class std::multiset<_Val, _Cmp1, _Alloc>;

      static auto&
      _S_get_tree(std::set<_Val, _Cmp2, _Alloc>& __set)
      { return __set._M_t; }

      static auto&
      _S_get_tree(std::multiset<_Val, _Cmp2, _Alloc>& __set)
      { return __set._M_t; }
    };


namespace ranges::__detail
{
  template<typename _Tp> extern inline const bool __enable_view_impl;
  template<typename _Key, typename _Compare, typename _Alloc>
    inline constexpr bool
      __enable_view_impl<std::multiset<_Key, _Compare, _Alloc>>
 = false;
}




}
# 63 "/usr/local/include/c++/10.0.0/set" 2 3
# 71 "/usr/local/include/c++/10.0.0/set" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

  namespace pmr
  {
    template<typename _Tp> class polymorphic_allocator;
    template<typename _Key, typename _Cmp = std::less<_Key>>
      using set = std::set<_Key, _Cmp, polymorphic_allocator<_Key>>;
    template<typename _Key, typename _Cmp = std::less<_Key>>
      using multiset = std::multiset<_Key, _Cmp, polymorphic_allocator<_Key>>;
  }

}



namespace std __attribute__ ((__visibility__ ("default")))
{

  template<typename _Key, typename _Compare, typename _Alloc,
    typename _Predicate>
    inline typename set<_Key, _Compare, _Alloc>::size_type
    erase_if(set<_Key, _Compare, _Alloc>& __cont, _Predicate __pred)
    { return __detail::__erase_nodes_if(__cont, __pred); }

  template<typename _Key, typename _Compare, typename _Alloc,
    typename _Predicate>
    inline typename multiset<_Key, _Compare, _Alloc>::size_type
    erase_if(multiset<_Key, _Compare, _Alloc>& __cont, _Predicate __pred)
    { return __detail::__erase_nodes_if(__cont, __pred); }

}
# 8 "tree.h" 2



# 10 "tree.h"
template<typename T>
struct PrintSizeof
{
 template<std::size_t size>
 struct PrintSizeof_impl;
 PrintSizeof()
 {
  PrintSizeof_impl<sizeof(T)> a;
 }
};

struct Keyword;

template<typename T, std::size_t chunk_size = 1024, std::size_t init_chunks = 1024>
struct MemoryPool
{
 std::vector<void *> pools;
 std::size_t num_of_allocated_elements_in_current_chunk;
 void *next_free_element;
 MemoryPool() : num_of_allocated_elements_in_current_chunk(0), next_free_element(nullptr)
 {
  pools.reserve(init_chunks);
  allocate_chunk();
 }
 MemoryPool(MemoryPool const &a) = delete;
 MemoryPool(MemoryPool &&a) = delete;
 MemoryPool &operator=(MemoryPool const &a) = delete;
 MemoryPool &operator=(MemoryPool &&a) = delete;
 ~MemoryPool() noexcept
 {
  try
  {
   for (std::size_t i(0); i < pools.size(); ++i)
   {
    void *ptr(pools[i]);
    T *all_elements(static_cast<T *>(ptr));
    std::size_t chunk_length((i == pools.size() - 1) ? num_of_allocated_elements_in_current_chunk : chunk_size);
    for (std::size_t j(0); j < chunk_length; ++j)
    {
     all_elements[j].~T();
    }
    delete[] static_cast<char *>(ptr);
   }
  }
  catch (...)
  {
   ;
  }
 }
 void allocate_chunk()
 {
  std::size_t block_size(sizeof(T) * chunk_size);
  void *new_chunk = static_cast<void *>(new char[block_size]);
  num_of_allocated_elements_in_current_chunk = 0;
  next_free_element = new_chunk;
  pools.emplace_back(new_chunk);
 }
 void *allocate(size_t size)
 {
  auto ret(next_free_element);
  if (++num_of_allocated_elements_in_current_chunk == chunk_size)
   allocate_chunk();
  else [[likely]]
   next_free_element = static_cast<void *>(static_cast<char *>(next_free_element) + sizeof(T));
  return ret;
 }
 void deallocate(void *ptr) {
  ;
 }
};

struct TrieNode
{
 Keyword *keyword{nullptr};
 std::uint32_t count{0};

 union
 {
  std::uint32_t ch{0};
  char ch_[4];
 };
 std::uint32_t mask{0};

 TrieNode *parent{nullptr};

 struct ChildNode
 {
  std::uint32_t ch{0};
  std::uint32_t mask{0};
  TrieNode *child;
 };

 std::vector<ChildNode> children;
};

using TrieNodeMemoryPool = MemoryPool<TrieNode>;

void *operator new(std::size_t sz, TrieNodeMemoryPool &pool)
{
 return pool.allocate(sz);
}

void operator delete(void *ptr, TrieNodeMemoryPool &pool)
{
 pool.deallocate(ptr);
}

static TrieNodeMemoryPool g_trienodePool;

std::array<TrieNode *, 256> g_querywords;

void InitRootTrieNodes()
{
 std::uint32_t i = 0;
 for (auto &ele : g_querywords)
 {
  ele = new(g_trienodePool) TrieNode;
  ele->ch = (i++) << 24;
 }
}

struct Keyword
{
 std::uint32_t tagid;
 std::string keyword;
 std::vector<TrieNode *> query_words;
};

std::unordered_map<std::string, std::unique_ptr<Keyword>> g_keywords;

struct Tag
{
 std::uint32_t id;
 std::uint32_t count;
 std::uint32_t category;
 std::unordered_map<std::uint32_t, Keyword *> lang_keywords;
 std::vector<Keyword *> alias_keywords;
};

std::vector<std::unique_ptr<Tag>> g_tags;

void AddTag(std::uint32_t id, std::uint32_t count, std::uint32_t category)
{
 if (g_tags.size() <= id)
 {
  std::size_t shortage(id - g_tags.size() + 1);
  for (std::size_t i(0); i < shortage; ++i)
   g_tags.emplace_back(nullptr);
 }
 g_tags[id].reset(new Tag{id, count, category});
}

void UpdateTagCategory(std::uint32_t id, std::uint32_t category)
{
 g_tags[id]->category = category;
}

void DeleteKeyword(std::string const &keyword);

void DeleteTag(std::uint32_t id)
{

 std::vector<std::string> tmp;
 for (auto const& kw : g_tags[id].get()->lang_keywords)
  tmp.emplace_back(kw.second->keyword);
 for (auto const &kw : g_tags[id].get()->alias_keywords)
  tmp.emplace_back(kw->keyword);
 for (auto &kw : tmp)
  DeleteKeyword(kw);
 g_tags[id].reset(nullptr);
}

inline void BackpropFreq(TrieNode *node)
{
 for (; node; node = node->parent)
 {
  node->count = 0;
  for (auto const &[ch, mask, nnode] : node->children)
   node->count = std::max(node->count, nnode->count);
 }
}

inline void BackpropFreqLeaf(TrieNode *leaf)
{
 for (auto node(leaf->parent); node; node = node->parent)
 {
  node->count = 0;
  for (auto const &[ch, mask, nnode] : node->children)
   node->count = std::max(node->count, nnode->count);
 }
}

auto AddQueryWord(Keyword *keyword, std::string const &word)
{
 auto const &tag(g_tags[keyword->tagid]);
 auto word_iter(word.cbegin());
 std::uint8_t root_key(static_cast<std::uint8_t>(word_iter[0]));

 TrieNode *cur(g_querywords[root_key]);






 word_iter += 1;

 while (word.cend() - word_iter >= 4)
 {
  TrieNode *child{nullptr};
  std::uint32_t key((static_cast<std::uint8_t>(word_iter[3]) << 24) | (static_cast<std::uint8_t>(word_iter[2]) << 16) | (static_cast<std::uint8_t>(word_iter[1]) << 8) | static_cast<std::uint8_t>(word_iter[0]));
  for (auto const &[ch, mask, nnode] : cur->children)
  {
   if (key == ch)
   {
    child = nnode;
    word_iter += 4;
    break;
   }
  }
  if (!child)
  {
   TrieNode *nnode(new(g_trienodePool) TrieNode);
   nnode->ch = key;
   nnode->mask = 0xFFFFFFFF;
   nnode->parent = cur;
   cur->children.push_back({nnode->ch, nnode->mask, nnode});
   cur = nnode;
   word_iter += 4;
  }
  else
   cur = child;
 }

 std::ptrdiff_t remaining_length(word.cend() - word_iter);

 if (remaining_length > 0)
 {
  std::uint32_t key{0};
  std::uint32_t mask((1u << (remaining_length * 8)) - 1u);
  for (std::ptrdiff_t i(0); i < remaining_length; ++i)
   key |= static_cast<std::uint8_t>(word_iter[i]) << (i * 8);


  auto found(std::find_if(cur->children.begin(), cur->children.end(), [&key](auto const &a) {return a.ch == key; }));

  if (found == cur->children.end())
  {


   TrieNode *nnode(new(g_trienodePool) TrieNode);
   nnode->ch = key;
   nnode->mask = mask;
   nnode->parent = cur;
   nnode->count = tag->count;
   cur->children.push_back({nnode->ch, nnode->mask, nnode});
   cur = nnode;
  }
  else
   cur = found->child;
 }

 auto keyword_already_exist(std::find_if(cur->children.begin(), cur->children.end(), [&keyword](auto const &a) {return a.child->keyword == keyword; }));

 if (keyword_already_exist == cur->children.end()) [[likely]]
 {


  TrieNode * nnode(new(g_trienodePool) TrieNode);
  nnode->ch = 0;
  nnode->mask = 0;
  nnode->parent = cur;
  nnode->count = tag->count;
  nnode->keyword = keyword;
  cur->children.push_back({nnode->ch, nnode->mask, nnode});
  BackpropFreqLeaf(nnode);
  return nnode;
 }
 else
 {


  return keyword_already_exist->child;
 }

}

void DeleteQueryWord(TrieNode *leaf)
{
 auto keyword(leaf->keyword);
 auto cur(leaf->parent);
 auto found(std::find_if(cur->children.begin(), cur->children.end(), [&keyword](auto const &a) {return a.child->keyword == keyword; }));
 cur->children.erase(found);
 if (cur->children.size() == 0)
 {

  auto key(cur->ch);
  for (cur = cur->parent; cur; cur = cur->parent)
  {
   auto found(std::find_if(cur->children.begin(), cur->children.end(), [&key](auto const &a) {return a.ch == key; }));
   cur->children.erase(found);
   if (cur->children.size() > 0)
    break;
   key = cur->ch;
  }
 }
 BackpropFreq(cur);
}

std::vector<std::string> _get_all_suffix(std::string const &keyword);

void AddKeyword(std::uint32_t tagid, std::string const &keyword, std::uint32_t lang = 0)
{
 if (g_keywords.contains(keyword))
 {
  auto const &keyword_obj(g_keywords[keyword]);
  auto &tag_obj(*g_tags[tagid]);
  if (lang != 0) [[likely]]
   tag_obj.lang_keywords[lang] = keyword_obj.get();
  return;
 }
 auto const &&suffix(_get_all_suffix(keyword));
 std::unique_ptr<Keyword> keyword_obj(new Keyword{tagid, keyword});
 for (auto const &query : suffix)
 {
  auto trie_node_ptr(AddQueryWord(keyword_obj.get(), query));
  keyword_obj->query_words.emplace_back(trie_node_ptr);
 }
 auto &tag_obj(*g_tags[tagid]);
 if (lang == 0)
  tag_obj.alias_keywords.emplace_back(keyword_obj.get());
 else [[likely]]
  tag_obj.lang_keywords[lang] = keyword_obj.get();
 g_keywords[keyword] = std::move(keyword_obj);
}

void DeleteKeyword(std::string const &keyword)
{


 auto keyword_obj(g_keywords[keyword].get());
 auto tag_obj(g_tags[keyword_obj->tagid].get());


 auto &tag_lang_keywords(tag_obj->lang_keywords);
 auto lang_it(std::find_if(tag_lang_keywords.begin(), tag_lang_keywords.end(), [&keyword_obj](auto const &a) {return a.second == keyword_obj; }));
 while (lang_it != tag_lang_keywords.end())
 {
  tag_lang_keywords.erase(lang_it);
  lang_it = std::find_if(tag_lang_keywords.begin(), tag_lang_keywords.end(), [&keyword_obj](auto const &a) {return a.second == keyword_obj; });
 }

 auto &tag_alias_keywords(tag_obj->alias_keywords);
 auto alias_it(std::find_if(tag_alias_keywords.begin(), tag_alias_keywords.end(), [&keyword_obj](auto const &a) {return a == keyword_obj; }));
 if (alias_it != tag_alias_keywords.end())
  tag_alias_keywords.erase(alias_it);

 for (TrieNode *leaf : keyword_obj->query_words)
 {
  DeleteQueryWord(leaf);
 }

 g_keywords.erase(keyword);
}

void UpdateKeyword(Keyword *keyword, std::uint32_t count)
{
 for (TrieNode *leaf : keyword->query_words)
 {
  leaf->count = count;
  BackpropFreqLeaf(leaf);
 }
}

void UpdateTagCount(std::uint32_t id, std::uint32_t count)
{
 auto &tag_obj(*g_tags[id]);
 tag_obj.count = count;
 for (Keyword *kwd : tag_obj.alias_keywords)
  UpdateKeyword(kwd, count);
 for (auto const& kwd : tag_obj.lang_keywords)
  UpdateKeyword(kwd.second, count);
}

void UpdateTagCountDiff(std::uint32_t id, std::int32_t diff)
{
 auto &tag_obj(*g_tags[id]);
 tag_obj.count += diff;
 for (Keyword *kwd : tag_obj.alias_keywords)
  UpdateKeyword(kwd, tag_obj.count);
 for (auto const &kwd : tag_obj.lang_keywords)
  UpdateKeyword(kwd.second, tag_obj.count);
}
# 434 "tree.h"
std::vector<std::string> const g_supported_languages = {
 "NAL",
 "CHS",
 "CHT",
 "CSY",
 "NLD",
 "ENG",
 "FRA",
 "DEU",
 "HUN",
 "ITA",
 "JPN",
 "KOR",
 "PLK",
 "PTB",
 "ROM",
 "RUS",
 "ESP",
 "TRK",
 "VIN"
};

std::uint32_t GetLanguageIndex(std::string const &str)
{
 for (std::uint32_t i(0); i < g_supported_languages.size(); ++i)
  if (g_supported_languages[i] == str)
   return i;
 return 0;
}

std::uint32_t operator ""_lang(char const *s, std::size_t len)
{
 std::string str;
 str.assign(s, len);
 return GetLanguageIndex(str);
}

std::vector<std::vector<std::uint32_t>> const g_lang_perference = {
 {"NAL"_lang},
 {"CHS"_lang, "CHT"_lang, "JPN"_lang, "ENG"_lang},
 {"CHT"_lang, "JPN"_lang, "CHS"_lang, "ENG"_lang},
 {"CSY"_lang},
 {"NLD"_lang},
 {"ENG"_lang, "JPN"_lang},
 {"FRA"_lang},
 {"DEU"_lang},
 {"HUN"_lang},
 {"ITA"_lang},
 {"JPN"_lang, "CHT"_lang, "ENG"_lang, "CHS"_lang},
 {"KOR"_lang},
 {"PLK"_lang},
 {"PTB"_lang},
 {"ROM"_lang},
 {"RUS"_lang},
 {"ESP"_lang},
 {"TRK"_lang},
 {"VIN"_lang}
};

auto QueryWord(std::string const &prefix, std::uint32_t max_words, std::uint32_t user_language = 0)
{
 user_language = std::min(user_language, static_cast<std::uint32_t>(g_lang_perference.size()) - 1);
 std::vector<Keyword *> ret{};
 std::set<std::uint32_t> used_tags;
 ret.reserve(max_words);

 auto prefix_iter(prefix.cbegin());
 uint8_t root_key(static_cast<std::uint8_t>(prefix_iter[0]));

 TrieNode *cur(g_querywords[root_key]);


 prefix_iter += 1;

 while (prefix.cend() - prefix_iter >= 4)
 {
  TrieNode *child{nullptr};
  std::uint32_t key((static_cast<std::uint8_t>(prefix_iter[3]) << 24) | (static_cast<std::uint8_t>(prefix_iter[2]) << 16) | (static_cast<std::uint8_t>(prefix_iter[1]) << 8) | static_cast<std::uint8_t>(prefix_iter[0]));
  for (auto const &[ch, mask, nnode] : cur->children)
  {
   if (key == ch)
   {
    child = nnode;
    prefix_iter += 4;
    break;
   }
  }
  if (!child)
   return ret;
  else
   cur = child;
 }

 auto cmp([](TrieNode *a, TrieNode *b) {
  return a->count < b->count;
 });

 std::priority_queue<TrieNode *, std::vector<TrieNode *>, decltype(cmp)> q;
 std::uint32_t key{0};
 ptrdiff_t remaining_length(prefix.cend() - prefix_iter);
 std::uint32_t mask((1u << (remaining_length * 8)) - 1u);
 for (ptrdiff_t i(0); i < remaining_length; ++i)
  key |= static_cast<std::uint8_t>(prefix_iter[i]) << (i * 8);
 for (auto const &[ch, mask_, nnode] : cur->children)
  if ((key & mask) == (ch & mask))
   q.push(nnode);

 while (!q.empty())
 {
  auto node(q.top());
  q.pop();

  if (node->keyword)
  {

   if (used_tags.count(node->keyword->tagid) > 0)
    continue;
   if (user_language == 0)
   {
    ret.emplace_back(node->keyword);
    used_tags.emplace(node->keyword->tagid);
   }
   else [[likely]]
   {
    auto const &preference(g_lang_perference[user_language]);
    auto const &tag_obj(g_tags[node->keyword->tagid]);
    bool found(false);
    for (std::uint32_t ul : preference)
    {
     if (tag_obj->lang_keywords.contains(ul))
     {
      auto const &keword_obj(tag_obj->lang_keywords[ul]);
      std::string const &keyword(keword_obj->keyword);
      if (keyword.find(prefix) != std::string::npos)
      {
       ret.emplace_back(keword_obj);
       used_tags.emplace(node->keyword->tagid);
       found = true;
       break;
      }
     }
    }
    if (!found)
    {
     ret.emplace_back(node->keyword);
     used_tags.emplace(node->keyword->tagid);
    }
   }
   if (ret.size() == max_words)
    return ret;
  }
  else
  {
   for (auto const &[ch, mask_, nnode] : node->children)
    q.push(nnode);
  }
 }

 return ret;
}


std::vector<std::string> _get_all_suffix(std::string const &keyword)
{
 std::vector<std::string> ret{};
 ret.reserve(keyword.size());
 for (auto it(keyword.begin()); it != keyword.end(); ++it)
 {
  ret.emplace_back(it, keyword.end());
  union
  {
   char ch;
   std::bitset<8> bts;
  } u{*it};
  if (u.bts.test(7))
  {

   std::size_t ones(0);
   for (std::size_t i(6); i >= 4; --i)
    if (u.bts.test(i))
     ++ones;
   it += ones;
  }
 }
 return std::move(ret);
}
# 8 "autocomplete.cpp" 2

template<typename T>
void ignore(T&&)
{}
# 23 "autocomplete.cpp"
inline constexpr std::uint64_t hash(std::string_view str)
{
 std::uint64_t ret = 5381;

 for (auto const &ch : str)
  ret = ((ret << 5) + ret) + ch;

 return ret;
}

auto response_header{"HTTP/1.1 200 OK\nContent-Type: text/html; charset=utf-8\nContent-Length: "};
auto response_header_json{"HTTP/1.1 200 OK\nContent-Type: application/json; charset=utf-8\nContent-Length: "};

auto response404{"HTTP/1.1 404 Not Found\nContent-Type: text/html; charset=utf-8\nContent-Length: 0\n\n"};
auto response405{"HTTP/1.1 405 Method Not Allowed\nContent-Type: text/html; charset=utf-8\nContent-Length: 0\n\n"};
auto response500{"HTTP/1.1 500 Internal Server Error\nContent-Type: text/html; charset=utf-8\nContent-Length: 0\n\n"};

enum class RequestMethod
{
 GET,
 POST
};

template<typename IsSpace, fast_io::character_input_stream input>
inline void read_split(input &in, std::basic_string<typename input::char_type> &str)
{
 IsSpace func;
 str.clear();
 for (decltype(fast_io::get<true>(in)) ch; !(ch = fast_io::get<true>(in)).second && !func(ch.first); str.push_back(ch.first));
}

inline constexpr std::uint8_t hex2int(char const &ch)
{
 std::uint8_t ch_0(static_cast<std::uint8_t>(ch) - static_cast<std::uint8_t>('0'));
 std::uint8_t ch_a(static_cast<std::uint8_t>(ch) - static_cast<std::uint8_t>('a'));
 std::uint8_t ch_A(static_cast<std::uint8_t>(ch) - static_cast<std::uint8_t>('A'));
 if (ch_0 < 10)
  return ch_0;
 if (ch_a < 16)
  return ch_a + 10;
 if (ch_A < 16)
  return ch_A + 10;
 throw std::runtime_error("not a hex");
}

inline auto decode_url(std::string const &url)
{
 std::string out;
 fast_io::istring_view url_isv(url);
 for (decltype(fast_io::get<true>(url_isv)) ch;;)
 {
  ch = fast_io::get<true>(url_isv);
  if (ch.second)
   break;
  if (ch.first == '%')
  {
   uint8_t ch2;
   auto hex1(fast_io::get<true>(url_isv));
   auto hex2(fast_io::get<true>(url_isv));
   if (hex1.second || hex2.second)
    throw std::runtime_error("decode failed");
   ch2 = (hex2int(hex1.first) << 4) | hex2int(hex2.first);
   out.push_back(static_cast<char>(ch2));
  }
  else
   out.push_back(ch.first);
 }
 return out;
}

inline auto parse_path(std::string const &raw_path)
{
 std::unordered_map<std::string, std::string> params;
 fast_io::istring_view path_isv(raw_path);
 auto is_question([](auto const &ch) {return ch == '?'; });
 auto is_amp_or_equ([](auto const &ch) {return ch == '&' || ch == '='; });

 std::string path;
 read_split<decltype(is_question)>(path_isv, path);
 for (std::string key, val;;)
 {
  read_split<decltype(is_amp_or_equ)>(path_isv, key);
  read_split<decltype(is_amp_or_equ)>(path_isv, val);
  if (key.size() > 0)
   params.emplace(std::move(key), decode_url(std::move(val)));
  else
   break;
 }

 return std::make_pair(path, params);
}


class http_error : public std::runtime_error
{
public:
 int code;
public:
 http_error(int code) : std::runtime_error("http error"), code(code)
 {}
};

void abort(int code = 404)
{
 throw http_error(code);
}

template<fast_io::character_output_stream output>
inline void handle_request_q(output &out, std::unordered_map<std::string, std::string> const &params)
{
 std::string prefix(params.at("q"));
 std::string max_words_str("10");
 std::string user_language("0");
 if (params.contains("n"))
  max_words_str = params.at("n");
 if(params.contains("l"))
  user_language = params.at("l");
 if (prefix.size() < 1)
  abort(400);
 std::uint32_t max_words{10};
 std::uint32_t user_lang_index{0};
 fast_io::istring_view isv(max_words_str);
 scan(isv, max_words);
 fast_io::istring_view isv_lang(user_language);
 scan(isv_lang, user_lang_index);
 if (max_words > 100 || max_words == 0)
  max_words = 10;


 auto query_result(QueryWord(prefix, max_words, user_lang_index));
 print(out, "[");
 for (std::size_t i(0); i != query_result.size(); ++i)
 {
  auto const& key(*query_result[i]);
  print(out, "{\"tag\":\"", key.keyword, "\",\"cat\":", g_tags[key.tagid]->category, ",\"cnt\":", g_tags[key.tagid]->count, "}");
  if (i != query_result.size() - 1)
   print(out, ",");
 }
 print(out, "]");
}

template<fast_io::character_output_stream output, fast_io::character_input_stream input>
inline void handle_request_addtag(output &out, input &content)
{
 ignore(out);
 std::uint32_t tagid;
 std::uint32_t count;
 std::uint32_t cat;
 std::size_t n(0);
 scan(content, n);
 for (std::size_t i(0); i != n; ++i)
 {
  scan(content, tagid, count, cat);
  AddTag(tagid, count, cat);
 }
}

template<fast_io::character_output_stream output, fast_io::character_input_stream input>
inline void handle_request_addword(output &out, input &content)
{
 ignore(out);
 std::uint32_t tagid;
 std::string word;
 std::string lang;
 std::size_t n(0);
 scan(content, n);
 for (std::size_t i(0); i != n; ++i)
 {
  scan(content, tagid, word, lang);
  if (word.size() < 2 || tagid >= g_tags.size() || lang.size() != 3)
   return;

  AddKeyword(tagid, word, GetLanguageIndex(lang));
 }
}

template<fast_io::character_output_stream output, fast_io::character_input_stream input>
inline void handle_request_setcount(output &out, input &content)
{
 ignore(out);
 std::uint32_t tagid;
 std::uint32_t count;
 std::size_t n(0);
 scan(content, n);
 for (std::size_t i(0); i != n; ++i)
 {
  scan(content, tagid, count);
  if (tagid >= g_tags.size())
   return;

  UpdateTagCount(tagid, count);
 }
}

template<fast_io::character_output_stream output, fast_io::character_input_stream input>
inline void handle_request_setcountdiff(output &out, input &content)
{
 ignore(out);
 std::uint32_t tagid;
 std::int32_t diff;
 std::size_t n(0);
 scan(content, n);
 for (std::size_t i(0); i != n; ++i)
 {
  scan(content, tagid, diff);
  if (tagid >= g_tags.size())
   return;

  UpdateTagCountDiff(tagid, diff);
 }
}

template<fast_io::character_output_stream output, fast_io::character_input_stream input>
inline void handle_request_deltag(output &out, input &content)
{
 ignore(out);
 std::uint32_t tagid;
 scan(content, tagid);
 if (tagid >= g_tags.size())
  return;

 DeleteTag(tagid);
}

template<fast_io::character_output_stream output, fast_io::character_input_stream input>
inline void handle_request_delword(output &out, input &content)
{
 ignore(out);
 std::string word;
 scan(content, word);
 if (word.size() < 2)
  return;

 DeleteKeyword(word);
}

template<fast_io::character_output_stream output, fast_io::character_input_stream input>
inline void handle_request(output &out, input &content, RequestMethod method, std::string const &path, std::unordered_map<std::string, std::string> const &params)
{
 std::string response_body;
 fast_io::basic_ostring<std::string> response_body_stream(std::move(response_body));
 auto path_hashed(hash(path));
 switch (method)
 {
 case RequestMethod::GET:
  if (path != "/")
   abort(404);
  handle_request_q(response_body_stream, params);
  break;
 case RequestMethod::POST:
  switch (path_hashed)
  {
  case hash("/addtag"):
   handle_request_addtag(response_body_stream, content);
   break;
  case hash("/addword"):
   handle_request_addword(response_body_stream, content);
   break;
  case hash("/setcount"):
   handle_request_setcount(response_body_stream, content);
   break;
  case hash("/setcountdiff"):
   handle_request_setcountdiff(response_body_stream, content);
   break;
  case hash("/deltag"):
   handle_request_deltag(response_body_stream, content);
   break;
  case hash("/delword"):
   handle_request_delword(response_body_stream, content);
   break;
  default:
   abort(404);
  }
  break;
 }

 print(out, response_header_json);
 print(out, response_body_stream.str().size());
 print(out, "\n\n");
 print(out, response_body_stream.str());
}

void handle_connection(fast_io::acceptor_buf& client_stream)
{
 try
 {
  auto request_header(scan_http_header(client_stream));
  RequestMethod method;
  std::string path_version;
  if (request_header.contains("POST"))
  {
   method = RequestMethod::POST;
   path_version = request_header["POST"];
  }
  else if (request_header.contains("GET"))
  {
   method = RequestMethod::GET;
   path_version = request_header["GET"];
  }
  else
  {
   print(client_stream, response405);
   return;
  }

  std::string raw_path;
  fast_io::istring_view isv(path_version);
  scan(isv, raw_path);

  auto const &[path, params] = parse_path(raw_path);

  handle_request(client_stream, client_stream, method, path, params);
 }
 catch (http_error const &ex)
 {
  print(client_stream, response404);
 }
 catch (std::exception const &e)
 {
  println(fast_io::err, e);
  print(client_stream, response500);
 }
}

int main()
try
{
 InitRootTrieNodes();
# 363 "autocomplete.cpp"
 fast_io::async_server server(5002, fast_io::sock::type::stream);
 fast_io::epoll::handle_pool pool(512);
 add_control(pool, server, fast_io::epoll::event::in);
 std::array<fast_io::epoll::events, 512> events_buffer;
 std::vector<fast_io::acceptor_buf> clients;
 for (;;)
  for (auto const &ele : wait(pool, events_buffer))
   switch (get(ele))
   {
   case fast_io::epoll::event::in:
    add_control(pool, clients.emplace_back(server), fast_io::epoll::event::out | fast_io::epoll::event::hup);
    break;
   case fast_io::epoll::event::out:
   case fast_io::epoll::event::hup:
    for (auto it(clients.begin()); it != clients.end(); ++it)
     if (*it == ele)
     {
      handle_connection(*it);
      iter_swap(it, clients.end() - 1);
      clients.pop_back();
      break;
     }
   };
}
catch (std::exception const &e)
{
 println(fast_io::err, e);
 return 1;
}
